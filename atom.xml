<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2020-10-22T01:16:58.840Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>划分字母区间</title>
    <link href="https://hoo334.github.io/2020/10/22/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"/>
    <id>https://hoo334.github.io/2020/10/22/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</id>
    <published>2020-10-22T01:06:57.000Z</published>
    <updated>2020-10-22T01:16:58.840Z</updated>
    
    <content type="html"><![CDATA[<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/" target="_blank" rel="noopener">763. 划分字母区间</a></h4><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>S</code>的长度在<code>[1, 500]</code>之间。</li><li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li></ul><p>同一个字母只能出现在同一片段，同一个字母第一次出现的下标位置和最后一次出现的下标位置必须出现在同一片段。因此，需要遍历字符串，得到每个字母最后一次出现的下标位置。</p><p>接下来使用贪心算法和双指针的方法将字符串划分为尽可能多的片段：</p><ul><li>从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end。</li><li>对于每个访问到的字母 c，得到当前字母最后一次出现的下标位置 endc，则当前片段的结束下标一定不会小于 endc，end = max(end, endc)。</li><li>当访问到下标 end 时，当前片段访问结束，当前判断的长度为 end - start  + 1，将当前片段的长度添加到返回值，然后令 start =  end + 1，继续寻找下一个片段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++)&#123;</span><br><span class="line">            last[S.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; partition = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++)&#123;</span><br><span class="line">            end = Math.max(end, last[S.charAt(i) - <span class="string">'a'</span>]);</span><br><span class="line">            <span class="keyword">if</span>(i == end)&#123;</span><br><span class="line">                partition.add(end - start + <span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> partition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;763-划分字母区间&quot;&gt;&lt;a href=&quot;#763-划分字母区间&quot; class=&quot;headerlink&quot; title=&quot;763. 划分字母区间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/partition-labels/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;763. 划分字母区间&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;字符串 &lt;code&gt;S&lt;/code&gt; 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="贪心" scheme="https://hoo334.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>比较含退格的字符串</title>
    <link href="https://hoo334.github.io/2020/10/19/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/10/19/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-10-19T01:42:37.000Z</published>
    <updated>2020-10-19T01:52:37.242Z</updated>
    
    <content type="html"><![CDATA[<h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">844. 比较含退格的字符串</a></h4><p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p><p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab##&quot;, T &#x3D; &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a##c&quot;, T &#x3D; &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a#c&quot;, T &#x3D; &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li><p><code>1 &lt;= S.length &lt;= 200</code></p></li><li><p><code>1 &lt;= T.length &lt;= 200</code></p></li><li><p><code>S</code> 和 <code>T</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code>。</p><p><strong>进阶：</strong></p></li></ol><ul><li>你可以用 <code>O(N)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li></ul><p>一个字符是否被删掉取决于它后面是否有#号，我们逆序遍历字符串，就可以立即确定当前字符是否会被删掉。</p><p>使用 s 记录字符串 S 中 # 号的数量，从后往前遍历每个字符：</p><ul><li>当前字符为 # 号，我们要多删除一个字符，s 加一；</li><li>当前字符不是 # 号：<ul><li>若 s 大于 0 ，则删去当前字符；</li><li>若 s 等于 0 ，当前字符不需要删除。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = S.length() - <span class="number">1</span>, j = T.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>;)&#123;</span><br><span class="line">            <span class="comment">//去掉 S 尾部需要删除的字符</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S.charAt(i) == <span class="string">'#'</span>)&#123;</span><br><span class="line">                    ++s;</span><br><span class="line">                    --i;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    --s;</span><br><span class="line">                    --i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//去掉 T 尾部需要删除的字符</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(T.charAt(j) == <span class="string">'#'</span>)&#123;</span><br><span class="line">                    ++t;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    --t;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//判断两个字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span>(S.charAt(i) != T.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//有一个字符串已经遍历完</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            --i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;844-比较含退格的字符串&quot;&gt;&lt;a href=&quot;#844-比较含退格的字符串&quot; class=&quot;headerlink&quot; title=&quot;844. 比较含退格的字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/backspace-string-compare/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;844. 比较含退格的字符串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定 &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 &lt;code&gt;#&lt;/code&gt; 代表退格字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果对空文本输入退格字符，文本继续为空。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="双指针" scheme="https://hoo334.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>N皇后</title>
    <link href="https://hoo334.github.io/2020/10/17/N%E7%9A%87%E5%90%8E/"/>
    <id>https://hoo334.github.io/2020/10/17/N%E7%9A%87%E5%90%8E/</id>
    <published>2020-10-17T02:34:29.000Z</published>
    <updated>2020-10-19T01:54:13.002Z</updated>
    
    <content type="html"><![CDATA[<h4 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N 皇后</a></h4><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201017103523238.png" alt="image-20201017103523238"></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><a id="more"></a><p> <strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：[</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]ss</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><p><strong>方法一：基于集合的回溯</strong></p><p>直接暴力枚举将 n 个皇后放在棋盘中。每行每列仅有一个皇后，且任何两个皇后都不能在同一条斜线上。</p><p>使用三个集合 columns、diagonals1，diagonals2 分别记录每一列以及两个方向斜线上是否有皇后。我们从第一行开始，每行放一个皇后，这样每行就只有一个皇后。</p><p>方向一的斜线为从左上到右下，同一条斜线上的每个位置满足<strong>行下标与列下标之差相等。</strong></p><p>方向二的斜线为从右上到左下，同一条斜线上的每个位置满足<strong>行下标与列下标之和相等。</strong></p><p>每次放置皇后时，对每个位置判断其是否在三个集合中，如果都不在，当前位置可以放置皇后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; solutions = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(queens, -<span class="number">1</span>);</span><br><span class="line">        Set&lt;Integer&gt; columns = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        backtrack(solutions, queens, n, <span class="number">0</span>, columns, diagonals1, diagonals2);</span><br><span class="line">        <span class="keyword">return</span> solutions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; solutions, <span class="keyword">int</span>[] queens, <span class="keyword">int</span> n, <span class="keyword">int</span> row, Set&lt;Integer&gt; columns, Set&lt;Integer&gt; diagonals1, Set&lt;Integer&gt; diagonals2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//row = n 代表已经得到一种结果</span></span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            List&lt;String&gt; board = generateBoard(queens, n);</span><br><span class="line">            solutions.add(board);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//尝试在当前行的每个位置放置皇后</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (columns.contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> diagonal1 = row - i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals1.contains(diagonal1)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> diagonal2 = row + i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals2.contains(diagonal2)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queens[row] = i;</span><br><span class="line">                columns.add(i);</span><br><span class="line">                diagonals1.add(diagonal1);</span><br><span class="line">                diagonals2.add(diagonal2);</span><br><span class="line">                <span class="comment">//继续放置下一行的皇后</span></span><br><span class="line">                backtrack(solutions, queens, n, row + <span class="number">1</span>, columns, diagonals1, diagonals2);</span><br><span class="line">                <span class="comment">//状态重置</span></span><br><span class="line">                queens[row] = -<span class="number">1</span>;</span><br><span class="line">                columns.remove(i);</span><br><span class="line">                diagonals1.remove(diagonal1);</span><br><span class="line">                diagonals2.remove(diagonal2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成棋盘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateBoard</span><span class="params">(<span class="keyword">int</span>[] queens, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; board = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] row = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">            Arrays.fill(row, <span class="string">'.'</span>);</span><br><span class="line">            row[queens[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            board.add(<span class="keyword">new</span> String(row));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n!)</li><li>空间复杂度O(n)，n 是皇后数量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;51-N-皇后&quot;&gt;&lt;a href=&quot;#51-N-皇后&quot; class=&quot;headerlink&quot; title=&quot;51. N 皇后&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-queens/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;51. N 皇后&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;&lt;em&gt;n&lt;/em&gt; 皇后问题研究的是如何将 &lt;em&gt;n&lt;/em&gt; 个皇后放置在 &lt;em&gt;n&lt;/em&gt;×&lt;em&gt;n&lt;/em&gt; 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/hoo334/picgo/raw/master//img/image-20201017103523238.png&quot; alt=&quot;image-20201017103523238&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图为 8 皇后问题的一种解法。&lt;/p&gt;
&lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，返回所有不同的 &lt;em&gt;n&lt;/em&gt; 皇后问题的解决方案。&lt;/p&gt;
&lt;p&gt;每一种解法包含一个明确的 &lt;em&gt;n&lt;/em&gt; 皇后问题的棋子放置方案，该方案中 &lt;code&gt;&amp;#39;Q&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 分别代表了皇后和空位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="回溯" scheme="https://hoo334.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>重构</title>
    <link href="https://hoo334.github.io/2020/10/16/%E9%87%8D%E6%9E%84/"/>
    <id>https://hoo334.github.io/2020/10/16/%E9%87%8D%E6%9E%84/</id>
    <published>2020-10-16T07:14:03.076Z</published>
    <updated>2020-10-16T07:14:51.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h2><h3 id="Duplicated-Code（重复代码）"><a href="#Duplicated-Code（重复代码）" class="headerlink" title="Duplicated Code（重复代码）"></a>Duplicated Code（重复代码）</h3><p>如果你在一个以上的地方看见相同的程序结构，将它们合二为一。</p><h3 id="Long-Method（过长函数）"><a href="#Long-Method（过长函数）" class="headerlink" title="Long Method（过长函数）"></a>Long Method（过长函数）</h3><p>将过长的函数分解为若干个小函数。</p><a id="more"></a><h3 id="Large-Class（过大的类）"><a href="#Large-Class（过大的类）" class="headerlink" title="Large Class（过大的类）"></a>Large Class（过大的类）</h3><p>单个类要做的事情太多，将其分解为几个类。</p><h3 id="Long-Parameter-List（过长参数列）"><a href="#Long-Parameter-List（过长参数列）" class="headerlink" title="Long Parameter List（过长参数列）"></a>Long Parameter List（过长参数列）</h3><p>如果参数太多，考虑使用参数对象。</p><h3 id="Divergent-Change（发散式变化）"><a href="#Divergent-Change（发散式变化）" class="headerlink" title="Divergent Change（发散式变化）"></a>Divergent Change（发散式变化）</h3><p>某个类经常因为不同的原因在不同的方向上发生变化。当你看见<strong>一个类</strong>说：“新加入一个数据库，我必须修改三个函数”</p><h3 id="Shotgun-Surgery（霰弹式修改）"><a href="#Shotgun-Surgery（霰弹式修改）" class="headerlink" title="Shotgun Surgery（霰弹式修改）"></a>Shotgun Surgery（霰弹式修改）</h3><p>如果每遇到某种变化，你都必须在许多<strong>不同</strong>的类中做出许多小修改。</p><h3 id="Feature-Envy（依恋情结）"><a href="#Feature-Envy（依恋情结）" class="headerlink" title="Feature Envy（依恋情结）"></a>Feature Envy（依恋情结）</h3><p>函数对某个类的兴趣高过于对自己所处类的兴趣。</p><h3 id="Data-Clumps（数据泥团）"><a href="#Data-Clumps（数据泥团）" class="headerlink" title="Data Clumps（数据泥团）"></a>Data Clumps（数据泥团）</h3><p>常在许多地方看到成群的数据，考虑将其抽取为类。</p><h3 id="Primitive-Obsession（基本类型偏执）"><a href="#Primitive-Obsession（基本类型偏执）" class="headerlink" title="Primitive Obsession（基本类型偏执）"></a>Primitive Obsession（基本类型偏执）</h3><p>尝试将原本单独存在的数据值替换为对象</p><h3 id="Switch-Statements（Switch-语句）"><a href="#Switch-Statements（Switch-语句）" class="headerlink" title="Switch Statements（Switch 语句）"></a>Switch Statements（Switch 语句）</h3><p>大多数时候，一看到 Switch ，就应该考虑使用<strong>多态</strong>来替换它。</p><h3 id="Parallel-Inheritance-Hierarchies（平行继承体系）"><a href="#Parallel-Inheritance-Hierarchies（平行继承体系）" class="headerlink" title="Parallel Inheritance Hierarchies（平行继承体系）"></a>Parallel Inheritance Hierarchies（平行继承体系）</h3><p>每当你为某个类增加一个子类，也必须为另一个类增加一个子类。消除策略：让一个继承体系的实例引用另一个继承体系的实例。</p><h3 id="Lazy-Class（冗余类）"><a href="#Lazy-Class（冗余类）" class="headerlink" title="Lazy Class（冗余类）"></a>Lazy Class（冗余类）</h3><p>删除它。</p><h3 id="Speculative-Generality（夸夸其谈未来性）"><a href="#Speculative-Generality（夸夸其谈未来性）" class="headerlink" title="Speculative Generality（夸夸其谈未来性）"></a>Speculative Generality（夸夸其谈未来性）</h3><p>删掉无用的函数和linshi函数中多余的参数。</p><h3 id="Temporary-Field（令人迷惑的暂时字段）"><a href="#Temporary-Field（令人迷惑的暂时字段）" class="headerlink" title="Temporary Field（令人迷惑的暂时字段）"></a>Temporary Field（令人迷惑的暂时字段）</h3><p>类中某个实例变量仅为某种特定情况而设置，通常你认为对象在所有时候都需要它的所有变量，在变量未被使用的情况下猜测其设置目的，会让你发疯的！将这些变量抽取为类。</p><h3 id="Message-Chains（过度耦合的消息链）"><a href="#Message-Chains（过度耦合的消息链）" class="headerlink" title="Message Chains（过度耦合的消息链）"></a>Message Chains（过度耦合的消息链）</h3><p>用户向一个对象请求另一个对象，然后再向后者请求另一个都西昂，然后再请求另一个对象 ……… 这就是消息链。</p><h3 id="Middle-Man（中间人）"><a href="#Middle-Man（中间人）" class="headerlink" title="Middle Man（中间人）"></a>Middle Man（中间人）</h3><p>某个类接口有一半的函数都委托给其他类，这是就应该去掉 Middle Man，直接和真正负责的对象打交道。</p><h3 id="Inappropriate-Intimacy（狎昵关系）"><a href="#Inappropriate-Intimacy（狎昵关系）" class="headerlink" title="Inappropriate Intimacy（狎昵关系）"></a>Inappropriate Intimacy（狎昵关系）</h3><p>两个类过于亲密，花费太多时间去探究彼此的 private 成分。应该将这两个类分开，帮它们划清界限。</p><h3 id="Alternative-Classes-with-Different-Interfaces（异曲同工的类）"><a href="#Alternative-Classes-with-Different-Interfaces（异曲同工的类）" class="headerlink" title="Alternative Classes with Different Interfaces（异曲同工的类）"></a>Alternative Classes with Different Interfaces（异曲同工的类）</h3><p>两个函数做着同样的事情，却有不同的签名，尝试根据它们的用途进行重命名。</p><h3 id="Data-Class（纯稚的数据类）"><a href="#Data-Class（纯稚的数据类）" class="headerlink" title="Data Class（纯稚的数据类）"></a>Data Class（纯稚的数据类）</h3><p>拥有一些字段，以及用于访问这些字段的函数。</p><h3 id="Refused-Bequest（被拒绝的捐赠）"><a href="#Refused-Bequest（被拒绝的捐赠）" class="headerlink" title="Refused Bequest（被拒绝的捐赠）"></a>Refused Bequest（被拒绝的捐赠）</h3><p>子类不想或不需要继承超类的函数和数据。</p><h3 id="Comments（过多的注释）"><a href="#Comments（过多的注释）" class="headerlink" title="Comments（过多的注释）"></a>Comments（过多的注释）</h3><p> 一段代码中有长长的注释，尝试重构复杂的地方。</p><h3 id="Incomplete-Library-Class（不完美的库类）"><a href="#Incomplete-Library-Class（不完美的库类）" class="headerlink" title="Incomplete Library Class（不完美的库类）"></a>Incomplete Library Class（不完美的库类）</h3><p>想要对库类添加或修改，可以引入本地扩展。</p><h2 id="重新组织函数"><a href="#重新组织函数" class="headerlink" title="重新组织函数"></a>重新组织函数</h2><h3 id="Extract-Method（提炼函数）"><a href="#Extract-Method（提炼函数）" class="headerlink" title="Extract Method（提炼函数）"></a>Extract Method（提炼函数）</h3><p>你有一段代码可以被组织在一起并独立出来。<strong>将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。</strong></p><h3 id="Inline-Method（内联函数）"><a href="#Inline-Method（内联函数）" class="headerlink" title="Inline Method（内联函数）"></a>Inline Method（内联函数）</h3><p>一个函数的本体与名称同样清楚易懂。<strong>在函数调用点插入函数本体，然后删除函数。</strong></p><h3 id="Inline-Temp（内联临时变量）"><a href="#Inline-Temp（内联临时变量）" class="headerlink" title="Inline Temp（内联临时变量）"></a>Inline Temp（内联临时变量）</h3><p>你有一个临时变量，只被一个简单表达式肤质一次，而它妨碍了其他重构手法。</p><p><strong>将所有对该变量的引用动作，替换为对它赋值的表达式自身。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = anOrder.basePrice();</span><br><span class="line"><span class="keyword">return</span> basePrice &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> anOrder.basePrice() &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="Return-Temp-With-Query（以查询取代临时变量）"><a href="#Return-Temp-With-Query（以查询取代临时变量）" class="headerlink" title="Return Temp With Query（以查询取代临时变量）"></a>Return Temp With Query（以查询取代临时变量）</h3><p>你的此程序以一个临时变量保存某一表达式的运算结果。</p><p><strong>将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = _quantity * _itemPrice;</span><br><span class="line"><span class="keyword">if</span>(basePrice &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.99</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(basePrice() &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.99</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">basePrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Introduce-Explaining-Variable（引用解释性变量）"><a href="#Introduce-Explaining-Variable（引用解释性变量）" class="headerlink" title="Introduce Explaining Variable（引用解释性变量）"></a>Introduce Explaining Variable（引用解释性变量）</h3><p>你有一个复杂的表达式，<strong>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((platform.toUpperCase().indexOf(<span class="string">'MAC'</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">  (browser.toUpperCase().indexOf(<span class="string">'IE'</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">  wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isMacOS = platform.toUpperCase().indexOf(<span class="string">'MAC'</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isIEBrowser = browser.toUpperCase().indexOf(<span class="string">'IE'</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> wasResized = resize &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(isMacOS &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized)&#123;</span><br><span class="line"><span class="comment">// do something&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Split-Temporary-Variable（分解临时变量）"><a href="#Split-Temporary-Variable（分解临时变量）" class="headerlink" title="Split Temporary Variable（分解临时变量）"></a>Split Temporary Variable（分解临时变量）</h3><p>你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。<strong>针对每次赋值，创造一个独立、对应的临时变量。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> temp = <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println(temp);</span><br><span class="line">temp = _height * _width;</span><br><span class="line">System.out.println(temp);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> perimeter = <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println(perimeter);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> area = _height * _width;</span><br><span class="line">System.out.println(area);</span><br></pre></td></tr></table></figure><h3 id="Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="Remove Assignments to Parameters（移除对参数的赋值）"></a>Remove Assignments to Parameters（移除对参数的赋值）</h3><p>代码对一个参数进行赋值。<strong>以一个临时变量取代该参数的位置</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discount</span><span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inputVal &gt; <span class="number">50</span>) inputVal -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discount</span><span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = inputVal;</span><br><span class="line">    <span class="keyword">if</span>(result &gt; <span class="number">50</span>) result -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Method-with-Object（以函数对象取代函数）"><a href="#Replace-Method-with-Object（以函数对象取代函数）" class="headerlink" title="Replace Method with Object（以函数对象取代函数）"></a>Replace Method with Object（以函数对象取代函数）</h3><p>你有一个大型函数，其中对局部变量的使用使你无法采用<strong><em>Extract Method</em></strong>。</p><p><strong>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="comment">//长函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">        <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">        <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">        <span class="comment">// long computation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PriceCalculator().compute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriceCalculator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//long computation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Subsititute-Algorithm（替换算法）"><a href="#Subsititute-Algorithm（替换算法）" class="headerlink" title="Subsititute Algorithm（替换算法）"></a>Subsititute Algorithm（替换算法）</h3><p>你想要把某个算法替换为另一个更清晰的算法。<strong>将函数本体替换为另一个算法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[i].equals(<span class="string">"Don"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Don"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(people[i].equals(<span class="string">"John"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"John"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(people[i].equals(<span class="string">"Kent"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Kent"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; candidates = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">"Don"</span>, <span class="string">"John"</span>, <span class="string">"Kent"</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.contains(people[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> people[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在对象之间搬移特性"><a href="#在对象之间搬移特性" class="headerlink" title="在对象之间搬移特性"></a>在对象之间搬移特性</h2><h3 id="Move-Method（搬移函数）"><a href="#Move-Method（搬移函数）" class="headerlink" title="Move Method（搬移函数）"></a>Move Method（搬移函数）</h3><p>你的程序中，有个函数与其驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p><p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单独的委托函数，或者将旧函数完全移除。</p><h3 id="Move-Field（搬移字段）"><a href="#Move-Field（搬移字段）" class="headerlink" title="Move Field（搬移字段）"></a>Move Field（搬移字段）</h3><p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p><p><strong>在目标类新建一个字段，修改源字段地所有用户，令它们改用新字段。</strong></p><h3 id="Extract-Class（提炼类）"><a href="#Extract-Class（提炼类）" class="headerlink" title="Extract Class（提炼类）"></a>Extract Class（提炼类）</h3><p>某个类做了应该由两个类做的事。</p><p><strong>建立一个新类，将相关的字段和函数从旧类搬移到新类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String officeAreaCode;</span><br><span class="line">    <span class="keyword">private</span> String officeNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getTelephoneNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"("</span> + officeAreaCode + <span class="string">")"</span> + officeNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TelephoneNumber tel;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getTelephoneNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tel.getTelephoneNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelephoneNumber</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String officeAreaCode;</span><br><span class="line">    <span class="keyword">private</span> String officeNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getTelephoneNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"("</span> + officeAreaCode + <span class="string">")"</span> + officeNumber);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Inline-Class（将类内联化）"><a href="#Inline-Class（将类内联化）" class="headerlink" title="Inline Class（将类内联化）"></a>Inline Class（将类内联化）</h3><p>某个类没有做太多事情。<strong>将这个类的所有特性搬移到另一个类中，然后移除原类。</strong></p><p>刚好与<strong><em>Extract Class</em></strong>相反。</p><h3 id="Hide-Delegate（隐藏“委托关系”）"><a href="#Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="Hide Delegate（隐藏“委托关系”）"></a>Hide Delegate（隐藏“委托关系”）</h3><p>客户通过一个委托类来调用另一个对象。<strong>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</strong></p><p>如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数，那么客户就必须知晓这一层委托关系。万一委托关系发生变化，客户也得相应变化。你可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，然后去除这种依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartmeent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> department;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person manager;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Persion <span class="title">getManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果客户希望知道某人的经理是谁，他必须先取得 Department 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager = john.getDepartment().getManager();</span><br></pre></td></tr></table></figure><p>这样就对客户暴露了 Department 的工作原理，我们在 Person 中建立一个简单的委托函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">getManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> department.getManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后客户直接调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager = john.getManager();</span><br></pre></td></tr></table></figure><h3 id="Remove-Middle-Man（移除中间人）"><a href="#Remove-Middle-Man（移除中间人）" class="headerlink" title="Remove Middle Man（移除中间人）"></a>Remove Middle Man（移除中间人）</h3><p>某个类做了过多的简单委托动作。<strong>让客户直接调用委托类。</strong></p><p>在 <strong><em>Hide Delegate</em></strong> 中这层封装也是有代价的，它的代价就是：每当客户需要使用受托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受托类的特性越来越多，这一过程会让你痛苦不已。这个时候你就应该让客户直接调用受托类。</p><h3 id="Introduce-Foreign-Method（引入外加函数）"><a href="#Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="Introduce Foreign Method（引入外加函数）"></a>Introduce Foreign Method（引入外加函数）</h3><p>你需要为提供服务的类增加一个函数，但你无法修改这个类。<strong>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date newStart = <span class="keyword">new</span> Date(previousEnd.getYear(), previousEnd.getMonth(), previousEnd.getDate() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date <span class="keyword">new</span> Start = nextDay(previousEnd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Date <span class="title">nextDay</span><span class="params">(Date arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(arg.getYear(), arg.getMonth(), arg.getDate() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可以修改源码，可以自行添加一个新函数；如果不能，就得在客户端编码，补足你要的那个函数。</p><p>如果你发现自己为一个服务类建立了大量外加函数，或者发现有许多类都需要同样的外加函数，就不应该再使用本项重构，而应该使用<strong><em>Introduce Local Extension</em></strong>。</p><h3 id="Introduce-Local-Extension（引入本地扩展）"><a href="#Introduce-Local-Extension（引入本地扩展）" class="headerlink" title="Introduce Local Extension（引入本地扩展）"></a>Introduce Local Extension（引入本地扩展）</h3><p>你需要为服务类提供一些额外函数，但你无法修改这个类。</p><p><strong>建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。</strong></p><p>我们需要将这些额外函数组织在一起，放到一个恰当地方去。有两种标准对象技术——<strong>子类化（subclassing）</strong>和<strong>包装（wrapping）。</strong>将子类和包装类统称为本地扩展（Local Extension）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MfDateSub</span> <span class="keyword">extends</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    MfDateSub(String dateString)&#123;</span><br><span class="line">        <span class="keyword">super</span>(dateString);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Date <span class="title">nextDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(getYear(), getMonth(), getDate() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MfDateWrap</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date original;</span><br><span class="line">    MfDateWrap(String dateString)&#123;</span><br><span class="line">        original = <span class="keyword">new</span> Date(dateString);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MfDateWrap(Date arg)&#123;</span><br><span class="line">        original = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original.getYear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original.getMonth();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他对 Date 类函数的包装</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">Date <span class="title">nextDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(getYear(), getMonth(), getDate() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新组织数据"><a href="#重新组织数据" class="headerlink" title="重新组织数据"></a>重新组织数据</h2><h3 id="Self-Encapsulate-Field（自封装字段）"><a href="#Self-Encapsulate-Field（自封装字段）" class="headerlink" title="Self Encapsulate Field（自封装字段）"></a>Self Encapsulate Field（自封装字段）</h3><p>你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。<strong>为这个字段建立设值/取值函数，并只以这些函数来访问字段。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> low, high;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">includes</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg &gt;= low &amp;&amp; arg &lt;= high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> low, hign;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">includes</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Data-Value-with-Object（以对象取代数据值）"><a href="#Replace-Data-Value-with-Object（以对象取代数据值）" class="headerlink" title="Replace Data Value with Object（以对象取代数据值）"></a>Replace Data Value with Object（以对象取代数据值）</h3><p>你有一个数据项，需要与其他数据和行为一起使用才有意义。<strong>将数据项变成对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Change-Value-to-Reference（将值对象改为引用对象）"><a href="#Change-Value-to-Reference（将值对象改为引用对象）" class="headerlink" title="Change Value to Reference（将值对象改为引用对象）"></a>Change Value to Reference（将值对象改为引用对象）</h3><p>你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。<strong>将这个值对象变成引用对象。</strong></p><p>在<strong><em>Replace Data Value with Object</em></strong>中，留下了一个重构后的程序。到目前为止，Customer 对象还是值对象。就算多份订单属于同一用户，但每个 Order 对象还是拥有各自的 Customer 对象。我希望一个用户可以有多个订单，所有 Order 对象共同拥有同一个 Customer 对象<strong>（每一个客户名称只该对应一个Customer对象）</strong>。</p><p>首先使用<strong><em>Replace Constructor with Factory Method</em></strong>。这样，就可以控制 Customer 对象的创建过程。在 Customer 类中定义这个工厂函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Customer <span class="title">create</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Customer(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后更改调用点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String customer)</span></span>&#123;</span><br><span class="line">        customer = Customer.create(customer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把 Customer 类的构造函数改为 private。</p><p>在 Customer 类中使用 HashMap 存储 Customer 对象，并更改工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Customer&gt; instances = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">()</span></span>&#123;</span><br><span class="line">        instances.put(<span class="keyword">this</span>.getName(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接写死几个数据(应该从数据库读取)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadCustomer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Customer(<span class="string">"a"</span>).store();</span><br><span class="line">        <span class="keyword">new</span> Customer(<span class="string">"b"</span>).store();</span><br><span class="line">        <span class="keyword">new</span> Customer(<span class="string">"c"</span>).store();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Customer <span class="title">getNamed</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Customer) instances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Change-Reference-to-Value（将引用对象改为值对象）"><a href="#Change-Reference-to-Value（将引用对象改为值对象）" class="headerlink" title="Change Reference to Value（将引用对象改为值对象）"></a>Change Reference to Value（将引用对象改为值对象）</h3><p>你有一个引用对象，很小且<strong>不可变</strong>，而且不易管理。<strong>将它变成一个值对象（类没有修改对象数据的函数）。</strong></p><h3 id="Replace-Array-with-Object（以对象取代数组）"><a href="#Replace-Array-with-Object（以对象取代数组）" class="headerlink" title="Replace Array with Object（以对象取代数组）"></a>Replace Array with Object（以对象取代数组）</h3><p>你有一个数组，其中的元素各自代表不同的东西。<strong>以对象替换数组，对于数组中的每个元素，以一个字段来表示。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] row = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">row[<span class="number">0</span>] = <span class="string">"Liverpool"</span>;</span><br><span class="line">row[<span class="number">1</span>] = <span class="string">"15"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Performance p = <span class="keyword">new</span> Performance();</span><br><span class="line">p.setName(<span class="string">"Livepool"</span>);</span><br><span class="line">p.setWins(<span class="string">"15"</span>);</span><br></pre></td></tr></table></figure><h3 id="Duplicate-Observed-Data-（复制“被监视数据”）"><a href="#Duplicate-Observed-Data-（复制“被监视数据”）" class="headerlink" title="Duplicate Observed Data （复制“被监视数据”）"></a>Duplicate Observed Data （复制“被监视数据”）</h3><p>你有一些领域（Model）数据置身于 GUI 控件中，而领域函数需要访问这些函数。</p><p>将该数据复制到一个领域对象中。建立一个Observer 模式，用以同步领域对象和 GUI 对象内的重复数据。</p><h3 id="Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h3><p>两个类都需要使用对方特性，但其间只有一条单向连接。<strong>添加一个反向指针，并使修改函数（指改变双方关系的函数）能够同时更新两条连接。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个用户可以有多个订单</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(Customer arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(customer != <span class="keyword">null</span>)</span><br><span class="line">            customer.friendOrders().remove(<span class="keyword">this</span>);</span><br><span class="line">        customer = arg;</span><br><span class="line">        <span class="keyword">if</span>(customer != <span class="keyword">null</span>)</span><br><span class="line">            customer.friendOrders().add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function">Set&lt;Order&gt; <span class="title">friengOrders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orders;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Change-Bidirectional-Association-to-Unidirectional-（将双向关联改为单向关联）"><a href="#Change-Bidirectional-Association-to-Unidirectional-（将双向关联改为单向关联）" class="headerlink" title="Change Bidirectional Association to Unidirectional （将双向关联改为单向关联）"></a>Change Bidirectional Association to Unidirectional （将双向关联改为单向关联）</h3><p>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。<strong>去除不必要的关联。</strong></p><p>双向关联很有用，但你也为必须为它付出代价，那就是维护双向连接、确保对象被正确创建和删除而增加的复杂度。大量双向连接也容易造成“僵尸对象”：某个对象本来已经死亡了，却仍然保留在系统中，因为对它的引用还没有完全清除。</p><h3 id="Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）"><a href="#Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）" class="headerlink" title="Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）"></a>Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）</h3><p>你有一个字面数值，带有特别意义。<strong>创建一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">potentialEnergy</span><span class="params">(<span class="keyword">double</span> mass, <span class="keyword">double</span> height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mass * <span class="number">9.81</span> * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> GRAVITATIONAL_CONSTANT = <span class="number">9.81</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">potentialEnergy</span><span class="params">(<span class="keyword">double</span> mass, <span class="keyword">double</span> height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mass * GRAVITATIONAL_CONSTANT * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Encapsulate-Field（封装字段）"><a href="#Encapsulate-Field（封装字段）" class="headerlink" title="Encapsulate Field（封装字段）"></a>Encapsulate Field（封装字段）</h3><p>你的类中存在一个 public 字段。<strong>将它声明为 private，并提供相应的访问函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String name;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Encapsulate-Collection（封装集合）"><a href="#Encapsulate-Collection（封装集合）" class="headerlink" title="Encapsulate Collection（封装集合）"></a>Encapsulate Collection（封装集合）</h3><p>有个函数返回一个集合。<strong>让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; skills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String[] getSkills()&#123;</span><br><span class="line">        <span class="keyword">return</span> (String[])skills.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSkill</span><span class="params">(<span class="keyword">int</span> index, String newSkill)</span></span>&#123;</span><br><span class="line">        skill.set(index, newSkill);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="Replace Record with Data Class（以数据类取代记录）"></a>Replace Record with Data Class（以数据类取代记录）</h3><p>你需要面对传统编程环境中的记录结构。为该记录创建一个 POJO。</p><h3 id="Replace-Type-Code-with-Class（以类取代类型码）"><a href="#Replace-Type-Code-with-Class（以类取代类型码）" class="headerlink" title="Replace Type Code with Class（以类取代类型码）"></a>Replace Type Code with Class（以类取代类型码）</h3><p>类之中有一个数值类型码，但它不影响类的行为。<strong>以一个新的类替换该数值类型码。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> O = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> AB = <span class="number">3</span>;</span><br><span class="line">    privaet <span class="keyword">int</span> bloodGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BloodGroup bloddGroup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloodGroup</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup O = <span class="keyword">new</span> BloodGroup(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup A = <span class="keyword">new</span> BloodGroup(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup B = <span class="keyword">new</span> BloodGroup(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup AB = <span class="keyword">new</span> BloodGroup(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup[] values = &#123;O,A,B,AB&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BloodGroup</span><span class="params">(<span class="keyword">int</span> code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Type-Code-with-Subclasses（以子类取代类型码）"><a href="#Replace-Type-Code-with-Subclasses（以子类取代类型码）" class="headerlink" title="Replace Type Code with Subclasses（以子类取代类型码）"></a>Replace Type Code with Subclasses（以子类取代类型码）</h3><p>你有一个不可变的类型码，它会影响类的行为。<strong>以子类取代这个类型码。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENGINEER = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SALESMAN = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MANAGER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.ENGINEER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他两个不写了</span></span><br></pre></td></tr></table></figure><h3 id="Replace-Type-Code-with-State-Strategy-（以State-Strategy取代类型码）"><a href="#Replace-Type-Code-with-State-Strategy-（以State-Strategy取代类型码）" class="headerlink" title="Replace Type Code with State/Strategy （以State/Strategy取代类型码）"></a>Replace Type Code with State/Strategy （以State/Strategy取代类型码）</h3><p>你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它。<strong>以状态对象取代类型码。</strong></p><p>继续使用上面的 Employee 例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeType</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getTypeCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTypeCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.ENGNIEER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩余两个省略</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENGINEER = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SALESMAN = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MANAGER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> EmployeeType type;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type.getTypeCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(arg)&#123;</span><br><span class="line">            <span class="keyword">case</span> ENGNIEER:</span><br><span class="line">                type = <span class="keyword">new</span> Engineer();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SALESMAN:</span><br><span class="line">                type = <span class="keyword">new</span> Salesman();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MANAGER:</span><br><span class="line">                type = <span class="keyword">new</span> Manager();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Incorrect Employee Code"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Subclass-with-Field（以字段取代子类）"><a href="#Replace-Subclass-with-Field（以字段取代子类）" class="headerlink" title="Replace Subclass with Field（以字段取代子类）"></a>Replace Subclass with Field（以字段取代子类）</h3><p>你的各个子类的唯一差别只在“返回常量数据”的函数上。<strong>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'M'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'F'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> code;</span><br><span class="line">    Person(<span class="keyword">char</span> code)&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Person <span class="title">createMale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">'M'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Person <span class="title">createFemale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">'F'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简化条件表达式"><a href="#简化条件表达式" class="headerlink" title="简化条件表达式"></a>简化条件表达式</h2><h3 id="Decompose-Conditional（分解条件表达式）"><a href="#Decompose-Conditional（分解条件表达式）" class="headerlink" title="Decompose Conditional（分解条件表达式）"></a>Decompose Conditional（分解条件表达式）</h3><p>你有一个复杂的条件（if - then - else）语句。<strong>从 if、then、else 三个段落中分别提炼处独立函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(date.before (SUMMER_START) || date.after(SUMMER_END))</span><br><span class="line">    charge = quantity * winterRate + winterServiceCharge;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    charge = quantity * summerRate;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(notSummer(date))</span><br><span class="line">    charge = winterCharge(quantity);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    charge = summerCharge(quantity);</span><br></pre></td></tr></table></figure><h3 id="Consolidate-Conditional-Expression（合并条件表达式）"><a href="#Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="Consolidate Conditional Expression（合并条件表达式）"></a>Consolidate Conditional Expression（合并条件表达式）</h3><p>你有一系列条件测试，都得到相同结果。<strong>将这些测试合并为一个条件表达式，并将这个条件表达式提炼为一个独立函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seniority &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(monthsDisabled &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isPartTime) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isNotEligibleForDisability()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNotEligibleForDisability</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seniority &lt; <span class="number">2</span> || monthsDisabled &gt; <span class="number">12</span> || isPartTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="Consolidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>Consolidate Duplicate Conditional Fragments（合并重复的条件片段）</h3><p>在条件表达式的每个分支上有着相同的一段代码。<strong>将这段重复代码搬移到条件表达式之外。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isSpecialDeal())&#123;</span><br><span class="line">    total = price * <span class="number">0.95</span>;</span><br><span class="line">    send();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    total = price * <span class="number">0.98</span>;</span><br><span class="line">    send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isSpecialDeal())</span><br><span class="line">    total = price * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    total = price * <span class="number">0.98</span>;</span><br><span class="line">send();</span><br></pre></td></tr></table></figure><h3 id="Remove-Control-Flag（移除控制标记）"><a href="#Remove-Control-Flag（移除控制标记）" class="headerlink" title="Remove Control Flag（移除控制标记）"></a>Remove Control Flag（移除控制标记）</h3><p>在一系列布尔表达式中，某个变量带有“控制标记（control flag）的作用。<strong>以 break 语句或 return 语句取代控制标记。</strong></p><h3 id="Replace-Nested-Conditional-with-Guard-Classes（以卫语句取代嵌套条件表达式）"><a href="#Replace-Nested-Conditional-with-Guard-Classes（以卫语句取代嵌套条件表达式）" class="headerlink" title="Replace Nested Conditional with Guard Classes（以卫语句取代嵌套条件表达式）"></a>Replace Nested Conditional with Guard Classes（以卫语句取代嵌套条件表达式）</h3><p>函数中的条件逻辑使人难以看清正常的执行路径。<strong>使用卫语句（单独检查语句）</strong>表现所有特殊情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">    <span class="keyword">if</span>(isDead) result = deadAmount();</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isSeparated) result = separatedAmount();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isRetired) result = retiredAmount();</span><br><span class="line">            <span class="keyword">else</span> result = normalPayment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isDead) <span class="keyword">return</span> deadAmount();</span><br><span class="line">    <span class="keyword">if</span>(isSeparated) <span class="keyword">return</span> separatedAmount();</span><br><span class="line">    <span class="keyword">if</span>(isRetired) <span class="keyword">return</span> retiredAmount();</span><br><span class="line">    <span class="keyword">return</span> normalAmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>Replace Conditional with Polymorphism（以多态取代条件表达式）</h3><p>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。<strong>将这个条件表达式的每个分支放进一个子类的覆写函数中，然后将原始函数声明为抽象函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> EUROPEAN : <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">        <span class="keyword">case</span> AFRICAN: <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() * numberOfCoconuts;</span><br><span class="line">        <span class="keyword">case</span> NORWEGIAN_BLUE: <span class="keyword">return</span> isNailed ? <span class="number">0</span> : getBaseSpeed(voltage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">European</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSpeed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩下两个类省略</span></span><br></pre></td></tr></table></figure><h3 id="Introduce-Null-Object（引入-Null-对象）"><a href="#Introduce-Null-Object（引入-Null-对象）" class="headerlink" title="Introduce Null Object（引入 Null 对象）"></a>Introduce Null Object（引入 Null 对象）</h3><p>你需要再三检查某独享是否为 null。<strong>将 null 值替换为 null 对象。</strong></p><h3 id="Introduce-Assertion（引入断言）"><a href="#Introduce-Assertion（引入断言）" class="headerlink" title="Introduce Assertion（引入断言）"></a>Introduce Assertion（引入断言）</h3><p>某一段代码需要对程序状态做出某种假设。<strong>以断言明确表现这种假设。</strong></p><p>断言的失败应该导致一个非受控异常。程序最后的成品往往将断言统统删除。</p><h2 id="简化函数调用"><a href="#简化函数调用" class="headerlink" title="简化函数调用"></a>简化函数调用</h2><h3 id="Remove-Method（函数改名）"><a href="#Remove-Method（函数改名）" class="headerlink" title="Remove Method（函数改名）"></a>Remove Method（函数改名）</h3><p>函数的名称未能揭示函数的用途。<strong>修改函数名称。</strong></p><h3 id="Add-Parameter（添加参数）"><a href="#Add-Parameter（添加参数）" class="headerlink" title="Add Parameter（添加参数）"></a>Add Parameter（添加参数）</h3><p>某个函数需要从调用端得到更多信息。<strong>为此函数添加一个对象参数，让该对象带进函数所需信息。</strong></p><h3 id="Remove-Parameter（移除参数）"><a href="#Remove-Parameter（移除参数）" class="headerlink" title="Remove Parameter（移除参数）"></a>Remove Parameter（移除参数）</h3><p>函数本体不再需要某个参数。<strong>将该参数去除。</strong></p><h3 id="Separate-Query-from-Modifier（将查询函数和修改函数分离）"><a href="#Separate-Query-from-Modifier（将查询函数和修改函数分离）" class="headerlink" title="Separate Query from Modifier（将查询函数和修改函数分离）"></a>Separate Query from Modifier（将查询函数和修改函数分离）</h3><p>某个函数既返回对象状态值，又修改对象状态。<strong>建立两个不同的函数，其中一个负责查询，另一个负责修改。</strong></p><h3 id="Parameterize-Method（令函数携带参数）"><a href="#Parameterize-Method（令函数携带参数）" class="headerlink" title="Parameterize Method（令函数携带参数）"></a>Parameterize Method（令函数携带参数）</h3><p>若干函数做了类似的工作，但在函数本体中却包含了不同的值。<strong>建立单一函数，以参数表达那些不同的值。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fivePercentRaise</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tenPercentRaise</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">raise</span><span class="params">(<span class="keyword">double</span> percentage)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）"><a href="#Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）" class="headerlink" title="Replace Parameter with Explicit Methods（以明确函数取代参数）"></a>Replace Parameter with Explicit Methods（以明确函数取代参数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String name, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name.equals(<span class="string">"height"</span>))&#123;</span><br><span class="line">        height = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(name.equals(<span class="string">"width"</span>))&#123;</span><br><span class="line">        width = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    height = arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    width = arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Preserve-Whole-Object（保持对象完整）"><a href="#Preserve-Whole-Object（保持对象完整）" class="headerlink" title="Preserve Whole Object（保持对象完整）"></a>Preserve Whole Object（保持对象完整）</h3><p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。<strong>改为传递整个对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange().getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTemoRange().getHigh();</span><br><span class="line">withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">withinPlan = plan,withinRange(daysTempRange());</span><br></pre></td></tr></table></figure><h3 id="Replace-Parameter-with-Methods（以函数取代函数）"><a href="#Replace-Parameter-with-Methods（以函数取代函数）" class="headerlink" title="Replace Parameter with Methods（以函数取代函数）"></a>Replace Parameter with Methods（以函数取代函数）</h3><p>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能调用前一个函数。<strong>让参数接受者去除该项参数，并直接调用前一个函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line">discountLevel = getDiscountLevel();</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice, discountLevel);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice);</span><br><span class="line"><span class="comment">// 让 discountedPrice 直接调用 getDiscountLevel 函数</span></span><br></pre></td></tr></table></figure><h3 id="Introduce-Parameter-Object（引入参数对象）"><a href="#Introduce-Parameter-Object（引入参数对象）" class="headerlink" title="Introduce Parameter Object（引入参数对象）"></a>Introduce Parameter Object（引入参数对象）</h3><p>某些参数总是很自然地同时出现。<strong>以一个对象取代这些参数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">amountInvoicedIn</span><span class="params">(Date start, Date end)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">amountInvoicedIn</span><span class="params">(DateRange dateRange)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Remove-Setting-Method（移除设值函数）"><a href="#Remove-Setting-Method（移除设值函数）" class="headerlink" title="Remove Setting Method（移除设值函数）"></a>Remove Setting Method（移除设值函数）</h3><p>类中的某个字段应该在对象创建时被设值，然后就不再改变。<strong>去掉该字段的所有设值函数。</strong></p><h3 id="Hide-Method（隐藏函数）"><a href="#Hide-Method（隐藏函数）" class="headerlink" title="Hide Method（隐藏函数）"></a>Hide Method（隐藏函数）</h3><p>有一个函数，从来没有被其他任何类用到。<strong>将这个函数修改为 private。</strong></p><h3 id="Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）"><a href="#Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）" class="headerlink" title="Replace Constructor with Factory Method（以工厂函数取代构造函数）"></a>Replace Constructor with Factory Method（以工厂函数取代构造函数）</h3><p>你希望在创建对象时不仅仅是做简单的建构动作。<strong>将构造函数替换为工厂函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee(<span class="keyword">int</span> type)&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Employee <span class="title">create</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Employee(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Encapsulate-Downcast（封装向下转型）"><a href="#Encapsulate-Downcast（封装向下转型）" class="headerlink" title="Encapsulate Downcast（封装向下转型）"></a>Encapsulate Downcast（封装向下转型）</h3><p>某个函数返回的对象，需要函数调用者执行向下转型（downcast）。<strong>将向下转型动作移到函数中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">lastReading</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readings.lastElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Reading <span class="title">lastReading</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Reading)readings.lastElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Error-Code-with-Exception（以异常取代错误码）"><a href="#Replace-Error-Code-with-Exception（以异常取代错误码）" class="headerlink" title="Replace Error Code with Exception（以异常取代错误码）"></a>Replace Error Code with Exception（以异常取代错误码）</h3><p>某个函数返回一个特定的代码，用以表示某种特殊情况。<strong>改用异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &gt; balance)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> <span class="keyword">throws</span> BalaceException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &gt; balance) <span class="keyword">throw</span> <span class="keyword">new</span> BalanceException();</span><br><span class="line">    balance -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Exception-with-Test（以测试取代异常）"><a href="#Replace-Exception-with-Test（以测试取代异常）" class="headerlink" title="Replace Exception with Test（以测试取代异常）"></a>Replace Exception with Test（以测试取代异常）</h3><p>面对一个调用着可以预先检查的条件，你抛出了一个异常。<strong>修改调用者，使它在调用函数之气那先做检查。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getValueForPeriod</span><span class="params">(<span class="keyword">int</span> periodNumber)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value[periodNumber];</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123; <span class="comment">// 滥用异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getValueForPeriod</span><span class="params">(<span class="keyword">int</span> periodNumber)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(periodNumber &gt;= values.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> values[periodNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理概括关系（继承关系）"><a href="#处理概括关系（继承关系）" class="headerlink" title="处理概括关系（继承关系）"></a>处理概括关系（继承关系）</h2><h3 id="Pull-Up-Field（字段上移）"><a href="#Pull-Up-Field（字段上移）" class="headerlink" title="Pull Up Field（字段上移）"></a>Pull Up Field（字段上移）</h3><p>两个子类拥有相同的字段。<strong>将该字段移至超类。</strong></p><h3 id="Pull-Up-Method（函数上移）"><a href="#Pull-Up-Method（函数上移）" class="headerlink" title="Pull Up Method（函数上移）"></a>Pull Up Method（函数上移）</h3><p>有些函数，在各个子类中产生完全相同的结果。<strong>将该函数移至超类。</strong></p><h3 id="Pull-Up-Constructor-Body（构造函数本体上移）"><a href="#Pull-Up-Constructor-Body（构造函数本体上移）" class="headerlink" title="Pull Up Constructor Body（构造函数本体上移）"></a>Pull Up Constructor Body（构造函数本体上移）</h3><p>你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。<strong>在超类中新建一个构造函数，并在子类构造函数中调用它。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    Manager(String name, String id, <span class="keyword">int</span> grade)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    Manager(String name, String id, <span class="keyword">int</span> grade)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, id);</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Push-Down-Method（函数下移）"><a href="#Push-Down-Method（函数下移）" class="headerlink" title="Push Down Method（函数下移）"></a>Push Down Method（函数下移）</h3><p>超类中的某个函数只与部分（而非全部）子类有关。<strong>将这个函数移到相关的那些子类去。</strong></p><h3 id="Push-Down-Field（字段下移）"><a href="#Push-Down-Field（字段下移）" class="headerlink" title="Push Down Field（字段下移）"></a>Push Down Field（字段下移）</h3><p>超类中的某些字段只被部分（而非全部）子类用到。<strong>将这个字段移到需要它的那些子类去。</strong></p><h3 id="Extract-Subclass（提炼子类）"><a href="#Extract-Subclass（提炼子类）" class="headerlink" title="Extract Subclass（提炼子类）"></a>Extract Subclass（提炼子类）</h3><p>类中的某些特性只被某些（而非全部）实例用到。<strong>新建一个子类，将上面所说的那一部分特性移到子类中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">unitPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">Employee <span class="title">getEmployee</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">unitPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaborItem</span> <span class="keyword">extends</span> <span class="title">JobItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">unitPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">Employee <span class="title">getEmployee</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Extract-Superclass（提炼超类）"><a href="#Extract-Superclass（提炼超类）" class="headerlink" title="Extract Superclass（提炼超类）"></a>Extract Superclass（提炼超类）</h3><p>两个类有相似特性。<strong>为这两个类建立一个超类，将相同特性移至超类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeadCount</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Party</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Party</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeadCount</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Extract-Interface（提炼接口）"><a href="#Extract-Interface（提炼接口）" class="headerlink" title="Extract Interface（提炼接口）"></a>Extract Interface（提炼接口）</h3><p>若干客户使用类接口中的同一子集，或者两个类的接口有部分相同。<strong>将相同的子集提炼到独立接口中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRate</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">hasSpecialSkill</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    String getDepartment&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Billable</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">hasSpecialSkill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Billable</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRate</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">hasSpecialSkill</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    String getDepartment&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collapse-Hierarchy（折叠继承体系）"><a href="#Collapse-Hierarchy（折叠继承体系）" class="headerlink" title="Collapse Hierarchy（折叠继承体系）"></a>Collapse Hierarchy（折叠继承体系）</h3><p>超类与子类之间无太大区别。<strong>将它们合为一体。</strong></p><h3 id="Form-Template-Method（塑造模板函数）"><a href="#Form-Template-Method（塑造模板函数）" class="headerlink" title="Form Template Method（塑造模板函数）"></a>Form Template Method（塑造模板函数）</h3><p>你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同。</p><p><strong>将这些操作分别放金独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。</strong></p><h3 id="Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="Replace Inheritance with Delegation（以委托取代继承）"></a>Replace Inheritance with Delegation（以委托取代继承）</h3><p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来得数据。<strong>在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。</strong></p><h3 id="Replace-Delegation-with-Inheritance（以继承取代委托）"><a href="#Replace-Delegation-with-Inheritance（以继承取代委托）" class="headerlink" title="Replace Delegation with Inheritance（以继承取代委托）"></a>Replace Delegation with Inheritance（以继承取代委托）</h3><p>你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。<strong>让委托类继承受托类。</strong></p><h2 id="大型重构"><a href="#大型重构" class="headerlink" title="大型重构"></a>大型重构</h2><h3 id="Tease-Apart-Inheritance（梳理并分解继承体系）"><a href="#Tease-Apart-Inheritance（梳理并分解继承体系）" class="headerlink" title="Tease Apart Inheritance（梳理并分解继承体系）"></a>Tease Apart Inheritance（梳理并分解继承体系）</h3><p>某个继承体系同时承担两项责任。<strong>建立两个继承体系，并通过委托关系让其中一个可以调用另一个。</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201016150252385.png" alt="image-20201016150252385"></p><h3 id="Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）"><a href="#Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）" class="headerlink" title="Convert Procedural Design to Objects（将过程化设计转换为对象设计）"></a>Convert Procedural Design to Objects（将过程化设计转换为对象设计）</h3><p>你手上有一些传统过程化风格的代码。<strong>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象中。</strong></p><h3 id="Separate-Domain-from-Presentation（将领域和表述-显示分离）"><a href="#Separate-Domain-from-Presentation（将领域和表述-显示分离）" class="headerlink" title="Separate Domain from Presentation（将领域和表述/显示分离）"></a>Separate Domain from Presentation（将领域和表述/显示分离）</h3><p>某些 GUI 类中包含了领域逻辑。<strong>将领域逻辑分离出来，为它们建立独立的领域类。</strong></p><p>MVC 模式最核心的价值在于：它将用户界面代码（即视图；也是“展示层”）和领域逻辑（即模型）分离了。展现类只含用以处理用户界面的逻辑；领域类不含任何与程序外观的代码，只含业务逻辑相关代码。</p><h3 id="Extract-Hierarchy（提炼继承体系）"><a href="#Extract-Hierarchy（提炼继承体系）" class="headerlink" title="Extract Hierarchy（提炼继承体系）"></a>Extract Hierarchy（提炼继承体系）</h3><p>你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的。<strong>建立继承体系，以一个子类表示一种特殊情况。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码的坏味道&quot;&gt;&lt;a href=&quot;#代码的坏味道&quot; class=&quot;headerlink&quot; title=&quot;代码的坏味道&quot;&gt;&lt;/a&gt;代码的坏味道&lt;/h2&gt;&lt;h3 id=&quot;Duplicated-Code（重复代码）&quot;&gt;&lt;a href=&quot;#Duplicated-Code（重复代码）&quot; class=&quot;headerlink&quot; title=&quot;Duplicated Code（重复代码）&quot;&gt;&lt;/a&gt;Duplicated Code（重复代码）&lt;/h3&gt;&lt;p&gt;如果你在一个以上的地方看见相同的程序结构，将它们合二为一。&lt;/p&gt;
&lt;h3 id=&quot;Long-Method（过长函数）&quot;&gt;&lt;a href=&quot;#Long-Method（过长函数）&quot; class=&quot;headerlink&quot; title=&quot;Long Method（过长函数）&quot;&gt;&lt;/a&gt;Long Method（过长函数）&lt;/h3&gt;&lt;p&gt;将过长的函数分解为若干个小函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://hoo334.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>填充每个节点的下一个右侧节点指针</title>
    <link href="https://hoo334.github.io/2020/10/15/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <id>https://hoo334.github.io/2020/10/15/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</id>
    <published>2020-10-15T00:50:05.000Z</published>
    <updated>2020-10-15T01:10:36.824Z</updated>
    
    <content type="html"><![CDATA[<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></h4><p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><a id="more"></a><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201015085236630.png" alt=""></p><p><strong>方法一：层次遍历</strong></p><p>在遍历每层时将同一层的结点连接起来。</p><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul><p><strong>方法二：使用已建立的 next 指针</strong></p><p>我们使用 nextHead 指针保存下一层的头节点，nextTail 保存下一层的尾结点。使用 ptr 指针遍历当前层的结点，同时将下一层的结点连接成链表。令 ptr = nextHead，即可遍历下一层结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node nextHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Node nextTail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Node ptr = root;</span><br><span class="line">        <span class="keyword">while</span>(ptr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前层开始访问时将下一层信息清空</span></span><br><span class="line">            nextHead = <span class="keyword">null</span>;</span><br><span class="line">            nextTail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//连接</span></span><br><span class="line">            <span class="keyword">while</span>(ptr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ptr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    helper(ptr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ptr.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    helper(ptr.right);</span><br><span class="line">                &#125;</span><br><span class="line">                ptr = ptr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入下一层</span></span><br><span class="line">            ptr = nextHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(Node nextNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//维护下一层的头节点和尾结点</span></span><br><span class="line">        <span class="keyword">if</span>(nextHead == <span class="keyword">null</span>)&#123;</span><br><span class="line">        nextHead = nextNode;</span><br><span class="line">        nextTail = nextHead;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        nextTail.next = nextNode;</span><br><span class="line">        nextTail = nextTail.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul><p>注意到题目中的<strong><em>完美二叉树</em></strong>条件，我们可以更加简单地使用 next 指针。</p><p>对于结点的连接只有两种情况：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201015090455731.png" alt=""></p><ol><li>左右子节点相连</li><li>当前结点的右子结点和下一个结点的左子结点相连</li></ol><p>下一层的头节点就是当前层头节点的左子结点（任何一个结点都有左右子节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node leftmost = root;</span><br><span class="line">        <span class="keyword">while</span>(leftmost.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node head = leftmost;</span><br><span class="line">            <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">                head.left.next = head.right;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(head.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head.right.next = head.next.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            leftmost = leftmost.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;116-填充每个节点的下一个右侧节点指针&quot;&gt;&lt;a href=&quot;#116-填充每个节点的下一个右侧节点指针&quot; class=&quot;headerlink&quot; title=&quot;116. 填充每个节点的下一个右侧节点指针&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;116. 填充每个节点的下一个右侧节点指针&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个&lt;strong&gt;完美二叉树&lt;/strong&gt;，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct Node &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Node *left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Node *right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Node *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 &lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;初始状态下，所有 next 指针都被设置为 &lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="https://hoo334.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>环形链表II</title>
    <link href="https://hoo334.github.io/2020/10/10/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
    <id>https://hoo334.github.io/2020/10/10/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</id>
    <published>2020-10-10T00:54:14.000Z</published>
    <updated>2020-10-10T01:23:45.857Z</updated>
    
    <content type="html"><![CDATA[<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h4><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>说明：</strong>不允许修改给定的链表。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201010085610758.png" alt="image-20201010085610758"></p><p><strong>方法一：快慢指针</strong></p><p>在环形链表中，我们使用快慢指针，快慢指针相遇则链表中有环。我们具体分析相遇时的情况：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201010090508224.png" alt="image-20201010090508224"></p><p>假设相遇的点在图中红点处，快慢指针在快指针走了 n 圈后相遇，快指针走过的总路程为 <code>a + n(b + c) + b</code>，慢指针走过的总路程为<code>a + b</code>，由于快指针走过的路程是慢指针走过路程的两倍，故<code>a + n(b + c) + b == 2(a + b)</code>，得到<code>a = (n - 1)(b + c) + c</code>，到这里我们发现从相遇点到入环点的距离加上 n - 1 圈的环长，恰好等于从链表头部到入环点的位置。</p><p>在快慢指针相遇时，让另外一个指针 ptr 从链表头开始向后走，同时让慢指针在环中走，当两个指针相遇时，ptr 指向的结点就是环的入口，此时慢指针走过的路程为<code>(n - 1)(b + c) + c</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                ListNode ptr = head;</span><br><span class="line">                <span class="keyword">while</span>(ptr != slow)&#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul><p><strong>方法二：哈希表</strong></p><p>使用一个哈希表存储已经访问过的结点，发现当前访问过的结点存在于哈希表，返回当前结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pos = head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(pos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(pos))&#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(pos);</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;142-环形链表-II&quot;&gt;&lt;a href=&quot;#142-环形链表-II&quot; class=&quot;headerlink&quot; title=&quot;142. 环形链表 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;142. 环形链表 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;不允许修改给定的链表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="https://hoo334.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
  </entry>
  
  <entry>
    <title>颜色分类</title>
    <link href="https://hoo334.github.io/2020/10/07/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <id>https://hoo334.github.io/2020/10/07/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</id>
    <published>2020-10-07T01:24:40.000Z</published>
    <updated>2020-10-07T01:40:33.448Z</updated>
    
    <content type="html"><![CDATA[<h4 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></h4><p>给定一个包含红色、白色和蓝色，一共 <em>n</em> 个元素的数组，<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><p><strong>方法一：单指针</strong></p><p>使用两次遍历，第一次遍历将所有的 0 交换到数组头部，第二次遍历将所有的 1 交换到数组头部的 0 之后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[ptr];</span><br><span class="line">                nums[ptr] = temp;</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ptr; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[ptr];</span><br><span class="line">                nums[ptr] = temp;</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：双指针</strong></p><p>使用 p0 指针维护数组前部的 0 ，使用 p2 指针维护数组后部的 2 。在遍历的过程中，我们需要找出所有的 0 交换至数组的头部，找出所有的 2 交换至数组的尾部。</p><p>从左到右遍历整个数组，设当前遍历到的位置为 i ，对应的元素为 nums[i]；</p><ul><li>如果 nums[i] = 0，将其与 nums[p0] 交换，将 p0 后移一个位置；</li><li>如果 nums[i] = 2，将其与 nums[p2] 交换，将 p2 前移一个位置；</li></ul><p>对于第二种情况，交换后 nums[i] 可能为 2 ，也可能为 0。当我们找到 2 时，需要<strong>不断</strong>地将其与 nums[p2] 进行交换，直到新的 nums[i] 不为 2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= p2; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= p2 &amp;&amp; nums[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                nums[i] = nums[p2];</span><br><span class="line">                nums[p2] = <span class="number">2</span>;</span><br><span class="line">                --p2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = nums[p0];</span><br><span class="line">                nums[p0] = <span class="number">0</span>;</span><br><span class="line">                ++p0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;75-颜色分类&quot;&gt;&lt;a href=&quot;#75-颜色分类&quot; class=&quot;headerlink&quot; title=&quot;75. 颜色分类&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-colors/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;75. 颜色分类&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个包含红色、白色和蓝色，一共 &lt;em&gt;n&lt;/em&gt; 个元素的数组，&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/原地算法&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt;对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。&lt;/p&gt;
&lt;p&gt;此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;br&gt;不能使用代码库中的排序函数来解决这道题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="双指针" scheme="https://hoo334.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树中的插入操作</title>
    <link href="https://hoo334.github.io/2020/10/02/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <id>https://hoo334.github.io/2020/10/02/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</id>
    <published>2020-10-02T01:24:17.000Z</published>
    <updated>2020-10-02T01:34:24.769Z</updated>
    
    <content type="html"><![CDATA[<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></h4><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p> <a id="more"></a><p>例如, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和 插入的值: 5</span><br></pre></td></tr></table></figure><p>你可以返回这个二叉搜索树:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F;</span><br><span class="line">1   3 5</span><br></pre></td></tr></table></figure><p>或者这个树也是有效的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     5</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   </span><br><span class="line">1   3</span><br><span class="line">     \</span><br><span class="line">      4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li><li>每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li><li><code>-10^8 &lt;= val &lt;= 10^8</code></li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul><p>我们把要插入的结点和根结点的值比较：</p><ul><li>比根节点值大，如果根节点右子结点为空，直接将其插入到根节点的右子结点；如果根节点右子结点不为空，将根节点右子结点设为根节点，重复执行上述操作。</li><li>比根节点值小，如果根节点左子结点为空，直接将其插入到根节点的左子结点；如果根节点左子结点不为空，将根节点左子结点设为根节点，重复执行上述操作。</li></ul><p><strong>方法一：递归</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：迭代</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode pos = root;</span><br><span class="line">        <span class="keyword">while</span>(pos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; pos.val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pos.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pos = pos.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pos.left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pos = pos.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;701-二叉搜索树中的插入操作&quot;&gt;&lt;a href=&quot;#701-二叉搜索树中的插入操作&quot; class=&quot;headerlink&quot; title=&quot;701. 二叉搜索树中的插入操作&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;701. 二叉搜索树中的插入操作&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。&lt;/p&gt;
&lt;p&gt;注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>填充每个节点的下一个右侧节点指针II</title>
    <link href="https://hoo334.github.io/2020/10/02/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II/"/>
    <id>https://hoo334.github.io/2020/10/02/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II/</id>
    <published>2020-10-02T01:08:47.000Z</published>
    <updated>2020-10-02T01:22:38.992Z</updated>
    
    <content type="html"><![CDATA[<h4 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. 填充每个节点的下一个右侧节点指针 II</a></h4><p>给定一个二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p> <a id="more"></a><p><strong>进阶：</strong></p><ul><li><p>你只能使用常量级额外空间。</p></li><li><p>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><p><strong>示例：</strong></p></li></ul><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201002091021913.png" alt="image-20201002091021913"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>树中的节点数小于 <code>6000</code></li><li><code>-100 &lt;= node.val &lt;= 100</code></li></ul><p><strong>方法一：层次遍历</strong></p><p>我们可以想到层次遍历，将每一层的结点串起来。这样时间复杂度为O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="comment">//保存上一个结点指针</span></span><br><span class="line">            Node last = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//将每层结点链接起来</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                Node t = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(t.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                    last.next = t;</span><br><span class="line">                &#125;</span><br><span class="line">                last = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul><p><strong>方法二：使用已建立的 Next 指针</strong></p><p>对于第一层的第一个元素，它的第一个孩子结点就是下一层的起始结点，我们使用一个指针<code>nextStart</code>维护这个结点。将当前层的所有结点的子节点链接起来，在遍历到下一层时，将<code>nextStart</code>置为当前层的首结点就可以访问到当前层的所有结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node last = <span class="keyword">null</span>, nextStart = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//当前层的第一个结点</span></span><br><span class="line">        Node start = root;</span><br><span class="line">        <span class="keyword">while</span>(start != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将当前层的前一个结点和下一层的首结点置空</span></span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">            nextStart = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//对于当前层的每个结点，如果存在子节点，则将其链接起来，并维护下一层的起始结点</span></span><br><span class="line">            <span class="keyword">for</span>(Node p = start; p != <span class="keyword">null</span>; p = p.next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    handle(p.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    handle(p.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将下一层结点设置为当前层的起始结点</span></span><br><span class="line">            start = nextStart;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Node p)</span></span>&#123;</span><br><span class="line">        <span class="comment">//下一层的起始结点为空</span></span><br><span class="line">        <span class="keyword">if</span>(nextStart == <span class="keyword">null</span>)&#123;</span><br><span class="line">            nextStart = p;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//将前一个结点连接到当前结点</span></span><br><span class="line">        <span class="keyword">if</span>(last != <span class="keyword">null</span>)&#123;</span><br><span class="line">            last.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;117-填充每个节点的下一个右侧节点指针-II&quot;&gt;&lt;a href=&quot;#117-填充每个节点的下一个右侧节点指针-II&quot; class=&quot;headerlink&quot; title=&quot;117. 填充每个节点的下一个右侧节点指针 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;117. 填充每个节点的下一个右侧节点指针 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二叉树&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct Node &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Node *left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Node *right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Node *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 &lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;初始状态下，所有 next 指针都被设置为 &lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>监控二叉树</title>
    <link href="https://hoo334.github.io/2020/09/22/%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/09/22/%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-09-22T02:17:07.000Z</published>
    <updated>2020-09-22T02:22:07.808Z</updated>
    
    <content type="html"><![CDATA[<h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a><a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener">968. 监控二叉树</a></h4><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p> <a id="more"></a><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200922101835400.png" alt="image-20200922101835400"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,0,null,0,0]</span><br><span class="line">输出：1</span><br><span class="line">解释：如图所示，一台摄像头足以监控所有节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200922102001569.png" alt="image-20200922102001569"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,0,null,0,null,0,null,null,0]</span><br><span class="line">输出：2</span><br><span class="line">解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个结点，为当前结点安装相机</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(root) == <span class="number">0</span>)&#123;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0: 待覆盖; 1: 已覆盖; 2: 已安装相机</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结点为空表示已覆盖</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span> r = dfs(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span> || r == <span class="number">0</span>)&#123; <span class="comment">// 有任意一个子结点未覆盖就需要将当前结点安装相机</span></span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">2</span> || r == <span class="number">2</span>)&#123; <span class="comment">// 任意一个结点安装了相机，当前结点为已覆盖</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//子结点都已覆盖，且都没有相机，当前结点由父节点来覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;968-监控二叉树&quot;&gt;&lt;a href=&quot;#968-监控二叉树&quot; class=&quot;headerlink&quot; title=&quot;968. 监控二叉树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-cameras/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;968. 监控二叉树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二叉树，我们在树的节点上安装摄像头。&lt;/p&gt;
&lt;p&gt;节点上的每个摄影头都可以监视&lt;strong&gt;其父对象、自身及其直接子对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算监控树的所有节点所需的最小摄像头数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>子集</title>
    <link href="https://hoo334.github.io/2020/09/20/%E5%AD%90%E9%9B%86/"/>
    <id>https://hoo334.github.io/2020/09/20/%E5%AD%90%E9%9B%86/</id>
    <published>2020-09-20T01:14:46.000Z</published>
    <updated>2020-09-20T01:26:23.527Z</updated>
    
    <content type="html"><![CDATA[<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></h4><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>方法一：回溯搜索</strong></p><p>执行一次深度优先搜索，一条路走到底，走不通的是否，返回回来，继续执行，一直递归，直到回到起点。</p><p>我们可以画出搜索路径。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/IMG_20200920_091853.jpg" alt="IMG_20200920_091853"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line">            dfs(nums, i + <span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：位运算</strong></p><p>对于数组 nums 中的每个数来说，有<code>选</code>和<code>不选</code>两种选择，我们可以使用二进制位来代替。”1“代表选中，”0“代表不选中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; len;</span><br><span class="line"><span class="comment">//[0, n) 的二进制代表了所有的组合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//判断每一位是否为 1 ，若为 1 将当前位对应的数字加入结果</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( ((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span> )&#123;</span><br><span class="line">                    cur.add(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;78-子集&quot;&gt;&lt;a href=&quot;#78-子集&quot; class=&quot;headerlink&quot; title=&quot;78. 子集&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/subsets/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;78. 子集&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一组&lt;strong&gt;不含重复元素&lt;/strong&gt;的整数数组 &lt;em&gt;nums&lt;/em&gt;，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;解集不能包含重复的子集。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>左叶子之和</title>
    <link href="https://hoo334.github.io/2020/09/19/%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/"/>
    <id>https://hoo334.github.io/2020/09/19/%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</id>
    <published>2020-09-19T02:22:11.000Z</published>
    <updated>2020-09-19T02:26:19.798Z</updated>
    
    <content type="html"><![CDATA[<h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. 左叶子之和</a></h4><p>计算给定二叉树的所有左叶子之和。</p><a id="more"></a><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure><p>我们可以很快写出所有叶子之和的递归代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个叶子是否为左叶子只有它的父节点知道，我们使用 father 来维护父节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//父结点指针</span></span><br><span class="line">    TreeNode father = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//判断当前叶子是否为左叶子</span></span><br><span class="line">            <span class="keyword">if</span>(father != <span class="keyword">null</span> &amp;&amp; father.left == root)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.val;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新父节点</span></span><br><span class="line">        father = root;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;404-左叶子之和&quot;&gt;&lt;a href=&quot;#404-左叶子之和&quot; class=&quot;headerlink&quot; title=&quot;404. 左叶子之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-left-leaves/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;404. 左叶子之和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;计算给定二叉树的所有左叶子之和。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>罗马数字转整数</title>
    <link href="https://hoo334.github.io/2020/09/19/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://hoo334.github.io/2020/09/19/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</id>
    <published>2020-09-19T02:17:30.000Z</published>
    <updated>2020-09-19T02:21:38.361Z</updated>
    
    <content type="html"><![CDATA[<h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数</a></h4><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p> <strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li><li>IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li><li>关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/罗马数字#knowledge_article" target="_blank" rel="noopener">罗马数字 - Mathematics </a>。</li></ul><p>由题意可知，当一个较小的数放在较大的数左侧时，结果就要减去这个较小的数；当一个较大的数放在较小的数左侧时，结果就要加上这个较大的数。</p><p>我们使用一个循环，每次先判断当前数和下一个数的大小，然后维护结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, curNum = map.get(s.charAt(<span class="number">0</span>)), nextNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            nextNum = map.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(curNum &lt; nextNum)&#123;</span><br><span class="line">                ans -= curNum;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += curNum;</span><br><span class="line">            &#125;</span><br><span class="line">            curNum = nextNum;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//加上最后一个罗马字符代表的数字</span></span><br><span class="line">        ans += curNum;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;13-罗马数字转整数&quot;&gt;&lt;a href=&quot;#13-罗马数字转整数&quot; class=&quot;headerlink&quot; title=&quot;13. 罗马数字转整数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/roman-to-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;13. 罗马数字转整数&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;罗马数字包含以下七种字符: &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数学" scheme="https://hoo334.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>3的幂</title>
    <link href="https://hoo334.github.io/2020/09/19/3%E7%9A%84%E5%B9%82/"/>
    <id>https://hoo334.github.io/2020/09/19/3%E7%9A%84%E5%B9%82/</id>
    <published>2020-09-19T02:13:32.000Z</published>
    <updated>2020-09-19T02:17:01.878Z</updated>
    
    <content type="html"><![CDATA[<h4 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326. 3的幂"></a><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">326. 3的幂</a></h4><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 27</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 45</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能不使用循环或者递归来完成本题吗？</p><p><strong>方法一：循环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：整数限制</strong></p><p>n 最大为 int 的最大值，我们将 int 范围内的最大 3 的幂次整数（1162261467）找出，如果它能整除 n ，则 n 为 3 的幂次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;326-3的幂&quot;&gt;&lt;a href=&quot;#326-3的幂&quot; class=&quot;headerlink&quot; title=&quot;326. 3的幂&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/power-of-three/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;326. 3的幂&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数，写一个函数来判断它是否是 3 的幂次方。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数学" scheme="https://hoo334.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>计算质数</title>
    <link href="https://hoo334.github.io/2020/09/19/%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0/"/>
    <id>https://hoo334.github.io/2020/09/19/%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0/</id>
    <published>2020-09-19T02:06:33.000Z</published>
    <updated>2020-09-19T02:11:05.431Z</updated>
    
    <content type="html"><![CDATA[<h4 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">204. 计数质数</a></h4><p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure><p>暴力方法会超时，我们使用<strong>厄拉多塞筛法</strong>。</p><p>该方法的核心是，<strong>一个质数的倍数不会是质数</strong>。具体来说，2 是质数，那么 4 ，6，8 … 不会是质数。</p><p>我们使用一个数组来存储是否为质数的标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// book 初始化全部为false，将不是质数的下标变为 true</span></span><br><span class="line">        <span class="keyword">boolean</span>[] book = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!book[i])&#123;</span><br><span class="line">                ++count;</span><br><span class="line">                <span class="comment">//质数 i 的倍数不可能为质数，将其标记为 true</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j += i)&#123;</span><br><span class="line">                    book[j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;204-计数质数&quot;&gt;&lt;a href=&quot;#204-计数质数&quot; class=&quot;headerlink&quot; title=&quot;204. 计数质数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/count-primes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;204. 计数质数&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;统计所有小于非负整数 &lt;em&gt;n&lt;/em&gt; 的质数的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数学" scheme="https://hoo334.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>全排列II</title>
    <link href="https://hoo334.github.io/2020/09/18/%E5%85%A8%E6%8E%92%E5%88%97II/"/>
    <id>https://hoo334.github.io/2020/09/18/%E5%85%A8%E6%8E%92%E5%88%97II/</id>
    <published>2020-09-18T01:50:36.000Z</published>
    <updated>2020-09-18T02:05:25.858Z</updated>
    
    <content type="html"><![CDATA[<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></h4><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>在搜索前对候选数组排序</strong>，一旦发现某个分支搜索下去可能搜索到重复的元素就停止搜索。</p><p>我们可以画出下面的递归图（来自<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">liweiwei</a>）：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200918095243920.png" alt="image-20200918095243920"></p><p>以[1, 1, 2] 为例，我们需要保证只出现一次 [1, 1, 2]，在上图中有两种情况，搜索的是同一个数字</p><ul><li>在图中②处，搜索的数和上一次一样，但上一次的<code>1</code>还在使用中。</li><li><strong>在图中①处，搜索的数和上一次一样，但上一次的<code>1</code>刚刚被撤销，由于它已经被撤销，有可能后面的搜索还会使用到它，因此会产生重复，需要剪掉它。</strong></li></ul><p>在<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a>的 DFS 代码中需要添加如下代码来进行剪枝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>])&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序是剪枝的基础</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;(len));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(index == len)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 剪枝条件：i &gt; 0 是为了保证 nums[i - 1] 有意义</span></span><br><span class="line">            <span class="comment">// 写 !used[i - 1] 是因为 nums[i - 1] 在深度优先遍历的过程中刚刚被撤销选择</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">            dfs(nums, index + <span class="number">1</span>, path);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;47-全排列-II&quot;&gt;&lt;a href=&quot;#47-全排列-II&quot; class=&quot;headerlink&quot; title=&quot;47. 全排列 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/permutations-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;47. 全排列 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个可包含重复数字的序列，返回所有不重复的全排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>全排列</title>
    <link href="https://hoo334.github.io/2020/09/18/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>https://hoo334.github.io/2020/09/18/%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2020-09-18T01:45:33.000Z</published>
    <updated>2020-09-18T01:49:59.336Z</updated>
    
    <content type="html"><![CDATA[<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h4><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>解释图例来自<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">liweiwei</a>。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200918094821040.png" alt="image-20200918094821040"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line"></span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;(len));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(index == len)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//没有使用的数字都可以使用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                path.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">                dfs(nums, index + <span class="number">1</span>, path);</span><br><span class="line"></span><br><span class="line">                path.removeLast();</span><br><span class="line">                visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;46-全排列&quot;&gt;&lt;a href=&quot;#46-全排列&quot; class=&quot;headerlink&quot; title=&quot;46. 全排列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/permutations/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;46. 全排列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个 &lt;strong&gt;没有重复&lt;/strong&gt; 数字的序列，返回其所有可能的全排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>解数独</title>
    <link href="https://hoo334.github.io/2020/09/15/%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
    <id>https://hoo334.github.io/2020/09/15/%E8%A7%A3%E6%95%B0%E7%8B%AC/</id>
    <published>2020-09-15T00:52:11.000Z</published>
    <updated>2020-09-15T01:08:50.920Z</updated>
    
    <content type="html"><![CDATA[<h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></h4><p>编写一个程序，通过已填充的空格来解决数独问题。</p><p>一个数独的解法需<strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li></ol><a id="more"></a><p>空白格用 <code>&#39;.&#39;</code> 表示。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200915085345737.png" alt="image-20200915085345737"></p><p>一个数独。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200915085359798.png" alt="image-20200915085359798"></p><p>答案被标成红色。</p><p><strong>Note:</strong></p><ul><li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li><li>你可以假设给定的数独只有唯一解。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><p>由于每个数字只能在同一行、同一列和同一个九宫格中只会出现一次，我们使用三个数组来标记该数字是否出现，如果出现则直接退出递归。同时使用一个数组保存剩余的空位，对每个空位尝试放入 1- 9的数字，如果将所有空位都使用完，没有出现错误则发现了一种解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] line = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] column = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][][] block = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="keyword">int</span>[]&gt; spaces = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">//保存空位</span></span><br><span class="line">                    spaces.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//标记已存在的数字</span></span><br><span class="line">                    <span class="keyword">int</span> digit = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//从第一个空位开始递归</span></span><br><span class="line">        dfs(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将所有空位用完，找到了一组解</span></span><br><span class="line">        <span class="keyword">if</span>(pos == spaces.size())&#123;</span><br><span class="line">            valid = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//获取一个空位</span></span><br><span class="line">        <span class="keyword">int</span>[] space = spaces.get(pos);</span><br><span class="line">        <span class="keyword">int</span> i = space[<span class="number">0</span>], j = space[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//尝试将该空位中放入 1-9 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> digit = <span class="number">0</span>; digit &lt; <span class="number">9</span> &amp;&amp; !valid; ++digit)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit])&#123;</span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="keyword">true</span>;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>) (digit + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">                dfs(board, pos + <span class="number">1</span>);</span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;37-解数独&quot;&gt;&lt;a href=&quot;#37-解数独&quot; class=&quot;headerlink&quot; title=&quot;37. 解数独&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sudoku-solver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;37. 解数独&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;编写一个程序，通过已填充的空格来解决数独问题。&lt;/p&gt;
&lt;p&gt;一个数独的解法需&lt;strong&gt;遵循如下规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一个以粗实线分隔的 &lt;code&gt;3x3&lt;/code&gt; 宫内只能出现一次。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>JPA中@Transactional怎么用？</title>
    <link href="https://hoo334.github.io/2020/09/11/@Transactional%E5%88%B0%E5%BA%95%E6%9C%89%E5%95%A5%E7%94%A8/"/>
    <id>https://hoo334.github.io/2020/09/11/@Transactional%E5%88%B0%E5%BA%95%E6%9C%89%E5%95%A5%E7%94%A8/</id>
    <published>2020-09-11T12:59:08.000Z</published>
    <updated>2020-09-15T00:44:24.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先新建一个 SpringBoot 项目，修改 pom.xml，增加以下内容：</p><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mysql --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后新建配置文件 application.yml，我们需要在本地有个 test 数据库。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/test?useSSL=true&amp;characterEncoding=utf-8&amp;serverTimezone=Hongkong</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">org.hibernate.dialect.MySQL5InnoDBDialect</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>新建实体类 User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"usr"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建启动类 DemoMain：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>  <span class="comment">//开启事务管理</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoMain<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，打开Navicat，可以看到 test 数据库中有一张 usr 表。</p><p>在Navicat 中插入两个User：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into usr(money) values(10000);</span><br><span class="line">insert into usr(money) values(0);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200911211455133.png" alt="image-20200911211455133"></p><p>到这里，一切准备就绪。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>新建 UserRepository ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Modifying;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Query;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"update usr set money = money - 1 where id = ?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(Long userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"update usr set money = money + 1 where id = ?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Long userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub()</code>方法使用户 1 账户减少一块钱，<code>add()</code>方法使用户 2 账户增加一块钱。</p><p>实现 UserService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Transactional //重点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户 1 向用户 2 转一千块（每次一块）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            userRepository.sub(<span class="number">1L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户 2 每次收到 1 块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            userRepository.add(<span class="number">2L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>transfer()</code>方法模拟，用户 1 向用户 2 转账 1000 次，每次 1000 块，但是用户 2 需要等待用户 1 的所有转出都完成才开始转入。</p><p>新建 UserController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/transfer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">transfer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.transfer();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"done"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>现在启动DemoMain，访问 <a href="http://localhost:8080/transfer" target="_blank" rel="noopener">http://localhost:8080/transfer</a> ，然后<strong>立即</strong>关闭这个程序。</p><p>现在我们来看 usr 表</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200911212851901.png" alt="image-20200911212851901"></p><p> 发现它们账户总和资金并不是 10000 ，这是非常危险的，转账丢钱了！查看控制栏我们也能看到 Hibernate 执行的 sql 信息。</p><p>我们再试一次，先启动 DemoMain，访问 <a href="http://localhost:8080/transfer" target="_blank" rel="noopener">http://localhost:8080/transfer</a> ，然后<strong>立即</strong>关闭 MySQL（模拟一次数据库故障），然后再启动 MySQL。</p><p>再看 usr 表</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200911213334624.png" alt="image-20200911213334624"></p><p>钱又变少了！！</p><p>看到这里，你可能已经猜到了 <code>@Transactional</code>注解是用来干啥的，它就是用来保证转账的金额总和不变。</p><p>现在我们将<code>transfer()</code>方法上的<code>@Transactional</code>恢复，然后将两个账户恢复至初始状态（账户 1 中 10000块，账户 2 中 0 块，PS：这两句 SQL 会写吧。。）</p><p>我们再尝试一次服务故障，发现控制栏中依然有 Hibernate 执行的 sql 信息，打开 usr 表，账户 1 中依然有 10000块，账户 1 的所有转账都失败了！</p><p>再试一次数据库故障，账户 1 中依然有 10000 块，转账依然失败。</p><p>这种情况是符合我们的预期，宁可失败，也不能少钱。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常来说，repository 实例的 CRUD 方法是事务的，如果自己定义 SQL，需要在除 SELECT 语句的方法（INSERT、UPDATE 等）上加上<code>@Transactional</code>（保证事务性）和<code>@Modifying</code>。</p><p>另一种方法就是在 service 的方法上添加<code>@Transactional</code>注解，现在 repository 上的<code>@Transactional</code>注解被忽略，永远使用的是最外层的 @Transactional 注解。注意：必须要在启动类上添加 <code>@EnableTransactionManagement</code>开启事务管理。</p><p>如果这个事务在中途失败了，Spring 会将该事务回滚。</p><p><strong>由于个人水平有限，如有错误和不足请轻喷</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;首先新建一个 SpringBoot 项目，修改 pom.xml，增加以下内容：&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://hoo334.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://hoo334.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>组合总和III</title>
    <link href="https://hoo334.github.io/2020/09/11/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/"/>
    <id>https://hoo334.github.io/2020/09/11/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/</id>
    <published>2020-09-11T04:38:58.000Z</published>
    <updated>2020-09-11T04:50:29.049Z</updated>
    
    <content type="html"><![CDATA[<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a></h4><p>找出所有相加之和为 <strong><em>n</em></strong> 的 <strong>k</strong> 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure><p>需要注意的是，不能包含重复的数字，不能包含重复的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> n 剩余的数字之和</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> k 剩余的数字个数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> min 当前能选取的最小数字</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> path 递归路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> min, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 和为 0 且 剩余数字个数为 0 将当前路径加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//从最小值开始递归</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = min; k &gt; <span class="number">0</span> &amp;&amp; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; n)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            <span class="comment">//下一次选择只能选择比自己大的数字</span></span><br><span class="line">            dfs(n - i, k - <span class="number">1</span>, i + <span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;216-组合总和-III&quot;&gt;&lt;a href=&quot;#216-组合总和-III&quot; class=&quot;headerlink&quot; title=&quot;216. 组合总和 III&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;216. 组合总和 III&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;找出所有相加之和为 &lt;strong&gt;&lt;em&gt;n&lt;/em&gt;&lt;/strong&gt; 的 &lt;strong&gt;k&lt;/strong&gt; 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
</feed>
