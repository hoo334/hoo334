<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2021-03-12T03:18:32.324Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>验证二叉树的前序序列化</title>
    <link href="https://hoo334.github.io/2021/03/12/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://hoo334.github.io/2021/03/12/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-03-12T03:01:25.000Z</published>
    <updated>2021-03-12T03:18:32.324Z</updated>
    
    <content type="html"><![CDATA[<h4 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/" target="_blank" rel="noopener">331. 验证二叉树的前序序列化</a></h4><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">&#x2F; \ &#x2F; \   &#x2F; \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>方法一：递归</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        String[] arr = preorder.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> helper(arr) &amp;&amp; i == arr.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> i == arr.length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!arr[i].equals(<span class="string">"#"</span>) &amp;&amp; i + <span class="number">2</span> &lt; len</span><br><span class="line">                &amp;&amp; arr[i + <span class="number">1</span>].equals(<span class="string">"#"</span>) &amp;&amp; arr[i + <span class="number">2</span>].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">2</span> &gt;= len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> left = <span class="keyword">false</span>, right = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            left = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = helper(arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            right = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = helper(arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：栈</strong></p><p>我们定义一个概念叫做槽位，一个槽位可被看作<strong>当前二叉树中正在等待被节点填充</strong>的那些位置。</p><p>每当遇到一个结点时：</p><ul><li>遇到空结点，消耗一个槽位；</li><li>遇到非空结点，消耗一个槽位，增加两个子节点的槽位。</li></ul><p>此外还需要对根节点进行处理。</p><p>我们使用栈来维护槽位的变化，栈中的每个元素代表了对应节点处<strong>剩余槽位的数量</strong>，栈顶元素代表下一步可用的槽位。每当遇到空结点时，仅将栈顶元素减 1 ，遇到非空节点时，将栈顶元素减 1 后，再向栈中压入一个 2 。无论何时，如果栈顶元素变为 0，立刻将栈顶弹出。结束后，如果栈为空，则序列合法，在遍历过程中，如果槽位数量不足，则序列不合法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(preorder.charAt(i) == <span class="string">','</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(preorder.charAt(i) == <span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(top &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    stack.push(top);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; n &amp;&amp; preorder.charAt(i) != <span class="string">','</span>)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(top &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    stack.push(top);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul><p><strong>方法三：计数</strong></p><p>如果将方法二中栈中元素看成一个整体，即所有剩余槽位的数量，也能维护槽位的变化。因此我们只用维护一个计数器，代表栈中所有元素之和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slots = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slots == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(preorder.charAt(i) == <span class="string">','</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(preorder.charAt(i) == <span class="string">'#'</span>)&#123;</span><br><span class="line">                slots--;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; n &amp;&amp; preorder.charAt(i) != <span class="string">','</span>)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                slots++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slots == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;331-验证二叉树的前序序列化&quot;&gt;&lt;a href=&quot;#331-验证二叉树的前序序列化&quot; class=&quot;headerlink&quot; title=&quot;331. 验证二叉树的前序序列化&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;331. 验证二叉树的前序序列化&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 &lt;code&gt;#&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>基本计算器II</title>
    <link href="https://hoo334.github.io/2021/03/11/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II/"/>
    <id>https://hoo334.github.io/2021/03/11/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II/</id>
    <published>2021-03-11T01:44:12.000Z</published>
    <updated>2021-03-11T01:55:51.575Z</updated>
    
    <content type="html"><![CDATA[<h4 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. 基本计算器 II</a></h4><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot; 3&#x2F;2 &quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot; 3+5 &#x2F; 2 &quot;</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由整数和算符 <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> 组成，中间由一些空格隔开</li><li><code>s</code> 表示一个 <strong>有效表达式</strong></li><li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 231 - 1]</code> 内</li><li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li></ul><p>此题没有括号，乘除优先于加减计算，不妨先进行所有的乘除运算，并将这些乘除运算后的整数放回原来的位置，之后整个表达式的值，就等于一系列整数加减后的值。</p><p>我们可以使用一个栈来保存进行乘除运算后的整数的值。对于加减号后的数字，直接压入栈中；对于乘除号后的数字，直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//第一个数字前的符号设置为 + ，直接将第一个数入栈</span></span><br><span class="line">        <span class="keyword">char</span> preSign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//将连续的数字字符转换为整数</span></span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前字符不是数字或空格，或者当前是最后一个字符，计算最后结果</span></span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != <span class="string">' '</span> || i == n - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">switch</span> (preSign) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: stack.push(num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: stack.push(-num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'*'</span>: stack.push(stack.pop() * num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>: stack.push(stack.pop() / num); <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//更新符号和数字</span></span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            preSign = s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//将所有数字相加，得到最后结果</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            ans += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;227-基本计算器-II&quot;&gt;&lt;a href=&quot;#227-基本计算器-II&quot; class=&quot;headerlink&quot; title=&quot;227. 基本计算器 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/basic-calculator-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;227. 基本计算器 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个字符串表达式 &lt;code&gt;s&lt;/code&gt; ，请你实现一个基本计算器来计算并返回它的值。&lt;/p&gt;
&lt;p&gt;整数除法仅保留整数部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置解析</title>
    <link href="https://hoo334.github.io/2021/03/10/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://hoo334.github.io/2021/03/10/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2021-03-10T12:10:52.000Z</published>
    <updated>2021-03-12T03:01:06.137Z</updated>
    
    <content type="html"><![CDATA[<p>使用Spring Initializer 生成一个最简单的 Web 应用，打开启动类。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Demo01Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击 @SpringBootApplication ，我们可以看到如下注解信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br></pre></td></tr></table></figure><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>@SpringBootConfiguration 表示一个类提供Spring Boot应用程序。它的作用等同于@Configuration，以便可以自动找到配置。应用程序应该只包含<strong>一个</strong>@SpringBootConfiguration ，通常的Spring Boot应用程序将从@SpringBootApplication自动继承它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = Configuration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">boolean</span> <span class="title">proxyBeanMethods</span>() <span class="title">default</span> <span class="title">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxyBeanMethods 方法指定是否应代理@Bean方法：<strong>默认为 Full模式</strong>，保证每个@Bean方法被调用多少次返回的Bean都是单实例的；也可为 Lite 模式（值为 false），每次调用 @Bean 方法都会返回新的实例。<br>如果配置类 Bean 之间有依赖关系，则强制使用 Full 模式。<br>新建 MyConfig 配置类来测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123; <span class="comment">//User 为一个POJO，这里省略定义</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"li"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在 Main 方法中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyConfig bean = run.getBean(MyConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">User u1 = bean.getUser();</span><br><span class="line">User u2 = bean.getUser();</span><br><span class="line">System.out.println(<span class="string">"U1 == U2? "</span> + (u1 == u2));</span><br></pre></td></tr></table></figure><p>运行，可以看到结果为 true，在用户代码中直接调用@Bean方法的情况下也返回共享的单例bean实例。</p><p>接下来为 <code>@Configuration</code> 添加配置<code>@Configuration(proxyBeanMethods = false)</code>,再次运行，可以看到结果为 false，返回了两个不同的实例。</p><p>接下来测试组建依赖，修改 MyConfig 为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User(<span class="string">"li"</span>, <span class="number">18</span>);</span><br><span class="line">        u.setPet(getPet());</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">"tom"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将 proxyBeanMethods 改为 false，IDEA 将会提示“使用 Bean 标记的方法被 proxyBeanMethods 为 false 的配置类调用，将其改为 true 或者使用依赖注入。”</p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>替换默认的 Filter，替换为AutoConfigurationExcludeFilter</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol><li><p>@AutoConfigurationPackage<br>使用 @AutoConfigurationPackage 来注册包。如果没有指定 base packages 或 base package classes，则注册带有@AutoConfigurationPackage 的类所在的包。</p></li><li><p>@Import(AutoConfigurationPackages.Registrar.class)<br>AutoConfigurationImportSelector 中有如下函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>找到 getAutoConfigurationEntry 定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//获取注解元信息</span></span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">       <span class="comment">//获取所有配置类</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"><span class="comment">//去掉重复的配置类，去掉需要排除的配置类，最终返回</span></span><br><span class="line">       configurations = removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最核心的方法是 getCandidateConfigurations ，用来获取所有的配置类，点击进入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">+ <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击进入 loadFactoryNames 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">ClassLoader classLoaderToUse = classLoader;</span><br><span class="line"><span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">classLoaderToUse = SpringFactoriesLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line">String factoryTypeName = factoryType.getName();</span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击进入 loadSpringFactories方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">String[] factoryImplementationNames =</span><br><span class="line">StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;())</span><br><span class="line">.add(factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打断点运行到 classLoader.getResource位置，我们可以看到 FACTORIES_RESOURCE_LOCATION 此时为<code>META-INF/spring.factories</code>,这里扫描系统中所有 <code>META-INF/spring.factories</code>位置的文件，spring-boot-autoconfigure-2.4.3.jar 中的 spring.factories 文件写死了 springboot 启动就给容器中加载所有的配置类（xxxxx AutoConfiguration）。</p><p>在 spring boot 启动过程中，所有的自动配置都是条件配置，以org.springframework.boot.autoconfigure.web.servlet 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(DispatcherServlet<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(<span class="title">ServletWebServerFactoryAutoConfiguration</span>.<span class="title">class</span>)</span></span><br></pre></td></tr></table></figure><p>@ConditionalOnClass(DispatcherServlet.class) 注解指定 只有 DispatcherServlet.class 在类路径中存在才自动配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(MultipartResolver<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">name</span> </span>= DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span></span><br><span class="line"><span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以自己配置 MultipartResolver，如果自行定义了这个 Bean，那么 spring boot 就会使用用户自定义的。</p><p>总结：</p><ul><li><p>SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration</p></li><li><p>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定</p></li><li><p>生效的配置类就会给容器中装配很多组件</p></li><li><p>只要容器中有这些组件，相当于这些功能就有了</p></li><li><p>定制化配置</p></li><li><ul><li>用户直接自己@Bean替换底层的组件</li><li>用户去看这个组件是获取的配置文件什么值就去修改。</li></ul></li></ul><p><strong>xxxxxAutoConfiguration —&gt; 组件  —&gt;</strong> <strong>xxxxProperties里面拿值  —-&gt; application.properties</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Spring Initializer 生成一个最简单的 Web 应用，打开启动类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://hoo334.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://hoo334.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>基本计算器</title>
    <link href="https://hoo334.github.io/2021/03/10/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>https://hoo334.github.io/2021/03/10/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2021-03-10T01:40:13.000Z</published>
    <updated>2021-03-10T01:56:32.819Z</updated>
    
    <content type="html"><![CDATA[<h4 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a><a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">224. 基本计算器</a></h4><p>实现一个基本的计算器来计算一个简单的字符串表达式 <code>s</code> 的值。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot; 2-1 + 2 &quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 表示一个有效的表达式</li></ul><p><strong>方法一：栈</strong></p><p>基本计算器只包含加减法，括号对一个数只影响其正负。以示例三为例：</p><ul><li>数字 1 前面没有符号，记为 +1</li><li>数字 4 前面有一个 + 号，记为 +4</li><li>数字 5 和 数字 2 前面有两个 + 号，记为 +5，+2</li><li>数字 3 前面有一个 + 号（<strong>不包括（4 + 5 + 2）里的 + 号</strong>）和一个 - 号，记为 -3</li><li>数字 6 前面有一个 + 号，记为 +6</li><li>数字 8 前面有两个 + 号，记为 + 8</li></ul><p>将这些数字加起来，我们得到最终结果 23。</p><p>我们使用一个栈 ops 来记录当前位置所处的每个括号所共同形成的符号，同时使用 sign 来表示当前的符号（sign 为 1 代表正数）。</p><p>如果当前遇到了 + 号，当前符号为 ops.peek()；如果当前遇到了 - 号，当前符号为 - ops.peek()。</p><p>每当遇到 ( 时，都要将当前 sign 取值压入栈中；每当遇到 ）时，都从栈中弹出一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; ops = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        ops.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span>) &#123;</span><br><span class="line">                sign = ops.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'-'</span>) &#123;</span><br><span class="line">                sign = -ops.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                ops.push(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                ops.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//遇到一个数，直接加入结果</span></span><br><span class="line">                <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;224-基本计算器&quot;&gt;&lt;a href=&quot;#224-基本计算器&quot; class=&quot;headerlink&quot; title=&quot;224. 基本计算器&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/basic-calculator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;224. 基本计算器&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;实现一个基本的计算器来计算一个简单的字符串表达式 &lt;code&gt;s&lt;/code&gt; 的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>二维区域和检索-矩阵不可变</title>
    <link href="https://hoo334.github.io/2021/03/02/%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <id>https://hoo334.github.io/2021/03/02/%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/</id>
    <published>2021-03-02T01:48:24.000Z</published>
    <updated>2021-03-02T02:05:53.090Z</updated>
    
    <content type="html"><![CDATA[<h4 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">304. 二维区域和检索 - 矩阵不可变</a></h4><p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (<em>row</em>1, <em>col</em>1) ，右下角为 (<em>row</em>2, <em>col</em>2)。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210302095000679.png" alt="image-20210302095000679"><br>上图子矩阵左上角 (row1, col1) = <strong>(2, 1)</strong> ，右下角(row2, col2) = <strong>(4, 3)，</strong>该子矩形内元素的总和为 8。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D; [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>你可以假设矩阵不可变。</li><li>会多次调用 <em>sumRegion</em> 方法<em>。</em></li><li>你可以假设 <em>row</em>1 ≤ <em>row</em>2 且 <em>col</em>1 ≤ <em>col</em>2。</li></ol><p><strong>方法一：二维前缀和</strong></p><p>注意到矩阵不可变，我们可以使用二维数组保存数组的前缀和，然后就可以在O(1)时间复杂度内查到区域和。对于示例中的数组我们建立如下前缀和数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">000000</span><br><span class="line">0334810</span><br><span class="line">0814182427</span><br><span class="line">0917212836</span><br><span class="line">01322263449</span><br><span class="line">01423303858</span><br></pre></td></tr></table></figure><p>题中数组下标范围是<code>0 &lt;= row &lt; matrix.length</code>和<code>0 &lt;= col &lt; matrix[0].length</code>。子矩阵左上角(row1,col1)，右下角(row2,col2)。<code>子矩阵和 = sum[row2 + 1][col2 + 1] - sum[row2 + 1][col1] - sum[row1][col2 + 1] + sum[row1][col1]</code>。sum 数组多加一行一列是为了避免计算时下标是否越界判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length + <span class="number">1</span>][matrix[<span class="number">0</span>].length + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//计算 sum 数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sum.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; sum[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - sum[row1][col2 + <span class="number">1</span>] - sum[row2 + <span class="number">1</span>][col1] + sum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度，初始化O(mn)，查询O(1)，其中 m 和 n 分别为数组的行数和列数。</li><li>空间复杂度O(mn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;304-二维区域和检索-矩阵不可变&quot;&gt;&lt;a href=&quot;#304-二维区域和检索-矩阵不可变&quot; class=&quot;headerlink&quot; title=&quot;304. 二维区域和检索 - 矩阵不可变&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-2d-immutable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;304. 二维区域和检索 - 矩阵不可变&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (&lt;em&gt;row&lt;/em&gt;1, &lt;em&gt;col&lt;/em&gt;1) ，右下角为 (&lt;em&gt;row&lt;/em&gt;2, &lt;em&gt;col&lt;/em&gt;2)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/hoo334/picgo/raw/master//img/image-20210302095000679.png&quot; alt=&quot;image-20210302095000679&quot;&gt;&lt;br&gt;上图子矩阵左上角 (row1, col1) = &lt;strong&gt;(2, 1)&lt;/strong&gt; ，右下角(row2, col2) = &lt;strong&gt;(4, 3)，&lt;/strong&gt;该子矩形内元素的总和为 8。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>翻转图像</title>
    <link href="https://hoo334.github.io/2021/02/24/%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>https://hoo334.github.io/2021/02/24/%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2021-02-24T02:13:08.000Z</published>
    <updated>2021-02-24T02:21:39.724Z</updated>
    
    <content type="html"><![CDATA[<h4 id="832-翻转图像"><a href="#832-翻转图像" class="headerlink" title="832. 翻转图像"></a><a href="https://leetcode-cn.com/problems/flipping-an-image/" target="_blank" rel="noopener">832. 翻转图像</a></h4><p>给定一个二进制矩阵 <code>A</code>，我们想先水平翻转图像，然后反转图像并返回结果。</p><p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 <code>[1, 1, 0]</code> 的结果是 <code>[0, 1, 1]</code>。</p><p>反转图片的意思是图片中的 <code>0</code> 全部被 <code>1</code> 替换， <code>1</code> 全部被 <code>0</code> 替换。例如，反转 <code>[0, 1, 1]</code> 的结果是 <code>[1, 0, 0]</code>。</p><a id="more"></a><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">输出：[[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；</span><br><span class="line">     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；</span><br><span class="line">     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li><li><code>0 &lt;= A[i][j] &lt;= 1</code></li></ul><p><strong>方法一：双指针</strong></p><p>对于每一行元素，我们使用 left 和 right 指针来对该行元素进行水平翻转和反转操作。</p><table><thead><tr><th align="center"></th><th align="center">left</th><th align="center">right</th><th align="center">处理后left</th><th align="center">处理后right</th></tr></thead><tbody><tr><td align="center">①</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">②</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">③</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">④</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p>我们可以发现，当 left 和 right 指向的值相等时时，元素才需要变化，只用用该元素与 1 异或。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][left] == A[i][right])&#123;</span><br><span class="line">                    A[i][left] ^= <span class="number">1</span>;</span><br><span class="line">                    A[i][right] ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当一行元素个数为奇数时，需要将最中间的数翻转</span></span><br><span class="line">            <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">                A[i][left] ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;832-翻转图像&quot;&gt;&lt;a href=&quot;#832-翻转图像&quot; class=&quot;headerlink&quot; title=&quot;832. 翻转图像&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/flipping-an-image/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;832. 翻转图像&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二进制矩阵 &lt;code&gt;A&lt;/code&gt;，我们想先水平翻转图像，然后反转图像并返回结果。&lt;/p&gt;
&lt;p&gt;水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 &lt;code&gt;[1, 1, 0]&lt;/code&gt; 的结果是 &lt;code&gt;[0, 1, 1]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;反转图片的意思是图片中的 &lt;code&gt;0&lt;/code&gt; 全部被 &lt;code&gt;1&lt;/code&gt; 替换， &lt;code&gt;1&lt;/code&gt; 全部被 &lt;code&gt;0&lt;/code&gt; 替换。例如，反转 &lt;code&gt;[0, 1, 1]&lt;/code&gt; 的结果是 &lt;code&gt;[1, 0, 0]&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>爱生气的书店老板</title>
    <link href="https://hoo334.github.io/2021/02/23/%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/"/>
    <id>https://hoo334.github.io/2021/02/23/%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</id>
    <published>2021-02-23T01:01:27.000Z</published>
    <updated>2021-02-23T01:08:32.409Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1052-爱生气的书店老板"><a href="#1052-爱生气的书店老板" class="headerlink" title="1052. 爱生气的书店老板"></a><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/" target="_blank" rel="noopener">1052. 爱生气的书店老板</a></h4><p>今天，书店老板有一家店打算试营业 <code>customers.length</code> 分钟。每分钟都有一些顾客（<code>customers[i]</code>）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p><p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 <code>X</code> 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。<br> <a id="more"></a></p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：customers &#x3D; [1,0,1,2,1,1,7,5], grumpy &#x3D; [0,1,0,1,0,1,0,1], X &#x3D; 3</span><br><span class="line">输出：16</span><br><span class="line">解释：</span><br><span class="line">书店老板在最后 3 分钟保持冷静。</span><br><span class="line">感到满意的最大客户数量 &#x3D; 1 + 1 + 1 + 1 + 7 + 5 &#x3D; 16.</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000</code></li><li><code>0 &lt;= customers[i] &lt;= 1000</code></li><li><code>0 &lt;= grumpy[i] &lt;= 1</code></li></ul><p><strong>方法一：滑动窗口</strong></p><p>首先我们将确定满意的顾客加起来，然后使用滑动窗口计算可以额外增加的最大满意数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="keyword">int</span>[] customers, <span class="keyword">int</span>[] grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计确定满意的客户</span></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; customers.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                total += customers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//统计第一个窗口中额外增加的满意数</span></span><br><span class="line">        <span class="keyword">int</span> increase = <span class="number">0</span>, maxIncrease = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                increase += customers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxIncrease = increase;</span><br><span class="line"><span class="comment">//使用滑动窗口计算最大满意数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = X; i &lt; customers.length; i++)&#123;</span><br><span class="line">            increase = increase - grumpy[i - X] * customers[i - X] + grumpy[i] * customers[i];   </span><br><span class="line">            maxIncrease = Math.max(increase, maxIncrease);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total + maxIncrease;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1052-爱生气的书店老板&quot;&gt;&lt;a href=&quot;#1052-爱生气的书店老板&quot; class=&quot;headerlink&quot; title=&quot;1052. 爱生气的书店老板&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/grumpy-bookstore-owner/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1052. 爱生气的书店老板&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;今天，书店老板有一家店打算试营业 &lt;code&gt;customers.length&lt;/code&gt; 分钟。每分钟都有一些顾客（&lt;code&gt;customers[i]&lt;/code&gt;）会进入书店，所有这些顾客都会在那一分钟结束后离开。&lt;/p&gt;
&lt;p&gt;在某些时候，书店老板会生气。 如果书店老板在第 &lt;code&gt;i&lt;/code&gt; 分钟生气，那么 &lt;code&gt;grumpy[i] = 1&lt;/code&gt;，否则 &lt;code&gt;grumpy[i] = 0&lt;/code&gt;。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。&lt;/p&gt;
&lt;p&gt;书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 &lt;code&gt;X&lt;/code&gt; 分钟不生气，但却只能使用一次。&lt;/p&gt;
&lt;p&gt;请你返回这一天营业下来，最多有多少客户能够感到满意的数量。&lt;br&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="滑动窗口" scheme="https://hoo334.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>托普利茨矩阵</title>
    <link href="https://hoo334.github.io/2021/02/22/%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5/"/>
    <id>https://hoo334.github.io/2021/02/22/%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5/</id>
    <published>2021-02-22T00:09:35.000Z</published>
    <updated>2021-02-22T00:17:25.470Z</updated>
    
    <content type="html"><![CDATA[<h4 id="766-托普利茨矩阵"><a href="#766-托普利茨矩阵" class="headerlink" title="766. 托普利茨矩阵"></a><a href="https://leetcode-cn.com/problems/toeplitz-matrix/" target="_blank" rel="noopener">766. 托普利茨矩阵</a></h4><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回 <code>false</code> <em>。</em></p><p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 <strong>托普利茨矩阵</strong> 。</p> <a id="more"></a><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210222081038267.png" alt="image-20210222081038267"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,1,2,3],[9,5,1,2]]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">在上述矩阵中, 其对角线为: </span><br><span class="line">&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;。 </span><br><span class="line">各条对角线上的所有元素均相同, 因此答案是 True 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210222081059141.png" alt="image-20210222081059141"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2],[2,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">对角线 &quot;[1, 2]&quot; 上的元素不同。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><p><code>m == matrix.length</code></p></li><li><p><code>n == matrix[i].length</code></p></li><li><p><code>1 &lt;= m, n &lt;= 20</code></p></li><li><p><code>0 &lt;= matrix[i][j] &lt;= 99</code></p><p><strong>进阶：</strong></p></li><li><p>如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？</p></li><li><p>如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？</p></li></ul><p><strong>方法一：遍历</strong></p><p>可以发现，托普利兹矩阵中每一个元素都和它左上角的元素相等，我们直接比较当前元素和左上角元素是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] != matrix[i - <span class="number">1</span>][j - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(mn)，m 和 n 分别是数组的长宽</li><li>空间复杂度O(1)</li></ul><p>进阶问题一：将每一行从硬盘复制到内存中的一个连续数组中，在读取下一行时，直接与内存中的数据进行比较。</p><p>进阶问题二：将数组竖直切分为若干个子矩阵，保证两个相邻的子矩阵至少有一行或一列是重合 的，判断子矩阵是否符合要求。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;766-托普利茨矩阵&quot;&gt;&lt;a href=&quot;#766-托普利茨矩阵&quot; class=&quot;headerlink&quot; title=&quot;766. 托普利茨矩阵&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/toeplitz-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;766. 托普利茨矩阵&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个 &lt;code&gt;m x n&lt;/code&gt; 的矩阵 &lt;code&gt;matrix&lt;/code&gt; 。如果这个矩阵是托普利茨矩阵，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; &lt;em&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 &lt;strong&gt;托普利茨矩阵&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>绝对差不超过限制的最长连续子数组</title>
    <link href="https://hoo334.github.io/2021/02/21/%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://hoo334.github.io/2021/02/21/%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2021-02-21T01:55:40.000Z</published>
    <updated>2021-02-21T02:47:41.185Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">1438. 绝对差不超过限制的最长连续子数组</a></h4><p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code> <em>。</em></p><p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [8,2,4,7], limit &#x3D; 4</span><br><span class="line">输出：2 </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[8] 最大绝对差 |8-8| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[8,2] 最大绝对差 |8-2| &#x3D; 6 &gt; 4. </span><br><span class="line">[8,2,4] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[8,2,4,7] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[2] 最大绝对差 |2-2| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[2,4] 最大绝对差 |2-4| &#x3D; 2 &lt;&#x3D; 4.</span><br><span class="line">[2,4,7] 最大绝对差 |2-7| &#x3D; 5 &gt; 4.</span><br><span class="line">[4] 最大绝对差 |4-4| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[4,7] 最大绝对差 |4-7| &#x3D; 3 &lt;&#x3D; 4.</span><br><span class="line">[7] 最大绝对差 |7-7| &#x3D; 0 &lt;&#x3D; 4. </span><br><span class="line">因此，满足题意的最长子数组的长度为 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| &#x3D; 5 &lt;&#x3D; 5 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^9</code></li><li><code>0 &lt;= limit &lt;= 10^9</code></li></ul><p><strong>方法一：暴力法（超时）</strong></p><p>直接枚举子数组的开始位置和结束位置，同时维护最大最小值，并判断该子数组是否满足条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//枚举每一个子数组nums[i ... j]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//初始化子数组中最大最小值</span></span><br><span class="line">            <span class="keyword">int</span> min = nums[i], max = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;<span class="comment">//对于每个子数组，更新最大最小值</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; max)&#123;</span><br><span class="line">                    max = nums[j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[j] &lt; min)&#123;</span><br><span class="line">                    min = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//判断子数组是否满足条件并维护结果</span></span><br><span class="line">                <span class="keyword">if</span>(max - min &lt;= limit &amp;&amp; j - i + <span class="number">1</span> &gt; ans)&#123;</span><br><span class="line">                    ans = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(1)</li></ul><p><strong>方法二：滑动窗口+单调队列</strong></p><p>枚举每一个位置作为右端点，找到其对应的最靠左的左端点，满足区间中最大与最小值不超过 limit。我们分别使用两个单调队列保存最大和最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; queMax = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; queMin = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举每一个右端点 right</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!queMax.isEmpty() &amp;&amp; queMax.peekLast() &lt; nums[right]) &#123;</span><br><span class="line">                queMax.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!queMin.isEmpty() &amp;&amp; queMin.peekLast() &gt; nums[right]) &#123;</span><br><span class="line">                queMin.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            queMax.offerLast(nums[right]);</span><br><span class="line">            queMin.offerLast(nums[right]);</span><br><span class="line">            <span class="comment">//当 nums[left ... right]不满足条件时将 left 右移</span></span><br><span class="line">            <span class="keyword">while</span> (!queMax.isEmpty() &amp;&amp; !queMin.isEmpty() &amp;&amp; queMax.peekFirst() - queMin.peekFirst() &gt; limit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == queMin.peekFirst()) &#123;</span><br><span class="line">                    queMin.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == queMax.peekFirst()) &#123;</span><br><span class="line">                    queMax.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = Math.max(ret, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul><p><strong>方法三：滑动窗口+有序集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            map.put(nums[right], map.getOrDefault(nums[right], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (map.lastKey() - map.firstKey() &gt; limit) &#123;</span><br><span class="line">                map.put(nums[left], map.get(nums[left]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(nums[left]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(nums[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = Math.max(ret, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1438-绝对差不超过限制的最长连续子数组&quot;&gt;&lt;a href=&quot;#1438-绝对差不超过限制的最长连续子数组&quot; class=&quot;headerlink&quot; title=&quot;1438. 绝对差不超过限制的最长连续子数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1438. 绝对差不超过限制的最长连续子数组&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，和一个表示限制的整数 &lt;code&gt;limit&lt;/code&gt;，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 &lt;code&gt;limit&lt;/code&gt; &lt;em&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果不存在满足条件的子数组，则返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="滑动窗口" scheme="https://hoo334.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>数组的度</title>
    <link href="https://hoo334.github.io/2021/02/20/%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/"/>
    <id>https://hoo334.github.io/2021/02/20/%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</id>
    <published>2021-02-20T01:39:03.000Z</published>
    <updated>2021-02-20T01:58:19.787Z</updated>
    
    <content type="html"><![CDATA[<h4 id="697-数组的度"><a href="#697-数组的度" class="headerlink" title="697. 数组的度"></a><a href="https://leetcode-cn.com/problems/degree-of-an-array/" target="_blank" rel="noopener">697. 数组的度</a></h4><p>给定一个非空且只包含非负数的整数数组 <code>nums</code>，数组的度的定义是指数组里任一元素出现频数的最大值。</p><p>你的任务是在 <code>nums</code> 中找到与 <code>nums</code> 拥有相同大小的度的最短连续子数组，返回其长度。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：[1, 2, 2, 3, 1]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">输入数组的度是2，因为元素1和2的出现频数最大，均为2.</span><br><span class="line">连续子数组里面拥有相同度的有如下所示:</span><br><span class="line">[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</span><br><span class="line">最短连续子数组[2, 2]的长度为2，所以返回2.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,2,3,1,4,2]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>nums.length</code> 在1到 50,000 区间范围内。</li><li><code>nums[i]</code> 是一个在 0 到 49,999 范围内的整数。</li></ul><p><strong>方法一：哈希表</strong></p><p>假设数组中出现次数最多的数为 x，数组中最短连续子数组中必定包含了数组中所有 x，且子数组首尾必定都是 x。</p><p>数组中可能有多个与数组的度相同的子数组，为了找到最短子数组的长度，需要统计每一个数第一次出现的位置和最后一次出现的位置。</p><p>使用哈希表来保存每一个数，每个数映射到一个数组，数组中三个元素分别为：这个数出现的次数，这个数第一次出现的数组下标，这个数最后一次出现的数组下标。</p><p>优先选择度最大的数，在度相同的情况下选择子数组最短的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, <span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;<span class="comment">//数出现过，出现次数加一并维护最后一次出现的位置</span></span><br><span class="line">                ++map.get(nums[i])[<span class="number">0</span>]; </span><br><span class="line">                map.get(nums[i])[<span class="number">2</span>] = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//数第一次出现，添加信息</span></span><br><span class="line">                map.put(nums[i], <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, i, i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>, minLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, <span class="keyword">int</span>[]&gt; entry : map.entrySet())&#123;<span class="comment">//对每个数筛选</span></span><br><span class="line">            <span class="keyword">int</span>[] arr = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(maxNum &lt; arr[<span class="number">0</span>])&#123;<span class="comment">//优先选择度最大的数，并保存度和最短连续子数组长度</span></span><br><span class="line">                maxNum = arr[<span class="number">0</span>];</span><br><span class="line">                minLen = arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxNum == arr[<span class="number">0</span>])&#123;<span class="comment">//度相同，选择子数组最短的数</span></span><br><span class="line">                <span class="keyword">if</span>(minLen &gt; arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    minLen = arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;697-数组的度&quot;&gt;&lt;a href=&quot;#697-数组的度&quot; class=&quot;headerlink&quot; title=&quot;697. 数组的度&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/degree-of-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;697. 数组的度&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个非空且只包含非负数的整数数组 &lt;code&gt;nums&lt;/code&gt;，数组的度的定义是指数组里任一元素出现频数的最大值。&lt;/p&gt;
&lt;p&gt;你的任务是在 &lt;code&gt;nums&lt;/code&gt; 中找到与 &lt;code&gt;nums&lt;/code&gt; 拥有相同大小的度的最短连续子数组，返回其长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>NSGA2 遗传算法</title>
    <link href="https://hoo334.github.io/2020/12/27/NSGA2/"/>
    <id>https://hoo334.github.io/2020/12/27/NSGA2/</id>
    <published>2020-12-27T01:02:38.000Z</published>
    <updated>2021-02-20T01:40:40.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NSGA2"><a href="#NSGA2" class="headerlink" title="NSGA2"></a>NSGA2</h1><p>快速的、精英主义的、多目标遗传算法</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用非支配排序和共享的多目标进化算法（EA）主要受到批评：1）（3）O(MN^3)计算复杂度（其中，M为目标函数数量和人口数量 N）；  2）非民族主义的方法；  3）需要指定共享参数。 在本文中，我们提出了一种基于非支配排序的多目标EA（MOEA），称为非支配排序遗传算法II（NSGA-II），它可以缓解上述三个难题。 具体来说，提出了一种具有（2）计算复杂度的快速非支配排序方法。 另外，提出了一个选择算子，该算子通过组合父母和后代种群并选择最佳的（相对于适应性和传播性）解决方案来创建交配池。 针对棘手的测试问题的仿真结果表明，与帕累托归档的演化策略和强度帕累托EA相比，拟议的NSGA-II在大多数问题中都能找到更好的解决方案分布，并且能够在真正的帕累托最优前沿附近找到更好的收敛性。 另外两个精英MOEA特别重视创建多样化的帕累托最优阵线。<br>   此外，我们修改了优势的定义，以便有效地解决约束性多目标问题。 将受约束的NSGA-II在许多测试问题（包括五目标七约束的非线性问题）上的仿真结果与另一个受约束的多目标优化器进行了比较，并且观察到NSGA-II的性能要好得多。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="非支配排序"><a href="#非支配排序" class="headerlink" title="非支配排序"></a>非支配排序</h3><p>将种群 P 分级为 F1，F2， F3…</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123101830454.png" alt="image-20201123101830454"></p><p>对于每个个体，有两个参数：</p><ul><li>n_p，支配 p 的个体数</li><li>S_p，被 p 支配的个体数</li></ul><p>算法首先对每个个体计算 n_p 和 S_p，并将 n_p = 0 的个体放入 F1集合中，并设 p_rank = 1。这个操作的时间复杂度为 O(N^2)，空间复杂度O(N^2)，N 为种群的个体数。</p><p>非支配排序步骤：</p><ol><li>对集合 F_i（i 初始化为 1）中的每个个体 p（n_p = 0），它的支配个体集合为 S_p，遍历集合中的每个元素 q，执行 n_q -= 1，如果 q 仅被 p 支配（即 n_q = 1），则代表它是下一层 F_(i + 1) 的元素，q_rank = i + 1，将其加入到集合 Q 中。</li><li>i = i + 1，记 F_i 中得到的个体为第 i 个非支配层的个体，F_i = Q ，重复步骤 1，直到整个种群被分级。 </li></ol><h3 id="拥挤度"><a href="#拥挤度" class="headerlink" title="拥挤度"></a>拥挤度</h3><p>拥挤度是指种群中给定个体的周围个体的密度,直观上可表示为个体。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123104555048.png" alt="image-20201123104555048"></p><p>长方形的周长就是 i 的拥挤度。拥挤距离计算需要根据每个目标函数值按升序对人群进行排序。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123204159237.png" alt="image-20201123204159237"></p><p>在带精英策略的非支配排序遗传算法中，拥挤度的计算是保证种群多样性的一个重要环节。</p><p>拥挤距离计算需要根据每个目标函数值按升序对人群进行排序。 </p><p>I[i].m 是集合 I 中的第 i 个个体的第 m 个对象函数值。</p><p>算法步骤：</p><p>初始化每个个体的拥挤度为 0，对于每个目标函数值 m，对种群进行排序，令两个边界的两个个体拥挤度为无穷。</p><p>计算拥挤度：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123212058306.png" alt="image-20201123212058306"></p><p>将每个归一化后的值加入拥挤度，其中<img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123212113353.png" alt="image-20201123212113353">为每个函数值归一化后的值。</p><h3 id="拥挤度比较算子"><a href="#拥挤度比较算子" class="headerlink" title="拥挤度比较算子"></a>拥挤度比较算子</h3><p>在经过非支配排序和拥挤度计算后，我们得到非支配排序 i_rank 和拥挤度 i_distance。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123214216461.png" alt="image-20201123214216461"></p><p>在具有不同非支配等级的两个解决方案之间，我们倾向于非支配等级较低（更好）的解决方案。否则，如果两个解决方案属于同一个非支配层，那么我们更喜欢位于不拥挤的解决方案（拥挤度越大，证明当前解决方案越稀疏）。</p><h3 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h3><p>最初，将创建一个随机的父母群体。 人口基于非统治进行排序。 每个解决方案的适应性（或等级）均等于其非支配级别（1是最佳级别，2是次佳级别，依此类推）。 因此，假定适合度最小。 首先，通常使用二元锦标赛选择，重组和变异运算符来创建大小为后代的种群Q0。</p><p>首先得到一个合并种群<img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123221904004.png" alt="image-20201123221904004">，种群大小为 2N。对该种群进行非支配排序，最优非支配集合 F1 中的解是最优解，比种群中的其他解更加重要。如果 F1 的大小小于 N，将其加入新种群P_(t + 1)，将剩下的非支配层按照它们的顺序加入 P_(t + 1)。</p><p>我们要使 P_(t + 1)的大小为 N，对最后一个非支配层（例如 图2中的 F3）使用拥挤度比较算子对解进行降序排序，取最后一个非支配层的前 N - |P _ (t + 1)|个解。然后对 P_(t + 1)进行选择，交叉和变异得到 Q _ (t + 1)，然后继续进行下一次循环。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123215417480.png" alt="image-20201123215417480"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123215444579.png" alt="image-20201123215444579"></p><p>  “变异”运算符是用于生成修饰种群的多个运算符（如交叉，变异等）的集合。 交叉算子的目的是从交配池中随机选择两个或多个解决方案（父代），并通过在父解决方案之间交换信息来创建一个或多个解决方案。 交叉算子的交叉概率为p; 指出参与交叉操作的人口成员的比例。 剩下的1-p人口的比例只是复制到修改后的（儿童）人口中。 在具有n个实值变量并涉及与两个父解的交叉的实参优化的上下文中，每个变量可以一次交叉。 依赖于两个父变量值之间的差异的概率分布通常用于创建两个新数字，作为围绕两个父变量值的子变量[5]。 除了可变方式重组算子，矢量方式重组算子还建议将父解决方案变量之间的相关性传播到创建的子解决方案中[6，7]。</p><h3 id="支配"><a href="#支配" class="headerlink" title="支配"></a>支配</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201124133529203.png" alt=""></p><h3 id="非支配前沿"><a href="#非支配前沿" class="headerlink" title="非支配前沿"></a>非支配前沿</h3><p>图中的非支配前言为 3，5，6 从 3 到 5 ，f1 的收益变大，但 f2 收益变小。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201124134131436.png" alt=""></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>与单目标优化不同，多目标优化中有两个目标：1）收敛到帕累托最优集；2）维持帕累托最优集的解的多样性。</p><p>第一个度量 γ 度量到一组已知的Pareto最优解的收敛程度。第二个度量标准 Δ 衡量获得的解决方案之间实现的扩展程度。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201127193127398.png" alt="image-20201127193127398"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201127190055560.png" alt="image-20201127190055560"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NSGA2&quot;&gt;&lt;a href=&quot;#NSGA2&quot; class=&quot;headerlink&quot; title=&quot;NSGA2&quot;&gt;&lt;/a&gt;NSGA2&lt;/h1&gt;&lt;p&gt;快速的、精英主义的、多目标遗传算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://hoo334.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>四数相加II</title>
    <link href="https://hoo334.github.io/2020/11/27/%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>https://hoo334.github.io/2020/11/27/%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II/</id>
    <published>2020-11-27T01:02:38.000Z</published>
    <updated>2020-11-27T01:08:22.972Z</updated>
    
    <content type="html"><![CDATA[<h4 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a></h4><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 <code>(i, j, k, l)</code> ，使得 <code>A[i] + B[j] + C[k] + D[l] = 0</code>。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><a id="more"></a><p><strong>例如:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">A &#x3D; [ 1, 2]</span><br><span class="line">B &#x3D; [-2,-1]</span><br><span class="line">C &#x3D; [-1, 2]</span><br><span class="line">D &#x3D; [ 0, 2]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个元组如下:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</span><br></pre></td></tr></table></figure><p><strong>方法一：哈希表</strong></p><p>我们首先将数组 A 和 B 的每个元素组合<code>A[i] + A[j]</code>出现次数加入哈希表，然后计算数组 C 和数组 D的组合<code>C[m] + D[n]</code>，如果哈希表中包含<code>-(C[m] + D[n])</code>，将哈希表中出现的次数加入结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; countAB = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : A)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m : B)&#123;</span><br><span class="line">                countAB.put(n + m, countAB.getOrDefault(n + m, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : C)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m : D)&#123;</span><br><span class="line">                <span class="keyword">if</span>(countAB.containsKey(- n - m))&#123;</span><br><span class="line">                    ans += countAB.get(-n -m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(n^2)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;454-四数相加-II&quot;&gt;&lt;a href=&quot;#454-四数相加-II&quot; class=&quot;headerlink&quot; title=&quot;454. 四数相加 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/4sum-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;454. 四数相加 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 &lt;code&gt;(i, j, k, l)&lt;/code&gt; ，使得 &lt;code&gt;A[i] + B[j] + C[k] + D[l] = 0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>完全二叉树的节点个数</title>
    <link href="https://hoo334.github.io/2020/11/24/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/"/>
    <id>https://hoo334.github.io/2020/11/24/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</id>
    <published>2020-11-24T01:25:44.000Z</published>
    <updated>2020-11-24T01:46:34.549Z</updated>
    
    <content type="html"><![CDATA[<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></h4><p>给出一个<strong>完全二叉树</strong>，求出该树的节点个数。</p><a id="more"></a><p><strong>说明：</strong></p><p><a href="https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin" target="_blank" rel="noopener">完全二叉树</a>的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \  &#x2F;</span><br><span class="line">4  5 6</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>方法一：暴力</strong></p><p>:) 年轻人不讲码德，暴力就完事了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(N)</li><li>空间复杂度O(logN)</li></ul><p><strong>方法二：二分查找 + 位运算</strong></p><p>规定根节点位于第 0 层，完全二叉树的最大层数为 h。根据二叉树的性质，最后一层的结点数最少为 1，最多为 2^h。对于最大层数为 h 的完全二叉树，结点个数在 [2^h, 2^(h + 1) - 1]范围内，可以在该范围内使用二分查找来得到完全二叉树的结点个数。</p><p>根据结点个数范围的上下界得到当前需要判断的结点个数 k，如果第 k 个结点存在，则结点个数一定 大于等于 k，如果第 k 个结点不存在，则结点个数一定小于 k，因此可以将查找的范围缩小一半。</p><p>如何判断第 k 个结点是否存在，如果第 k 个结点位于第 h 层，则 k 的二进制表示包含 h + 1 位，其中最高位为 1，其余各位从高到低表示根节点到第 k 个结点的路径 ，0 表示移动到左子结点，1表示移动到右子结点。</p><p>例如数字 12 二进制表示 1100，则从根节点开始向下判断 右，左，左结点是否存在。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201124094205904.png" alt="image-20201124094205904"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> level =  <span class="number">0</span>;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++level;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span> &lt;&lt; level, high = (<span class="number">1</span> &lt;&lt; (level + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low +(high - low + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(exists(root, level, mid))&#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bits = <span class="number">1</span> &lt;&lt; (level - <span class="number">1</span>);</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> &amp;&amp; bits &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((bits &amp; k) == <span class="number">0</span>)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            bits &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201124094629941.png" alt="image-20201124094629941"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;222-完全二叉树的节点个数&quot;&gt;&lt;a href=&quot;#222-完全二叉树的节点个数&quot; class=&quot;headerlink&quot; title=&quot;222. 完全二叉树的节点个数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/count-complete-tree-nodes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;222. 完全二叉树的节点个数&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给出一个&lt;strong&gt;完全二叉树&lt;/strong&gt;，求出该树的节点个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="位运算" scheme="https://hoo334.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>移掉K位数字</title>
    <link href="https://hoo334.github.io/2020/11/15/%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
    <id>https://hoo334.github.io/2020/11/15/%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/</id>
    <published>2020-11-15T01:04:53.000Z</published>
    <updated>2020-11-15T01:49:34.273Z</updated>
    
    <content type="html"><![CDATA[<h4 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></h4><p>给定一个以字符串表示的非负整数 <em>num*，移除这个数中的 *k</em> 位数字，使得剩下的数字最小。</p><a id="more"></a><p><strong>注意:</strong></p><ul><li><em>num</em> 的长度小于 10002 且 ≥ <em>k。</em></li><li><em>num</em> 不会包含任何前导零。</li></ul><p><strong>示例 1 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num &#x3D; &quot;1432219&quot;, k &#x3D; 3</span><br><span class="line">输出: &quot;1219&quot;</span><br><span class="line">解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</span><br></pre></td></tr></table></figure><p><strong>示例 2 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num &#x3D; &quot;10200&quot;, k &#x3D; 1</span><br><span class="line">输出: &quot;200&quot;</span><br><span class="line">解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br></pre></td></tr></table></figure><p>示例 <strong>3 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num &#x3D; &quot;10&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;0&quot;</span><br><span class="line">解释: 从原数字移除所有的数字，剩余为空就是0。</span><br></pre></td></tr></table></figure><p><strong>方法一：贪心+单调栈</strong></p><p>对于两个长度相同的序列，最左边的不同数字决定了这两个数字的大小。例如，对于 A = laxxx，B = lbxxx，如果 a &gt; b 则 A &gt; B。</p><p>要使剩下的数字最小，需要保证靠前的数字尽可能小。以 425 为例，如果只要求我们删除一个数字，从左到右，有 4，2，5三个选择。我们将每一个数字和它的左邻居进行比较。从 2 开始，2 小于它的左邻居 4。假设我们保留数字 4 ，可能的组合都以 4 开头。如果我们保留数字 2 ，可能的组合都以 2 开头，显然小于 4 开头的组合，我们应该删除数字 4 。</p><p>我们可以得到删除一个数字的贪心策略：</p><p>在一个序列中，如果发现前一个数字大于后一个数字，删除前一个数字；如果没有，则删除序列中最后一个数字。</p><p>我们可以对序列执行 k 次这个策略，最后就可得到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(num);</span><br><span class="line">        <span class="comment">//执行 k 次删除一个数字策略</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sb.length() &amp;&amp; k &gt; <span class="number">0</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.charAt(i - <span class="number">1</span>) &gt; sb.charAt(i))&#123;</span><br><span class="line">                sb.deleteCharAt(i - <span class="number">1</span>);</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//序列中没有递减数字，删除最后 k 个数字</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; k &lt;= sb.length())&#123;</span><br><span class="line">            sb.delete(sb.length() - k, sb.length());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//删除前导 0 </span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; sb.length() &amp;&amp; sb.charAt(index) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.delete(<span class="number">0</span>, index);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">"0"</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(NK)，N 为 num 序列长度，K 为要删除的数字个数。</p><p>空间复杂度O(N)，N 为 StringBuffer 空间。</p><p>我们可以使用单调栈来加速删除的过程，栈中的元素代表截止到当前位置，删除不超过 k 个数字后，所能得到的最小整数。根据之前的讨论：在使用 k 个删除字数前，栈中的序列从栈底到栈顶单调不减。</p><p>对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到</p><ul><li>栈为空</li><li>新的栈顶元素不大于当前数字</li><li>我们已经删除了  k 位数字</li></ul><p>上述步骤结束后我们还需要进行额外的处理：</p><ul><li>我们删除了 m 个数字 且 m &lt; k，需要删除序列尾部的 k - m 个数字</li><li>需要删除前导 0 </li><li>如果最后序列为空，应该返回 0 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = num.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> digit = num.charAt(i);</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; k &gt; <span class="number">0</span> &amp;&amp; deque.peekLast() &gt; digit)&#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer ret = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">boolean</span> leadingZero = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">char</span> digit = deque.pollFirst();</span><br><span class="line">            <span class="keyword">if</span>(leadingZero &amp;&amp; digit == <span class="string">'0'</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leadingZero = <span class="keyword">false</span>;</span><br><span class="line">            ret.append(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret.length() == <span class="number">0</span> ? <span class="string">"0"</span> : ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(N)，N 为 num 序列长度，尽管存在嵌套循环，但最坏情况为删除序列全部数字，时间复杂度为 2N。</p><p>空间复杂度O(N)，N 为 StringBuffer 空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;402-移掉K位数字&quot;&gt;&lt;a href=&quot;#402-移掉K位数字&quot; class=&quot;headerlink&quot; title=&quot;402. 移掉K位数字&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-k-digits/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;402. 移掉K位数字&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个以字符串表示的非负整数 &lt;em&gt;num*，移除这个数中的 *k&lt;/em&gt; 位数字，使得剩下的数字最小。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="贪心" scheme="https://hoo334.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="单调栈" scheme="https://hoo334.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>下一个排列</title>
    <link href="https://hoo334.github.io/2020/11/10/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>https://hoo334.github.io/2020/11/10/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</id>
    <published>2020-11-10T01:53:16.000Z</published>
    <updated>2020-11-10T02:21:03.928Z</updated>
    
    <content type="html"><![CDATA[<h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a></h4><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>修改，只允许使用额外常数空间。</p><a id="more"></a><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p><p>下一个排列总是比当前排列要大，除非当前排列是最大的，我们需要找到一个下一个排列，且变化的幅度尽量小。</p><p>我们需要找到一个尽量靠右的<em>较小数</em>和尽量小的<em>较大数</em>，交换这两个数使排列变大，同时交换之后我们需要将较小数右边的递减序列重排，来得到变换幅度最小的序列。</p><p>以[1, 5, 8, 4, 7, 6, 5, 3, 1]为例，我们可以得到下一个序列[1, 5, 8, 5, 1, 3, 4, 6, 7]。</p><p>直观的想法是，从右至左找到第一个不是递减序列中的值，找到了 4，它右边的递减序列为 [7, 6, 5, 3, 1]。接下来找一个数和 4 交换，这个数必须比 4 大（比 4 小的序列已经生成过）又要使变化幅度最小，我们找到了第一个大于 4 的数 5。将 4 和 5 交换，得到[1, 5, 8, 5, 7, 6, 4, 3, 1]，还需要将 5 右边的递减序列翻转，得到[1, 5, 8, 5, 1, 3, 4, 6, 7]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//从右至左找到一个不是递减序列中的值</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//在递减序列中找到一个比前一个找到的值稍大的数</span></span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j])&#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换这两个数</span></span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将右边的递减序列翻转</span></span><br><span class="line">        reverse(nums, i + <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = start, right = end;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;31-下一个排列&quot;&gt;&lt;a href=&quot;#31-下一个排列&quot; class=&quot;headerlink&quot; title=&quot;31. 下一个排列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;31. 下一个排列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;
&lt;p&gt;如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。&lt;/p&gt;
&lt;p&gt;必须&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/原地算法&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt;修改，只允许使用额外常数空间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>买卖股票的最佳时机II</title>
    <link href="https://hoo334.github.io/2020/11/08/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
    <id>https://hoo334.github.io/2020/11/08/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</id>
    <published>2020-11-08T01:50:33.000Z</published>
    <updated>2020-11-08T02:09:50.984Z</updated>
    
    <content type="html"><![CDATA[<h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h4><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li><li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li></ul><p><strong>方法一：动态规划</strong></p><p>由于不能同时参与多笔交易，每天交易结束后，手中有股票和没股票两种情况，定义<code>dp[i][0]</code>为第 i 天结束后手中没有股票的最大利润，定义<code>dp[i][1]</code>为第 i 天结束后手中有股票的最大利润。</p><p>第 i 天结束时，手中没有股票有两种情况：</p><ul><li>第 i - 1 天没有股票，第 i 天没有买入；</li><li>第 i - 1 天有股票，第 i 天卖出。</li></ul><p>取两种收益的最大值，我们可以写出 dp 方程：<br>$$<br>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])<br>$$<br>第 i 天结束时，手中有股票有两种情况：</p><ul><li>第 i - 1 天有股票，第 i 天没有卖出；</li><li>第 i - 1 天没有股票，第 i 天买入。</li></ul><p>取两种收益的最大值，我们可以写出 dp 方程：<br>$$<br>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])<br>$$<br>考虑初始状态：第 0 天结束时，手中没有股票，收益为 0 ；第 0 天结束时，手中有股票，此时我们在第 0 天买入了股票，收益为 -prices[0]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><p>由于第 i 天的状态只与 第 i - 1 天的状态有关，我们可以只用 O(1)空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newdp0 = Math.max(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newdp1 = Math.max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newdp0;</span><br><span class="line">            dp1 = newdp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><p><strong>方法二：贪心</strong></p><p><strong>贪心算法的直觉</strong>：由于不限制交易次数，只要今天股价比昨天高，就交易。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])&#123;</span><br><span class="line">                ans += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;122-买卖股票的最佳时机-II&quot;&gt;&lt;a href=&quot;#122-买卖股票的最佳时机-II&quot; class=&quot;headerlink&quot; title=&quot;122. 买卖股票的最佳时机 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;122. 买卖股票的最佳时机 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个数组，它的第 &lt;em&gt;i&lt;/em&gt; 个元素是一支给定股票第 &lt;em&gt;i&lt;/em&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="贪心" scheme="https://hoo334.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>插入区间</title>
    <link href="https://hoo334.github.io/2020/11/04/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>https://hoo334.github.io/2020/11/04/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</id>
    <published>2020-11-04T01:39:41.000Z</published>
    <updated>2020-11-04T01:55:57.365Z</updated>
    
    <content type="html"><![CDATA[<h4 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a><a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">57. 插入区间</a></h4><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><a id="more"></a> <p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure><p><strong>方法一：模拟</strong></p><p>对于区间<code>s1 = [l1, r1]</code>和区间<code>s2 = [l2, r2]</code>，如果它们没有交集，那么要么 s1 在 s2 左侧（r1 &lt; l2），要么 s2 在 s1 左侧（r2 &lt; l1）。</p><p>如果两者有交集，那么并集为<code>[min(l1, l2), max(r1, r2)]</code>。</p><p>当插入区间[left, right]时，如果它不与其他区间相交，直接将其加入答案；如果它与其他区间有交集，将两个区间取并集，然后继续插入新的区间[left’, right‘]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span> placed = <span class="keyword">false</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ansList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] interval : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(interval[<span class="number">0</span>] &gt; right)&#123;</span><br><span class="line">                <span class="comment">//当前区间在插入区间的右侧且无交集，直接加入结果集</span></span><br><span class="line">                <span class="keyword">if</span>(!placed)&#123;</span><br><span class="line">                    ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">                    placed = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(interval[<span class="number">1</span>] &lt; left)&#123;</span><br><span class="line">                <span class="comment">//当前区间在插入区间的左侧且无交集，将当前区间加入结果集</span></span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//与插入区间有交集，计算它们的并集</span></span><br><span class="line">                left = Math.min(left, interval[<span class="number">0</span>]);</span><br><span class="line">                right = Math.max(right, interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!placed)&#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[ansList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansList.size(); ++i)&#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;57-插入区间&quot;&gt;&lt;a href=&quot;#57-插入区间&quot; class=&quot;headerlink&quot; title=&quot;57. 插入区间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/insert-interval/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;57. 插入区间&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给出一个&lt;em&gt;无重叠的 ，&lt;/em&gt;按照区间起始端点排序的区间列表。&lt;/p&gt;
&lt;p&gt;在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>时间插入、删除和获取随机元素-允许重复</title>
    <link href="https://hoo334.github.io/2020/10/31/O(1)%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0-%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/"/>
    <id>https://hoo334.github.io/2020/10/31/O(1)%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0-%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/</id>
    <published>2020-10-31T03:32:21.000Z</published>
    <updated>2020-10-31T03:43:15.130Z</updated>
    
    <content type="html"><![CDATA[<h4 id="381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="#381-O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="381. O(1) 时间插入、删除和获取随机元素 - 允许重复"></a><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/" target="_blank" rel="noopener">381. O(1) 时间插入、删除和获取随机元素 - 允许重复</a></h4><p>设计一个支持在<em>平均</em> 时间复杂度 <strong>O(1)</strong> 下<strong>，</strong> 执行以下操作的数据结构。</p><p><strong>注意: 允许出现重复元素。</strong></p><ol><li><p><code>insert(val)</code>：向集合中插入元素 val。</p></li><li><p><code>remove(val)</code>：当 val 存在时，从集合中移除一个 val。</p></li><li><p><code>getRandom</code>：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</p></li></ol><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个空的集合。</span><br><span class="line">RandomizedCollection collection &#x3D; new RandomizedCollection();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 1 。返回 true 表示集合不包含 1 。</span><br><span class="line">collection.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。</span><br><span class="line">collection.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</span><br><span class="line">collection.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应当有 2&#x2F;3 的概率返回 1 ，1&#x2F;3 的概率返回 2 。</span><br><span class="line">collection.getRandom();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">collection.remove(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应有相同概率返回 1 和 2 。</span><br><span class="line">collection.getRandom();</span><br></pre></td></tr></table></figure><p>使用一个数组 nums 存储所有的数字，我们随机生成下标就可在 O(1)时间内得到一个随机元素。</p><p>在列表中删除最后一个元素的时间复杂度是 O(1)，如果要在 O(1)时间复杂度删除数组中间的元素，我们需要将它与最后一个元素交换，最后将最后一个元素删除。</p><p>remove 函数的参数为删除的数的 val，我们需要将一个数值对应数组中的下标存储起来，使用一个Set 存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; map;</span><br><span class="line">    List&lt;Integer&gt; nums;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将 val 添加到数组中</span></span><br><span class="line">        nums.add(val);</span><br><span class="line">        <span class="comment">//将 当前下标添加进 val 对应的 set</span></span><br><span class="line">        Set&lt;Integer&gt; set = map.getOrDefault(val, <span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line">        set.add(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将 set 放入 map</span></span><br><span class="line">        map.put(val, set);</span><br><span class="line">        <span class="comment">//数组中是否已经存在 val</span></span><br><span class="line">        <span class="keyword">return</span> set.size() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组中没有 val，删除失败</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到 val 对应的一个 数组下标</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = map.get(val).iterator();</span><br><span class="line">        <span class="keyword">int</span> i = it.next();</span><br><span class="line">        <span class="comment">//得到数组中最后一个数字</span></span><br><span class="line">        <span class="keyword">int</span> lastNum = nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将最后一个数组拷贝到下标 i 处</span></span><br><span class="line">        nums.set(i, lastNum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除set 中的下标</span></span><br><span class="line">        map.get(val).remove(i);</span><br><span class="line">        map.get(lastNum).remove(nums.size() - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//将 lastNum 的新下标加入set</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; nums.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            map.get(lastNum).add(i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//删除后 set 为空，删除这个 键值对</span></span><br><span class="line">        <span class="keyword">if</span>(map.get(val).size() == <span class="number">0</span>)&#123;</span><br><span class="line">            map.remove(val);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//删除数组中最后一个元素</span></span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//随机生成数组下标</span></span><br><span class="line">        <span class="keyword">return</span> nums.get( (<span class="keyword">int</span>) ( Math.random() * nums.size() ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(1)</li><li>空间复杂度O(N)，N为数组中所有元素的数目。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;381-O-1-时间插入、删除和获取随机元素-允许重复&quot;&gt;&lt;a href=&quot;#381-O-1-时间插入、删除和获取随机元素-允许重复&quot; class=&quot;headerlink&quot; title=&quot;381. O(1) 时间插入、删除和获取随机元素 - 允许重复&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;381. O(1) 时间插入、删除和获取随机元素 - 允许重复&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;设计一个支持在&lt;em&gt;平均&lt;/em&gt; 时间复杂度 &lt;strong&gt;O(1)&lt;/strong&gt; 下&lt;strong&gt;，&lt;/strong&gt; 执行以下操作的数据结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意: 允许出现重复元素。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;insert(val)&lt;/code&gt;：向集合中插入元素 val。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;remove(val)&lt;/code&gt;：当 val 存在时，从集合中移除一个 val。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;getRandom&lt;/code&gt;：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数组中的最长山脉</title>
    <link href="https://hoo334.github.io/2020/10/25/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/"/>
    <id>https://hoo334.github.io/2020/10/25/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/</id>
    <published>2020-10-25T02:27:01.000Z</published>
    <updated>2020-10-25T03:34:00.032Z</updated>
    
    <content type="html"><![CDATA[<h4 id="845-数组中的最长山脉"><a href="#845-数组中的最长山脉" class="headerlink" title="845. 数组中的最长山脉"></a><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/" target="_blank" rel="noopener">845. 数组中的最长山脉</a></h4><p>我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “<em>山脉”</em>：</p><ul><li><code>B.length &gt;= 3</code></li><li>存在 <code>0 &lt; i &lt; B.length - 1</code> 使得 <code>B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]</code></li></ul><p>（注意：B 可以是 A 的任意子数组，包括整个数组 A。）</p><p>给出一个整数数组 <code>A</code>，返回最长 <em>“山脉”</em> 的长度。</p><p>如果不含有 “<em>山脉”</em> 则返回 <code>0</code>。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,1,4,7,3,2,5]</span><br><span class="line">输出：5</span><br><span class="line">解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：不含 “山脉”。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000</code></li></ol><p><strong>方法一：枚举山顶</strong></p><p>我们对于数组 A 中的每个数使用一次中心扩展，即可求出以当前数为山顶的子数组长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; A[l] &lt; A[l + <span class="number">1</span>])&#123;</span><br><span class="line">                --l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; A.length &amp;&amp; A[r - <span class="number">1</span>] &gt; A[r])&#123;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l != i - <span class="number">1</span> &amp;&amp; r != i + <span class="number">1</span>)&#123;</span><br><span class="line">                ans = Math.max(ans, r - l - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(1)</li></ul><p>由于左侧山脚到山顶的序列是严格单调递增的，从山顶到右侧山脚的序列是严格单调递减的。我们可以计算从任意一个元素开始，向左右两侧最多可扩展的元素。</p><p>我们用 <code>left[i]</code>表示<code>A[i]</code>向左侧最多可以扩展的元素数目，用 <code>right[i]</code>表示<code>A[i]</code>向右侧最多可以扩展的元素数目。<br>$$<br>left[i]=\left{<br>\begin{aligned}<br>left[i - 1] + 1, \ \ A[i] &gt; A[i - 1] \<br>0, \ \ A[i] \leq A[i - 1] 或 i =0\<br>\end{aligned}<br>\right.<br>$$</p><p>$$<br>right[i]=\left{<br>\begin{aligned}<br>right[i + 1] + 1, \ \ A[i] &gt; A[i + 1] \<br>0, \ \ A[i] \leq A[i + 1] 或 i = n -1\<br>\end{aligned}<br>\right.<br>$$<br>计算出所有 left 和 right 后，枚举山顶，只有当left[i] 和 right[i]都大于 0 时，A[i]才能作为山顶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            left[i] = A[i] &gt; A[i - <span class="number">1</span>] ? left[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            right[i] = A[i] &gt; A[i + <span class="number">1</span>] ? right[i + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left[i] != <span class="number">0</span> &amp;&amp; right[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                ans = Math.max(ans, left[i] + right[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul><p><strong>方法二：枚举山脚</strong></p><p>当我们从左向右遍历整个数组 A 时，可以使用双指针的方法，一个枚举左侧山脚，另一个不断向右移动到右侧山脚。</p><p>山顶数组最少为 3 个元素，需要保证<code>left + 2 &lt; n</code>和 <code>A[left] &lt; A[left + 1]</code>。</p><p>我们将right 初始化为 left + 1，不断将其右移，直到不满足<code>A[right] &lt; A[right + 1]</code></p><ul><li>如果 right = n - 1，此时已经无法形成山脉</li><li>如果 right 指向的是山顶，我们需要判断是否有 A[right] &gt; A[right + 1]，如果right 指向的是山顶，不断右移 right 直到不满足 A[right] &gt; A[right + 1]，此时 right 指向右侧山脚，A[left] 到 A[right]就对应着一座山脉。</li><li>右侧的山脚有可能是下一座山脉的左侧山脚，我们需要将 right 的值赋予 left，以便进行下一次枚举。在其他所有情况下，将right + 1赋给left。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">2</span> &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> right = left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[left] &lt; A[left + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">while</span>(right + <span class="number">1</span> &lt; n &amp;&amp; A[right] &lt; A[right + <span class="number">1</span>])&#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(right &lt; n - <span class="number">1</span> &amp;&amp; A[right] &gt; A[right + <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">while</span>(right + <span class="number">1</span> &lt; n &amp;&amp; A[right] &gt; A[right + <span class="number">1</span>])&#123;</span><br><span class="line">                        ++right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;845-数组中的最长山脉&quot;&gt;&lt;a href=&quot;#845-数组中的最长山脉&quot; class=&quot;headerlink&quot; title=&quot;845. 数组中的最长山脉&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-mountain-in-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;845. 数组中的最长山脉&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “&lt;em&gt;山脉”&lt;/em&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;B.length &amp;gt;= 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;存在 &lt;code&gt;0 &amp;lt; i &amp;lt; B.length - 1&lt;/code&gt; 使得 &lt;code&gt;B[0] &amp;lt; B[1] &amp;lt; ... B[i-1] &amp;lt; B[i] &amp;gt; B[i+1] &amp;gt; ... &amp;gt; B[B.length - 1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（注意：B 可以是 A 的任意子数组，包括整个数组 A。）&lt;/p&gt;
&lt;p&gt;给出一个整数数组 &lt;code&gt;A&lt;/code&gt;，返回最长 &lt;em&gt;“山脉”&lt;/em&gt; 的长度。&lt;/p&gt;
&lt;p&gt;如果不含有 “&lt;em&gt;山脉”&lt;/em&gt; 则返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="双指针" scheme="https://hoo334.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>视频拼接</title>
    <link href="https://hoo334.github.io/2020/10/24/%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5/"/>
    <id>https://hoo334.github.io/2020/10/24/%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5/</id>
    <published>2020-10-24T02:56:32.000Z</published>
    <updated>2020-10-24T03:31:23.285Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a><a href="https://leetcode-cn.com/problems/video-stitching/" target="_blank" rel="noopener">1024. 视频拼接</a></h4><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 <code>T</code> 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p><p>视频片段 <code>clips[i]</code> 都用区间进行表示：开始于 <code>clips[i][0]</code> 并于 <code>clips[i][1]</code> 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 <code>[0, 7]</code> 可以剪切成 <code>[0, 1] + [1, 3] + [3, 7]</code> 三部分。</p><p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（<code>[0, T]</code>）。返回所需片段的最小数目，如果无法完成该任务，则返回 <code>-1</code> 。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：clips &#x3D; [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T &#x3D; 10</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">我们选中 [0,2], [8,10], [1,9] 这三个片段。</span><br><span class="line">然后，按下面的方案重制比赛片段：</span><br><span class="line">将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。</span><br><span class="line">现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：clips &#x3D; [[0,1],[1,2]], T &#x3D; 5</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">我们无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：clips &#x3D; [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T &#x3D; 9</span><br><span class="line">输出：3</span><br><span class="line">解释： </span><br><span class="line">我们选取片段 [0,4], [4,7] 和 [6,9] 。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：clips &#x3D; [[0,4],[2,8]], T &#x3D; 5</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">注意，你可能录制超过比赛结束时间的视频。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= clips.length &lt;= 100</code></li><li><code>0 &lt;= clips[i][0] &lt;= clips[i][1] &lt;= 100</code></li><li><code>0 &lt;= T &lt;= 100</code></li></ul><p><strong>方法一：动态规划</strong></p><p>我们使用 <code>dp[i]</code>表示整个运动过程<code>[0, i]</code>所需的最小片段数。我们遍历每段 clip ，如果 i 在这段 clip 中（<code>clip[0] &lt; i &lt;= clip[1]</code>），那么使用 <code>dp[clip[0]]</code> 和 当前这一段clip就可覆盖<code>[0,1]</code>.对于符合情况的每段 clip，我们统计 dp[i] 的最小值即可。<br>$$<br>dp[i] = min(dp[i], dp[clip[0]] + 1), (clip[0] &lt; i \leq clip[1])<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="keyword">int</span>[][] clips, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[T + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE - <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= T; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] clip : clips)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; clip[<span class="number">0</span>] &amp;&amp; i &lt;= clip[<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[clip[<span class="number">0</span>]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[T] == Integer.MAX_VALUE - <span class="number">1</span> ? -<span class="number">1</span> : dp[T];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(T * N)，T 是区间的长度，N 是子区间的数量。</li><li>空间复杂度O(T)，T 是区间的长度。</li></ul><p><strong>方法二：贪心</strong></p><p>对于每一段左端点相等的视频片段，右端点越远越好。对于每个位置 i，我们记录以其为左端点中最远的右节点<code>maxn[i]</code>。</p><p>每遍历到一个位置 i ，我们需要更新当前位置能到达的最远处 last，如果更新后 last == i，那么说明下一个位置不能被覆盖，返回 -1。</p><p>同时我们需要维护上一个区间的结束位置 pre，每次我们越过一个旧的子区间，到达一个新的子区间，这个子区间的结束位置就为 last，此时令 pre = last，答案加 1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="keyword">int</span>[][] clips, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] maxn = <span class="keyword">new</span> <span class="keyword">int</span>[T];</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, last = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] clip : clips)&#123;</span><br><span class="line">            <span class="keyword">if</span>(clip[<span class="number">0</span>] &lt; T)&#123;</span><br><span class="line">                maxn[clip[<span class="number">0</span>]] = Math.max(clip[<span class="number">1</span>], maxn[clip[<span class="number">0</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++)&#123;</span><br><span class="line">            last = Math.max(last, maxn[i]);</span><br><span class="line">            <span class="keyword">if</span>(i == last)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == pre)&#123;</span><br><span class="line">                pre = last;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(T + N)，O(N)时间对子区间进行预处理，O(T)时间枚举每个位置。</li><li>空间复杂度O(T)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1024-视频拼接&quot;&gt;&lt;a href=&quot;#1024-视频拼接&quot; class=&quot;headerlink&quot; title=&quot;1024. 视频拼接&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/video-stitching/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1024. 视频拼接&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;你将会获得一系列视频片段，这些片段来自于一项持续时长为 &lt;code&gt;T&lt;/code&gt; 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。&lt;/p&gt;
&lt;p&gt;视频片段 &lt;code&gt;clips[i]&lt;/code&gt; 都用区间进行表示：开始于 &lt;code&gt;clips[i][0]&lt;/code&gt; 并于 &lt;code&gt;clips[i][1]&lt;/code&gt; 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 &lt;code&gt;[0, 7]&lt;/code&gt; 可以剪切成 &lt;code&gt;[0, 1] + [1, 3] + [3, 7]&lt;/code&gt; 三部分。&lt;/p&gt;
&lt;p&gt;我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（&lt;code&gt;[0, T]&lt;/code&gt;）。返回所需片段的最小数目，如果无法完成该任务，则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="贪心" scheme="https://hoo334.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
