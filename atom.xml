<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-22T02:36:55.666Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2020/04/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-22T01:49:06.000Z</published>
    <updated>2020-04-22T02:36:55.666Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。每次遍历一次都使一个元素归位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="comment">//外层循环 N-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">//内层循环 N-i-1 次。第 i 次遍历整个数组需要交换 N-i-1 次。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;N-i; j++)&#123;</span><br><span class="line">                <span class="comment">//比较和交换</span></span><br><span class="line">                <span class="keyword">if</span>(a[j].compareTo(a[j-<span class="number">1</span>]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    Comparable temp = a[j];</span><br><span class="line">                    a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">                    a[j-<span class="number">1</span>] =temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h3><p>选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小元素，存放到排序序列的前部分，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="comment">// 找出未排序序列中的最小元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[min].compareTo(a[j]) &gt; <span class="number">0</span>) min = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使未排序序列中的最小值归位</span></span><br><span class="line">            Comparable temp = a[min];</span><br><span class="line">            a[min] = a[i];</span><br><span class="line">            a[i] = temp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将第 i 个元素与前面的 0 ~ i-1 个元素比较,若比其中的元素小则依次交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span> &amp;&amp; a[j].compareTo(a[j-<span class="number">1</span>])&lt;<span class="number">0</span> ;j--)&#123;</span><br><span class="line">               Comparable temp = a[j];</span><br><span class="line">               a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">               a[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h +<span class="number">1</span>;  <span class="comment">//h = 1,4,13,40 ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将数组变为 h 有序，即相隔 h 个元素 的元素构成一组，组内有序，</span></span><br><span class="line"><span class="comment">        将 h 的值逐渐缩小则数组有序。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h; i&lt;N; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=h &amp;&amp; a[j].compareTo(a[j-h])&lt;<span class="number">0</span>; j-=h)&#123;</span><br><span class="line">                    Comparable temp = a[j];</span><br><span class="line">                    a[j] = a[j-h];</span><br><span class="line">                    a[j-h] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组a[lo...hi]排序</span></span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a,lo,mid);</span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);</span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将a[lo..mid] 和a[mid+1..hi]归并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//将a[lo..hi] 复制到aux[lo..hi]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo; k&lt;=hi; ++k)</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> i = lo, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo; k&lt;=hi; ++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++]; <span class="comment">//左半边用尽</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];<span class="comment">//右半边用尽</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(aux[i].compareTo(aux[j]) &lt; <span class="number">0</span>) a[k] = aux[i++];</span><br><span class="line">                      <span class="keyword">else</span> a[k] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//将左半部分排序</span></span><br><span class="line">        sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将右半部分排序</span></span><br><span class="line">        sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[]a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组切分为a[lo..i-1], a[i], a[i+1..hi]</span></span><br><span class="line">        <span class="keyword">int</span> i=lo,j=hi;</span><br><span class="line">        <span class="comment">//选取第一个元素为基准点</span></span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i，j 相遇停止</span></span><br><span class="line">        <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//先从左边开始，不能保证你最后和基准点交换的那个数，是小于等于左边的。例如 2，1，4，9</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//找出右边比基准点小的元素的下标</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; i &amp;&amp; a[j].compareTo(v) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找出左边比基准点大的元素的下标</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i].compareTo(v) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="comment">//交换a[i] 和 a[j]</span></span><br><span class="line">                Comparable temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] =temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i，j 相遇，基准点的位置已经找到，将a[v] 与 a[i] 交换。</span></span><br><span class="line">        Comparable temp = a[lo];</span><br><span class="line">        a[lo] = a[j];</span><br><span class="line">        a[j] =temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回基准点的下标</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点开始，从下至上，从右至左向下调整。</span></span><br><span class="line">            adjustDown(a,i,a.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换堆顶元素与最后一个元素，最大的元素归位。由于破坏了大根堆的特性需要重新调整堆顶元素。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a.length-<span class="number">1</span>; j&gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="comment">//交换元素</span></span><br><span class="line">            Comparable temp = a[<span class="number">0</span>];</span><br><span class="line">            a[<span class="number">0</span>] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向下调整大根堆</span></span><br><span class="line">            adjustDown(a,<span class="number">0</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(Comparable[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>*i+<span class="number">1</span>; k&lt;length; k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到两个子结点中较大的一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; a[k].compareTo(a[k+<span class="number">1</span>])&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果子结点的值大于父结点的值，将父结点向下调整，继续向下调整</span></span><br><span class="line">            <span class="keyword">if</span>(a[k].compareTo(temp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//父结点的值设置为子结点的值</span></span><br><span class="line">                a[i] = a[k];</span><br><span class="line">                <span class="comment">//对当前结点继续向下调整</span></span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将 temp 值放到最终的位置</span></span><br><span class="line">        a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>]]></content>
    
    <summary type="html">
    
      排序算法总结
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>DFS &amp; BFS medium</title>
    <link href="http://yoursite.com/2020/04/20/DFS&amp;BFSMedium/"/>
    <id>http://yoursite.com/2020/04/20/DFS&amp;BFSMedium/</id>
    <published>2020-04-20T03:28:20.000Z</published>
    <updated>2020-04-20T03:42:38.123Z</updated>
    
    <content type="html"><![CDATA[<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h4><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure><p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1 ，则以其为起始结点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对网格中的每个 1 都做深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//发现一个岛屿</span></span><br><span class="line">                    ++ count;</span><br><span class="line">                    <span class="comment">//将该 1 相连的 1 全部置为 0</span></span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">//将第 r 行，第 c 列的 1 相邻的 1 全部置为 0</span></span><br><span class="line">        grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(r-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="string">'1'</span>) dfs(grid, r-<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span>(r+<span class="number">1</span> &lt;rows &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) dfs(grid, r+<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span>(c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="string">'1'</span>)dfs(grid, r, c-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(c+<span class="number">1</span> &lt; cols &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>)dfs(grid, r, c+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//发现一个岛屿</span></span><br><span class="line">                    grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                    ++count;</span><br><span class="line">                    </span><br><span class="line">                    Queue&lt;Integer&gt; neighbors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    neighbors.add(i*cols+j);</span><br><span class="line">                    <span class="comment">//BFS</span></span><br><span class="line">                    <span class="keyword">while</span>(! neighbors.isEmpty())&#123;</span><br><span class="line">                        <span class="comment">//得到保存的行列信息</span></span><br><span class="line">                        <span class="keyword">int</span> id = neighbors.remove();</span><br><span class="line">                        <span class="keyword">int</span> r = id / cols;</span><br><span class="line">                        <span class="keyword">int</span> c = id % cols;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//将第 i 行，第 j 列的 1 相邻的 1 全部置为 0</span></span><br><span class="line">                        <span class="keyword">if</span>(r-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add((r-<span class="number">1</span>)*cols+c);</span><br><span class="line">                            grid[r-<span class="number">1</span>][c] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(r+<span class="number">1</span> &lt;rows &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add((r+<span class="number">1</span>)*cols+c);</span><br><span class="line">                            grid[r+<span class="number">1</span>][c] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add(r*cols + c - <span class="number">1</span>);</span><br><span class="line">                            grid[r][c-<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(c+<span class="number">1</span> &lt; cols &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add(r*cols + c + <span class="number">1</span>);</span><br><span class="line">                            grid[r][c+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode medium DFS &amp; BFS 总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>动态规划 medium</title>
    <link href="http://yoursite.com/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92medium/"/>
    <id>http://yoursite.com/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92medium/</id>
    <published>2020-04-19T01:43:48.000Z</published>
    <updated>2020-04-20T02:30:21.155Z</updated>
    
    <content type="html"><![CDATA[<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a></h4><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p>动态转移方程为：<code>dp[i] = MIN(dp[i], dp[i - j * j] + 1)</code>，<code>i</code>表示当前数字，<code>j*j</code>表示平方数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure><p>使用 dp 数组来保存以当前下标为和的完全平方数的个数。依次对每个数判断是否可以使用之前的dp数组中的值加一个较大的完全平方数得到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="comment">//最坏的情况，全部由 1 相加得到</span></span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; i-j*j&gt;=<span class="number">0</span>; ++j)&#123;</span><br><span class="line">                <span class="comment">//尝试由 i-1, i-4, i-9 ...得到 i </span></span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. 摆动序列</a></h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为<strong>摆动序列。</strong>第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反, <code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong><br>你能否用 O(<em>n</em>) 时间复杂度完成此题?</p><p>每当我们选择一个元素作为摆动序列的一部分时，这个元素要么是上升的，要么是下降的，这取决于前一个元素的大小。</p><p>我们使用两个数组来 dp，up[i] 存的是目前为止的以第 i 个元素结尾的上升摆动序列的长度。</p><p>类似的，down[i] 存的是目前为止以第 i 个元素结尾的下降摆动序列的长度。</p><p>数组中的任何元素都对应下面三种可能状态中的一种：</p><ol><li>上升的位置，意味着 nums[i] &gt; nums[i - 1]</li><li>下降的位置，意味着 nums[i] &lt; nums[i - 1]</li><li>相同的位置，意味着 nums[i] == nums[i - 1]</li></ol><p>如果为情况 1 ，意味着在这里摆动上升，前一个数字肯定处于下降的位置。所以 up[i] = down[i-1]+1, down[i] = down[i-1]。</p><p>如果为情况 2， 意味着在这里摆动下降，前一个数字肯定处在上升的位置。所以 down[i] = up[i-1]+1, up[i] = up[i-1]。</p><p>如果为情况 3，up[i] = up[i-1], down[i] = down[i-1]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        up[<span class="number">0</span>] = down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="comment">//情况1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                up[i] = down[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>])&#123; <span class="comment">//情况 2</span></span><br><span class="line">                down[i] = up[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//情况 3</span></span><br><span class="line">                down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">                up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up[nums.length-<span class="number">1</span>], down[nums.length-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：我们只需要 up[i-1] 和 down[i-1] ，只需要两个变量来保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                up = down + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                down = up + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode medium 动态规划总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树 hard</title>
    <link href="http://yoursite.com/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91hard/"/>
    <id>http://yoursite.com/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91hard/</id>
    <published>2020-04-18T08:18:51.000Z</published>
    <updated>2020-04-21T02:12:49.999Z</updated>
    
    <content type="html"><![CDATA[<h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></h4><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 后序遍历 “左右根”。需要一个栈来保存根结点，</span></span><br><span class="line"><span class="comment">    * 还需要一个指针来记录上一个访问的结点来判断是否访问过根结点的右子结点。</span></span><br><span class="line"><span class="comment">    * 当访问过树的最右叶子结点后，弹出根结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode lastPrintNode = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">while</span>(root != <span class="keyword">null</span> || ! s.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//根结点入栈</span></span><br><span class="line">               s.push(root);</span><br><span class="line">               <span class="comment">//继续入栈根结点的左子结点</span></span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//无左子结点，将根结点复制一份</span></span><br><span class="line">               root = s.peek();</span><br><span class="line">               <span class="comment">//查看右子结点是否为空或右子结点已经访问过</span></span><br><span class="line">               <span class="keyword">if</span>(root.right == <span class="keyword">null</span> || root.right == lastPrintNode)&#123;</span><br><span class="line">                   <span class="comment">//根结点出栈</span></span><br><span class="line">                    s.pop(); </span><br><span class="line">                   <span class="comment">//访问根结点</span></span><br><span class="line">                    res.add(root.val); </span><br><span class="line">                   <span class="comment">//更新上一个访问过的结点</span></span><br><span class="line">                    lastPrintNode = root; </span><br><span class="line">                   <span class="comment">//取根结点的根节点访问</span></span><br><span class="line">                    root = <span class="keyword">null</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">//右子结点不为空，访问右子结点</span></span><br><span class="line">                   root = root.right;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode 二叉树hard
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树 medium</title>
    <link href="http://yoursite.com/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91medium/"/>
    <id>http://yoursite.com/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91medium/</id>
    <published>2020-04-18T08:04:11.000Z</published>
    <updated>2020-04-22T01:43:04.757Z</updated>
    
    <content type="html"><![CDATA[<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h4><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 中序遍历 “左根右”。需要一个栈来保存根结点。</span></span><br><span class="line"><span class="comment">    * 当访问过树的最左叶子结点后，弹出根结点，访问根结点，继续访问根节点的右子结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环条件：栈中元素不为空。树的根结点非空</span></span><br><span class="line">       <span class="keyword">while</span>(root != <span class="keyword">null</span> || ! s.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//根结点入栈</span></span><br><span class="line">               s.push(root);</span><br><span class="line">               <span class="comment">//继续入栈根结点的左子结点</span></span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//无左子结点，将根结点出栈</span></span><br><span class="line">               root = s.pop();</span><br><span class="line">               <span class="comment">//访问根结点</span></span><br><span class="line">               res.add(root.val);</span><br><span class="line">               <span class="comment">//继续访问根结点的右子结点</span></span><br><span class="line">               root = root.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></h4><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p><p> <strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 前序遍历 “根左右”。需要一个栈来保存已经访问过的根结点。</span></span><br><span class="line"><span class="comment">    * 当已经访问过树的最左叶子结点后，弹出根结点，继续访问根结点的右子结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="comment">//循环条件：栈中元素不为空。树的根节点非空</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || ! s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//访问根节点</span></span><br><span class="line">                ans.add(root.val);</span><br><span class="line">                <span class="comment">//保存根节点</span></span><br><span class="line">                s.push(root);</span><br><span class="line">                <span class="comment">//访问根结点的左子结点</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无左子结点，弹出根结点</span></span><br><span class="line">                root = s.pop();</span><br><span class="line">                <span class="comment">//继续访问右子结点</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></h4><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure><p>第一感觉就是用层次遍历，保存每一层的最后一个结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"><span class="comment">//层次遍历使用的队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(! queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// len 为层次遍历时每一层的结点个数</span></span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                <span class="comment">// 是否为最后一个结点</span></span><br><span class="line">                <span class="keyword">if</span>(i == len-<span class="number">1</span>)&#123;</span><br><span class="line">                res.add(t.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将左右子结点加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) queue.add(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) queue.add(t.right);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以模仿二叉树遍历，只是先遍历右子结点然后遍历左子结点。同时在遍历的过程中保存每一层的第一个结点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            假设二叉树深度为 i ，res 数组的大小为 i。</span></span><br><span class="line"><span class="comment">            当 res.size() 小于当前访问的层数时就代表这是最右侧结点。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt; level)&#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先遍历右子结点</span></span><br><span class="line">            helper(root.right, level+<span class="number">1</span>, res);</span><br><span class="line">            <span class="comment">//后遍历左子结点</span></span><br><span class="line">            helper(root.left, level+<span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode 二叉树medium
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数组 medium</title>
    <link href="http://yoursite.com/2020/04/17/%E6%95%B0%E7%BB%84Medium/"/>
    <id>http://yoursite.com/2020/04/17/%E6%95%B0%E7%BB%84Medium/</id>
    <published>2020-04-17T02:51:13.000Z</published>
    <updated>2020-04-21T02:15:18.176Z</updated>
    
    <content type="html"><![CDATA[<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h4><p>给你 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://i.loli.net/2020/04/21/23RAHzps9cYvGKC.jpg" alt="img"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure><p>使用双指针。左指针为 i，右指针为 j 。水的容量为 (j - i) * min(i , j) 。我们需要维护一个容器的容量的最大值。我们需要找出最大的容量。此时需要向中间移动左右指针中比较小的那个值。证明：一般 i &lt; j ，容器的容量为  <code>min(height[i] , height[j])*(j-i)</code> , 如果我们将两个指针中的比较高的值向中间移动，那么得到的容量一定小于前面算出的容量（j 变小了，i 不变，两个边界最小值不变）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=height.length-<span class="number">1</span>; i&lt;=j ;)&#123;</span><br><span class="line">            <span class="comment">//维护最大容量</span></span><br><span class="line">            max = Math.max(max, (j-i) * Math.min(height[i], height[j]) );</span><br><span class="line">            <span class="comment">//移动高度较小的指针</span></span><br><span class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure><p>对于数组中任意一个位置 i，最远到达的位置为 i + nums[i] 。实时维护一个可到达的最远位置 rightmax，如果rightmax 大于数组最后一个位置的下标即可返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rightmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">                 <span class="comment">//最远可到达 rightmax </span></span><br><span class="line">            <span class="keyword">if</span>(i &lt;= rightmax)&#123;</span><br><span class="line">            <span class="comment">//实时更新 rightmax 的值</span></span><br><span class="line">            rightmax = Math.max(rightmax , i+nums[i]);</span><br><span class="line">                <span class="comment">//大于最后一个位置的下标返回 true</span></span><br><span class="line">            <span class="keyword">if</span>(rightmax &gt;= n-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。</p><p>如果某个 <strong>连续</strong> 子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p><p>请返回这个数组中「优美子数组」的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,1,1], k &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,4,6], k &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line">解释：数列中不包含任何奇数，所以不存在优美子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,1,2,2,1,2,2,2], k &#x3D; 2</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50000</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><p>在这个题目中偶数是没有用的，我们可以建立一个 odd 数组来记录第 i 个奇数的下标，假设当前枚举到第 i 个，那么 <code>[odd[i], odd[i+k-1]]</code> 这个子数组恰好包含 k 个奇数。这个范围左侧的奇数下标为 odd[i-1], 右侧的奇数下标为 odd[i+k]。如果<code>[odd[i], odd[i+k-1]]</code> 这个包含 k 个奇数的子数组左右侧都右偶数，那么满足条件的包含 k 个奇数的子数组个数为  (<em>odd</em>[<em>i</em>]−<em>odd</em>[<em>i</em>−1])∗(<em>odd</em>[<em>i</em>+<em>k</em>]−<em>odd</em>[<em>i</em>+<em>k</em>−1]) 。我们只要遍历一遍 odd 数组即可求解答案。</p><p>边界处理：</p><ol><li>当 nums[0] 为奇数时，odd[1] = 0，此时左边没有偶数 odd[1] - odd[0] 应该为 1（只有 nums[0] 为子数组左侧边界）。此时 odd[0] = -1。</li><li>当记录最后一个奇数时（假设这是第 index 个奇数，对应 nums 数组中的下标为 x）， odd[index] = x, odd[index+1] = nums.length。odd 数组最后一个元素记录的是数组中所有元素的数量。</li></ol><p>以示例 3 来解释：我们生成的 odd 数组为 [-1, 3, 6, 10]，对其遍历一遍得到结果 (3 - (-1)) * (10-6) = 16。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] odd = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成 odd 数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>)odd[++index] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//边界处理</span></span><br><span class="line">        odd[<span class="number">0</span>] = -<span class="number">1</span>; odd[++index] = n;</span><br><span class="line"><span class="comment">//计算结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+k &lt;= index; ++i)&#123;</span><br><span class="line">            ans += (odd[i] - odd[i-<span class="number">1</span>])*(odd[i+k] - odd[i+k-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode medium 数组总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Object</title>
    <link href="http://yoursite.com/2020/04/14/Object/"/>
    <id>http://yoursite.com/2020/04/14/Object/</id>
    <published>2020-04-14T12:46:18.000Z</published>
    <updated>2020-04-19T00:39:31.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-lang-Object"><a href="#java-lang-Object" class="headerlink" title="java.lang.Object"></a>java.lang.Object</h1><p>类Object是类层次结构的根。 每个类都有Object作为超类。 所有对象，包括数组，实现这个类的方法。</p><h3 id="类层次结构"><a href="#类层次结构" class="headerlink" title="类层次结构"></a>类层次结构</h3><p><img src="https://i.loli.net/2020/04/14/6IRKvZyzNhxYTgk.png" alt="image-20200414205022670"></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>public Object(){}</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives"></a>registerNatives</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中有两种方法：Java 方法和本地方法。Java 方法是由 Java 语言编写，编译成字节码，存储在 class 文件中。本地方法是由其他语言（比如 C 、C++ 、汇编）编写的，编译成和处理器相关的机器代码。本地方法保存在动态链接库中，格式是各个平台专有的。Java 方法是平台无关的，但本地方法不是。运行中的 Java 程序调用本地方法是，虚拟机装载包含这个本地方法的动态库。本地方法是联系 Java 程序和底层主机操作系统的连接方法。</p><p>本地方法的实现是由其他语言编写并保存在动态链接库中，因此在 Java 类中不需要方法实现。registerNatives() 本质上就是一个本地方法，但这又是一个区别于一般本地方法的本地方法，从本地方法名可以猜测出该方法是用来注册本地方法的。上述代码的功能就是先定义了registerNatives()方法，然后当该类被加载的时候，调用该方法完成对该类中本地方法的注册。</p><p>凡是包含registerNatives()本地方法的类，同时也包含了其他本地方法。所以，显然，当包含registerNatives()方法的类被加载的时候，<strong>注册的方法就是该类所包含的除了registerNatives()方法以外的所有本地方法</strong>。</p><p>一个Java程序要想调用一个本地方法，需要执行两个步骤：第一，通过System.loadLibrary()将包含本地方法实现的动态文件加载进内存；第二，当Java程序需要调用本地方法时，虚拟机在加载的动态文件中定位并链接该本地方法，从而得以执行本地方法。registerNatives()方法的作用就是取代第二步，让程序主动将本地方法链接到调用方，当Java程序需要调用本地方法时就可以直接调用，而不需要虚拟机再去定位并链接。</p><h4 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><p>返回运行时类的Object 。 返回Class对象被 static synchronized 所表示的类方法修饰。<br>实际结果的类型是Class&lt;? extends |X|&gt;，其中|X| 是getClass被调用时静态类型的擦除。 例如，下列代码不需要强制转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number n = <span class="number">0</span>; </span><br><span class="line">Class&lt;? extends Number&gt; c = n.getClass();</span><br></pre></td></tr></table></figure><h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>返回该对象的哈希码值。 为其他哈希表提供支持，例如 java.util.HashMap 。<br>一般 hashCode 满足以下规则：</p><ul><li><p>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用，hashCode方法都必须始终返回同一个值。在一个应用程序与另一个应用程序的执行过程中，执行hashCode方法所返回的值可以不一致。</p></li><li><p>如果两个对象由 equals() 判断为 true ，那么他们的哈希码值必须相等。</p></li><li><p>如果两个对象由 equals() 判断为 false ，那么他们的哈希码值可以相等。应该为不同的对象生成不同的哈希码来提高哈希表的性能。哈希码值一般是将对象地址转成一个整数来得到。</p></li></ul><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断某个其他对象是否 “等于” 这个对象。默认比较的是两个对象的地址，当且仅当 this 和 obj 同时指向同一个对象时返回 true。</p><p>按照约定，equals要满足以下规则。</p><ul><li><strong>自反性</strong>:  x.equals(x) 一定是true</li><li><strong>对null</strong>:  x.equals(null) 一定是false</li><li><strong>对称性</strong>:  x.equals(y)  和 y.equals(x)结果一致</li><li><strong>传递性</strong>:  a 和 b equals , b 和 c  equals，那么 a 和 c也一定equals。</li><li><strong>一致性</strong>:  在某个运行时期间，2个对象的状态的改变不会影响equals的决策结果，那么，在这个运行时期间，无论调用多少次equals，都返回相同的结果。</li></ul><p>通常 equals 方法被重写时，必须重写 hashcode 方法。如果重写了 equals 方法，没有重写 hashcode 方法，判断两个值相等的对象时，当 equals 方法判断为 true（对象的值相等则为 true）时，由于两个值相等的对象地址不一样，所以生成的 hashcode 也不一样。违反了 hashcode 的规则：equals 为 true 两个对象的哈希码值必须相等。</p><h4 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>创建并返回此对象的副本。按照惯例，返回的对象应该通过调用<code>super.clone</code>获得。</p><p><code>clone</code>的方法<code>Object</code>执行特定的克隆操作。  首先，如果此对象的类不实现接口<code>Cloneable</code>  ，则抛出<code>CloneNotSupportedException</code> 。  请注意，所有数组都被认为是实现接口<code>Cloneable</code>  ，并且数组类型<code>T[]</code>的<code>clone</code>方法的返回类型是<code>T[]</code>  ，其中T是任何引用或原始类型。  否则，该方法将创建该对象的类的新实例，并将其所有字段初始化为完全符合该对象的相应字段的内容，就像通过赋值一样。  这些字段的内容本身不被克隆。 因此，该方法执行该对象的“浅拷贝”，而不是“深度拷贝”操作。 </p><p><code>Object</code>类本身并不实现接口<code>Cloneable</code>  ，因此在类别为<code>Object</code>的对象上调用<code>clone</code>方法将导致运行时抛出异常</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>返回一个代表对象的字符串。这个字符串中含有对象的相关信息，便于阅读。建议所有的子类重写这个方法。</p><p>Object 类的 toString 方法返回对象的类名 + ‘@’ + 对象的哈希码值得十六进制数。</p><h4 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>唤醒<strong>任意</strong>一个正在等待该对象的监视器的线程。一个线程通过调用 wait 方法来等待对象的监视器。被唤醒的线程只有在当前线程放弃了对象的锁之后才能被执行。被唤醒的线程与其他线程平等竞争对象的锁。该方法只能由作为该对象的监视器的所有者线程调用。</p><p>线程有三种方式称为对象监视器的所有者：</p><ol><li><p>通过执行对象的同步方法。</p></li><li><p>通过执行对象的同步语句（锁住此对象）。</p></li><li><p>执行类的同步静态方法。</p></li></ol><h4 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>唤醒<strong>所有</strong>一个正在等待该对象的监视器的线程。一个线程通过调用 wait 方法来等待对象的监视器。</p><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>使当前线程阻塞直到另一个线程调用此对象的 notify 方法或 notifyAll 方法或指定的时间已过，当前线程变为就绪状态。当前线程必须拥有此对象的监视器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                               <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           timeout++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       wait(timeout);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>与只有一个参数的 wait 方法类似，更加精细地控制等待被唤醒的时间直到放弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使当前线程阻塞直到另一个线程调用此对象的 notify 方法或 notifyAll 方法。</p><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>当垃圾收集器确定不再有该对象的引用时调用。finalize 方法通常的目的是在对象不可撤销丢弃之前执行清除动作。甚至finalize 方法可以让此对象再次可用于其他线程而避免被垃圾收集器清除。finalize 方法只能调用一次。</p><p>参考：</p><p><a href="https://blog.csdn.net/Saintyyu/article/details/90452826" target="_blank" rel="noopener">https://blog.csdn.net/Saintyyu/article/details/90452826</a></p>]]></content>
    
    <summary type="html">
    
      JDK 源码分析
    
    </summary>
    
    
      <category term="JDK 源码分析" scheme="http://yoursite.com/categories/JDK-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="java.lang包" scheme="http://yoursite.com/tags/java-lang%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>数组 easy</title>
    <link href="http://yoursite.com/2020/04/09/%E6%95%B0%E7%BB%84Easy/"/>
    <id>http://yoursite.com/2020/04/09/%E6%95%B0%E7%BB%84Easy/</id>
    <published>2020-04-09T01:41:01.000Z</published>
    <updated>2020-04-21T01:46:59.462Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h4><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p>以 num[i] 为 HashMap 的 key，i 为 HashMap 的 value。每遍历到一个新的 nums[i] 判断 HashMap 中是否包含值为 target - nums[i] 的 key，如果包含则取出 key 的 value ，返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; numMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(numMap.containsKey(target-nums[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,numMap.get(target-nums[i])&#125;;</span><br><span class="line"></span><br><span class="line">            numMap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h4><p>给定一个排序数组，你需要在<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地</a></strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>我们使用i，j两个二指针， j 在前面走。如果 j 指向的元素等于 i 指向的元素 j 直接向前移，如果 j 指向的元素不等于 i 指向的元素，i 向前移 ，将 j 指向的元素赋给 i ，j向前移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;nums.length;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] != nums[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-i != <span class="number">1</span>)&#123;</span><br><span class="line">                nums[++i]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ++i; <span class="comment">//i，j相邻 直接 ++i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h4><p>给定一个已按照<strong><em>升序排列\</em></strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br></pre></td></tr></table></figure><p>双指针左右向数组中间移动，直到它们的和为 target。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=numbers.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[j]+numbers[i] &gt;target)&#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[j]+numbers[i] &lt;target)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></h4><p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>由于多数元素出现的次数比其他元素出现次数的总和还要多，我们可以设置一个计数 count 和 返回结果 majority ，</p><p>当出现的元素和 majority 相同时 count 加一， 当出现的元素和 majority 不同时 count 减一， 当 count 为 0 时更换 majority 为当前遍历的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                majority = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[i] == majority)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">268. 缺失数字</a></h4><p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><p>利用 2 ^2 = 0 ， 0 ^ 2 = 2 异或运算的特性，我们可以在线性时间复杂度找出缺失的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        res=res^(i+<span class="number">1</span>)^nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303. 区域和检索 - 数组不可变</a></h4><p>给定一个整数数组  <em>nums*，求出数组从索引 *i</em> 到 <em>j</em> (<em>i</em> ≤ <em>j</em>) 范围内元素的总和，包含 <em>i, j</em> 两点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>你可以假设数组不可变。</li><li>会多次调用 <em>sumRange</em> 方法。</li></ol><p>注意到 “假设数组不可变” 这个条件，我们可以自然地想到直接将一些区域和存储起来，多次调用 <em>sumRange</em> 方法时只用 O(1) 时间复杂度就可以得到结果。</p><p>在数组初始化的时候生成一个前 n 项和的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">     <span class="comment">//sum[i] 代表前 i (i&gt;=1) 个元素的和      </span></span><br><span class="line">     sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第i+1个 到 j+1个元素的和</span></span><br><span class="line">     <span class="keyword">return</span> sum[j+<span class="number">1</span>] - sum[i];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">392. 判断子序列</a></h4><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>你可以认为 <strong>s</strong> 和 <strong>t</strong> 中仅包含英文小写字母。字符串 <strong>t</strong> 可能会很长（长度 ~= 500,000），而 <strong>s</strong> 是个短字符串（长度 &lt;=100）。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><p><strong>示例 1:</strong><br><strong>s</strong> = <code>&quot;abc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p><p>返回 <code>true</code>.</p><p><strong>示例 2:</strong><br><strong>s</strong> = <code>&quot;axc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p><p>返回 <code>false</code>.</p><p>最直观的办法就是维护两个指针，判断子序列中的所有字符是否在原始字符串中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;t.length() &amp;&amp; j&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子字符串被全部匹配</span></span><br><span class="line">        <span class="keyword">return</span> j == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></h4><p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为<em>O(n)</em>的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><p>将当前元素的值的绝对值作为下标，将以当前元素为下标的数组元素值置位为负，再遍历一次数组即可找出所有未出现的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = Math.abs(nums[i])-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="532-数组中的K-diff数对"><a href="#532-数组中的K-diff数对" class="headerlink" title="532. 数组中的K-diff数对"></a><a href="https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/" target="_blank" rel="noopener">532. 数组中的K-diff数对</a></h4><p>给定一个整数数组和一个整数 <strong>k</strong>, 你需要在数组里找到<strong>不同的</strong> k-diff 数对。这里将 <strong>k-diff</strong> 数对定义为一个整数对 (i, j), 其中 <strong>i</strong> 和 <strong>j</strong> 都是数组中的数字，且两数之差的绝对值是 <strong>k</strong>.</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3, 1, 4, 1, 5], k &#x3D; 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。</span><br><span class="line">尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:[1, 2, 3, 4, 5], k &#x3D; 1</span><br><span class="line">输出: 4</span><br><span class="line">解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 3, 1, 5, 4], k &#x3D; 0</span><br><span class="line">输出: 1</span><br><span class="line">解释: 数组中只有一个 0-diff 数对，(1, 1)。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>数对 (i, j) 和数对 (j, i) 被算作同一数对。</li><li>数组的长度不超过10,000。</li><li>所有输入的整数的范围在 [-1e7, 1e7]。</li></ol><p>我们先将整数数组排序， 从第一个元素开始 向右寻找 diff 为 k 的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//去掉相同元素</span></span><br><span class="line">        <span class="keyword">for</span>(;i&gt;<span class="number">0</span>&amp;&amp;i&lt;nums.length&amp;&amp;nums[i]==nums[i-<span class="number">1</span>];i++);</span><br><span class="line">　　　　　　　<span class="comment">//向右寻找</span></span><br><span class="line">        j=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;nums.length&amp;&amp;nums[j]-nums[i]&lt;k;j++);</span><br><span class="line">        <span class="comment">//找到一对 j-i==k</span></span><br><span class="line">        <span class="keyword">if</span>(j&lt;nums.length&amp;&amp;nums[j]-nums[i]==k)</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode easy 数组总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>动态规划 easy</title>
    <link href="http://yoursite.com/2020/04/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92Easy/"/>
    <id>http://yoursite.com/2020/04/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92Easy/</id>
    <published>2020-04-08T03:20:53.000Z</published>
    <updated>2020-04-20T03:47:01.186Z</updated>
    
    <content type="html"><![CDATA[<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h4><p>难度简单1831收藏分享切换为英文关注反馈</p><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>设f(k) 表示连续以下标为 k 的元素结尾的连续子数组的和，f(k) = max( nums[k], nums[k] + f(k-1) ),如果f(k) &lt; 0 ，从当前元素开始求和。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化连续子数组的最大和，当前子数组的最大和。</span></span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">    <span class="comment">//尝试向当前子数组后加入 nums[i]，如果当前子数组和为负，</span></span><br><span class="line">        <span class="comment">//则以当前元素作为第一个元素开始重新计算连续子数组。</span></span><br><span class="line">        sum = Math.max(nums[i],sum+nums[i]);</span><br><span class="line">        <span class="comment">//取最大值。</span></span><br><span class="line">        max = Math.max(max,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h4><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><ol><li>有一个台阶只有一种选择；</li><li>有两个台阶有 2 阶、1阶 + 1阶两种选择；</li><li>有三个台阶有也有两种选择：从第二个台阶爬一阶，从第一个台阶一次爬两阶。爬上第二个台阶有两种方法，故通过第二个台阶到第三个台阶有两种方法，加上从第一个台阶到第三个台阶有一种方法故有三种方法。</li></ol><p>设 f(n) 为爬上第 n 个台阶的方法总数，则有 f(n) = f(n-1) + f(n-2)；第 n 个台阶的方法数由第 n-1 个台阶和第 n-2 个台阶的方法数组成，即可以从 n-1 个台阶爬一个台阶到第 n 阶和从第 n-2 个台阶爬两个台阶到第 n 个台阶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ;i &lt; n ; ++i)&#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h4><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p>假设我们在第 i 天之前买一张股票，想要在第 i 天卖掉它，我们肯定在前 i-1 天中选择一天价格最低的时候买入，在股票价格最高的时候卖出。但是如果在前 i-1 天中的某一天可以获得比第 i 天获得的更大利润就不能选择第 i 天卖出而要选择前 i-1 天中的最大利润。第 i 天能获得的最大利润 = max( 前 i-1 天的最大利润，第 i 天的股票价格 - 前 i-1 天股票的最低价格)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>,min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;prices.length;++i)&#123;</span><br><span class="line">        max=Math.max(max,prices[i]-min);</span><br><span class="line">        min=Math.min(prices[i],min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><p>以示例 2 为例：</p><ol><li>当只有一个数 2 时我们只能偷2；</li><li>当有两个数 2，7 时我们选择偷 7 ；</li><li>当有2，7，9 时，我们比较 2+9 和7 谁大就取谁，偷 2+9 =11；</li><li>当有2，7，9，3 时我们有 11 和（3+7）比较 选择 11 ；</li><li>当2，7，9，3，1 时 11 和 11 +1 我们选择 12。</li></ol><p>设 f(n) 为偷盗前 n 个房屋的最高金额，则 f(n) = max( f(n-1), f(n-2) + num)。即偷盗前 n 个房屋可以有偷第 n 个房屋和不偷第 n 个房屋两种选择，取其中金额最大的一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preMax = <span class="number">0</span>, curMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = curMax;</span><br><span class="line">        curMax = Math.max(preMax + x , curMax);</span><br><span class="line">        preMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></h4><p>数组的每个索引做为一个阶梯，第 <code>i</code>个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>(索引从0开始)。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: cost &#x3D; [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><code>cost</code> 的长度将会在 <code>[2, 1000]</code>。</li><li>每一个 <code>cost[i]</code> 将会是一个Integer类型，范围为 <code>[0, 999]</code>。</li></ol><p>如果我们需要到达第 i 个台阶，我们有两种选择：</p><ol><li>从第 i-2 个台阶到达第 i 个台阶，花费为到达第 i-2 个台阶的最小花费 + cost[i]；</li><li>从第 i-1 个台阶到达第 i 个台阶，花费为到达第 i-2 个台阶的最小花费 + cost[i]；</li></ol><p>到达第 i 个台阶的最小代价为这两种花费的最小值。</p><p>即 <code>cost[i] = min( minPrice[i-1], minPrice[i-2] ) + cost[i]</code>。由于只要使用到前两个台阶的最小代价，所以只用维护两个变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//pre 为前 1 个台阶的最小花费，pre2 为前 2 个台阶的最小花费。</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, pre2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cost.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = cost[i] + Math.min(pre,pre2);</span><br><span class="line">            pre2 = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(pre,pre2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode easy 动态规划总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>事务管理与恢复</title>
    <link href="http://yoursite.com/2020/04/06/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>http://yoursite.com/2020/04/06/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%8E%E6%81%A2%E5%A4%8D/</id>
    <published>2020-04-06T01:27:11.000Z</published>
    <updated>2020-04-20T03:44:31.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h4><p>​    对于用户而言，事务是具有完整逻辑意义的数据库操作序列的集合。对于数据库管理系统而言，事务则是一个读写操作序列。这些操作是一个不可分割的逻辑工作单元，要么都做，要么都不做。</p><p>​    通常有有两种类型的事务结束语句：</p><p>​    1）事务提交（commit）：将成功完成事务的执行结果（即更新）永久化，并释放事务占有的全部资源。</p><p>​    2）事务回滚（rollback）：中止当前事务、撤销其对数据库所做的更新，并释放事务占有的全部资源。</p><p>​    </p><p>SQL Server 数据库提供了 3 种类型的事务模式：显式事务、隐式事务及自定义事务。</p><p>​    显式事务是指用户使用了 Transact-SQL 事务语句所定义的事务，其事务语句包括：</p><p>​    事务开始：begin transaction</p><p>​    事务提交：commit transaction，commit work</p><p>​    事务回滚：rollback transaction，rollback work</p><p>​    隐式事务是指事务提交或回滚后，SQL Server 自动开始新的事务。该类事务不需要采用 begin transaction 语句标识事务的开始。</p><p>​    自动定义事务模式：当一个语句成功执行后，它被自动提交，而当执行过程中出错时，则被自动回滚。</p><h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h4><p>​    1）原子性（Atomicity）。事务的所有操作要么全部被执行，要么都不执行。</p><p>​    2）一致性（Consistency）。一个单独执行的事务应保证其执行结果的一致性，即总是将数据库从一个一致性状态转化到另一个一致性状态。</p><p>​    3）隔离性（Isolation）。当多个事务并发执行时，一个事务的执行不能影响另一个事务，即并发执行的各个事务不能相互干扰。</p><p>​    4）持久性（Durability）。一个事务提交成功后，它对数据库的改变必须是永久的，即使随后系统出现故障。</p><h4 id="事务并发执行与调度"><a href="#事务并发执行与调度" class="headerlink" title="事务并发执行与调度"></a>事务并发执行与调度</h4><p>​    数据库管理系统允许多个事务并发执行，其主要优点是增加系统吞吐量和减少平均响应时间。</p><p>​    </p><p>​    并发事务带来的问题：</p><p>​    1）<strong>脏读（Dirty Read）</strong>：一个事务正在访问数据并对数据进行修改，修改还没有提交到数据库，这是另外一个事务访问了这个数据，然后使用了这个数据。这个数据更改之前的数据，另一个事务读到的数据是“脏数据”，依靠“脏数据”所做的操作是不正确的。</p><p>　2）<strong>丢失修改（Lost to modify）</strong>：一个事务读取一个数据时，另外一个事务也访问了该数据，在第一个事务中修改数据后，第二个事务也修改了这个数据。第一个事务内的修改结果丢失，因此称作丢失修改。例如事务1读取某表中的数据 A=20 ，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改丢失。</p><p>　3）<strong>不可重复读（Unrepeatable read）</strong>：在一个事务内多次读同一个数据在这个事务还没有结束时，另一个事务也访问该数据。在第一个事务的两次读之间，另一个事务可能已经修改了数据，导致两次读取的数据可能不太一样。</p><p>　4）<strong>幻读（Phanatom read）</strong>：幻读与不可重复读类似。发生在一个事务读了几行数据，接着另一个并发 事务插入了一些数据。在随后的查询中第一个事务就会发现多了一些原本不存在的记录，好像发生了幻觉。    </p><h4 id="事务调度及正确性准则"><a href="#事务调度及正确性准则" class="headerlink" title="事务调度及正确性准则"></a>事务调度及正确性准则</h4><p>​    事务并发执行顺序是随机的，将由多个事务操作组成的随机执行序列称为一个调度。对于一组事务操作组成的调度序列而言，应满足下列条件：</p><p>​    1）该调度包括该组事务的全部操作；</p><p>​    2）属于同一个事务的操作应保持在原事务中的执行顺序。</p><p>​    串行调度：在调度 S 中，如果属于同一事务的操作都是相邻的，则称 S 是串行调度。</p><p>​    冲突操作：在一个调度 S 中，如果 A 和 B 是不同事务在相同数据对象上的操作，并且其中至少有一个是写操作，则称 A 与 B 是冲突操作。</p><p>​    冲突等价：如果一调度 S 可以经过交换一系列非冲突操作执行的顺序而得到一个新的调度 S‘ ，则称 S 与 S’ 是冲突等价的。</p><p>​    冲突可串行化：如果一调度 S 与一串行调度是冲突等价 的，则称 S 是冲突可串行化的。</p><h5 id="判断调度是否可串行化的方法"><a href="#判断调度是否可串行化的方法" class="headerlink" title="判断调度是否可串行化的方法"></a>判断调度是否可串行化的方法</h5><p><img src="https://i.loli.net/2020/04/06/KOWfz9e1juAwros.png" alt="image-20200406101649482"></p><p><img src="https://i.loli.net/2020/04/06/4C2VSsKYmMUngI8.png" alt="image-20200406101753978"></p><p><img src="https://i.loli.net/2020/04/06/W5y9jOtbTdmeuCz.png" alt="image-20200406101814976"></p><p><img src="https://i.loli.net/2020/04/06/1uJ9kfFZqtl7VEz.png" alt="image-20200406101908368"></p><p>​    图 10-2(a) 中，对于 A 的并发访问：R1(A), W1(A), R2(A), W2(A)，存在 W1(A)后执行R2(A)，W1(A)后执行W2(A)。故 T1 -&gt; T2。优先图中无环可以串行化。</p><p>​    图 10-2(b) 中，对于 A 的并发访问：R2(A), W2(A), R1(A), W1(A) ，存在 W2(A)后执行R1(A)，W2(A)后执行W1A)。故 T2 -&gt; T1。优先图中无环可以串行化。</p><p>​    图10-8 中，对于 A 的并发访问：R4(A), W4(A), R6(A), W6(A)，存在 W4(A)后执行R6(A)，W4(A)后执行W6(A)。故 T4-&gt; T6。对于 B 的并发访问：R6(B), W6(B), R4(B), W4(B)，存在 W6(B)后执行R4(B)，W6(B)后执行W4(B)。故 T6-&gt; T4。优先图中有环，不可串行化。</p><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="基于封锁的协议"><a href="#基于封锁的协议" class="headerlink" title="基于封锁的协议"></a>基于封锁的协议</h4><p>​    并发控制机制大体上可分为悲观的和乐观的两种。悲观的并发控制方法认为数据库 的一致性经常会收到破坏，因此在事务访问数据对象前采取一定措施加以控制，只有得到访问许可时，才能访问数据对象，如<strong>基于封锁的并发控制方法</strong>。而乐观的并发控制方法则认为数据库的一致性通常不会得到破坏，故事务执行时可直接访问数据对象，只在事务结束时才验证数据库的一致性是否会遭到破坏，如基于有效性验证方法。</p><p>​    基于封锁的并发控制方法的基本思想是：当事务 <em>T</em> 需访问数据对象 <em>Q</em> 时，先申请对 <em>Q</em> 的锁。如批准获得，则 <em>T</em> 继续执行，且此后不允许其他任何事物修改 <em>Q</em>，直到事务 <em>T</em> 释放 <em>Q</em> 上的锁为止。</p><p>​    基本锁类型：</p><p>​    1）共享锁（Shared Lock，记为 S ）：如果事务 <em>T</em> 获得的对象 <em>Q</em> 上的共享锁，则 <em>T</em> 可读 <em>Q</em> 但不能写 <em>Q</em> 。</p><pre><code>2）排他锁（eXclusive lock，记为 X ）：如果事务 *T* 获得的对象 *Q* 上的排他锁，则 *T* 可读 *Q* 又能写 *Q* 。</code></pre><p>​    <strong>一个数据对象 <em>Q</em> 上可能有多个（被不同事务拥有的）共享锁，但任何时候只能有一个排他锁。</strong></p><p><img src="https://i.loli.net/2020/04/06/sNHdY7A2PhBy3ET.png" alt="image-20200406104004431"></p><p><img src="https://i.loli.net/2020/04/06/JX7bQ8va4hoMHNK.png" alt="image-20200406104529309"></p><p>​    图10-13 中的调度存在以下问题：</p><p>​    1）脏读。T2 步骤 11 读了 T1 修改后的数据，而T1 在步骤 12 回滚了。</p><p>​    2）不可重复读。如 T3 两次读到 A 的值不同。</p><p>​    3）不可串行化。</p><p>​    出现上述问题的原因是<strong>事务过早地释放了锁</strong>，如果规定事务在结束后才释放其持有地锁则可以保证调度的可串行性。但这会导致系统性能下降。</p><h4 id="两阶段封锁协议"><a href="#两阶段封锁协议" class="headerlink" title="两阶段封锁协议"></a>两阶段封锁协议</h4><p>​    两阶段封锁协议要求每个事务分两个阶段提出申请锁和解锁申请。</p><p>​    1）增长阶段：事务可以获得锁，但不能释放锁。</p><p>​    2）缩减阶段：事务可以释放锁，但不能获得新锁。</p><p>​    一开始，事务处于增长阶段，事务根据需要获得锁。一旦该事务释放了锁，它就进入了缩减阶段，不能再发出加锁请求。</p><p>​    两阶段封锁协议能保证冲突可串行化。对于任何事务，调度中该事务获得其最后加锁的时刻（增长阶段结束点）称为事务的封锁点。多个事务可以根据它们的封锁点进行排序，而这个顺序就是并发事务的一个冲突可串行化顺序。</p><p><img src="https://i.loli.net/2020/04/06/6OxDya25XE3bVAo.png" alt="image-20200406105546498"></p><p>​    图10-14 采用了两阶段封锁，允许 T4 在获得全部锁后（A 和 B 上的排他锁）提前释放部分锁（步骤 7 释放了 A 上的排他锁），T5得以提前执行，从而提高了 T4 和 T5 的并发度，该调度是可串行化 的。</p><p>​    两阶段封锁保证了并发执行事务的正确性，但仍存在两个主要问题：</p><p>​    1）可能导致死锁，即持有锁的事务出现相互等待都不能继续执行。解除死锁的一个简单方法是超时机制。如果一个事务为某个锁等待的时间过长，可以悲观得认为死锁已经发生，回滚该事务并重启。</p><p>​    2）不能避免读脏数据。</p><p>​    另一个两阶段封锁得变体是强两阶段封锁协议，它要求事务提交之前不得释放任何锁。事务可以按其提交得顺序串行化。</p><h3 id="恢复与备份"><a href="#恢复与备份" class="headerlink" title="恢复与备份"></a>恢复与备份</h3><h4 id="故障分类及恢复策略"><a href="#故障分类及恢复策略" class="headerlink" title="故障分类及恢复策略"></a>故障分类及恢复策略</h4><p>​    1）事务故障。事务未运行至正常终止点就夭折了。</p><p>​    2）系统故障。突发事件导致系统停止运行。</p><p>​    3）介质故障。硬件损坏。</p><p>​    4）其他故障。有人攻击。</p><h4 id="事务访问数据方式"><a href="#事务访问数据方式" class="headerlink" title="事务访问数据方式"></a>事务访问数据方式</h4><p>​    对于一个事务而言，它是通过 3 个地址空间同数据库进行交互：</p><p>​    1）保存数据库元素的磁盘块空间——物理数据库。</p><p>​    2）缓冲区管理器所管理的内存地址空间——数据缓冲区。</p><p>​    3）事务的局部地址空间——事务工作区。</p><p>​    当事务要读取数据库元素时，首先必须将该元素从物理数据库读取到数据缓冲区中，除非它已经在缓冲区中，然后再将缓冲区中的内容读到事务工作区中。</p><p><img src="https://i.loli.net/2020/04/06/GZAjXMbNu4z7apB.png" alt="image-20200406111338451"></p><p><img src="https://i.loli.net/2020/04/06/TcfswaB6NqoKzdp.png" alt="image-20200406111426865"></p><h4 id="基于日志的故障恢复策略"><a href="#基于日志的故障恢复策略" class="headerlink" title="基于日志的故障恢复策略"></a>基于日志的故障恢复策略</h4><p>​    日志是 DBMS 记录数据库全部更新操作的序列文件。通常一个数据库系统只有一个日志文件，为所有事务共享，其主要特点有：</p><p>​    1）日志文件记录了数据库的全部更新顺序。</p><p>​    2）每条日志都记录在日志的尾部，故日志文件是一个追加文件。</p><p>​    3）DBMS 允许事务的并发执行导致日志文件是“交错的”。</p><p>​    4）属于单个事务的日志顺序与该事务的更新操作顺序是一致的。</p><p>​    5）日志记录通常是先写到日志缓冲区中，然后写到稳定存储器中。</p><p>​    数据库中的日志记录有两种类型：</p><p>​    1）记录数据更新操作的日志记录，包括 update，insert 和 delete 操作。</p><p>​    2）记录事务操作的日志记录，包括start，commit 和 abort 操作。</p><p>​    它们的具体记录格式如下：</p><p>​    &lt; Ti, A, V1,V2 &gt; 表示 Ti 对数据元素 A 执行了更新操作，V1为 A 更新前的值，V2表示 A 更新后的值。</p><p>​    &lt; Ti, START &gt; 表示事务 Ti 已经开始。此时 DBMS 完成对事务的初始化工作，如分配事务工作区等。</p><p>​    &lt; Ti, COMMIT &gt; 表示事务 Ti 已经提交。</p><p>​    &lt; Ti, ABORT &gt; 表示事务已经终止，即事务执行失败。</p><p>​    为了保证数据库能运用日志进行恢复，要求日志文件必须放到稳定存储器上，并且要求每条日志记录必须在其所包含数据元素的更新值写到稳定存储器之前写到稳定存储器上，即<strong>先写日志</strong>规则。</p><h5 id="UNDO-操作"><a href="#UNDO-操作" class="headerlink" title="UNDO 操作"></a>UNDO 操作</h5><p>​    事务 T 执行过程中修改了数据库后，可能由于某种原因事务中止或系统崩溃，可使用 UNDO 恢复技术将 T 修改的全部数据对象值恢复到 T 开始前的状态。</p><p>​    对于要 UNDO 的事务 T ，日志中记录有 &lt;T, START&gt; 以及 T 对数据库的所有更新操作的日志记录。UNDO 过程为：从 T 的最后一条更新日志开始，从日志尾向日志头（反向）依次将 T 更新的数据元素恢复为旧值（V1）。</p><p>​    之所以需要 UNDO ，是因为故障发生时未提交事务的修改可能已写到磁盘上。</p><h5 id="REDO-操作"><a href="#REDO-操作" class="headerlink" title="REDO 操作"></a>REDO 操作</h5><p>​    REDO 操作时对已提交事务进行重做，将数据库状态恢复到事务结束后的状态。</p><p>​    对于要 REDO 的事务 T，日志中已经记录了 &lt;T, START&gt;  ，T 的所有更新操作日志以及 &lt;T, COMMIT&gt;。REDO 的过程为：从 T 的第一条更新日志记录来时，从日志头向日志尾（顺向）依次将 T 更新的数据元素值恢复为新值（V2）。</p><p>​    需要 REDO 的原因是，故障发生时可能有些已提交事务的更新数据还未写到磁盘上。</p><h5 id="并发执行事务的基本恢复过程"><a href="#并发执行事务的基本恢复过程" class="headerlink" title="并发执行事务的基本恢复过程"></a>并发执行事务的基本恢复过程</h5><p>​    1）分析阶段。从日志头开始顺向扫描日志，以确定重做事务集和撤销事务集。将既有  &lt;T, START&gt;又有 &lt;T, COMMIT&gt; 日志记录的事务 T 加入重做事务集。将只有  &lt;T, START&gt;没有 &lt;T, COMMIT&gt; 日志记录的事务 T 加入撤销事务集。</p><p>​    2）撤销阶段。从日志尾反向扫描日志，对每一条属于撤销事务集中的事务更新操作日志依次执行 UNDO 操作。</p><p>​    3）重做阶段。从日志头顺向扫描日志，对每一条属于重做事务集中的事务更新操作日志依次执行 REDO 操作。</p><h4 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h4><p>​    检查点是周期性地向日志中写一条检查点记录并记录所有当前活跃的事务，为恢复管理器提供信息，以决定从日志的何处开始恢复。在日志记录中使用 &lt; Checkpoint L &gt;来指定检查点 L 。</p><p>​    图10-19 是系统崩溃时的不同事务状态类型，其中 Tc 为完成最近检查点时刻，Tf 为故障发生时刻。 </p><p><img src="https://i.loli.net/2020/04/06/TgmJlz6Qevkprni.png" alt="image-20200406114406231"></p><h4 id="备份与介质故障恢复"><a href="#备份与介质故障恢复" class="headerlink" title="备份与介质故障恢复"></a>备份与介质故障恢复</h4><p>​    动态备份是指备份操作与用户事务的执行并发进行，备份期间允许对数据库进行存取或修改。静态备份则要等待用户事务结束然后备份。</p><p>​    具体进行数据备份时可以有两种方式，一种是全备份，一种是增量备份。</p><p>​    全备份是指每次备份全部数据库，而增量备份只备份上次备份后更新过的数据。</p>]]></content>
    
    <summary type="html">
    
      本文是复习数据库整理的资料
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>E-R 模型</title>
    <link href="http://yoursite.com/2020/04/05/E-R-%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/04/05/E-R-%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-04-05T14:23:02.000Z</published>
    <updated>2020-04-22T07:03:28.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库设计过程"><a href="#数据库设计过程" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h3><p>​    1）需求分析：了解和分析系统将要提供的功能及未来数据库的用户需求。</p><p>​    2）概念设计：根据需求分析中得到的信息，设计者此阶段须选择适当的数据模型将这些需求转化为数据库的概念模式。例如 <strong>E - R 模型</strong> 是概念设计。</p><p>​    3）逻辑设计：将概念设计转化为所选择的数据库管理系统支持的逻辑数据模型，即数据库模式。逻辑数据库设计的任务是将 E - R 模型转化为关系数据库模式。</p><p>​    4）模式求精：对已得到的关系数据库模式进行分析找出潜在的问题并加以改进和优化。</p><p>​    5）物理设计：为逻辑数据库选取一个最适合现实应用的物理结构。</p><p>​    6）应用与安全设计：数据库系统必须指出哪些用户可以访问数据库以及他们通过哪些存储过程访问数据库。</p><h3 id="E-R-模型基本概念及表示"><a href="#E-R-模型基本概念及表示" class="headerlink" title="E - R 模型基本概念及表示"></a>E - R 模型基本概念及表示</h3><h4 id="实体与实体集"><a href="#实体与实体集" class="headerlink" title="实体与实体集"></a>实体与实体集</h4><p>​    实体是客观世界中可区别于其他事物的“事物”或“对象”。</p><p>​    实体的两个特征：独立存在（一个实体的存在不依赖于其他实体）、可区别于其他实体。</p><p>​    实体集是指具有相同类型及相同性质（或属性）的实体集合。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>​    实体是通过一组属性来描述的，属性是实体集中每个实体都具有的描述性性质。在已实体集中，所有实体都具有相同的属性。</p><p>​    每个属性所允许的取值范围或集合称为该属性的<strong>域</strong>。</p><p>​    E - R 模型中的属性可按如下类型划分：</p><p>​    1）简单属性和复合属性。简单属性是指不能再分为更小部分的属性。复合属性指可以进一步划分为更小部分的属性。</p><p>​    2）单值属性和多值属性。如果某属性对一个特定实体任何时候都只能有单独的一个值，则称该属性为单值属性，否则为多值属性。例如一个studentNo 属性只对应一个学号，为单值属性。一个phoneNumber属性可能有不同数目的值，为多值属性。</p><p>​    3）空值（NULL）属性。当某个属性上没有值时可以使用 NULL 值。</p><p>​    4）派生属性，这类属性的值可以从其他属性的值派生出来。例如实体集 Student 的 age 属性表示学生的年龄，它可以由当前日期和生日属性的值计算得到。</p><p>​    在 E - R 图中，实体集用矩形表示，属性用椭圆表示，多值属性用双椭圆表示，派生属性用虚线椭圆表示，属性与实体之间用连线表示。</p><p><img src="https://i.loli.net/2020/04/05/2lqtAhLbzMSsjE4.png" alt="image-20200405101025891"></p><h4 id="联系与联系集"><a href="#联系与联系集" class="headerlink" title="联系与联系集"></a>联系与联系集</h4><p>​    联系集是 n （n &gt;= 2）个实体集上的数学关系，这些实体集不必互异。</p><p>​    参与联系的实体集的数目称为联系集的度。</p><p>​    下图中，Student 与 Course 之间有 Enroll 联系集，选课联系集上有 Score 属性。课程里面的 PriorCourse 属性参照 Course 关系。 </p><p><img src="https://i.loli.net/2020/04/05/kKAVRhcFCMYjawT.png" alt="image-20200405101234923"></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="映射约束"><a href="#映射约束" class="headerlink" title="映射约束"></a>映射约束</h4><p>​    映射基数指一实体集中的一个实体通过一个联系集能同时与另一个实体集相联系的实体数目。在二元联系中，共有 4 种映射基数：1：1（一对一）、1：m（一对多）、m：1（多对一）、m：n（多对多）。</p><p>​    在 E - R 图中，“—&gt;”指向参与联系集中“一”方实体集，线段“—”表示参与联系集中的“多”方实体集。</p><h4 id="码约束"><a href="#码约束" class="headerlink" title="码约束"></a>码约束</h4><h5 id="实体集的码"><a href="#实体集的码" class="headerlink" title="实体集的码"></a>实体集的码</h5><p>​    码是一个或多个属性的集合。</p><p>​    超码是一个或多个属性的集合，超码中的这些属性可以让我们在一个实体集中唯一地标识一个实体。</p><p>​    候选码是极小的超码集，也就是它的任意真子集都不是超码，而他本身是超码。</p><p>​    主码是被选中用来在一个关系中区分不同元组的候选码。</p><h5 id="联系集的码"><a href="#联系集的码" class="headerlink" title="联系集的码"></a>联系集的码</h5><p>​    二元联系集的主码选择依赖于联系集的映射基数，具体如下。</p><p>​    1）一对一：主码可以使用参与联系集中的任何一方实体集的主码；</p><p>​    2）一对多和多对一：主码由“多的一方实体集的主码组成；</p><p>​    3）多对多：主码由参与联系集中所有实体集的主码组成。</p><h4 id="参与约束"><a href="#参与约束" class="headerlink" title="参与约束"></a>参与约束</h4><p>​    如果实体集 A 中的每个实体都参与到联系集 R 中至少一个联系中，则称实体集 A 全部参与联系集 R。</p><h4 id="存在依赖与弱实体集"><a href="#存在依赖与弱实体集" class="headerlink" title="存在依赖与弱实体集"></a>存在依赖与弱实体集</h4><p>​    存在一类实体集，其属性不足以形成主码，它们必须依赖于其他实体集的存在而存在，称这样的实体集为<strong>弱实体集</strong>。与此相对，其属性可以形成主码的实体集称为<strong>强实体集</strong>。弱实体集所依赖的强实体集称为<strong>标识实体集</strong>。弱实体集必须与一个标识实体集相关联才有意义，该实体集称为<strong>标识实体集</strong>。</p><p>​    对于弱实体集，必须满足下列限制：</p><p>​    1）标识实体集和弱实体集必须是一对多联系集。</p><p>​    2）弱实体集在标识联系集中是全部参与。</p><p>​    E - R 图使用双矩形表示弱实体集，双菱形表示标识联系，用虚下划线表示弱实体集的部分码。下图描述了 CourseClass 及其标识实体集 Course 之间的标识联系集 Arrange 。注意标识联系集没有描述性属性，因为任何所需的属性都可和弱实体相关联。</p><p><img src="https://i.loli.net/2020/04/05/JW8oG15VvgYqley.png" alt="image-20200405103558371"></p><h3 id="E-R-模型转化为关系模型"><a href="#E-R-模型转化为关系模型" class="headerlink" title="E - R 模型转化为关系模型"></a>E - R 模型转化为关系模型</h3><h4 id="E-R-模型转化方法"><a href="#E-R-模型转化方法" class="headerlink" title="E - R 模型转化方法"></a>E - R 模型转化方法</h4><p>​    1）强实体集转化方法：将实体集的每个属性对应为关系模式的属性，实体集的码作为关系模式的码。</p><p>​    2）弱实体集转化方法：弱实体集对应的关系模式属性由弱实体集本身的描述属性加上所依赖的强实体集的主码属性组成。<strong>主码由所依赖的强实体集主码和弱实体集的部分码组成</strong>。</p><p>​    3）联系集转化方法    </p><p>​        联系集一般转化方法：一个联系集转化为一个关系模式。联系集的主码设置见“联系集的主码“。</p><p>​        一对多或多对一联系集的转化：在 ”多“ 方的实体集中添加 ”一“ 方的主码，使 ”一“ 方的主码成为 ”多“ 方 的外码。</p><p>​    4）复合属性及多值属性转化方法：对于复合属性，应为每个子属性创建一个单独的属性，而不是为复合属性自身创建的一个单独的属性。</p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><img src="https://i.loli.net/2020/04/14/Kfh8vNiTAQraPkX.png" alt="image-20200414081715392"></p><p>​    <img src="https://i.loli.net/2020/04/14/cdBWLxwvRQb9FnV.png" alt="image-20200414081741823"></p><p><img src="https://i.loli.net/2020/04/14/Ex5MTBGdXacLkyV.png" alt="image-20200414081901050"></p><p><img src="https://i.loli.net/2020/04/14/jGQMRbT2FCctdne.png" alt="image-20200414081801666"></p><p><img src="https://i.loli.net/2020/04/14/GPsadUnVFbQJm9l.png" alt="image-20200414081819570"></p><p><img src="https://i.loli.net/2020/04/14/eAio7uRHx3bcEQX.png" alt="image-20200414081934207"></p><p><img src="https://i.loli.net/2020/04/14/roiPmwSHdhaqDV4.png" alt="image-20200414101333649"></p><p><img src="https://i.loli.net/2020/04/14/a1hWbyZrOe6kMSC.png" alt="image-20200414101352852"></p><p><img src="https://i.loli.net/2020/04/14/IqghOSjkUmcQD7M.png" alt="image-20200414101445958"></p><p><img src="https://i.loli.net/2020/04/14/jJVGegbAKdwCi1S.png" alt="image-20200414101457645"></p>]]></content>
    
    <summary type="html">
    
      本文为复习数据库整理的资料。
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库完整性与安全性</title>
    <link href="http://yoursite.com/2020/04/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>http://yoursite.com/2020/04/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/</id>
    <published>2020-04-05T14:23:02.000Z</published>
    <updated>2020-04-20T03:45:00.025Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h3><h4 id="SQL-存取控制机制"><a href="#SQL-存取控制机制" class="headerlink" title="SQL 存取控制机制"></a>SQL 存取控制机制</h4><p>​    SQL 支持受控的存取保护，即在自主存取控制中，用户对于不同的数据对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户。因此自主存取控制非常灵活。</p><p>​    自主存取控制通过 SQL 的 grant 和 revoke 语句实现。</p><p>​    用户权限是由两个要素组成的：数据对象和操作对象。</p><p>​    用户的存取权限：该用户可以在哪些数据对象上进行哪些类型的操作。定义存取权限称为授权。</p><p>​    自主存取控制能够通过授权机制有效地控制其他用户对敏感数据的存取。</p><h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><p>​    创建用户语句 create user 的语法如下：</p><p><img src="https://i.loli.net/2020/04/05/PMcSmGxa3O7JzBb.png" alt="image-20200405154743908"></p><p>​    只有系统的超级用户才有权创建一个新的数据库用户。新创建的数据库用户有 3 种权限 connect、resource 和 dba。默认为 connect 权限，拥有 connect 权限的用户不能创建新用户、模式和基本表，只能登录数据库。然后由 dba 或其他用户给他转授权限。拥有 resource 权限的用户可以创建基本表和视图，并称为所创建对象的属主，但不能创建模式和新用户。数据库对象的属主可以使用 grant 语句把该对象上的存取权限授予其他用户。拥有 dba 权限的用户是系统中的超级用户，可以创建新用户、模式、基本表和视图等；dba 拥有所有数据库对象的存取权限，还可以将这些权限授予给一般用户。</p><h5 id="权限的授予与收回"><a href="#权限的授予与收回" class="headerlink" title="权限的授予与收回"></a>权限的授予与收回</h5><p>​    grant 和 revoke 有两种权限：目标权限和命令权限。</p><h6 id="命令权限的授予与收回"><a href="#命令权限的授予与收回" class="headerlink" title="命令权限的授予与收回"></a>命令权限的授予与收回</h6><p>​    命令级权限主要指 DDL 操作权限。命令权限的授予语句 grant 和 收回语句 revoke 的语法分别为：</p><p><img src="https://i.loli.net/2020/04/05/jWhtYLXsdeT6iAE.png" alt="image-20200405155559635"></p><p>​    其中 &lt; command_list &gt; 可以是 create database、create default、create function、create procedure、create rule、create table、create view、create index、backup database 和 backup log 等。</p><p>​    一次可以授予多种权限，授予多种权限时，权限之间用逗号分隔。</p><p>​    all：表示上述所有权限。</p><p>​    public：表示所有用户。</p><p>​    &lt; username_list &gt;：指定的用户名列表。如果将某组权限同时授予多个用户，则用户名之间用逗号分隔。</p><h6 id="目标权限的授予与收回"><a href="#目标权限的授予与收回" class="headerlink" title="目标权限的授予与收回"></a>目标权限的授予与收回</h6><p>​    目标权限主要指对对象的 DML 操作权限。对象权限的授予语句 grant 和收回语句 revoke 的语法分别为：</p><p><img src="https://i.loli.net/2020/04/05/iEl5Mm3Tw8tWVQ6.png" alt="image-20200405160348795"></p><p>​    其中 &lt; command_list &gt; 可以是 update、select、insert、delete、execute 和 all 。execute 针对存储过程授予执行权限，update、select、insert、delete 针对基本表和视图授权， all 指全部的权限。</p><p>​    cascade ：级联收回。</p><p>​    restrict：默认值，若转赋了权限，则不能收回。</p><p>​    with grant option：将指定对象上的目标权限授予其他安全账户的能力，但是不允许循环授权。即不允许将其得到的权限授予其祖先。</p><h3 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h3><h4 id="完整性约束条件"><a href="#完整性约束条件" class="headerlink" title="完整性约束条件"></a>完整性约束条件</h4><p>​    完整性约束条件作用的对象可以是关系、元组、列 3 种。列约束主要是列的类型、取值范围、精度、是否允许空值等的约束条件。元组约束是元组中属性间的联系的约束。关系约束是若干元组间、关系集合上以及关系之间的约束。</p><p>​    完整性约束条件涉及的这 3 类对象，其状态可以是静态的，也可以是动态的。</p><p>​    静态约束是指数据库每一确定状态时的数据对象所应满足的约束条件，它反映数据库状态合理性的约束，这是最重要的一类完整性约束。</p><p>​    静态约束主要表现在：</p><p>​    1）静态列级约束：对一个列的取值域的说明。对数据类型（类型，长度、单位、精度等）、数据格式、对取值范围或取值集合的约束、对空值的约束和其他约束。</p><p>​    2）静态元组约束：规定元组的各个列之间的约束关系。</p><p>​    3）静态关系约束：在一个关系的各个元组之间或若干关系之间存在各种联系或约束。常见的静态关系约束有：<strong>实体完整性约束、参照完整性约束和函数依赖约束</strong>。</p><p>​    </p><p>​    动态约束是指数据库从一种状态转变为另一种状态时的新、旧值之间所应满足的约束条件，它是反映数据库状态变迁的约束。</p><p>​    动态约束主要表现在：</p><p>​    1）动态列级约束。修改列定义或列值时应满足的约束条件。<strong>包括修改列定义时的约束</strong>（将允许空值的列修改为不允许空值，记录中有一列为空值，拒绝修改）<strong>修改列值时的约束</strong>（修改列值有时需要参照其旧值）。</p><p>​    2）动态元组约束：指需改元组的值时元组中各个字段间需要满足某种约束条件。</p><p>​    3）动态关系约束：动态关系约束是加在关系变化前后状态上的限制条件。例如，事物一致性、原子性等约束条件。</p><p>​    </p><p>​    完整性约束又可以分为立即执行的约束和延迟执行的约束。</p><p>​    立即执行约束：检查是否违背完整性约束的时机是在一条语句执行完后立即检查。</p><p>​    延迟执行约束：需要延迟到整个事务执行结束后再进行检查。</p><p>​    </p><h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>​    实体完整性要求基本表的主码值唯一且不允许为空值。primary key 指定</p><p>​    实体完整性的检查和违约处理：</p><p>​    1）检查主码是否唯一。如果不唯一则拒绝插入或修改。（索引或顺序查找）</p><p>​    2）检查主码的各个属性是否为空，只要有一个为空则拒绝插入或修改。</p><h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><p>​    参照完整性为若干个表中的相应元组建立联系。参照完整性定义是使用 create table 语句中的 foreign key 和 references 短语来实现，或通过 alter table 语句中的 add foreign key 来实现。</p><pre><code>参照完整性的检查和违约处理：</code></pre><p>​    1）拒绝执行。如果发生了违约，阻止操作。</p><p>​    2）级联操作。当删除或修改被参照关系的某个元组造成了与参照关系的不一致时，则删除或修改参照表中所有不一致的元组。级联操作必须在定义外码时给出定义（在外码定义最后追加 on delete/update cascade）。</p><p>​    3）设置为空值。如果外码可以为空，发生了违约则将外码置空。</p><p>​    4）置空值删除。删除被参照关系的元组，并将被参照关系中相应元组的外码置空值。</p><h4 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h4><h5 id="属性上的约束"><a href="#属性上的约束" class="headerlink" title="属性上的约束"></a>属性上的约束</h5><p>​    包括：列值非空、列值唯一、设置默认值和满足 check 定义。如果不满足则拒绝相应的操作。</p><p>​    以上约束分别通过 not null、unique、default+默认值、check 实现。</p><h5 id="元组上的约束"><a href="#元组上的约束" class="headerlink" title="元组上的约束"></a>元组上的约束</h5><p>​    元组上的约束可以设置不同属性之间的取值相互约束条件，也是用 check 实现。插入元组或修改属性的值时，RDBMS 检查元组上的约束条件是否满足，否则拒绝操作。</p><p><img src="https://i.loli.net/2020/04/05/fNQagDl4ZItoTWi.png" alt="image-20200405164250636"></p><p>​    第一个 check 为属性上的约束，放在属性定义后，第二个 check 为元组上的约束。    </p><h4 id="完整性约束的修改"><a href="#完整性约束的修改" class="headerlink" title="完整性约束的修改"></a>完整性约束的修改</h4><p>​    要修改约束必须先删除约束，然后加入新的约束。</p><p><img src="https://i.loli.net/2020/04/05/n9JVSWwL5aC14o8.png" alt="image-20200405164505007"></p><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>​    若要对 select 语句返回的结果值进行逐行处理，必须使用游标。可对游标的当前位置进行更新、查询和删除，使用游标必须经历 5 个步骤：</p><p>​    1）定义游标：declare；</p><p>​    2）打开游标：open；</p><p>​    3）逐行提取游标集中的行：fetch；</p><p>​    4）关闭游标：close；</p><p>​    5）释放游标：deallocate；</p><h4 id="游标的使用"><a href="#游标的使用" class="headerlink" title="游标的使用"></a>游标的使用</h4><h5 id="定义游标"><a href="#定义游标" class="headerlink" title="定义游标"></a>定义游标</h5><p><img src="https://i.loli.net/2020/04/05/vcoWwbID6UaBy2i.png" alt="image-20200405165033658"></p><p>​    read only 表示当前游标集中的元组仅可以查询，不可以修改。update表示可以对当前游标集中的元组进行更新操作，如果有 of &lt; columnName_list &gt;，表示仅可以对游标集中指定的属性列进行更新操作。</p><h5 id="打开游标"><a href="#打开游标" class="headerlink" title="打开游标"></a>打开游标</h5><p>​    系统按照游标的定义从数据库中将数据检索出来，放在内存的游标集中，并为游标集指定一个游标，该游标指向游标集中的第一个元组。</p><p>​    打开游标的语法：open &lt; cursorName &gt;</p><h5 id="获取当前游标值"><a href="#获取当前游标值" class="headerlink" title="获取当前游标值"></a>获取当前游标值</h5><p>​    要对当前游标所指向的元组进行操作，必须获取当前游标所指向的元组，其语法是</p><p>​    fetch &lt; cursorName &gt; into &lt; @variableName_list &gt;</p><p>​    <strong>获取当前游标的值，必须将当前游标所指向的元组的各个属性值分别用变量接收，其变量个数、数据类型必须与定义游标中的 select 子句所定义的属性（或表达式）个数数据类型相一致。</strong></p><p>​    SQL Server 中，变量名前面必须使用 @ 符号，使用一个 @ 符号位局部变量，使用两个 @ 为全局变量。</p><p>​    执行一次该语句，系统将当前游标所指向的元组属性放到变量中，然后游标自动下移一个元组。当游标移至尾部，则不可以再读取游标，必须关闭游标再重新打开游标。可以通过检查全局变量 @@FETCH_STATUS 来判断是否已经读完游标集中所有行。</p><p>​    @@FETCH_STATUS 的值有：</p><p>​    0 ：fetch 语句成功，表示已经从游标集中获取了元组值。</p><p>​    1：fetch 语句失败或此行不在结果集中。</p><p>​    2：被提取的行不存在。</p><h5 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h5><p>​    close  &lt; cursorName &gt;</p><h5 id="释放游标所占用的存储空间"><a href="#释放游标所占用的存储空间" class="headerlink" title="释放游标所占用的存储空间"></a>释放游标所占用的存储空间</h5><p>deallocate  &lt; cursorName &gt;</p><h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><p><img src="https://i.loli.net/2020/04/05/NUanJEF7lpHYyhA.png" alt="image-20200405195554371"></p><h4 id="对当前游标集的修改"><a href="#对当前游标集的修改" class="headerlink" title="对当前游标集的修改"></a>对当前游标集的修改</h4><p>​    可以对当前游标集中的元组执行删除和更新操作。</p><h5 id="删除游标集中的当前行"><a href="#删除游标集中的当前行" class="headerlink" title="删除游标集中的当前行"></a>删除游标集中的当前行</h5><p>​    delete from &lt; tableName &gt; where current of &lt; cursorName  &gt;</p><h5 id="更新游标集中的当前行"><a href="#更新游标集中的当前行" class="headerlink" title="更新游标集中的当前行"></a>更新游标集中的当前行</h5><p>​    update &lt; tableName &gt;</p><p>​    set &lt; columnName &gt;=&lt; expr &gt;[,&lt; columnName &gt;=&lt; expr &gt;…]</p><p>​    where current of &lt; cursorName &gt;</p><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>​    存储过程是为了完成特定功能汇集而成的一组命名了的 SQL 语句集合，该集合编译后存放在数据库中，可按实际情况重新编译。</p><p>​    使用存储过程的优点：将业务操作封装、便于事务管理、实现一定程度的安全性保护、特别适合统计和查询操作、减少网络通信量。</p><h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><p><img src="https://i.loli.net/2020/04/05/vXtEcyQObCRpxT6.png" alt="image-20200405200322658"></p><p>​    output：输出参数，被调用者获取使用。</p><h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><p>​    存储过程创建后存放在数据库中，当要使用存储过程时，必须执行命令 execute。</p><p><img src="https://i.loli.net/2020/04/05/GlUWZ8rtMVhSO5y.png" alt="image-20200405200618013"></p><h4 id="修改和删除存储过程"><a href="#修改和删除存储过程" class="headerlink" title="修改和删除存储过程"></a>修改和删除存储过程</h4><h5 id="修改存储过程"><a href="#修改存储过程" class="headerlink" title="修改存储过程"></a>修改存储过程</h5><p><img src="https://i.loli.net/2020/04/05/z1no7G8baR5Yp9t.png" alt="image-20200405200745811"></p><p><img src="https://i.loli.net/2020/04/05/s79bqRDMnWKrEvm.png" alt="image-20200405200755212"></p><h5 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h5><p>​    drop procedure &lt; procedureName &gt;</p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>​    触发器是用户定义在关系表上的一类由事件驱动的存储过程，由服务器自动激活。触发器可以进行更为复杂的检查和操作，具有更精细和强大的数据控制能力。</p><p>​    有两个特殊的表用在触发器语句中，不同的数据库其名称不一样。以SQL Server 为例介绍触发器。</p><p>​    1）deleted 表。存储 delete 和 update 语句执行时所影响的行的拷贝，在 delete 和 update 语句执行前被作用的行转移到 deleted 表中，即将被删除的元组或修改前的元组值存入该表中。</p><p>​    2）inserted 表。存储 insert 和 update 语句执行时所映像的行的拷贝，在 insert 和 update 语句执行期间，新行被同时加到 inserted 表和触发器中，即将被插入的元组或修改后的元组存入该表中，同时也更新基本表。</p><h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><p><img src="https://i.loli.net/2020/04/05/KzmCBDclWnp6hxR.png" alt="image-20200405201801494"></p><p>​    &lt;insert|update|delete&gt; ：触发器事件。</p><h4 id="修改和删除触发器"><a href="#修改和删除触发器" class="headerlink" title="修改和删除触发器"></a>修改和删除触发器</h4><p>​    修改触发器：</p><p><img src="https://i.loli.net/2020/04/05/rSV8gNdlaT6vQwx.png" alt="image-20200405202018722"></p><p>​    删除触发器：</p><p>​    drop trigger &lt; triggerName &gt;</p><h4 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h4><p>​    触发器常用于保证完整性，并在一定程度上实现安全性，如用触发器来进行审计。</p>]]></content>
    
    <summary type="html">
    
      复习数据库整理的资料
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>利用gradle添加依赖</title>
    <link href="http://yoursite.com/2020/04/04/Gradle%E4%BE%9D%E8%B5%96%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2020/04/04/Gradle%E4%BE%9D%E8%B5%96%E4%B8%8B%E8%BD%BD/</id>
    <published>2020-04-04T06:39:13.000Z</published>
    <updated>2020-04-04T10:14:40.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用gradle添加依赖"><a href="#利用gradle添加依赖" class="headerlink" title="利用gradle添加依赖"></a>利用gradle添加依赖</h1><p>1、新建一个gradle项目</p><p>可以看到build.gradle</p><p><img src="https://i.loli.net/2020/04/04/qxOINuGoR7pAsE2.png" alt="img"></p><p> 2、编写gradle.properties</p><p><img src="https://i.loli.net/2020/04/04/Bj2opT4nKwUvLyq.png" alt="img"></p><p> 3、修改build.gradle编译jar，利用${key} 来获取key的值</p><p><img src="https://i.loli.net/2020/04/04/AjhOQ9rK3IHnL8D.png" alt="img"></p><p> 4、等待gradle自动导入</p><p><img src="https://i.loli.net/2020/04/04/WKCFrN3MavV6ncg.png" alt="img"></p><p> 可以看到已经导入完成，开始玩耍。。。</p><p>如果遇到依赖下载慢的情况 在build.gradle文件repositories加入：           </p><p>maven{ url’<a href="http://maven.aliyun.com/nexus/content/groups/public/&#39;}" target="_blank" rel="noopener">http://maven.aliyun.com/nexus/content/groups/public/&#39;}</a></p><p>使用阿里云的maven仓库</p><p>mavenLocal()可以让项目先检查本地的仓库，有的话不用下载。</p>]]></content>
    
    <summary type="html">
    
      Gradle 构件工具
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Git上传本地项目</title>
    <link href="http://yoursite.com/2020/04/04/Git%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2020/04/04/Git%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-04-04T06:39:13.000Z</published>
    <updated>2020-04-04T10:17:09.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git上传本地项目"><a href="#Git上传本地项目" class="headerlink" title="Git上传本地项目"></a>Git上传本地项目</h1><p><strong>如何将本地项目push到GitHub上？</strong></p><p>GitHub新建一个 repostory 找到URL 例如：<a href="https://github.com/hoo334/test.git" target="_blank" rel="noopener">https://github.com/hoo334/test.git</a></p><p>找到项目文件夹 右键git bash here</p><p><strong>git init</strong></p><p>*<em>git add . *</em></p><p><strong>git commit -m “提交信息”</strong></p><p><strong>git remote add origin URL</strong></p><p><strong>git push -u origin master</strong></p><p><strong>提交更新到Github</strong></p><p><strong>git status （可选 查看更改文件）</strong></p><p><strong>git add 你想要提交更改的文件 或者git add .</strong></p><p><strong>git commit -m “提交信息”</strong></p><p><strong>git push  origin master</strong></p><p><strong>如果操作失误就直接删掉目录内的.git整个文件夹 重新git init。</strong></p>]]></content>
    
    <summary type="html">
    
      Git
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>JVM 运行时数据区</title>
    <link href="http://yoursite.com/2020/04/04/JVM%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <id>http://yoursite.com/2020/04/04/JVM%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</id>
    <published>2020-04-04T06:39:13.000Z</published>
    <updated>2020-04-04T10:20:58.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h1><p><img src="https://i.loli.net/2020/03/24/ML2CpVz6XdqoJkl.png" alt=""></p><p> <img src="https://i.loli.net/2020/03/24/VfYt7yh4pav9ure.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      JVM学习
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL语言</title>
    <link href="http://yoursite.com/2020/04/04/SQL%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2020/04/04/SQL%E8%AF%AD%E8%A8%80/</id>
    <published>2020-04-04T06:39:13.000Z</published>
    <updated>2020-04-21T14:27:10.227Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL-概述"><a href="#SQL-概述" class="headerlink" title="SQL 概述"></a>SQL 概述</h3><p>　　SQL 语言由 4 部分组成，包括数据定义语言 DDL、数据操纵语言 DML、数据控制语言和其他。</p><p>　　1）数据定义语言（Data Definition Language，DDL）：主要用于定义数据库的逻辑结构，包括数据库，基本表，视图和索引等，扩展 DDL 还支持存储过程、函数、对象、触发器等的定义。DDL 包括 3 类语言，即定义、修改和删除。</p><p>　　2）数据操纵语言（Data Manipulation Language，DML）：主要用于对数据库的数据进行检索和更新，其中更新操作包括插入、删除和修改数据。</p><p>　　3）数据控制语言（Data Control Language，DCL）：主要用于对数据库的对象进行授权、用户维护（包括创建、修改和删除）、完整性规则定义和事务定义等。</p><p>　　4）其他：主要是嵌入式 SQL 语言和动态 SQL 语言的定义。</p><p>　　</p><p>　　SQL特点：风格统一。高度非过程化。面向集合的操作方式。同一种语法结构提供两种使用方式（独立使用SQL对数据库进行操作，嵌入到高级语言中）。语言简洁，易学易用。</p><p>　　SQL主要动词：</p><p>　　1）数据查询：select；</p><p>　　2）数据定义：create、alter、drop；</p><p>　　3）数据操纵：insert、update、delete；</p><p>　　4）数据控制：grant、revoke；</p><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><p>　　where 子句可以实现关系代数中的选择运算，用于查询满足选择条件的元组。where 子句中常用的查询条件如下所示：</p><p><img src="https://i.loli.net/2020/04/04/5NmKQzuGXSE8p3H.png" alt="img"></p><p> 　% 表示任意长度的字符串，_表示任意一个字符， escape ‘ \ ‘ 表示 \ 后的符号不是通配符。</p><p><img src="https://i.loli.net/2020/04/04/bJOVFf4XQM53hxK.png" alt="img"></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>　　外连接：</p><p>　　1）左外连接</p><p>　　　　select xxx </p><p>　　　　from 表a <strong>left outer join</strong> 表b <strong>on</strong> a.xx=b.xx</p><p>　　2）右外连接</p><p>　　　　select xxx </p><p>　　　　from 表a <strong>right outer join</strong> 表b <strong>on</strong> a.xx=b.xx</p><p> 　3）全外连接</p><p>　　　　select xxx </p><p>　　　　from 表a <strong>full outer join</strong> 表b <strong>on</strong> a.xx=b.xx</p><h3 id="嵌套子查询"><a href="#嵌套子查询" class="headerlink" title="嵌套子查询"></a>嵌套子查询</h3><h4 id="使用-in-的子查询"><a href="#使用-in-的子查询" class="headerlink" title="使用 in 的子查询"></a>使用 in 的子查询</h4><p><img src="https://i.loli.net/2020/04/04/Ut6bKM5lAWsTPiL.png" alt="img"></p><p> <img src="https://i.loli.net/2020/04/04/Hm7MZoWqi2VEt9F.png" alt="img"></p><p><img src="https://i.loli.net/2020/04/04/BhbMpFjTZxcPXUn.png" alt="img"></p><p> <img src="https://i.loli.net/2020/04/04/Sq2ceb7Lfpahj8E.png" alt="img"></p><h4 id="使用比较运算符的子查询"><a href="#使用比较运算符的子查询" class="headerlink" title="使用比较运算符的子查询"></a>使用比较运算符的子查询</h4><p><img src="https://i.loli.net/2020/04/04/vt87Oam4YzwJxES.png" alt="img"></p><p><img src="https://i.loli.net/2020/04/04/OdEwbPAcBqGKonx.png" alt="img"></p><h4 id="使用存在量词-exists-的子查询"><a href="#使用存在量词-exists-的子查询" class="headerlink" title="使用存在量词 exists 的子查询"></a>使用存在量词 exists 的子查询</h4><p>　　SQL 查询提供量词运算。量词有两种：一是存在量词，二是全程量词。全程量词可以用存在量词替代，故 SQL 语句仅提供存在量词的运算，使用谓词 exists 表示，全称量词转化通过 not exists 谓词来实现。</p><p><img src="https://i.loli.net/2020/04/04/hM1PlF8UboEXQqe.png" alt="img"></p><p><img src="https://i.loli.net/2020/04/04/KN9bScEkCjZJhMf.png" alt="img"></p><p><img src="https://i.loli.net/2020/04/04/XEBS7msaRO3tfek.png" alt="img"></p><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p><img src="https://i.loli.net/2020/04/04/bLqFIkXJCKAzrGa.png" alt="img"></p><p> 　如果指定 distinct 谓词，表示在计算时首先消除&lt;列名&gt;取重复值的元组，然后再进行统计。</p><h4 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h4><p>　　在 SQL 查询中，往往需要对数据进行分组运算，分组运算的目的是为了细化聚合函数的作用对象。如果不对查询结果进行分组，则聚合函数作用于整个查询结果；如果对查询结果进行分组，则聚合函数分别作用于每个组，查询结果是按组聚合输出。SQL 语句中通过 group by 和having 子句来实现分组运算，其中：</p><p>　　group by 子句对查询结果按某一列或某几列进行分组，值相等的分为一组；</p><p>　　having 子句对分组的结果进行选择，仅输出满足条件的组。该子句必须与group by 子句配合使用。</p><p><img src="https://i.loli.net/2020/04/04/mWZfg9ps8JA73nF.png" alt="img"></p><p> 　聚合函数可以直接使用在 having 子句中，也可以用于子查询中，但<strong>在 where 子句中不可以直接使用聚合函数。</strong></p><h4 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h4><p><img src="https://i.loli.net/2020/04/04/h7m4821v9RjIJGN.png" alt="img"></p><p><img src="https://i.loli.net/2020/04/04/heOE2QcbPfitLYI.png" alt="img"></p><p> 或者</p><p>　　select studentNo, avg(score) as avgScore</p><p>　　from score </p><p>　　group by studentNo</p><p>　　having count(*) &gt;5</p><p>　　order by avgScore</p><p>　　limit 0,1</p><p><img src="https://i.loli.net/2020/04/04/NRbIMlTqom1LdJS.png" alt="img"></p><p><img src="https://i.loli.net/2020/04/04/kT2RU6ud3DBzLAf.png" alt="img"></p><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p>　　SQL 支持集合运算。select 语句查询的结果是集合，多个 select 语句的结果可以进行集合操作，传统的集合操作主要包括并 union、交 intersect、差 except 运算，<strong>在执行集合运算时要求参与运算的查询结果的列数一样，其对应列的数据类型必须一致。</strong></p><p><img src="https://i.loli.net/2020/04/04/QvEbtCTGPunSkRr.png" alt="img"></p><h3 id="SQL-查询一般格式"><a href="#SQL-查询一般格式" class="headerlink" title="SQL 查询一般格式"></a>SQL 查询一般格式</h3><p><img src="https://i.loli.net/2020/04/04/d5JLQ4SFejksW8t.png" alt="img"></p><h3 id="SQL-数据定义语言"><a href="#SQL-数据定义语言" class="headerlink" title="SQL 数据定义语言"></a>SQL 数据定义语言</h3><p>　　数据库中的关系集合必须由数据定义语言 DDL 来定义，包括：数据库模式、关系模式、每个属性的值域、完整性约束、每个关系的索引集合和关系的物理存储结构等。</p><p><img src="https://i.loli.net/2020/04/04/IADEaU95sFGYO8Q.png" alt="img"></p><h4 id="数据库的定义"><a href="#数据库的定义" class="headerlink" title="数据库的定义"></a>数据库的定义</h4><h5 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h5><p><img src="https://i.loli.net/2020/04/04/oZAH7Sla91zNXuF.png" alt="img"></p><h5 id="数据库的删除"><a href="#数据库的删除" class="headerlink" title="数据库的删除"></a>数据库的删除</h5><p><img src="https://i.loli.net/2020/04/04/QXKwkRidjT6Aq4L.png" alt="img"></p><h4 id="基本表的定义"><a href="#基本表的定义" class="headerlink" title="基本表的定义"></a>基本表的定义</h4><h5 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h5><p><img src="https://i.loli.net/2020/04/04/6rCEphyxYKgv3bi.png" alt="img"></p><p><img src="https://i.loli.net/2020/04/04/BNoTkclZdWVqS3L.png" alt="img"></p><p> <img src="https://i.loli.net/2020/04/04/ntiAphIVuWEmoXP.png" alt="img"></p><h5 id="基本表的修改"><a href="#基本表的修改" class="headerlink" title="基本表的修改"></a>基本表的修改</h5><p><img src="https://i.loli.net/2020/04/04/A9nHdB8csqLz6p5.png" alt="img"></p><p>　　 基本表在修改过程中，不可以删除列，一次仅执行一种操作。</p><h5 id="基本表的删除"><a href="#基本表的删除" class="headerlink" title="基本表的删除"></a>基本表的删除</h5><p>　　<img src="https://i.loli.net/2020/04/04/ZO6B1CmIU9dGKEe.png" alt="img"></p><p> 　若选择 restrict ，则该表的删除有限制条件，即该表不能有视图，触发器以及被他表所引用，该项为默认项。</p><p>　　若选择 cascade， 则该表的删除没有限制条件，在删除基本表的同时，也删除建立在该表上的所有索引，完整性规则，触发器和视图。</p><h4 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h4><p>　　如果数据有序，则检索速度是非常快的，对表中的记录进行排序有两种方案：一是对记录进行物理上的重新组织。二是不改变物理顺序，通过建立索引来实现数据记录的重新排列，称为逻辑排序。</p><p>　　一张表可以建立多个索引，可以从不同的角度加快查询速度，如果索引建立的比较多，会给数据维护带来较大的系统开销。</p><p>　　索引通常是由指针构成的记录，指针逻辑上按照索引关键字进行排序，但不改变表中记录的物理顺序。索引和基本表分别存储。</p><p>　　如果索引文件中的记录按照某个搜索码值指定的顺序物理存储，那么该搜索码对应的索引就称为<strong>主索引</strong>，也叫<strong>聚集索引</strong>。搜索码值顺序与索引文件中记录的物理顺序不同的那些索引称为<strong>辅助索引</strong>或<strong>非聚集索引</strong>。</p><h5 id="索引的建立"><a href="#索引的建立" class="headerlink" title="索引的建立"></a>索引的建立</h5><p><img src="https://i.loli.net/2020/04/04/B3SlMcuEm9wDe4s.png" alt="img"></p><h5 id="索引的删除"><a href="#索引的删除" class="headerlink" title="索引的删除"></a>索引的删除</h5><p>　　索引一旦建立，用户就不需要管理它，由系统自动维护。如果某个关系经常要执行插入、删除和修改操作，系统会花费很多时间来维护索引，从而降低基本表的更新速度，因此可删除那些不经常使用的索引。删除索引的语法为：</p><p><img src="https://i.loli.net/2020/04/04/OUpFAjhemWIoxsi.png" alt="img"></p><h3 id="SQL-数据更新语言"><a href="#SQL-数据更新语言" class="headerlink" title="SQL 数据更新语言"></a>SQL 数据更新语言</h3><p>　　SQL 数据更新语句包括 3 条：插入 insert、删除 delete、修改 update。</p><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="　　插入数据"></a>　　插入数据</h4><h5 id="插入一条元组"><a href="#插入一条元组" class="headerlink" title="插入一条元组"></a>插入一条元组</h5><p><img src="https://i.loli.net/2020/04/04/6vrnQYmcUW9O31k.png" alt="img"></p><h5 id="插入多条元组"><a href="#插入多条元组" class="headerlink" title="插入多条元组"></a>插入多条元组</h5><p><img src="https://i.loli.net/2020/04/04/HfeLn6dDRWCwyAZ.png" alt="img"></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="　删除数据"></a>　删除数据</h4><p>　　<img src="https://i.loli.net/2020/04/04/9yTpORSIfmKBXYj.png" alt="img"></p><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="　　修改数据"></a>　　修改数据</h4><p><img src="https://i.loli.net/2020/04/04/5mzi2Dy9jEgW3t4.png" alt="img"></p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>　　视图是虚表，是从一个或几个基本表（或视图）中导出的表，在系统的数据字典中仅存放了视图的定义，不存放视图对应的数据。</p><h4 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h4><p><img src="https://i.loli.net/2020/04/04/R9MgBo7XGwK2Y8a.png" alt="img"></p><p> 　with check option ：当对视图进行插入、删除和更新操作时必须满足视图定义的谓词条件。</p><p><img src="https://i.loli.net/2020/04/04/eETgZ48mJ17ASh3.png" alt="img"></p><h4 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h4><p>　　查询是对视图进行的最主要的操作。从用户的角度来看，查询视图与查询基本表的方式是完全一样的。</p><h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p>　　更新视图指通过视图来插入、删除和修改基本表中的数据。由于视图是一个虚表，不实际存放数据，对视图的更新最终要转换为对基本表的更新，因此，如果视图的定义中包含了表达式，或聚合运算，或消除重复值运算，则不能对视图进行更新操作。</p><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p><img src="https://i.loli.net/2020/04/04/FiN2qdoAf8LMkCu.png" alt="img"></p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><img src="https://i.loli.net/2020/04/04/VeDnJizjmpqPsXB.png" alt="img"></p><p> 　1）查询在2005-2008 年之间没有归还图书的读者编号、读者姓名、读者工作单位、图书编号、图书名称和借书日期。</p><p>　　分析：将读者、借阅、书籍三个关系连接起来然后判断书籍是否应该在 2005~2008年之间归还且书籍归还日期为空。</p><p>　　select rd.readerNo, rd.readerName, rd.workUnit, bk.bookNo, bk.bookName, br.borrowDate</p><p>　　from Reader rd, Borrow br, Book bk</p><p>　　where rd.readerNo=br.readerNo and br.bookNo=bk.bookNo and year(shouldDate) between 2005 and 2008 and br.returnDate is null</p><p>　　2)查询没有借书的读者姓名（分别用 in 子查询和存在量词子查询表达）。</p><p>　　分析：首先在借阅表中找出所有借过书还没有归还的读者号，然后判断每一个读者的读者号是否在前面找出的读者号里面，不在则代表没有借书。</p><p>　　select readerName</p><p>　　from Reader</p><p>　　where readerNo not in(</p><p>　　select distinct readerNo</p><p>　　from Borrow</p><p>　　where returnDate is null ); </p><p>　　select readerName</p><p>　　from Reader</p><p>　　where not exists (</p><p>　　select *</p><p>　　from Borrow</p><p>　　where Reader.readerNo=Borrow.readerNo and returnDate is null );</p><p>　　3)查询既借阅了“离散数学”又借阅了“数据库系统概念”两本书的读者编号、读者姓名、借书日期和图书名称。</p><p>　　分析：先找出借阅了离散数学的读者编号，再去看该读者是否借阅了数据库系统概念。</p><p>　　select rd.readerNo, rd.readerName, br.borrowDate, bk.bookName</p><p>　　from Reader rd, Borrow br, Book bk</p><p>　　where rd.readerNo=br.readerNo and br.bookNo=bk.bookNo and bookName=’离散数学’</p><p>　　and exists (</p><p>　　select * </p><p>　　from Borrow, Book</p><p>　　where Borrow.bookNo=Book.bookNo and rd.readerNo=Borrow.readerNo and Book.bookName=’数据库系统概念’ );</p><p>　　4）查询没有借阅’“经济管理”类图书的读者编号、读者姓名和出生日期（分别用 in 子查询和存在量词子查询表达）。</p><p>　　分析：先找出借阅了经济管理类书籍的读者号，然后判断每一个读者编号是否在前面找到的读者号中。</p><p>　　select readerNo, readerName, substring(identitycard,7,8) as birthday</p><p>　　from Reader</p><p>　　where readerNo not in (</p><p>　　select readerNo</p><p>　　from Borrow</p><p>　　where bookNo in(</p><p>　　select bookNo</p><p>　　from Book</p><p>　　where classNo in(</p><p>　　select classNo</p><p>　　from BookClass</p><p>　　where className=’经济管理’ )));</p><p>　　</p><p>　　</p><p>　　select readerNo, readerName, reader, substring(identitycard,7,8) as birthday</p><p>　　from Reader</p><p>　　where not exists(</p><p>　　select *</p><p>　　from Borrow br, Book bk, BookClass bc</p><p>　　where br.bookNo=bk.bookNo and bk.classNo=bc.classNo and bc,className=’经济管理’ and br.readerNo = Reader.readerNo);</p><p>　　</p><p>　　5)查询至少借阅了“马永强”所借的所有图书的读者编号、读者姓名、和工作单位。</p><p>　　分析：马永强所借的书他都借过 即 没有马永强借的书是他没有借的</p><p>　　select readerNo, readerName, workUnit</p><p>　　from Reader r1        //遍历每一位读者</p><p>　　where r1.readerNo not in(</p><p>　　select readerNo</p><p>　　from Borrow b1    //读者借书</p><p>　　where not exists(</p><p>　　select *</p><p>　　from Reader r2</p><p>　　where r2.readerName=’马永强’ and not exists(</p><p>　　select *</p><p>　　from Borrow b2      //马永强借书</p><p>　　where r2.readerNo=b2.readerNo and b1.bookNo=b2.bookNo and b2.returnDate is null)));</p>]]></content>
    
    <summary type="html">
    
      本文为复习数据库整理的资料。
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 深拷贝和浅拷贝</title>
    <link href="http://yoursite.com/2020/04/04/Java%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/04/04/Java%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-04-04T06:39:13.000Z</published>
    <updated>2020-04-04T10:21:55.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-深拷贝和浅拷贝"><a href="#Java-深拷贝和浅拷贝" class="headerlink" title="Java 深拷贝和浅拷贝"></a>Java 深拷贝和浅拷贝</h1><p>　　在浅拷贝中，如果原型对象的成员变量是基本类型时，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</p><p>　　对应的深拷贝，如果时成员变量为引用对象也复制一份给复制对象。</p><p>　　</p><p><strong>实现</strong></p><p>　　<strong>1、新建一个 Person 和 PersonId 类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> PersonId personId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.personId = <span class="keyword">new</span> PersonId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        personId.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person cloned = (Person)<span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", personId="</span> + personId +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonId</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PersonId&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<strong>2、使用 CloneDemo 类来测试浅拷贝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>,<span class="number">20</span>,<span class="number">123</span>);</span><br><span class="line">        Person cloned = person.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"original: "</span>+person);</span><br><span class="line">        System.out.println(<span class="string">"cloned: "</span>+cloned);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Modify Age and Id: "</span>);</span><br><span class="line">        cloned.setAge(<span class="number">55</span>);</span><br><span class="line">        cloned.setId(<span class="number">234</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"original: "</span>+person);</span><br><span class="line">        System.out.println(<span class="string">"cloned: "</span>+cloned);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<strong>3、输出</strong></p><p><img src="https://i.loli.net/2020/04/04/rXmNxfSUGDFlCnW.png" alt="img"></p><p> 　可以看到我们修改了拷贝对象的年龄和ID，原始对象的年龄还是20，原始对象的ID却变成了我们修改后的值，我们并没有对原始对象的ID进行修改，这里说明浅拷贝对于对象仅仅是拷贝了一个对象的引用而已。</p><p>　　<strong>4、接下来我们修改 Person 类的 clone() 方法，实现深拷贝。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Person cloned = (Person)<span class="keyword">super</span>.clone();</span><br><span class="line">    cloned.personId = personId.clone();</span><br><span class="line">    <span class="keyword">return</span> cloned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<strong>5、为了拷贝PersonId 的对象我们需要PersonId 类实现 Cloneable 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonId</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PersonId&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonId <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (PersonId)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<strong>6、再次运行 CloneDemo 输出</strong></p><p><img src="https://i.loli.net/2020/04/04/3jUA4G2YcBlKQCq.png" alt="img"></p><p> 　可以看到 原始对象的ID 值没有被修改。</p><p>　　<strong>7、使用序列化实现深拷贝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> PersonId personId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.personId = <span class="keyword">new</span> PersonId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        personId.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">try</span>(ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(bout)) &#123;</span><br><span class="line">                out.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>(InputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray()))&#123;</span><br><span class="line">                ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">                <span class="keyword">return</span> (Person)in.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            CloneNotSupportedException e2 = <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">            e2.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> e2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", personId="</span> + personId +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonId</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PersonId&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonId <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (PersonId)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　所有写入流的对象都要实现 Serializable 接口。将 Person 对象写入流中然后再从流中读取出来实现深拷贝。</p><p>　　 输出：</p><p><img src="https://i.loli.net/2020/04/04/q4buBy96jFGdP73.png" alt="img"></p><p><strong>总结</strong></p><p>　　<strong>若要实现深拷贝，如果对象中引用了其他对象，必须将引用的对象也克隆。</strong></p><p>　　</p>]]></content>
    
    <summary type="html">
    
      Java 学习
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring+JDBC征服数据库</title>
    <link href="http://yoursite.com/2020/04/04/Spring+JDBC%E5%BE%81%E6%9C%8D%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2020/04/04/Spring+JDBC%E5%BE%81%E6%9C%8D%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2020-04-04T06:39:13.000Z</published>
    <updated>2020-04-04T10:47:08.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-JDBC征服数据库"><a href="#Spring-JDBC征服数据库" class="headerlink" title="Spring+JDBC征服数据库"></a>Spring+JDBC征服数据库</h1><p>Spring将数据访问过程中固定的和可变的部分明确划分为两个不同的类，<strong>模板(template)</strong>和<strong>回调(callback)</strong>。模板管理过程中固定的部分，回调处理自定义的数据访问代码。</p><p>Spring的模板类处理数据访问的固定部分–事务控制、管理资源以及处理异常。同时，应用程序相关的数据访问–语句、绑定参数以及整理结果集在回调的实现中处理。</p><p>以Spittr这个应用来演示JDBC。</p><p>我们先定义Spitter和Spittle两个实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.domain;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String fullname;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> updateByEmail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spitter</span><span class="params">(Long id, String username, String password, String fullname, String email, <span class="keyword">boolean</span> updateByEmail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.fullname = fullname;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">        <span class="keyword">this</span>.updateByEmail = updateByEmail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFullname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fullname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUpdateByEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> updateByEmail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spittle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Spitter spitter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date postedDate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spittle</span><span class="params">(Long id, Spitter spitter, String message, Date postedDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.spitter = spitter;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.postedDate = postedDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">getSpitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spitter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getPostedDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> postedDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义SpittleRepository、SpitterRepository两个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spitter <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spitter <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Spitter&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的JDBC框架承担了资源管理和异常处理的工作，从而简化了JDBC代码，让我们只需编写从数据库读写数据的必要代码。</p><p>Spring为JDBC提供了三个模板供选择：</p><p>JdbcTemplate:最基本的Spring JDBC 模板，支持简单的JDBC数据库访问功能以及基于索引参数的查询。</p><p>NamedParameterJdbcTemplate：使用该模板类进行查询时可以将值以命名参数的形式绑定到SQL中，而不是简单的使用索引参数。</p><p>对于大多数JDBC任务来说，JdbcTemplate就是最好的方案。</p><p>我们定义JdbcSpitterRepository实现SpitterRepository接口，定义JdbcSpittleRepository实现SpittleRepository接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jdbc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.simple.SimpleJdbcInsert;</span><br><span class="line"><span class="keyword">import</span> spittr.db.SpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcSpitterRepository</span> <span class="keyword">implements</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSERT_SPITTER = <span class="string">"insert into Spitter(username,password,fullname,email,updateByEmail) values(?,?,?,?,?) "</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_SPITTER = <span class="string">"select id,username,password,fullname,email,updateByEmail from Spitter "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcSpitterRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span> </span>&#123;</span><br><span class="line">        Long id = spitter.getId();</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> spitterId = insertSpitterAndReturnId(spitter);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Spitter(spitterId,spitter.getUsername(),spitter.getPassword(),spitter.getFullname(),spitter.getEmail(),spitter.isUpdateByEmail());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">         jdbcTemplate.update(<span class="string">"update Spitter set username=?, password=?, fullname=?, email=?, updateByEmail=? where id =? "</span>,</span><br><span class="line">                 spitter.getUsername(),</span><br><span class="line">                 spitter.getPassword(),</span><br><span class="line">                 spitter.getFullname(),</span><br><span class="line">                 spitter.getEmail(),</span><br><span class="line">                 spitter.isUpdateByEmail(),</span><br><span class="line">                 id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> spitter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">insertSpitterAndReturnId</span><span class="params">(Spitter spitter)</span></span>&#123;</span><br><span class="line">        SimpleJdbcInsert jdbcInsert = <span class="keyword">new</span> SimpleJdbcInsert(jdbcTemplate).withTableName(<span class="string">"Spitter"</span>);</span><br><span class="line">        jdbcInsert.setGeneratedKeyName(<span class="string">"id"</span>);</span><br><span class="line">        Map&lt;String, Object&gt;args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">"username"</span>,spitter.getUsername());</span><br><span class="line">        args.put(<span class="string">"password"</span>,spitter.getPassword());</span><br><span class="line">        args.put(<span class="string">"fullname"</span>,spitter.getFullname());</span><br><span class="line">        args.put(<span class="string">"email"</span>,spitter.getEmail());</span><br><span class="line">        args.put(<span class="string">"updateByEmail"</span>,spitter.isUpdateByEmail());</span><br><span class="line">        <span class="keyword">long</span> spitterId = jdbcInsert.executeAndReturnKey(args).longValue();</span><br><span class="line">        <span class="keyword">return</span> spitterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSpitter</span><span class="params">(Spitter spitter)</span></span>&#123;</span><br><span class="line">        jdbcTemplate.update(INSERT_SPITTER,</span><br><span class="line">                spitter.getUsername(),</span><br><span class="line">                spitter.getPassword(),</span><br><span class="line">                spitter.getFullname(),</span><br><span class="line">                spitter.getEmail(),</span><br><span class="line">                spitter.isUpdateByEmail());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(SELECT_SPITTER+<span class="string">"where id = ?"</span>,<span class="keyword">new</span> SpitterRowMapper(),id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spitter&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(SELECT_SPITTER+<span class="string">"order by id"</span>,<span class="keyword">new</span> SpitterRowMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForLong(<span class="string">"select count(id) from spitter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(SELECT_SPITTER+<span class="string">"where username = ?"</span>,<span class="keyword">new</span> SpitterRowMapper(),username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpitterRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Spitter</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spitter <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Spitter(rs.getLong(<span class="string">"id"</span>),rs.getString(<span class="string">"username"</span>),rs.getString(<span class="string">"password"</span>),</span><br><span class="line">                    rs.getString(<span class="string">"fullname"</span>),rs.getString(<span class="string">"email"</span>),rs.getBoolean(<span class="string">"updateByEmail"</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.simple.SimpleJdbcInsert;</span><br><span class="line"><span class="keyword">import</span> spittr.db.SpittleRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcSpittleRepository</span> <span class="keyword">implements</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_SPITTLE = <span class="string">"select sp.id, s.id as spitterId, s.username, s.password, s.fullname, s.email, s.updateByEmail, sp.message, sp.postedTime from Spitter s, Spittle sp where s.id = sp.spitter"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_SPITTLE_BY_ID = SELECT_SPITTLE+<span class="string">" and sp.id=?"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_SPITTLE_BY_SPITTER_ID = SELECT_SPITTLE+<span class="string">" and s.id=? order by sp.postedTime desc"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_RECENT_SPITTLES = SELECT_SPITTLE+<span class="string">" order by sp.postedTime desc limit ?"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcSpittleRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForLong(<span class="string">"select count(id) from Spittle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> jdbcTemplate.queryForObject(SELECT_SPITTLE_BY_ID,<span class="keyword">new</span> SpittleRowMapper(),id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> spittleId = insertSpittleAndReturnId(spittle);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Spittle(spittleId,spittle.getSpitter(),spittle.getMessage(),spittle.getPostedDate());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(SELECT_SPITTLE_BY_SPITTER_ID,<span class="keyword">new</span> SpittleRowMapper(),id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findRecent(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(SELECT_RECENT_SPITTLES,<span class="keyword">new</span> SpittleRowMapper(),count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"delete from Spittle where id = ?"</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">insertSpittleAndReturnId</span><span class="params">(Spittle spittle)</span></span>&#123;</span><br><span class="line">        SimpleJdbcInsert jdbcInsert = <span class="keyword">new</span> SimpleJdbcInsert(jdbcTemplate).withTableName(<span class="string">"Spittle"</span>);</span><br><span class="line">        jdbcInsert.setGeneratedKeyName(<span class="string">"id"</span>);</span><br><span class="line">        Map&lt;String,Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">"spitter"</span>,spittle.getSpitter().getId());</span><br><span class="line">        args.put(<span class="string">"message"</span>,spittle.getMessage());</span><br><span class="line">        args.put(<span class="string">"postedTime"</span>,spittle.getPostedDate());</span><br><span class="line">        <span class="keyword">long</span> spittleId = jdbcInsert.executeAndReturnKey(args).longValue();</span><br><span class="line">        <span class="keyword">return</span> spittleId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Spittle</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spittle <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Spittle(rs.getLong(<span class="string">"id"</span>),</span><br><span class="line">                    <span class="keyword">new</span> Spitter(rs.getLong(<span class="string">"spitterId"</span>),rs.getString(<span class="string">"username"</span>),</span><br><span class="line">                            rs.getString(<span class="string">"password"</span>),rs.getString(<span class="string">"fullname"</span>),</span><br><span class="line">                            rs.getString(<span class="string">"email"</span>),rs.getBoolean(<span class="string">"updateByEmail"</span>)),</span><br><span class="line">                    rs.getString(<span class="string">"message"</span>),rs.getTimestamp(<span class="string">"postedTime"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Spring中JDBC将获取连接，捕获异常都封装在JdbcTemplate中让我们更关注数据操作代码。对于增删改查四个方面，JdbcTemplate都为我们封装了一系列的函数。</p><p>SimpleJdbcInsert 可以简化我们的插入操作，指定一个数据库中的表名，然后传入一个Map，Key为数据表中的表项名，Value为插入的值，并可以指定一个返回的值。</p><p>通过update方法来实现删改。</p><p>查询基本类型例如Long等有对应的queryForLong方法等，若要将查询结果处理成为对象或对象集合，我们需要实现RowMapper接口实现将查询结果的一行映射为对象。</p><p>其实以上的代码我们并不能运行，因为我们还没有指定数据库数据源我们写一个JdbcConfig配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> spittr.db.jdbc.JdbcSpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.db.jdbc.JdbcSpittleRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">                .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">                .addScripts(<span class="string">"classpath:spittr/db/jdbc/schema.sql"</span>,<span class="string">"classpath:spittr/db/jdbc/test-data.sql"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcSpitterRepository <span class="title">spitterRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcSpitterRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcSpittleRepository <span class="title">spittleRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcSpittleRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用EmbeddedDatabaseBuilder来新建一个嵌入式数据库，这里我们选择H2，addScripts方法可以执行我们写好的SQL脚本。</p><p>将数据源注入到JdbcTemplate就可以使用它了，是不是很方便？？</p><p>我们还可以使用DriverManagerDataSource来配置基于JDBC驱动的数据源。</p><p>我们定义了dataSource、jdbcTemplate、spitterRepository、spittleRepository和transactionManager五个bean，dataSource bean 用来注入到jdbcTemplate bean中，jdbcTemplate bean 用来注入到用到它的repository实现中。spitterRepository和spittleRepository bean 用来注入到使用到它们的类。transactionManager bean 用来实现 事务管理，这里我们没有用到它。</p><p>下面是测试类的一部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.jdbc.JdbcSpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span></span>=JdbcConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JdbcSpitterRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  JdbcSpitterRepository spitterRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">4</span>, spitterRepository.count());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Spitter&gt; spitters = spitterRepository.findAll();</span><br><span class="line">    assertEquals(<span class="number">4</span>, spitters.size());</span><br><span class="line">    assertSpitter(<span class="number">0</span>, spitters.get(<span class="number">0</span>));</span><br><span class="line">    assertSpitter(<span class="number">1</span>, spitters.get(<span class="number">1</span>));</span><br><span class="line">    assertSpitter(<span class="number">2</span>, spitters.get(<span class="number">2</span>));</span><br><span class="line">    assertSpitter(<span class="number">3</span>, spitters.get(<span class="number">3</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用JdbcConfig类配置应用上下文，自动装配相应的repository实现。</p><p>这里需要注意的是@Transactional注解当它置于方法前时表示该方法使用事务处理，当它置于类前时表示该类的所有方法都使用事务处理。</p>]]></content>
    
    <summary type="html">
    
      Spring 实战
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring之旅</title>
    <link href="http://yoursite.com/2020/04/04/Spring%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2020/04/04/Spring%E4%B9%8B%E6%97%85/</id>
    <published>2020-04-04T06:39:13.000Z</published>
    <updated>2020-04-04T10:47:32.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring之旅"><a href="#Spring之旅" class="headerlink" title="Spring之旅"></a>Spring之旅</h1><p>Spring是一个开源框架，Spring根本使命：简化Java开发。</p><p>为了简化java开发的复杂性，Spring使用如下4种策略：</p><p>1、基于POJO(Plain Old Java Object 简单Java对象 )的轻量级和最小侵入性编程。</p><p>2、通过依赖注入和面向接口实现松耦合。</p><p>3、基于切面和惯例进行声明式编程。</p><p>4、通过切面和模板减少样板式代码。</p><p>这里以一个骑士出征的例子来解释一些相关概念</p><p>首先定义一个骑士接口，其中有一个embarkOnQuest方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Knight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始行动</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">embarkOnQuest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再定义一个远征行动接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Quest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">embark</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步定义一个拯救少女行动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RescueDamselQuest</span> <span class="keyword">implements</span> <span class="title">Quest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//开始行动拯救少女</span></span><br><span class="line">        System.out.println(<span class="string">"Embarking on a quest to rescue the damsel"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个屠杀巨龙行动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">//杀巨龙行动</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlayDragonQuest</span> <span class="keyword">implements</span> <span class="title">Quest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrintStream printStream;</span><br><span class="line">    <span class="comment">//依赖注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SlayDragonQuest</span><span class="params">(PrintStream printStream)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printStream = printStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printStream.println(<span class="string">"Embarking on quest to slay the dragon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义一个英勇的骑士类实现骑士接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">javapackage hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BraveKnight</span> <span class="keyword">implements</span> <span class="title">Knight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Quest quest;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖注入，而不是BraveKnight含有Quest对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BraveKnight</span><span class="params">(Quest quest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quest = quest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embarkOnQuest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quest.embark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里有人可能就写成下面这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BraveKnight</span> <span class="keyword">implements</span> <span class="title">Knight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Quest quest;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BraveKnight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        quest = <span class="keyword">new</span> RescueDamselQuest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embarkOnQuest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quest.embark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有一种情况：骑士不仅仅可以去杀龙还可以去拯救少女这里将它写死就不太合适，采用传递一个Quest对象，只要实现了Quest类的接口，任何类都可以传进来，骑士就可以去做很多行动，不是只执行一个任务。</p><p>这是依赖注入(DI)的一种方式：构造器注入</p><p>同样SlayDragonQuest类中也有依赖注入：将一个PrintStream对象注入到SlayDragonQuest中。</p><p>骑士出征之前和之后需要法师的吟唱，骑士类拥有法师类对象似乎不是一个好的选择，法师不应该被骑士拥有，有的骑士也不想法师吟唱这里先定义一个法师类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法师吟唱类 骑士出征之前之后需要法师吟唱</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minstrel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PrintStream printStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Minstrel</span><span class="params">(PrintStream printStream)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printStream = printStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AOP 应用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singBeforeQuest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printStream.println(<span class="string">"Fa la la,the knight is so brave!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singAfterQuest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printStream.println(<span class="string">"Tee hee hee , the brave knight did embark on a quest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法师的吟唱是骑士的出征非关键因素，这里利用AOP来实现法师吟唱模块化。</p><p>有多个Quest对象可以被注入到BraveKnight中，到底选择哪一个来注入呢？？</p><p>这里利用XML来正确装配这些对象。</p><p>装配的方式有：自动装配、XML显式装配、Java显式装配。</p><p>先定义knight.xml来解决骑士到底要做什么的问题。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line">&lt;bean id=<span class="string">"knight"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.BraveKnight"</span>&gt;</span><br><span class="line">    &lt;constructor-arg ref=<span class="string">"quest"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"quest"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.SlayDragonQuest"</span>&gt;</span><br><span class="line">        &lt;constructor-arg value=<span class="string">"#&#123;T(System).out&#125;"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>使用<bean></bean>声明一个bean 其中id为自己指定的名字 class为bean的类</p><p><constructor-arg> 元素为构造器参数 ref为依赖的bean，第一个constructor元素就决定了将一个id为quest的bean注入到id为knight的对象中。第二个constructor元素中 value代表将一个System.out值传入构造器。</p><p>第一个constructor元素就决定了骑士去杀龙而不是拯救少女。</p><p>等等，法师吟唱在哪？？？</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"knight"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.BraveKnight"</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">"quest"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"quest"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.SlayDragonQuest"</span>&gt;</span><br><span class="line">        &lt;constructor-arg value=<span class="string">"#&#123;T(System).out&#125;"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"minstrel"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.Minstrel"</span>&gt;</span><br><span class="line">        &lt;constructor-arg value=<span class="string">"#&#123;T(System).out&#125;"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:aspect ref=<span class="string">"minstrel"</span>&gt;</span><br><span class="line">            &lt;aop:pointcut id=<span class="string">"embark"</span> expression=<span class="string">"execution(* *.embarkOnQuest(..))"</span>/&gt;</span><br><span class="line">            </span><br><span class="line">            &lt;aop:before pointcut-ref=<span class="string">"embark"</span> method=<span class="string">"singBeforeQuest"</span>/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;aop:after pointcut-ref=<span class="string">"embark"</span> method=<span class="string">"singAfterQuest"</span>/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>&lt;aop:aspect ref=”minstrel”&gt;这一句将法师类声明为一个切面(AOP)。</p><p>pointcut定义了一个切入点，before决定在切入点之前做什么，after决定在切入点之后做什么。</p><p>来到验证阶段，看看骑士到底干了啥事？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnightMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("minstrel.xml");</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"knight.xml"</span>);</span><br><span class="line">        Knight knight = context.getBean(Knight<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        knight.embarkOnQuest();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassPathXmlApplicationContext 从xml文件中读取bean装配信息。</p><p>注释的第一行决定了法师要出来吟唱，通过控制台可以看到法师出来吟唱了，并且骑士执行的是杀龙的行动。</p><p><img src="https://i.loli.net/2020/04/04/iZRbHgK6a12jsmz.png" alt="img"></p><p>法师吟唱</p><p>没有注释的第二行决定法师不出来吟唱，执行的也是杀龙任务，也可以将xml里面的配置改为拯救少女，可能这个骑士他不喜欢拯救少女吧。</p><p><img src="https://i.loli.net/2020/04/04/OnfcdCHIohMaiSx.png" alt="img"></p><p>法师不吟唱</p><p>这个例子 初步展示了DI、AOP的思想。</p>]]></content>
    
    <summary type="html">
    
      Spring 实战
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>下载文泉学堂 PDF</title>
    <link href="http://yoursite.com/2020/04/04/%E4%B8%8B%E8%BD%BD%E6%96%87%E6%B3%89%E5%AD%A6%E5%A0%82%20PDF/"/>
    <id>http://yoursite.com/2020/04/04/%E4%B8%8B%E8%BD%BD%E6%96%87%E6%B3%89%E5%AD%A6%E5%A0%82%20PDF/</id>
    <published>2020-04-04T06:39:13.000Z</published>
    <updated>2020-04-04T10:27:19.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载文泉学堂-PDF"><a href="#下载文泉学堂-PDF" class="headerlink" title="下载文泉学堂 PDF"></a>下载文泉学堂 PDF</h1><p>　　今天画了20多大洋买了一本电子书，这本书居然只能在他们自己的网站上看。只能在他们自己的网站上我也忍了，但是这个体验非常糟糕，不能快速翻页一直在异步加载图片而不是一次性全部加载好的。最骚的是写这个阅读器的人把你看过的页码统统模糊掉，你想要往上翻又要加载一次，体验非常的糟糕，就想着能不能把这本书的pdf下载下来。</p><p>　　最后找到了一个方法：</p><p>　　1）安装油猴扩展，具体方法见百度。</p><p>　　2）安装下载脚本。<a href="https://greasyfork.org/zh-CN/scripts/396025-文泉学堂pdf下载" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/396025-%E6%96%87%E6%B3%89%E5%AD%A6%E5%A0%82pdf%E4%B8%8B%E8%BD%BD</a></p><p>　　3）打开文泉学堂 pdf 阅读器，点击某一页 pdf 即可开始下载，下载的比较慢，稍等一会你能看见自动翻页，必须等待前两个pdf 下载完后才能挂后台，chrome 有一个连续下载的提示框。</p><p>　　4）将下载的多个 pdf 合并为一个 pdf 。<a href="https://dl.pconline.com.cn/download/364420.html" target="_blank" rel="noopener">https://dl.pconline.com.cn/download/364420.html</a></p><p>　　参考：<a href="https://github.com/Kevin0z0/wenquan-pdf-download" target="_blank" rel="noopener">https://github.com/Kevin0z0/wenquan-pdf-download</a></p><p>　　感谢大佬，tql。</p><p>　　所有下载的pdf请在24小时内删除，请勿传播或进行营利，一切法律责任由用户自己承担，与本人无关。</p>]]></content>
    
    <summary type="html">
    
      pdf 下载利器
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
</feed>
