<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2021-04-23T02:51:10.841Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最大整除子集</title>
    <link href="https://hoo334.github.io/2021/04/23/%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/"/>
    <id>https://hoo334.github.io/2021/04/23/%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/</id>
    <published>2021-04-23T02:30:25.000Z</published>
    <updated>2021-04-23T02:51:10.841Z</updated>
    
    <content type="html"><![CDATA[<h4 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集"></a><a href="https://leetcode-cn.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">368. 最大整除子集</a></h4><p>给你一个由 <strong>无重复</strong> 正整数组成的集合 <code>nums</code> ，请你找出并返回其中最大的整除子集 <code>answer</code> ，子集中每一元素对 <code>(answer[i], answer[j])</code> 都应当满足：</p><ul><li><code>answer[i] % answer[j] == 0</code> ，或</li><li><code>answer[j] % answer[i] == 0</code></li></ul><p>如果存在多个有效解子集，返回其中任何一个均可。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：[1,3] 也会被视为正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,4,8]</span><br><span class="line">输出：[1,2,4,8]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 109</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><p><strong>方法一：动态规划</strong></p><ol><li>求最大整除子集的长度</li></ol><p>我们首先将输入数组按照升序排序，以便获得一个子集的最小整数或最大整数。dp[i] 定义为：以nums[i] 为最大整数的<strong>有序</strong>整除子集的数字个数，nums[i] 必须被选择。</p><p>从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0 … i - 1]的值，状态转移方程为：<br>$$<br>dp[i] = max(dp[j]) + 1, 其中 0 \leq j&lt;i 且\ nums[i]\  %\  nums[j] == 0<br>$$<br>最大整除子集长度就是 dp 数组中的最大值。</p><p>在遍历过程中我们保存最大整除子集的长度 maxSize 和子集中的最大数字 maxVal。</p><ol start="2"><li>倒序找出最大整除子集</li></ol><p>假设输入数组为[2,4,7,8,9,12,16,18](已经有序)，得到的动态规划表格如下：</p><table><thead><tr><th>nums</th><th>2</th><th>4</th><th>7</th><th>8</th><th>9</th><th>12</th><th>16</th><th>18</th></tr></thead><tbody><tr><td>dp</td><td>1</td><td>2</td><td>1</td><td>3</td><td>1</td><td>3</td><td>4</td><td>3</td></tr></tbody></table><ol><li>初始时 maxSize = 4, maxVal = 16</li><li>寻找大小为 3 的最大整除子集，我们看到 8 和 12 对应的状态值都是 3，但 16 % 12 != 0，我们选择包含 8 的最大整除子集，此时maxSize = 3, maxVal = 8</li><li>继续向左寻找大小为 2 的最大整除子集，只有 4 对应的状态值为 2 ，选择包含 4 的最大整除子集，此时maxSize = 2, maxVal = 4</li><li>继续向左寻找大小为 1 的最大整除子集，2 对应的状态值为 1 ，选择包含 2 的最大整除子集，此时maxSize = 1, maxVal = 2</li></ol><p>我们就得到最大整除子集[16,8,4,2]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态规划找出最大子集的个数、最大子集中的最大整数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxVal = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxSize)&#123;</span><br><span class="line">                maxSize = dp[i];</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒推获得最大子集</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(maxSize == <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; maxSize &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == maxSize &amp;&amp; maxVal % nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(nums[i]);</span><br><span class="line">                maxSize--;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(n)</li></ul><p>当前问题和使用动态规划解决的经典问题「<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">300. 最长递增子序列</a>」有相似之处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;368-最大整除子集&quot;&gt;&lt;a href=&quot;#368-最大整除子集&quot; class=&quot;headerlink&quot; title=&quot;368. 最大整除子集&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/largest-divisible-subset/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;368. 最大整除子集&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个由 &lt;strong&gt;无重复&lt;/strong&gt; 正整数组成的集合 &lt;code&gt;nums&lt;/code&gt; ，请你找出并返回其中最大的整除子集 &lt;code&gt;answer&lt;/code&gt; ，子集中每一元素对 &lt;code&gt;(answer[i], answer[j])&lt;/code&gt; 都应当满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;answer[i] % answer[j] == 0&lt;/code&gt; ，或&lt;/li&gt;
&lt;li&gt;&lt;code&gt;answer[j] % answer[i] == 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果存在多个有效解子集，返回其中任何一个均可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最长递增子序列</title>
    <link href="https://hoo334.github.io/2021/04/23/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://hoo334.github.io/2021/04/23/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2021-04-23T01:59:00.000Z</published>
    <updated>2021-04-23T02:11:47.607Z</updated>
    
    <content type="html"><![CDATA[<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a></h4><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列长度，<strong>nums[i] 必须被选择</strong>。</p><p>从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0 … i - 1]的值，状态转移方程为：<br>$$<br>dp[i] = max(dp[j]) + 1, 其中 0 \leq j&lt;i 且nums[j] &lt; nums[i]<br>$$<br>即考虑往 dp[0 … i - 1]中的最长上升子序列后面再加一个 nums[i]，此时 nums[i]必须大于前面的最长子序列中的最后一个元素，假设我们选择最长上升子序列 dp[j]，nums[i] 就必须大于 nums[j]。</p><p>最后整个数组的最长上升子序列即为所有 dp[i] 中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//尝试在dp[0 ... i-1]中找一个最长递增子序列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                maxLen = Math.max(maxLen, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;300-最长递增子序列&quot;&gt;&lt;a href=&quot;#300-最长递增子序列&quot; class=&quot;headerlink&quot; title=&quot;300. 最长递增子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;300. 最长递增子序列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到其中最长严格递增子序列的长度。&lt;/p&gt;
&lt;p&gt;子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，&lt;code&gt;[3,6,2,7]&lt;/code&gt; 是数组 &lt;code&gt;[0,3,1,6,2,2,7]&lt;/code&gt; 的子序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>解码方法</title>
    <link href="https://hoo334.github.io/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>https://hoo334.github.io/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</id>
    <published>2021-04-21T02:12:39.000Z</published>
    <updated>2021-04-23T01:31:51.660Z</updated>
    
    <content type="html"><![CDATA[<h4 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a></h4><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有字符映射到以 0 开头的数字。</span><br><span class="line">含有 0 的有效映射是 &#39;J&#39; -&gt; &quot;10&quot; 和 &#39;T&#39;-&gt; &quot;20&quot; 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;06&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;06&quot; 不能映射到 &quot;F&quot; ，因为字符串含有前导 0（&quot;6&quot; 和 &quot;06&quot; 在映射中并不等价）。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含数字，并且可能包含前导零。</li></ul><p>对于字符串s = “226”，我们从左至右分析，字符 ‘ 2 ’ 可以解码为‘B’，字符 ’22‘ 可以解码为 ‘V’，解码方法总数为剩下的 ”26“ 和 ”6“解码方法总和，我们可以轻松知道 ”26“的解码方法为 2 种，”6“ 的解码方法为 1 种。</p><p>因此我们可以使用递归来实现这种思想</p><p><strong>方法一：递归（超时）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//字符串长度为 0 或字符串第一个字符为 0，直接返回 0 </span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> decode(chars, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chars.length;</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(start == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//以 0 开头，直接返回 0 </span></span><br><span class="line">        <span class="keyword">if</span>(chars[start] == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取一个字符</span></span><br><span class="line">        <span class="keyword">int</span> ret = decode(chars, start + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//取两个字符</span></span><br><span class="line">        <span class="keyword">if</span>(start + <span class="number">1</span> &lt; n &amp;&amp; isDigit(chars[start], chars[start + <span class="number">1</span>]))&#123;</span><br><span class="line">            ret += decode(chars, start + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回相加的结果</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判断两个字符是否能解码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> upper, <span class="keyword">char</span> lower)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> up = (<span class="keyword">int</span>)(upper - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">int</span> low = (<span class="keyword">int</span>)(lower - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>( (up == <span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">9</span>) || (up == <span class="number">2</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">6</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：动态规划</strong></p><p>虽然递归方法超时了，但我们可以尝试使用动态规划。dp[i] 表示 s[i … n] 的解码方法总数，结果为 dp[0]。我们可以使用 dpi, dpi1, dpi2 三个变量来代替 dp 数组，初始时 dpi = 0, dpi1 = 1, dpi2 = 1。我们可以列出如下 dp 方程：<br>$$<br>dp[i] = 0,  s[i] = ‘0’<br>$$<br>$$<br>dp[i] = dp[i + 1],  s[i] \neq ‘0’ &amp;&amp; \ !isDigit(s[i], s[i + 1]) \<br>$$<br>$$<br>dp[i] = dp[i + 1] + dp[i + 2],  s[i] \neq ‘0’ &amp;&amp; \ isDigit(s[i], s[i + 1]) \<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dpi = <span class="number">0</span>, dpi1 = <span class="number">1</span>, dpi2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != <span class="string">'0'</span>)&#123;</span><br><span class="line">                dpi += dpi1;</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; isDigit(s.charAt(i), s.charAt(i + <span class="number">1</span>))) dpi += dpi2;</span><br><span class="line">            &#125;</span><br><span class="line">            dpi2 = dpi1;</span><br><span class="line">            dpi1 = dpi;</span><br><span class="line">            dpi = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dpi1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> upper, <span class="keyword">char</span> lower)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> up = (<span class="keyword">int</span>)(upper - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">int</span> low = (<span class="keyword">int</span>)(lower - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>( (up == <span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">9</span>) || (up == <span class="number">2</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">6</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;91-解码方法&quot;&gt;&lt;a href=&quot;#91-解码方法&quot; class=&quot;headerlink&quot; title=&quot;91. 解码方法&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/decode-ways/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;91. 解码方法&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;一条包含字母 &lt;code&gt;A-Z&lt;/code&gt; 的消息通过以下映射进行了 &lt;strong&gt;编码&lt;/strong&gt; ：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;A&amp;#39; -&amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;B&amp;#39; -&amp;gt; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;Z&amp;#39; -&amp;gt; 26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;要 &lt;strong&gt;解码&lt;/strong&gt; 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&lt;code&gt;&amp;quot;11106&amp;quot;&lt;/code&gt; 可以映射为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;AAJF&amp;quot;&lt;/code&gt; ，将消息分组为 &lt;code&gt;(1 1 10 6)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;KJF&amp;quot;&lt;/code&gt; ，将消息分组为 &lt;code&gt;(11 10 6)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，消息不能分组为 &lt;code&gt;(1 11 06)&lt;/code&gt; ，因为 &lt;code&gt;&amp;quot;06&amp;quot;&lt;/code&gt; 不能映射为 &lt;code&gt;&amp;quot;F&amp;quot;&lt;/code&gt; ，这是由于 &lt;code&gt;&amp;quot;6&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;06&amp;quot;&lt;/code&gt; 在映射中并不等价。&lt;/p&gt;
&lt;p&gt;给你一个只含数字的 &lt;strong&gt;非空&lt;/strong&gt; 字符串 &lt;code&gt;s&lt;/code&gt; ，请计算并返回 &lt;strong&gt;解码&lt;/strong&gt; 方法的 &lt;strong&gt;总数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;题目数据保证答案肯定是一个 &lt;strong&gt;32 位&lt;/strong&gt; 的整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>打家劫舍II</title>
    <link href="https://hoo334.github.io/2021/04/15/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/"/>
    <id>https://hoo334.github.io/2021/04/15/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/</id>
    <published>2021-04-15T01:17:21.000Z</published>
    <updated>2021-04-15T01:32:07.356Z</updated>
    
    <content type="html"><![CDATA[<h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，能够偷窃到的最高金额。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>方法一：动态规划</strong></p><p>此题是<a href="https://hoo334.github.io/2020/07/01/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">打家劫舍</a>的进阶，与打家劫舍不同的是，这题中的房屋是首尾相连的，第一间和最后一间房屋相邻，因此第一间房屋和最后一间房屋不能在同一晚上偷窃。</p><p>假设数组 nums 的长度为 n。如果不偷窃最后一间房屋，则偷窃房屋的下标范围是[0, n - 2]；如果偷最后一间房屋，则偷窃房屋的下标是[1, n - 1]。在确定偷窃房屋的下标范围之后，即可用打家劫舍中的方法解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一个房子和最后一个房子只能选择偷一个，因此做两次动态规划就可以了。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//偷第一个房子</span></span><br><span class="line">        <span class="keyword">int</span> first = robHelper(Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//偷最后一个房子</span></span><br><span class="line">        <span class="keyword">int</span> last = robHelper(Arrays.copyOfRange(nums, <span class="number">1</span>, nums.length));</span><br><span class="line">        <span class="keyword">return</span> Math.max(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">robHelper</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>,cur=<span class="number">0</span>,temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">            temp = cur;</span><br><span class="line">            cur = Math.max(pre+nums[i], cur);</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;213-打家劫舍-II&quot;&gt;&lt;a href=&quot;#213-打家劫舍-II&quot; class=&quot;headerlink&quot; title=&quot;213. 打家劫舍 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;213. 打家劫舍 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 &lt;strong&gt;围成一圈&lt;/strong&gt; ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你 &lt;strong&gt;在不触动警报装置的情况下&lt;/strong&gt; ，能够偷窃到的最高金额。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Aspect Spring AOP</title>
    <link href="https://hoo334.github.io/2021/04/12/Aspect%20Spring%20AOP/"/>
    <id>https://hoo334.github.io/2021/04/12/Aspect%20Spring%20AOP/</id>
    <published>2021-04-12T02:34:09.000Z</published>
    <updated>2021-04-15T03:21:05.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于注解的-Spring-AOP-开发"><a href="#基于注解的-Spring-AOP-开发" class="headerlink" title="基于注解的 Spring AOP 开发"></a>基于注解的 Spring AOP 开发</h3><a id="more"></a><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/v2-b5c523e28bba91c11c8d7f510ab84a79_1440w.png" alt="img"></p><h4 id="定义切入点函数"><a href="#定义切入点函数" class="headerlink" title="定义切入点函数"></a>定义切入点函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在执行完 UserDao.add() 方法后执行</span></span><br><span class="line"><span class="meta">@After</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>还可采用 @PointCut 关键字定义切入点表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Pointcut定义切点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用切入点函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@After</span>(value=<span class="string">"myPointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切入点指示符"><a href="#切入点指示符" class="headerlink" title="切入点指示符"></a>切入点指示符</h4><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><p>在定义匹配表达式时，通配符几乎随处可见如 <code>*</code> , <code>..</code> , <code>+</code> ,它们的含义如下：</p><ul><li><code>..</code>：匹配方法定义中任意数量的参数，此外还匹配类定义中任意数量包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任意返回值，任意名称，任意参数的公共方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * *(..))</span><br><span class="line"><span class="comment">//匹配com.zejian.dao包及其子包中所有类中的所有方法</span></span><br><span class="line">within(com.zejian.dao..*)</span><br></pre></td></tr></table></figure><ul><li><code>+</code>：匹配给定类的任意子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配实现了DaoUser接口的所有子类的方法</span></span><br><span class="line">within(com.zejian.dao.DaoUser+)</span><br></pre></td></tr></table></figure><ul><li><code>*</code>：匹配任意数量的字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配com.zejian.service包及其子包中所有类的所有方法</span></span><br><span class="line">within(com.zejian.service..*)</span><br><span class="line"><span class="comment">//匹配以set开头，参数为int类型，任意返回值的方法</span></span><br><span class="line">execution(* set*(<span class="keyword">int</span>))</span><br></pre></td></tr></table></figure><h5 id="类型签名表达式"><a href="#类型签名表达式" class="headerlink" title="类型签名表达式"></a>类型签名表达式</h5><p>为了方便类型（如接口、类名、包名）过滤方法，Spring AOP 提供了within关键字。其语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(&lt;type name&gt;)</span><br></pre></td></tr></table></figure><p>type name 则使用包名或者类名替换即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配com.zejian.dao包及其子包中所有类中的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao..*)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDaoImpl)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类及其子类中所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDaoImpl+)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配所有实现UserDao接口的类的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDao+)"</span>)</span><br></pre></td></tr></table></figure><h5 id="方法签名表达式"><a href="#方法签名表达式" class="headerlink" title="方法签名表达式"></a>方法签名表达式</h5><p>如果想根据方法签名进行过滤，关键字 execution 可以帮到我们，语法表达式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scope ：方法作用域，如public,private,protect</span></span><br><span class="line"><span class="comment">//returnt-type：方法返回值类型</span></span><br><span class="line"><span class="comment">//fully-qualified-class-name：方法所在类的完全限定名称</span></span><br><span class="line"><span class="comment">//parameters 方法参数</span></span><br><span class="line">execution(&lt;scope&gt; &lt;<span class="keyword">return</span>-type&gt; &lt;fully-qualified-<span class="class"><span class="keyword">class</span>-<span class="title">name</span>&gt;.*(<span class="title">parameters</span>))</span></span><br></pre></td></tr></table></figure><p>对于给定的作用域、返回值类型、完全限定类名以及参数匹配的方法将会应用切点函数指定的通知，这里给出模型案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配UserDaoImpl类中的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.zejian.dao.UserDaoImpl.*(..))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中的所有公共的方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.zejian.dao.UserDaoImpl.*(..))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中的所有公共方法并且返回值为int类型</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public int com.zejian.dao.UserDaoImpl.*(..))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中第一个参数为int类型的所有公共的方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.zejian.dao.UserDaoImpl.*(int , ..))"</span>)</span><br></pre></td></tr></table></figure><h5 id="其他指示符"><a href="#其他指示符" class="headerlink" title="其他指示符"></a>其他指示符</h5><ul><li><p>this：用于匹配当前 AOP 代理对象类型的执行方法；请注意是 <strong>AOP代理对象</strong>的类型匹配，这样就可能包括引入接口也类型匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的代理对象的方法进行过滤</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"this(com.zejian.spring.springAop.dao.UserDao)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut2</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>bean：Spring AOP 扩展的，AspectJ没有对应指示符，用于匹配特定名称的 Bean 对象的执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配名称中带有后缀Service的Bean。</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"bean(*Service)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>target：用于匹配当前目标对象类型的执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法进行过滤</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut3</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>@within：用于匹配所有持有指定注解类型内的方法；请注意与 within 是有区别的，within是用于匹配指定类型内的方法执行；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配使用了MarkerAnnotation注解的类(注意是类)</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@within(com.zejian.spring.annotation.MarkerAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut4</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>@annotation(com.zejian.spring.MarkerMethodAnnotation) : 根据所应用的注解进行方法过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配使用了MarkerAnnotation注解的方法(注意是方法)</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.zejian.spring.annotation.MarkerAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut5</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>切点指示符可以使用运算符语法进行表达式的混编，如and、or、not（或者&amp;&amp;、||、！），如下一个简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法并且该接口不在com.zejian.dao包及其子包下</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao) ！within(com.zejian.dao..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法并且该方法名称为addUser</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao)&amp;&amp;execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut7</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="5-种通知函数"><a href="#5-种通知函数" class="headerlink" title="5 种通知函数"></a>5 种通知函数</h5><p>通知主要分5种类型，分别是前置通知、后置通知、异常通知、最终通知以及环绕通知，下面分别介绍。</p><ul><li><p>前置通知 @Before</p><p>前置通知通过 @Before 注解进行标注，并可直接传入切点表达式的值，该通知在目标函数执行前执行，JoinPoint 是 Spring 提供的静态变量，通过它，可以获取目标对象的信息，如类名称，方法参数，方法名等，该参数可选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前置通知</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> joinPoint 该参数可以获取目标对象的信息,如类名称,方法参数,方法名称等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后置通知 @AfterReturning</p><p>通过 @AfterReturning 标注，该函数在目标函数执行完成后执行，并可以获取到目标函数最终的返回值  returnVal，当目标函数没有返回值时，returnVal 将返回 null。</p><p>必须通过returning = “returnVal”注明参数的名称而且必须与通知函数的参数名称相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后置通知，不需要参数时可以不提供</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AfterReturning</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"我是后置通知..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后置通知</span></span><br><span class="line"><span class="comment">* returnVal,切点方法执行后的返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AfterReturning</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>,returning = <span class="string">"returnVal"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">(JoinPoint joinPoint,Object returnVal)</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"我是后置通知...returnVal+"</span>+returnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异常通知 @AfterThrowing</p><p>该通知只有在异常时才会被出发，并由 throwing 来声明一个接受异常信息的变量，同样异常通知也用于 Joinpoing 参数，需要时可以加上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 抛出通知</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e 抛出异常的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>,throwing = <span class="string">"e"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowable</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"出现异常:msg="</span>+e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最终通知 @After</p><p>该通知有点类似于 finally 代码块，只要应用了，无论什么情况下都会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无论什么情况下都会执行的方法</span></span><br><span class="line"><span class="comment"> * joinPoint 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@After</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环绕通知 @Around</p><p>环绕通知既可在目标方法前执行也可以在目标方法后执行，更重要的是环绕通知可以控制目标方法是否指向执行，但即使如此，我们应该尽量以最简单的方式满足需求，在仅需目标方法前执行时，使用前置通知而非环绕通知。</p><p>第一个参数必须是 ProceedingJoinPoint，通过该对象的 proceed() 方法来执行目标函数，proceed() 的返回值就是环绕通知的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是环绕通知前...."</span>);</span><br><span class="line">    <span class="comment">//执行目标函数</span></span><br><span class="line">    Object obj= (Object) joinPoint.proceed();</span><br><span class="line">    System.out.println(<span class="string">"我是环绕通知后...."</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="通知传递参数"><a href="#通知传递参数" class="headerlink" title="通知传递参数"></a>通知传递参数</h5><p>在 Spring AOP 中，除了 execution 和 bean 指示符不能传递参数给通知方法，其他指示符都可以将<strong>匹配的方法相应参数或对象</strong>自动传递给通知方法。获取到匹配的方法参数后通过 <code>argNames</code>属性指定参数名。如下，args(param)、argNames=”param”、before(int param)这三个参数<strong>命名必须保持一致</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value=<span class="string">"args(param)"</span>, argNames=<span class="string">"param"</span>) <span class="comment">//明确指定了    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(<span class="keyword">int</span> param)</span> </span>&#123;    </span><br><span class="line">    System.out.println(<span class="string">"param:"</span> + param);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可直接使用 args 指示符不带 argNames 声明参数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(public * com.zejian..*.addUser(..)) &amp;&amp; args(userId,..)"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//调用addUser的方法时如果与addUser的参数匹配则会传递进来会传递进来</span></span><br><span class="line">    System.out.println(<span class="string">"userId:"</span> + userId);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>args(userId,..)表达式表示：只匹配那些至少接收一个参数而且传入的类型必须与userId一致的方法，传递的参数可以简单类型或者对象，只有参数和目标方法也匹配时才有会有值传递进来。</p><h3 id="Aspect-优先级"><a href="#Aspect-优先级" class="headerlink" title="Aspect 优先级"></a>Aspect 优先级</h3><p>如果有多个通知需要在同一个切点函数指定的过滤目标方法上执行，在所有前置通知函数中，优先级最高的通知函数将会被先执行，在所有后置通知函数中，优先级最高的通知函数将会最后执行。</p><p>新建名为 aspectdemo 的工程，首先引入核心依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectdemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AspectdemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启 AspectJAutoProxy ，添加配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在配置文件中启动<span class="doctag">@Aspect</span>支持后，</span></span><br><span class="line"><span class="comment"> * Spring容器只会尝试自动识别带<span class="doctag">@Aspect</span>的Bean，</span></span><br><span class="line"><span class="comment"> * 前提是任何定义的切面类都必须已在配置文件以Bean的形式声明。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加测试用 Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先添加优先级较高的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">切面实现 org.springframework.core.Ordered 接口，该接口用于控制切面类的优先级，同时重写getOrder方法，定制返回值，返回值(int 类型)越小优先级越大</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectOrderZero</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.hoo.aspectdemo.controller.TestController.testOrder())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 0 .. 执行顺序 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 0 .. 执行顺序 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 0 .. 执行顺序 3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningFour</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 0 .. 执行顺序 4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加优先级较低的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectOrderTwo</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.hoo.aspectdemo.controller.TestController.testOrder())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 2 .. 执行顺序 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 2 .. 执行顺序 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 2 .. 执行顺序 3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningFour</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 2 .. 执行顺序 4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，即可在控制台看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前置通知 ..优先级 0 .. 执行顺序 1</span><br><span class="line">前置通知 ..优先级 0 .. 执行顺序 2</span><br><span class="line">前置通知 ..优先级 2 .. 执行顺序 1</span><br><span class="line">前置通知 ..优先级 2 .. 执行顺序 2</span><br><span class="line">后置通知 ..优先级 2 .. 执行顺序 3</span><br><span class="line">后置通知 ..优先级 2 .. 执行顺序 4</span><br><span class="line">后置通知 ..优先级 0 .. 执行顺序 3</span><br><span class="line">后置通知 ..优先级 0 .. 执行顺序 4</span><br></pre></td></tr></table></figure><p>总结：在同一个切面中定义多个通知响应同一个切点函数，执行顺序为声明顺序；如果在不同的切面中定义多个通知响应同一个切点，进入时则优先级高的切面类中的通知函数优先执行，退出时则最后执行。</p><h3 id="Spring-AOP-简单应用场景"><a href="#Spring-AOP-简单应用场景" class="headerlink" title="Spring AOP 简单应用场景"></a>Spring AOP 简单应用场景</h3><ol><li>性能监控</li></ol><p>首先我们定义用于测试的controller，并模拟这个接口需要 5s 来执行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/monitor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMonitor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义性能监控信息类 MonitorTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorTime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Date logTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> consumeTime;</span><br><span class="line"> <span class="comment">// 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个监控的切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.hoo.aspectdemo.controller..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">logTimer</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MonitorTime monitor = <span class="keyword">new</span> MonitorTime();</span><br><span class="line">        <span class="comment">//获取目标类名称</span></span><br><span class="line">        String className = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        <span class="comment">//获取目标类方法名称</span></span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        monitor.setClassName(className);</span><br><span class="line">        monitor.setMethodName(methodName);</span><br><span class="line">        monitor.setLogTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计时并调用目标函数</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        monitor.setConsumeTime(time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把 MonitorTime 记录的信息上传给监控系统，这里没有实现</span></span><br><span class="line"></span><br><span class="line">        System.out.println(monitor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，访问<a href="http://localhost:8080/monitor，查看控制台，打印出如下信息：" target="_blank" rel="noopener">http://localhost:8080/monitor，查看控制台，打印出如下信息：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonitorTime&#123;className=<span class="string">'com.hoo.aspectdemo.controller.TestController2'</span>, methodName=<span class="string">'testMonitor'</span>, logTime=Mon Apr <span class="number">12</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">53</span> CST <span class="number">2021</span>, consumeTime=<span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>异常监控</li></ol><p>首先定义异常信息类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Date logTime;<span class="comment">//异常记录时间</span></span><br><span class="line">    <span class="keyword">private</span> String message;<span class="comment">//异常信息</span></span><br><span class="line"><span class="comment">// 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义自己的异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TestController2 中添加测试函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/monitor/&#123;mode&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMonitor2</span><span class="params">(@PathVariable Integer mode)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mode == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">" testMonitor() 方法出错了！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后定义异常处理的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionMonitorAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.hoo.aspectdemo.controller..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"exceptionMethod()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">monitorMethods</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            ExceptionInfo info = <span class="keyword">new</span> ExceptionInfo();</span><br><span class="line">            info.setClassName(joinPoint.getTarget().getClass().getName());</span><br><span class="line">            info.setMethodName(joinPoint.getSignature().getName());</span><br><span class="line">            info.setLogTime(<span class="keyword">new</span> Date());</span><br><span class="line">            info.setMessage(e.getMessage());</span><br><span class="line"></span><br><span class="line">            System.out.println(info);</span><br><span class="line">            <span class="comment">//上传日志系统，这里省略</span></span><br><span class="line">            <span class="comment">//返回失败信息</span></span><br><span class="line">            <span class="keyword">return</span> e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:8080/monitor/0" target="_blank" rel="noopener">http://localhost:8080/monitor/0</a> ，可以看到返回 ”success“信息，并在控制台可以看到访问时间日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonitorTime&#123;className&#x3D;&#39;com.hoo.aspectdemo.controller.TestController2&#39;, methodName&#x3D;&#39;testMonitor2&#39;, logTime&#x3D;Mon Apr 12 21:46:30 CST 2021, consumeTime&#x3D;11&#125;</span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:8080/monitor/1" target="_blank" rel="noopener">http://localhost:8080/monitor/1</a> ，可以看到返回 ”testMonitor() 方法出错了！“信息，并在控制台可以看到访问时间日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExceptionInfo&#123;className&#x3D;&#39;com.hoo.aspectdemo.controller.TestController2&#39;, methodName&#x3D;&#39;testMonitor2&#39;, logTime&#x3D;Mon Apr 12 21:47:15 CST 2021, message&#x3D;&#39; testMonitor() 方法出错了！&#39;&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-AOP-实现原理概要"><a href="#Spring-AOP-实现原理概要" class="headerlink" title="Spring AOP 实现原理概要"></a>Spring AOP 实现原理概要</h3><p>对于织入过程，一般分为动态织入和静态织入，动态织入在运行时动态地将要增强的代码织入到目标类中，这往往是通过动态代理技术完成的，如 Java JDK 的动态代理（底层通过反射实现）或者 CGLIB 的动态代理（底层通过继承实现）。</p><p>AspectJ 采用静态织入的方式。它在编译器使用 acj 编译器把 aspect 类编译成 class 字节码后，在 java 目标类编译时织入，先编译 aspect 类再编译目标类。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210414190852904.png" alt="image-20210414190852904"></p><h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>首先看一个简单的例子，声明一个 ExInterface 接口，利用 JDK 动态代理技术在 execute() 方法前后加入权限验证和日志记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的接口类，JDK 动态代理的实现必须要有对应的接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A类，实现了ExInterface接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">ExInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---- A.execute() ----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">//代理类的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要被代理的目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> A target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKProxy</span><span class="params">(A target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 创建代理类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExInterface <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ExInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用被代理类(目标对象)的任意方法都会触发invoke方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被代理类的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 被代理类的方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//过滤不需要该业务的方法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"execute"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="comment">//调用前验证权限</span></span><br><span class="line">            <span class="comment">//AuthCheck.authCheck();</span></span><br><span class="line">            System.out.println(<span class="string">"---- 鉴权 ----"</span>);</span><br><span class="line">            <span class="comment">//调用目标对象的方法</span></span><br><span class="line">            Object result = method.invoke(target, args);</span><br><span class="line">            <span class="comment">//记录日志数据</span></span><br><span class="line">            <span class="comment">//Report.recordLog();</span></span><br><span class="line">            System.out.println(<span class="string">"---- 记录日志 ----"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"delete"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不需要增强直接执行原方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">//创建 JDK 代理</span></span><br><span class="line">        JDKProxy jdkProxy = <span class="keyword">new</span> JDKProxy(a);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        ExInterface proxy = jdkProxy.createProxy();</span><br><span class="line">        <span class="comment">//执行代理对象方法</span></span><br><span class="line">        proxy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">---- 鉴权 ----</span><br><span class="line">---- A.execute() ----</span><br><span class="line">---- 记录日志 ----</span><br></pre></td></tr></table></figure><p>在 A 的 execute() 方法中没有调用任何权限和日志的 代码，也没有直接操作 a 对象，只是调用了 proxy 代理对象的方法，最终的结果却是预期的，这就是动态代理技术。动态代理的底层通过反射来实现，只要拿到 A 类的 class 文件和 A 类的实现接口，很自然就可以生成相同接口的代理类并调用  a 对象的方法。</p><p>实现 Java 动态代理是先决条件为：<strong>目标对象必须带接口</strong>，如果类的接口是 ExInterface，通过该接口，动态代理可以创建与 A 类类型相同的代理对象。</p><p>用JDK动态代理，被代理类(目标对象，如A类)，必须已有实现接口如(ExInterface)，因为JDK提供的Proxy类将通过目标对象的类加载器ClassLoader和Interface，以及句柄(Callback)创建与A类拥有相同接口的代理对象proxy，该代理对象将拥有接口ExInterface中的所有方法。同时，代理类必须实现一个类似回调函数的InvocationHandler接口并重写该接口中的invoke方法，当调用proxy的每个方法(如案例中的proxy#execute())时，invoke方法将被调用，利用该特性，可以在invoke方法中对目标对象(被代理对象如A)方法执行的前后动态添加其他外围业务操作，此时无需触及目标对象的任何代码，也就实现了外围业务的操作与目标对象(被代理对象如A)完全解耦合的目的。当然缺点也很明显需要拥有接口，这也就有了后来的CGLIB动态代理。  </p><h4 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a> 动态代理</h4><p>通过CGLIB动态代理实现上述功能并不要求目标对象拥有接口类，实际上CGLIB动态代理是通过继承的方式实现的，因此可以减少没必要的接口，下面直接通过简单案例协助理解。</p><p>首先引入 <a href="https://repository.ow2.org/nexus/content/repositories/releases/org/ow2/asm/asm/8.0.1/asm-8.0.1.jar" target="_blank" rel="noopener">asm-8.0.1.jar</a> 和 <a href="https://github.com/cglib/cglib/releases/download/RELEASE_3_3_0/cglib-3.3.0.jar" target="_blank" rel="noopener">cglib-3.3.0.jar</a>，也可使用 maven 下载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//被代理的类（目标对象）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---- A.execute() ----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被代理的目标类</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> A target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGLibProxy</span><span class="params">(A target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用 CGLIB 生成代理</span></span><br><span class="line">        <span class="comment">//1.生成增强类实例，用于生产代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.设置被代理类字节码，CGLIB 根据字节码生成被代理类的子类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3. 设置回调函数，即一个方法拦截</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//4.创建代理</span></span><br><span class="line">        <span class="keyword">return</span> (A) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 委托类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 每个被代理的方法都对应一个MethodProxy对象，</span></span><br><span class="line"><span class="comment">     *                    methodProxy.invokeSuper方法最终调用委托类(目标类)的原始方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//过滤不需要该业务的方法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"execute"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="comment">//调用前验证权限</span></span><br><span class="line">            System.out.println(<span class="string">"---- 鉴权 ----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用目标对象的方法（执行 A 独享即被代理对象的 execute 方法）</span></span><br><span class="line">            Object result = proxy.invokeSuper(obj,args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录日志数据（动态添加其他要执行业务）</span></span><br><span class="line">            System.out.println(<span class="string">"---- 日志 ----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"delete"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不需要增强直接执行原方法</span></span><br><span class="line">        <span class="keyword">return</span> proxy.invokeSuper(obj,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">        CGLibProxy cgLibProxy = <span class="keyword">new</span> CGLibProxy(a);</span><br><span class="line"></span><br><span class="line">        A proxy = cgLibProxy.createProxy();</span><br><span class="line"></span><br><span class="line">        proxy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">---- 鉴权 ----</span><br><span class="line">---- A.execute() ----</span><br><span class="line">---- 日志 ----</span><br></pre></td></tr></table></figure><p>被代理的类无需接口即可实现动态代理，而CGLibProxy代理类需要实现一个方法拦截器接口MethodInterceptor并重写intercept方法，类似JDK动态代理的InvocationHandler接口，也是理解为回调函数，同理每次调用代理对象的方法时，intercept方法都会被调用，利用该方法便可以在运行时对方法执行前后进行动态增强。关于代理对象创建则通过Enhancer类来设置的，Enhancer是一个用于产生代理对象的类，作用类似JDK的Proxy类，因为CGLib底层是通过继承实现的动态代理，因此需要传递目标对象(如A)的Class，同时需要设置一个回调函数对调用方法进行拦截并进行相应处理，最后通过create()创建目标对象(如A)的代理对象，运行结果与前面的JDK动态代理效果相同。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Spring AOP内部已都实现了这两种技术，Spring AOP 在使用时机上也进行自动化调整，当有接口时会自动选择JDK动态代理技术，如果没有则选择CGLIB技术，当然Spring AOP的底层实现并没有这么简单，为更简便生成代理对象，Spring AOP 内部实现了一个专注于生成代理对象的工厂类，这样就避免了大量的手动编码，这点也是十分人性化的，但最核心的还是动态代理技术。从性能上来说，Spring AOP 虽然无需特殊编译器协助，但性能上并不优于AspectJ的静态织入。<img src="https://gitee.com/hoo334/picgo/raw/master//img/v2-b091ac6fd64f493eaeabfeff4cee7fee_1440w.png" alt="img"></p><p><a href="https://blog.csdn.net/javazejian/article/details/56267036" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基于注解的-Spring-AOP-开发&quot;&gt;&lt;a href=&quot;#基于注解的-Spring-AOP-开发&quot; class=&quot;headerlink&quot; title=&quot;基于注解的 Spring AOP 开发&quot;&gt;&lt;/a&gt;基于注解的 Spring AOP 开发&lt;/h3&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://hoo334.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>丑数II</title>
    <link href="https://hoo334.github.io/2021/04/11/%E4%B8%91%E6%95%B0II/"/>
    <id>https://hoo334.github.io/2021/04/11/%E4%B8%91%E6%95%B0II/</id>
    <published>2021-04-11T02:37:25.000Z</published>
    <updated>2021-04-11T02:58:54.086Z</updated>
    
    <content type="html"><![CDATA[<h4 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">264. 丑数 II</a></h4><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1690</code></li></ul><p><strong>方法一：最小堆</strong></p><p>初始时堆为空，首先将最小的丑数 1 加入堆，每次取出堆顶元素 x，则 x 是堆中最小的丑数，2x，3x，5x也是丑数，因此将 2x，3x，5x，加入堆中，但这会导致出现重复元素，为了避免出现重复元素，我们使用哈希表去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] factors = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Set&lt;Long&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        seen.add(<span class="number">1L</span>);</span><br><span class="line">        heap.offer(<span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">int</span> ugly = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> curr = heap.poll();</span><br><span class="line">            ugly = (<span class="keyword">int</span>) curr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> factor : factors)&#123;</span><br><span class="line">                <span class="keyword">long</span> next = curr * factor;</span><br><span class="line">                <span class="keyword">if</span>(seen.add(next))&#123; </span><br><span class="line">                    heap.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ugly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(nlogn)</li><li>空间复杂度O(n)</li></ul><p><strong>方法二：动态规划</strong></p><p>在方法一中，我们存储了较多的丑数，导致空间复杂度较高。我们可以使用三个指针来指向最小的三个丑数。</p><p>定义数组 dp，dp[i] 表示第 i 个丑数，第 n 个丑数为 dp[n]，dp[1] = 1。</p><p>定义三个指针 p2，p3，p5，下一个丑数是当前指针指向的凑数乘以对应的质因数。下一个丑数分别为，2 * p2, 3 * p3, 5 * p5，我们取这三个数的最小值，然后将使用过的指针加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num2 = dp[p2] * <span class="number">2</span>, num3 = dp[p3] * <span class="number">3</span>, num5 = dp[p5] * <span class="number">5</span>;</span><br><span class="line">            <span class="comment">//取三个数中的最小值</span></span><br><span class="line">            dp[i] = Math.min(Math.min(num2, num3), num5);</span><br><span class="line">            <span class="comment">//将使用过的指针加一</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == num2)&#123;</span><br><span class="line">                ++p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == num3)&#123;</span><br><span class="line">                ++p3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == num5)&#123;</span><br><span class="line">                ++p5;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;264-丑数-II&quot;&gt;&lt;a href=&quot;#264-丑数-II&quot; class=&quot;headerlink&quot; title=&quot;264. 丑数 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ugly-number-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;264. 丑数 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，请你找出并返回第 &lt;code&gt;n&lt;/code&gt; 个 &lt;strong&gt;丑数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;丑数&lt;/strong&gt; 就是只包含质因数 &lt;code&gt;2&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt; 和/或 &lt;code&gt;5&lt;/code&gt; 的正整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组II</title>
    <link href="https://hoo334.github.io/2021/04/07/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/"/>
    <id>https://hoo334.github.io/2021/04/07/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/</id>
    <published>2021-04-07T01:29:14.000Z</published>
    <updated>2021-04-09T02:11:19.306Z</updated>
    
    <content type="html"><![CDATA[<h4 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></h4><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 5000</code></p></li><li><p><code>-104 &lt;= nums[i] &lt;= 104</code></p></li><li><p>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</p></li><li><p><code>-104 &lt;= target &lt;= 104</code></p><p><strong>进阶：</strong></p></li><li><p>这是 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">搜索旋转排序数组</a> 的延伸题目，本题中的 <code>nums</code> 可能包含重复元素。</p></li><li><p>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p></li></ul><p><strong>方法一：二分查找</strong></p><p>可以先查看题解<a href="https://hoo334.github.io/2020/04/27/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">搜索旋转排序数组</a>，对于数组中有重复元素的情况，二分查找可能会有<code>nums[l] = nums[mid] = nums[r]</code>,此时我们无法判断区间<code>[l, mid]</code>和 <code>[mid + 1, r]</code>哪个是有序的。</p><p>例如 <code>nums =[3,1,2,3,3,3,3]</code> ,target = 2，首次二分时，无法判断区间<code>[0,3]</code>和<code>[4,6]</code></p><p>哪个是有序的。对于这种情况，我们智能将当前二分区间左边界加一，右边界减一，然后在新区间上继续二分查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当三个数都相等时，左边界加一，右边界减一</span></span><br><span class="line">            <span class="keyword">if</span> (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;<span class="comment">//左边界有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<span class="comment">//mid 在有序部分</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//mid 不在有序部分</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//右边界有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;  <span class="comment">//mid 在有序部分</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//mid 不在有序部分</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(logN)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;81-搜索旋转排序数组-II&quot;&gt;&lt;a href=&quot;#81-搜索旋转排序数组-II&quot; class=&quot;headerlink&quot; title=&quot;81. 搜索旋转排序数组 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;81. 搜索旋转排序数组 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;已知存在一个按非降序排列的整数数组 &lt;code&gt;nums&lt;/code&gt; ，数组中的值不必互不相同。&lt;/p&gt;
&lt;p&gt;在传递给函数之前，&lt;code&gt;nums&lt;/code&gt; 在预先未知的某个下标 &lt;code&gt;k&lt;/code&gt;（&lt;code&gt;0 &amp;lt;= k &amp;lt; nums.length&lt;/code&gt;）上进行了 &lt;strong&gt;旋转&lt;/strong&gt; ，使数组变为 &lt;code&gt;[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]&lt;/code&gt;（下标 &lt;strong&gt;从 0 开始&lt;/strong&gt; 计数）。例如， &lt;code&gt;[0,1,2,4,4,4,5,6,6,7]&lt;/code&gt; 在下标 &lt;code&gt;5&lt;/code&gt; 处经旋转后可能变为 &lt;code&gt;[4,5,6,6,7,0,1,2,4,4]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;给你 &lt;strong&gt;旋转后&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;target&lt;/code&gt; ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 &lt;code&gt;nums&lt;/code&gt; 中存在这个目标值 &lt;code&gt;target&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>森林中的兔子</title>
    <link href="https://hoo334.github.io/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/"/>
    <id>https://hoo334.github.io/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/</id>
    <published>2021-04-04T01:57:00.000Z</published>
    <updated>2021-04-04T02:11:20.779Z</updated>
    
    <content type="html"><![CDATA[<h4 id="781-森林中的兔子"><a href="#781-森林中的兔子" class="headerlink" title="781. 森林中的兔子"></a><a href="https://leetcode-cn.com/problems/rabbits-in-forest/" target="_blank" rel="noopener">781. 森林中的兔子</a></h4><p>森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 <code>answers</code> 数组里。</p><p>返回森林中兔子的最少数量。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: answers &#x3D; [1, 1, 2]</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">两只回答了 &quot;1&quot; 的兔子可能有相同的颜色，设为红色。</span><br><span class="line">之后回答了 &quot;2&quot; 的兔子不会是红色，否则他们的回答会相互矛盾。</span><br><span class="line">设回答了 &quot;2&quot; 的兔子为蓝色。</span><br><span class="line">此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。</span><br><span class="line">因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。</span><br><span class="line"></span><br><span class="line">输入: answers &#x3D; [10, 10, 10]</span><br><span class="line">输出: 11</span><br><span class="line"></span><br><span class="line">输入: answers &#x3D; []</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li><code>answers</code> 的长度最大为<code>1000</code>。</li><li><code>answers[i]</code> 是在 <code>[0, 999]</code> 范围内的整数。</li></ol><p><strong>方法一：贪心</strong></p><p>两只相同颜色的兔子看到的其他同色兔子数必然是相同的。反之，若两只兔子看到的其他同色兔子数不同，那么这两只兔子颜色也不同。</p><p>因此，将 answer 中值相同的元素分为一组，对于每一组，计算出兔子的最少数量，然后将所有组的计算结果累加，就是最终的答案。</p><p>例如，现在有 13 只兔子回答 5，可以肯定至少有 3 种颜色的兔子。假设一只蓝色兔子回答 5 ，那么还有 5 只蓝色兔子；假设还有一只红色兔子回答 5 ，那么还有 5 只红色兔子；为了最小化可能的兔子数量，我们假设这 12 只兔子都在这 13 只兔子中。还剩下 1 只其他颜色兔子回答 5 ，那么其他颜色的兔子也为 5 只。最少会有 18 只兔子。</p><p>一般如果有 x 只兔子回答 y，则至少有 ceil(x / (y  + 1))种不同的颜色，且每种颜色有 y  + 1 只兔子，因此兔子数至少为<br>$$<br>\lceil \frac{x}{y + 1}\rceil * (y + 1)<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRabbits</span><span class="params">(<span class="keyword">int</span>[] answers)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y : answers)&#123;</span><br><span class="line">            count.put(y, count.getOrDefault(y, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> y = entry.getKey(), x = entry.getValue();</span><br><span class="line">            ans += (x + y) / (y + <span class="number">1</span>) * (y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;781-森林中的兔子&quot;&gt;&lt;a href=&quot;#781-森林中的兔子&quot; class=&quot;headerlink&quot; title=&quot;781. 森林中的兔子&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rabbits-in-forest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;781. 森林中的兔子&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 &lt;code&gt;answers&lt;/code&gt; 数组里。&lt;/p&gt;
&lt;p&gt;返回森林中兔子的最少数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="贪心" scheme="https://hoo334.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>最长公共子序列</title>
    <link href="https://hoo334.github.io/2021/04/03/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://hoo334.github.io/2021/04/03/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2021-04-03T12:00:52.000Z</published>
    <updated>2021-04-23T01:28:57.107Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h4><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><p>我们自顶向下考虑这个问题，以示例 1 为例：</p><ol><li><p>text1 的最后一个字符等于 text2 的最后一个字符，所以它们的最长公共子序列长度为 “abcd” 和 “ac” 的公共子序列长度 + 1。</p></li><li><p>问题转换为求 “abcd” 和 “ac” 的公共子序列长度，此时两个字符串末尾数字不相等，我们也可求 text1 的子串 “abc” 和 text2 “ac” 的公共子序列长度，也可求 text1 “abd” 和 text2的子串 “a”的公共子序列长度，结果为这两个公共子序列长度的最大值。</p></li><li><p>继续这个操作直到两个字符串为空。</p></li></ol><p>我们可以写出 dp：<br>$$<br>dp[i][j] =dp[i - 1][j - 1] + 1, \ text1[i] = text2[j] \<br>$$<br>$$<br>dp[i][j] = Math.max(dp[i - 1][j],\  dp[i][j - 1]), \ text1[i] \neq text2[j] \<br>$$</p><p><code>dp[i][j]</code>代表字符串 text1[0 … i - 1]，和 text2[0 … j - 1]的最长公共子序列，当 i = 0 或 j = 0 时，<code>dp[i][j] = 0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(mn)，m 和 n 分别为两个字符串的长度。</li><li>空间复杂度O(mn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1143-最长公共子序列&quot;&gt;&lt;a href=&quot;#1143-最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;1143. 最长公共子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-common-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1143. 最长公共子序列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定两个字符串 &lt;code&gt;text1&lt;/code&gt; 和 &lt;code&gt;text2&lt;/code&gt;，返回这两个字符串的最长 &lt;strong&gt;公共子序列&lt;/strong&gt; 的长度。如果不存在 &lt;strong&gt;公共子序列&lt;/strong&gt; ，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;一个字符串的 &lt;strong&gt;子序列&lt;/strong&gt; 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;&amp;quot;ace&amp;quot;&lt;/code&gt; 是 &lt;code&gt;&amp;quot;abcde&amp;quot;&lt;/code&gt; 的子序列，但 &lt;code&gt;&amp;quot;aec&amp;quot;&lt;/code&gt; 不是 &lt;code&gt;&amp;quot;abcde&amp;quot;&lt;/code&gt; 的子序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个字符串的 &lt;strong&gt;公共子序列&lt;/strong&gt; 是这两个字符串所共同拥有的子序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>直方图的水量</title>
    <link href="https://hoo334.github.io/2021/04/02/%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/"/>
    <id>https://hoo334.github.io/2021/04/02/%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/</id>
    <published>2021-04-02T02:21:04.000Z</published>
    <updated>2021-04-02T02:47:51.979Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题-17-21-直方图的水量"><a href="#面试题-17-21-直方图的水量" class="headerlink" title="面试题 17.21. 直方图的水量"></a><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/" target="_blank" rel="noopener">面试题 17.21. 直方图的水量</a></h4><p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 </p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>方法一：暴力</strong></p><p>对于下标 i ，水能达到的最大高度等于下标 i 两边的最大高度的最小值。下标 i 处能接的水能到达的最大高度减去 height[i]。</p><p>对于每个下标 i ，我们直接搜索其左边和右边的最大高度，取其中的最小值减去 height[i]，即是位置 i 能存的水量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> leftMax = height[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[j] &gt; leftMax)&#123;</span><br><span class="line">                    leftMax = height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> rightMax = height[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[j] &gt; rightMax)&#123;</span><br><span class="line">                    rightMax = height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Math.min(leftMax, rightMax) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(1)</li></ul><p><strong>方法二：动态规划</strong></p><p>我们使用两个数组 leftMax 和 rightMax，来存储左侧最小值和右侧最小值。leftMax[i] 表示下标 i 及其左边的位置中，height 的最大高度，rightMax[i]表示下标 i 及其右边的位置中，height的最大高度。</p><p>leftMax[0] = height[0]，rightMax[n - 1]  = height[n - 1]。最左边元素左侧没有比它更大的元素，最右边元素右侧没有比它更大的元素。<br>$$<br>leftMax[i] = max(leftMax[i - 1], height[i])\ \ \ 1 \leq i \leq n - 1<br>$$</p><p>$$<br>rightMax[i] = max(rightMax[i + 1],height[i])\ \ \ 0 \leq i \leq n - 2<br>$$</p><p>下标 i 处能接的水量为 min(leftMax[i], rightMax[i]) - height[i] 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            rightMax[i] = Math.max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans += Math.min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul><p><strong>方法三：双指针</strong></p><p>注意到下标 i 处能接的水量由 leftMax[i] 和 rightMax[i] 中的最小值决定。由于数组leftMax 是</p><p>从左往右计算，数组rightMax 是从右往左计算，因此可以使用双指针和两个标量代替两个数组。</p><p>维护两个指针 left 和 right，以及两个变量 leftMax 和 rightMax，初始时 left = 0， right = n - 1，leftMax = 0，rightMax = 0，在移动指针的过程中维护两个变量 leftMax 和 rightMax 的值。</p><p>当指针没有相遇时，进行如下操作：</p><ul><li>使用 height[left] 和 height[right] 的值更新 leftMax  和 rightMax 的值。</li><li>如果 <strong>height[left] &lt; height[right]</strong>，则必有 <strong>leftMax &lt; rightMax</strong>,下标 <strong>left</strong> 处能接的水量等于 <strong>leftMax - height[left]</strong>,将数量加入结果中，<strong>left++</strong></li><li>如果 <strong>height[left] &gt;= height[right]</strong>，则必有 <strong>leftMax &gt;= rightMax</strong>,下标 <strong>right</strong>处能接的水量等于 <strong>rightMax - height[right]</strong>,将数量加入结果中，<strong>right–</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;面试题-17-21-直方图的水量&quot;&gt;&lt;a href=&quot;#面试题-17-21-直方图的水量&quot; class=&quot;headerlink&quot; title=&quot;面试题 17.21. 直方图的水量&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/volume-of-histogram-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题 17.21. 直方图的水量&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="双指针，Leetcode Hard" scheme="https://hoo334.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%8CLeetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>笨阶乘</title>
    <link href="https://hoo334.github.io/2021/04/01/%E7%AC%A8%E9%98%B6%E4%B9%98/"/>
    <id>https://hoo334.github.io/2021/04/01/%E7%AC%A8%E9%98%B6%E4%B9%98/</id>
    <published>2021-04-01T02:32:40.000Z</published>
    <updated>2021-04-01T02:39:26.881Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1006-笨阶乘"><a href="#1006-笨阶乘" class="headerlink" title="1006. 笨阶乘"></a><a href="https://leetcode-cn.com/problems/clumsy-factorial/" target="_blank" rel="noopener">1006. 笨阶乘</a></h4><p>通常，正整数 <code>n</code> 的阶乘是所有小于或等于 <code>n</code> 的正整数的乘积。例如，<code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</code>。</p><p>相反，我们设计了一个笨阶乘 <code>clumsy</code>：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。</p><p>例如，<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p><p>另外，我们使用的除法是地板除法（<em>floor division</em>），所以 <code>10 * 9 / 8</code> 等于 <code>11</code>。这保证结果是一个整数。</p><p>实现上面定义的笨函数：给定一个整数 <code>N</code>，它返回 <code>N</code> 的笨阶乘。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：7</span><br><span class="line">解释：7 &#x3D; 4 * 3 &#x2F; 2 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：10</span><br><span class="line">输出：12</span><br><span class="line">解释：12 &#x3D; 10 * 9 &#x2F; 8 + 7 - 6 * 5 &#x2F; 4 + 3 - 2 * 1</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li><code>1 &lt;= N &lt;= 10000</code></li><li><code>-2^31 &lt;= answer &lt;= 2^31 - 1</code> （答案保证符合 32 位整数。）</li></ol><p><strong>方法一：使用栈模拟</strong></p><p>运算优先级是先乘除后加减。我们可以从 N 开始，枚举N - 1，N - 2 直到 1，枚举这些数的时候，认为它们之前的操作符按乘、除、加、减交替进行。</p><ul><li>出现乘除法是，我们可以把栈顶元素去除，与当前的 N 进行乘除法运算，并将结果重新压入栈中</li><li>出现加减法是，把减法视为加上一个数的相反数，然后压入栈，等待以后遇见乘除法时取出。</li></ul><p>最后将栈中所有元素相加得到答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clumsy</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(N);</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(N != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                stack.push(stack.pop() * N);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index % <span class="number">4</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                stack.push(stack.pop() / N);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index % <span class="number">4</span> == <span class="number">2</span>)&#123;</span><br><span class="line">                stack.push(N);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(-N);</span><br><span class="line">            &#125;</span><br><span class="line">            --N;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            ret += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1006-笨阶乘&quot;&gt;&lt;a href=&quot;#1006-笨阶乘&quot; class=&quot;headerlink&quot; title=&quot;1006. 笨阶乘&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/clumsy-factorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1006. 笨阶乘&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;通常，正整数 &lt;code&gt;n&lt;/code&gt; 的阶乘是所有小于或等于 &lt;code&gt;n&lt;/code&gt; 的正整数的乘积。例如，&lt;code&gt;factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;相反，我们设计了一个笨阶乘 &lt;code&gt;clumsy&lt;/code&gt;：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1&lt;/code&gt;。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。&lt;/p&gt;
&lt;p&gt;另外，我们使用的除法是地板除法（&lt;em&gt;floor division&lt;/em&gt;），所以 &lt;code&gt;10 * 9 / 8&lt;/code&gt; 等于 &lt;code&gt;11&lt;/code&gt;。这保证结果是一个整数。&lt;/p&gt;
&lt;p&gt;实现上面定义的笨函数：给定一个整数 &lt;code&gt;N&lt;/code&gt;，它返回 &lt;code&gt;N&lt;/code&gt; 的笨阶乘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>子集II</title>
    <link href="https://hoo334.github.io/2021/04/01/%E5%AD%90%E9%9B%86II/"/>
    <id>https://hoo334.github.io/2021/04/01/%E5%AD%90%E9%9B%86II/</id>
    <published>2021-04-01T01:36:02.000Z</published>
    <updated>2021-04-01T02:33:52.025Z</updated>
    
    <content type="html"><![CDATA[<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></h4><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure> <a id="more"></a><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><p><strong>方法一：回溯</strong></p><p>在阅读此题解前可查看前置问题<a href="https://hoo334.github.io/2020/09/20/%E5%AD%90%E9%9B%86/">子集</a>。</p><p>以数组<code>[1,2,3]</code>为例，在子集问题中我们的搜索路径如下图所示：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210401094806671.png" alt="image-20210401094806671"></p><p>类似的，我们画出数组<code>[1,2,2]</code>的搜索路径：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210401095255560.png" alt="image-20210401095255560"></p><p>可以看到[1,2] 和 [2] 出现了两次，我们在搜索的过程中需要剪枝。并且，nums 数组必须排序才能保证相同的解只出现在同一层。</p><p>下面以不排序的数组 <code>[2,3,2]</code>为例，画出搜索路径：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210401100627492.png" alt="image-20210401100627492"></p><p>在遍历到第二个<code>[2,3]</code>时，我们发现不了前面是否遍历过<code>[2,3]</code>这个子集，排序后搜索路径为：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210401100510220.png" alt="image-20210401100510220"></p><p>我们只用保存前一个遍历过的数字，再后续的遍历过程中，如果遇到相同的数字直接跳过即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = -<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != pre)&#123;</span><br><span class="line">                path.addLast(nums[i]);</span><br><span class="line">                dfs(nums, i + <span class="number">1</span>, path);</span><br><span class="line">                path.removeLast();</span><br><span class="line">                pre = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n * 2 ^ n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;90-子集-II&quot;&gt;&lt;a href=&quot;#90-子集-II&quot; class=&quot;headerlink&quot; title=&quot;90. 子集 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/subsets-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;90. 子集 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;解集 &lt;strong&gt;不能&lt;/strong&gt; 包含重复的子集。返回的解集中，子集可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [1,2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[],[0]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="回溯" scheme="https://hoo334.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>螺旋矩阵</title>
    <link href="https://hoo334.github.io/2021/03/15/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>https://hoo334.github.io/2021/03/15/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</id>
    <published>2021-03-15T01:52:21.000Z</published>
    <updated>2021-03-15T02:30:28.607Z</updated>
    
    <content type="html"><![CDATA[<h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></h4><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p> <a id="more"></a><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210315095358506.png" alt="image-20210315095358506"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210315095445985.png" alt="image-20210315095445985"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><p><strong>方法一：模拟</strong></p><p>我们可以确定箭头方向顺序为：向右、向下、向左、向上。使用一个数组来保存访问过的元素，在遍历过程中，如果遇到数组边界或已经访问过的元素，改变到下一个方向，继续访问。直到结果数组中的元素个数等于矩阵中元素个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; order = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//特殊情况处理</span></span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> order;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,&#123;<span class="number">1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> total = rows * cols;</span><br><span class="line">        <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++)&#123;</span><br><span class="line">            order.add(matrix[row][col]);</span><br><span class="line">            visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>], nextCol = col + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//遇到边界或已经访问过的元素，改变方向</span></span><br><span class="line">            <span class="keyword">if</span>(nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextCol &lt; <span class="number">0</span> || nextCol &gt;= cols || visited[nextRow][nextCol])&#123;</span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            col += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)，n 为矩阵中元素个数</li><li>空间复杂度O(n)</li></ul><p><strong>方法二：按层遍历</strong></p><p>将矩阵看成若干层，依次输出每一层的元素。</p><p>对于一个矩阵，我们可以使用四个点来确定其范围，分别是左上角[top, left]，右上角[top, right]，左下角[bottom, left]，右下角[bottom, right]。</p><p>访问当前层的元素顺序分别为：</p><ol><li><p>[top][left] … [top][right]</p></li><li><p>[top + 1][right] … [bottom][right]</p></li><li><p>[bottom][right - 1] … [bottom][left]</p></li><li><p>[bottom - 1][left] … [top + 1][left]</p></li></ol><p>需要注意的是，当矩阵为一行元素（top == bottom）时，步骤1、3会造成元素重复访问;当矩阵为一列元素（left == right）时，步骤2、4 会造成元素重复访问。所以需要在访问步骤 3、4外面加上 <code>top &lt; bottom &amp;&amp; left &lt; right</code>限制，来使这两个重复访问只执行一次。</p><p>要访问下一层元素，将 left 和 top 加一，right 和 bottom 减一即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; order = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> order;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = cols - <span class="number">1</span>, bottom = rows - <span class="number">1</span>, top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">                order.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++)&#123;</span><br><span class="line">                order.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//访问限制</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right &amp;&amp; top &lt; bottom)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; --i)&#123;</span><br><span class="line">                    order.add(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt;= top + <span class="number">1</span>; --i)&#123;</span><br><span class="line">                    order.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ++top;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">            --bottom;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)，n 为矩阵中元素个数</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;54-螺旋矩阵&quot;&gt;&lt;a href=&quot;#54-螺旋矩阵&quot; class=&quot;headerlink&quot; title=&quot;54. 螺旋矩阵&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/spiral-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;54. 螺旋矩阵&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个 &lt;code&gt;m&lt;/code&gt; 行 &lt;code&gt;n&lt;/code&gt; 列的矩阵 &lt;code&gt;matrix&lt;/code&gt; ，请按照 &lt;strong&gt;顺时针螺旋顺序&lt;/strong&gt; ，返回矩阵中的所有元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>设计哈希集合</title>
    <link href="https://hoo334.github.io/2021/03/13/%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/"/>
    <id>https://hoo334.github.io/2021/03/13/%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/</id>
    <published>2021-03-13T01:23:34.000Z</published>
    <updated>2021-03-13T01:46:32.372Z</updated>
    
    <content type="html"><![CDATA[<h4 id="705-设计哈希集合"><a href="#705-设计哈希集合" class="headerlink" title="705. 设计哈希集合"></a><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></h4><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p><p>实现 <code>MyHashSet</code> 类：</p><ul><li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li><li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li><li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li></ul><a id="more"></a><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;]</span><br><span class="line">[[], [1], [2], [1], [3], [2], [2], [2], [2]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, true, false, null, true, null, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyHashSet myHashSet &#x3D; new MyHashSet();</span><br><span class="line">myHashSet.add(1);      &#x2F;&#x2F; set &#x3D; [1]</span><br><span class="line">myHashSet.add(2);      &#x2F;&#x2F; set &#x3D; [1, 2]</span><br><span class="line">myHashSet.contains(1); &#x2F;&#x2F; 返回 True</span><br><span class="line">myHashSet.contains(3); &#x2F;&#x2F; 返回 False ，（未找到）</span><br><span class="line">myHashSet.add(2);      &#x2F;&#x2F; set &#x3D; [1, 2]</span><br><span class="line">myHashSet.contains(2); &#x2F;&#x2F; 返回 True</span><br><span class="line">myHashSet.remove(2);   &#x2F;&#x2F; set &#x3D; [1]</span><br><span class="line">myHashSet.contains(2); &#x2F;&#x2F; 返回 False ，（已移除）</span><br></pre></td></tr></table></figure><pre><code>**提示：**</code></pre><ul><li><code>0 &lt;= key &lt;= 106</code></li><li>最多调用 <code>104</code> 次 <code>add</code>、<code>remove</code> 和 <code>contains</code> 。</li></ul><p><strong>方法一：链地址法</strong></p><p>设哈希表的大小为 base，hash 函数为<code>hash(x) = x mod base</code>,base 取质数 769。</p><p>数组中每个位置是一个链表，当计算出哈希值后，就插入对应链表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE = <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList[BASE];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++)&#123;</span><br><span class="line">            data[i] = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(element == key)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].offerLast(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(element == key)&#123;</span><br><span class="line">                data[h].remove(element);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iter = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">            Integer element = iter.next();</span><br><span class="line">            <span class="keyword">if</span>(element == key)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % BASE;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n/b)，n为哈希表中的元素数量，b 为链表的数量，假设链表长度为均匀的。</li><li>空间复杂度O(n + b)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;705-设计哈希集合&quot;&gt;&lt;a href=&quot;#705-设计哈希集合&quot; class=&quot;headerlink&quot; title=&quot;705. 设计哈希集合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/design-hashset/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;705. 设计哈希集合&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;不使用任何内建的哈希表库设计一个哈希集合（HashSet）。&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;MyHashSet&lt;/code&gt; 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void add(key)&lt;/code&gt; 向哈希集合中插入值 &lt;code&gt;key&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool contains(key)&lt;/code&gt; 返回哈希集合中是否存在这个值 &lt;code&gt;key&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void remove(key)&lt;/code&gt; 将给定值 &lt;code&gt;key&lt;/code&gt; 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>验证二叉树的前序序列化</title>
    <link href="https://hoo334.github.io/2021/03/12/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://hoo334.github.io/2021/03/12/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-03-12T03:01:25.000Z</published>
    <updated>2021-03-12T03:18:32.324Z</updated>
    
    <content type="html"><![CDATA[<h4 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/" target="_blank" rel="noopener">331. 验证二叉树的前序序列化</a></h4><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">&#x2F; \ &#x2F; \   &#x2F; \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>方法一：递归</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        String[] arr = preorder.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> helper(arr) &amp;&amp; i == arr.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> i == arr.length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!arr[i].equals(<span class="string">"#"</span>) &amp;&amp; i + <span class="number">2</span> &lt; len</span><br><span class="line">                &amp;&amp; arr[i + <span class="number">1</span>].equals(<span class="string">"#"</span>) &amp;&amp; arr[i + <span class="number">2</span>].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">2</span> &gt;= len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> left = <span class="keyword">false</span>, right = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            left = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = helper(arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            right = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = helper(arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：栈</strong></p><p>我们定义一个概念叫做槽位，一个槽位可被看作<strong>当前二叉树中正在等待被节点填充</strong>的那些位置。</p><p>每当遇到一个结点时：</p><ul><li>遇到空结点，消耗一个槽位；</li><li>遇到非空结点，消耗一个槽位，增加两个子节点的槽位。</li></ul><p>此外还需要对根节点进行处理。</p><p>我们使用栈来维护槽位的变化，栈中的每个元素代表了对应节点处<strong>剩余槽位的数量</strong>，栈顶元素代表下一步可用的槽位。每当遇到空结点时，仅将栈顶元素减 1 ，遇到非空节点时，将栈顶元素减 1 后，再向栈中压入一个 2 。无论何时，如果栈顶元素变为 0，立刻将栈顶弹出。结束后，如果栈为空，则序列合法，在遍历过程中，如果槽位数量不足，则序列不合法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(preorder.charAt(i) == <span class="string">','</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(preorder.charAt(i) == <span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(top &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    stack.push(top);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; n &amp;&amp; preorder.charAt(i) != <span class="string">','</span>)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(top &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    stack.push(top);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul><p><strong>方法三：计数</strong></p><p>如果将方法二中栈中元素看成一个整体，即所有剩余槽位的数量，也能维护槽位的变化。因此我们只用维护一个计数器，代表栈中所有元素之和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slots = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slots == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(preorder.charAt(i) == <span class="string">','</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(preorder.charAt(i) == <span class="string">'#'</span>)&#123;</span><br><span class="line">                slots--;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; n &amp;&amp; preorder.charAt(i) != <span class="string">','</span>)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                slots++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slots == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;331-验证二叉树的前序序列化&quot;&gt;&lt;a href=&quot;#331-验证二叉树的前序序列化&quot; class=&quot;headerlink&quot; title=&quot;331. 验证二叉树的前序序列化&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;331. 验证二叉树的前序序列化&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 &lt;code&gt;#&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>基本计算器II</title>
    <link href="https://hoo334.github.io/2021/03/11/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II/"/>
    <id>https://hoo334.github.io/2021/03/11/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II/</id>
    <published>2021-03-11T01:44:12.000Z</published>
    <updated>2021-03-11T01:55:51.575Z</updated>
    
    <content type="html"><![CDATA[<h4 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. 基本计算器 II</a></h4><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot; 3&#x2F;2 &quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot; 3+5 &#x2F; 2 &quot;</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由整数和算符 <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> 组成，中间由一些空格隔开</li><li><code>s</code> 表示一个 <strong>有效表达式</strong></li><li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 231 - 1]</code> 内</li><li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li></ul><p>此题没有括号，乘除优先于加减计算，不妨先进行所有的乘除运算，并将这些乘除运算后的整数放回原来的位置，之后整个表达式的值，就等于一系列整数加减后的值。</p><p>我们可以使用一个栈来保存进行乘除运算后的整数的值。对于加减号后的数字，直接压入栈中；对于乘除号后的数字，直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//第一个数字前的符号设置为 + ，直接将第一个数入栈</span></span><br><span class="line">        <span class="keyword">char</span> preSign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//将连续的数字字符转换为整数</span></span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前字符不是数字或空格，或者当前是最后一个字符，计算最后结果</span></span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != <span class="string">' '</span> || i == n - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">switch</span> (preSign) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: stack.push(num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: stack.push(-num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'*'</span>: stack.push(stack.pop() * num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>: stack.push(stack.pop() / num); <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//更新符号和数字</span></span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            preSign = s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//将所有数字相加，得到最后结果</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            ans += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;227-基本计算器-II&quot;&gt;&lt;a href=&quot;#227-基本计算器-II&quot; class=&quot;headerlink&quot; title=&quot;227. 基本计算器 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/basic-calculator-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;227. 基本计算器 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个字符串表达式 &lt;code&gt;s&lt;/code&gt; ，请你实现一个基本计算器来计算并返回它的值。&lt;/p&gt;
&lt;p&gt;整数除法仅保留整数部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置解析</title>
    <link href="https://hoo334.github.io/2021/03/10/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://hoo334.github.io/2021/03/10/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2021-03-10T12:10:52.000Z</published>
    <updated>2021-03-12T03:01:06.137Z</updated>
    
    <content type="html"><![CDATA[<p>使用Spring Initializer 生成一个最简单的 Web 应用，打开启动类。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Demo01Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击 @SpringBootApplication ，我们可以看到如下注解信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br></pre></td></tr></table></figure><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>@SpringBootConfiguration 表示一个类提供Spring Boot应用程序。它的作用等同于@Configuration，以便可以自动找到配置。应用程序应该只包含<strong>一个</strong>@SpringBootConfiguration ，通常的Spring Boot应用程序将从@SpringBootApplication自动继承它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = Configuration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">boolean</span> <span class="title">proxyBeanMethods</span>() <span class="title">default</span> <span class="title">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxyBeanMethods 方法指定是否应代理@Bean方法：<strong>默认为 Full模式</strong>，保证每个@Bean方法被调用多少次返回的Bean都是单实例的；也可为 Lite 模式（值为 false），每次调用 @Bean 方法都会返回新的实例。<br>如果配置类 Bean 之间有依赖关系，则强制使用 Full 模式。<br>新建 MyConfig 配置类来测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123; <span class="comment">//User 为一个POJO，这里省略定义</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"li"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在 Main 方法中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyConfig bean = run.getBean(MyConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">User u1 = bean.getUser();</span><br><span class="line">User u2 = bean.getUser();</span><br><span class="line">System.out.println(<span class="string">"U1 == U2? "</span> + (u1 == u2));</span><br></pre></td></tr></table></figure><p>运行，可以看到结果为 true，在用户代码中直接调用@Bean方法的情况下也返回共享的单例bean实例。</p><p>接下来为 <code>@Configuration</code> 添加配置<code>@Configuration(proxyBeanMethods = false)</code>,再次运行，可以看到结果为 false，返回了两个不同的实例。</p><p>接下来测试组建依赖，修改 MyConfig 为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User(<span class="string">"li"</span>, <span class="number">18</span>);</span><br><span class="line">        u.setPet(getPet());</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">"tom"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将 proxyBeanMethods 改为 false，IDEA 将会提示“使用 Bean 标记的方法被 proxyBeanMethods 为 false 的配置类调用，将其改为 true 或者使用依赖注入。”</p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>替换默认的 Filter，替换为AutoConfigurationExcludeFilter</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol><li><p>@AutoConfigurationPackage<br>使用 @AutoConfigurationPackage 来注册包。如果没有指定 base packages 或 base package classes，则注册带有@AutoConfigurationPackage 的类所在的包。</p></li><li><p>@Import(AutoConfigurationPackages.Registrar.class)<br>AutoConfigurationImportSelector 中有如下函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>找到 getAutoConfigurationEntry 定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//获取注解元信息</span></span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">       <span class="comment">//获取所有配置类</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"><span class="comment">//去掉重复的配置类，去掉需要排除的配置类，最终返回</span></span><br><span class="line">       configurations = removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最核心的方法是 getCandidateConfigurations ，用来获取所有的配置类，点击进入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">+ <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击进入 loadFactoryNames 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">ClassLoader classLoaderToUse = classLoader;</span><br><span class="line"><span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">classLoaderToUse = SpringFactoriesLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line">String factoryTypeName = factoryType.getName();</span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击进入 loadSpringFactories方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">String[] factoryImplementationNames =</span><br><span class="line">StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;())</span><br><span class="line">.add(factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打断点运行到 classLoader.getResource位置，我们可以看到 FACTORIES_RESOURCE_LOCATION 此时为<code>META-INF/spring.factories</code>,这里扫描系统中所有 <code>META-INF/spring.factories</code>位置的文件，spring-boot-autoconfigure-2.4.3.jar 中的 spring.factories 文件写死了 springboot 启动就给容器中加载所有的配置类（xxxxx AutoConfiguration）。</p><p>在 spring boot 启动过程中，所有的自动配置都是条件配置，以org.springframework.boot.autoconfigure.web.servlet 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(DispatcherServlet<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(<span class="title">ServletWebServerFactoryAutoConfiguration</span>.<span class="title">class</span>)</span></span><br></pre></td></tr></table></figure><p>@ConditionalOnClass(DispatcherServlet.class) 注解指定 只有 DispatcherServlet.class 在类路径中存在才自动配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(MultipartResolver<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">name</span> </span>= DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span></span><br><span class="line"><span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以自己配置 MultipartResolver，如果自行定义了这个 Bean，那么 spring boot 就会使用用户自定义的。</p><p>总结：</p><ul><li><p>SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration</p></li><li><p>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定</p></li><li><p>生效的配置类就会给容器中装配很多组件</p></li><li><p>只要容器中有这些组件，相当于这些功能就有了</p></li><li><p>定制化配置</p></li><li><ul><li>用户直接自己@Bean替换底层的组件</li><li>用户去看这个组件是获取的配置文件什么值就去修改。</li></ul></li></ul><p><strong>xxxxxAutoConfiguration —&gt; 组件  —&gt;</strong> <strong>xxxxProperties里面拿值  —-&gt; application.properties</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Spring Initializer 生成一个最简单的 Web 应用，打开启动类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://hoo334.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://hoo334.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>基本计算器</title>
    <link href="https://hoo334.github.io/2021/03/10/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>https://hoo334.github.io/2021/03/10/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2021-03-10T01:40:13.000Z</published>
    <updated>2021-03-10T01:56:32.819Z</updated>
    
    <content type="html"><![CDATA[<h4 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a><a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">224. 基本计算器</a></h4><p>实现一个基本的计算器来计算一个简单的字符串表达式 <code>s</code> 的值。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot; 2-1 + 2 &quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 表示一个有效的表达式</li></ul><p><strong>方法一：栈</strong></p><p>基本计算器只包含加减法，括号对一个数只影响其正负。以示例三为例：</p><ul><li>数字 1 前面没有符号，记为 +1</li><li>数字 4 前面有一个 + 号，记为 +4</li><li>数字 5 和 数字 2 前面有两个 + 号，记为 +5，+2</li><li>数字 3 前面有一个 + 号（<strong>不包括（4 + 5 + 2）里的 + 号</strong>）和一个 - 号，记为 -3</li><li>数字 6 前面有一个 + 号，记为 +6</li><li>数字 8 前面有两个 + 号，记为 + 8</li></ul><p>将这些数字加起来，我们得到最终结果 23。</p><p>我们使用一个栈 ops 来记录当前位置所处的每个括号所共同形成的符号，同时使用 sign 来表示当前的符号（sign 为 1 代表正数）。</p><p>如果当前遇到了 + 号，当前符号为 ops.peek()；如果当前遇到了 - 号，当前符号为 - ops.peek()。</p><p>每当遇到 ( 时，都要将当前 sign 取值压入栈中；每当遇到 ）时，都从栈中弹出一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; ops = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        ops.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span>) &#123;</span><br><span class="line">                sign = ops.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'-'</span>) &#123;</span><br><span class="line">                sign = -ops.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                ops.push(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                ops.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//遇到一个数，直接加入结果</span></span><br><span class="line">                <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;224-基本计算器&quot;&gt;&lt;a href=&quot;#224-基本计算器&quot; class=&quot;headerlink&quot; title=&quot;224. 基本计算器&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/basic-calculator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;224. 基本计算器&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;实现一个基本的计算器来计算一个简单的字符串表达式 &lt;code&gt;s&lt;/code&gt; 的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>二维区域和检索-矩阵不可变</title>
    <link href="https://hoo334.github.io/2021/03/02/%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <id>https://hoo334.github.io/2021/03/02/%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/</id>
    <published>2021-03-02T01:48:24.000Z</published>
    <updated>2021-03-02T02:05:53.090Z</updated>
    
    <content type="html"><![CDATA[<h4 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">304. 二维区域和检索 - 矩阵不可变</a></h4><p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (<em>row</em>1, <em>col</em>1) ，右下角为 (<em>row</em>2, <em>col</em>2)。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210302095000679.png" alt="image-20210302095000679"><br>上图子矩阵左上角 (row1, col1) = <strong>(2, 1)</strong> ，右下角(row2, col2) = <strong>(4, 3)，</strong>该子矩形内元素的总和为 8。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D; [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>你可以假设矩阵不可变。</li><li>会多次调用 <em>sumRegion</em> 方法<em>。</em></li><li>你可以假设 <em>row</em>1 ≤ <em>row</em>2 且 <em>col</em>1 ≤ <em>col</em>2。</li></ol><p><strong>方法一：二维前缀和</strong></p><p>注意到矩阵不可变，我们可以使用二维数组保存数组的前缀和，然后就可以在O(1)时间复杂度内查到区域和。对于示例中的数组我们建立如下前缀和数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">000000</span><br><span class="line">0334810</span><br><span class="line">0814182427</span><br><span class="line">0917212836</span><br><span class="line">01322263449</span><br><span class="line">01423303858</span><br></pre></td></tr></table></figure><p>题中数组下标范围是<code>0 &lt;= row &lt; matrix.length</code>和<code>0 &lt;= col &lt; matrix[0].length</code>。子矩阵左上角(row1,col1)，右下角(row2,col2)。<code>子矩阵和 = sum[row2 + 1][col2 + 1] - sum[row2 + 1][col1] - sum[row1][col2 + 1] + sum[row1][col1]</code>。sum 数组多加一行一列是为了避免计算时下标是否越界判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length + <span class="number">1</span>][matrix[<span class="number">0</span>].length + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//计算 sum 数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sum.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; sum[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - sum[row1][col2 + <span class="number">1</span>] - sum[row2 + <span class="number">1</span>][col1] + sum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度，初始化O(mn)，查询O(1)，其中 m 和 n 分别为数组的行数和列数。</li><li>空间复杂度O(mn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;304-二维区域和检索-矩阵不可变&quot;&gt;&lt;a href=&quot;#304-二维区域和检索-矩阵不可变&quot; class=&quot;headerlink&quot; title=&quot;304. 二维区域和检索 - 矩阵不可变&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-2d-immutable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;304. 二维区域和检索 - 矩阵不可变&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (&lt;em&gt;row&lt;/em&gt;1, &lt;em&gt;col&lt;/em&gt;1) ，右下角为 (&lt;em&gt;row&lt;/em&gt;2, &lt;em&gt;col&lt;/em&gt;2)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/hoo334/picgo/raw/master//img/image-20210302095000679.png&quot; alt=&quot;image-20210302095000679&quot;&gt;&lt;br&gt;上图子矩阵左上角 (row1, col1) = &lt;strong&gt;(2, 1)&lt;/strong&gt; ，右下角(row2, col2) = &lt;strong&gt;(4, 3)，&lt;/strong&gt;该子矩形内元素的总和为 8。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>翻转图像</title>
    <link href="https://hoo334.github.io/2021/02/24/%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>https://hoo334.github.io/2021/02/24/%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2021-02-24T02:13:08.000Z</published>
    <updated>2021-02-24T02:21:39.724Z</updated>
    
    <content type="html"><![CDATA[<h4 id="832-翻转图像"><a href="#832-翻转图像" class="headerlink" title="832. 翻转图像"></a><a href="https://leetcode-cn.com/problems/flipping-an-image/" target="_blank" rel="noopener">832. 翻转图像</a></h4><p>给定一个二进制矩阵 <code>A</code>，我们想先水平翻转图像，然后反转图像并返回结果。</p><p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 <code>[1, 1, 0]</code> 的结果是 <code>[0, 1, 1]</code>。</p><p>反转图片的意思是图片中的 <code>0</code> 全部被 <code>1</code> 替换， <code>1</code> 全部被 <code>0</code> 替换。例如，反转 <code>[0, 1, 1]</code> 的结果是 <code>[1, 0, 0]</code>。</p><a id="more"></a><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">输出：[[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；</span><br><span class="line">     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；</span><br><span class="line">     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li><li><code>0 &lt;= A[i][j] &lt;= 1</code></li></ul><p><strong>方法一：双指针</strong></p><p>对于每一行元素，我们使用 left 和 right 指针来对该行元素进行水平翻转和反转操作。</p><table><thead><tr><th align="center"></th><th align="center">left</th><th align="center">right</th><th align="center">处理后left</th><th align="center">处理后right</th></tr></thead><tbody><tr><td align="center">①</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">②</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">③</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">④</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p>我们可以发现，当 left 和 right 指向的值相等时时，元素才需要变化，只用用该元素与 1 异或。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][left] == A[i][right])&#123;</span><br><span class="line">                    A[i][left] ^= <span class="number">1</span>;</span><br><span class="line">                    A[i][right] ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当一行元素个数为奇数时，需要将最中间的数翻转</span></span><br><span class="line">            <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">                A[i][left] ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;832-翻转图像&quot;&gt;&lt;a href=&quot;#832-翻转图像&quot; class=&quot;headerlink&quot; title=&quot;832. 翻转图像&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/flipping-an-image/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;832. 翻转图像&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二进制矩阵 &lt;code&gt;A&lt;/code&gt;，我们想先水平翻转图像，然后反转图像并返回结果。&lt;/p&gt;
&lt;p&gt;水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 &lt;code&gt;[1, 1, 0]&lt;/code&gt; 的结果是 &lt;code&gt;[0, 1, 1]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;反转图片的意思是图片中的 &lt;code&gt;0&lt;/code&gt; 全部被 &lt;code&gt;1&lt;/code&gt; 替换， &lt;code&gt;1&lt;/code&gt; 全部被 &lt;code&gt;0&lt;/code&gt; 替换。例如，反转 &lt;code&gt;[0, 1, 1]&lt;/code&gt; 的结果是 &lt;code&gt;[1, 0, 0]&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
</feed>
