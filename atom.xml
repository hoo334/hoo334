<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2020-07-22T06:28:16.842Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>寻找旋转排序数组中的最小值II</title>
    <link href="https://hoo334.github.io/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/"/>
    <id>https://hoo334.github.io/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/</id>
    <published>2020-07-22T03:06:19.000Z</published>
    <updated>2020-07-22T06:28:16.842Z</updated>
    
    <content type="html"><![CDATA[<h4 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a> 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li></ul><p>我们得到的旋转数组类似于下图，由两段单调递增的序列构成，右边序列的最大值小于等于左边序列的最小值。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200722142620638.png" alt="image-20200722142620638"></p><p>在二分查找过程中，我们有以下几种情况：</p><ol><li><p>左值 &lt; 中值，中值 &lt; 右值，最小值在左边，[中，右]范围内的值不可能为最小值，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">右</span><br><span class="line">中</span><br><span class="line">左</span><br></pre></td></tr></table></figure></li><li><p>左值 &lt; 中值，中值 &gt; 右值，最小值在右边，[左，中]范围内的值不可能为最小值，可以收缩左边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中</span><br><span class="line">左</span><br><span class="line">右</span><br></pre></td></tr></table></figure></li><li><p>左值 &gt; 中值，中值 &lt; 右值，最小值在左边界，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左</span><br><span class="line">右</span><br><span class="line">中</span><br></pre></td></tr></table></figure></li><li><p>中值 = 右值，最小值在左边界，右值重复(中值有可能不重复，例如 [3, 1, 1]，分别为左中右，收缩右边界变为 [3, 1])，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">左</span><br><span class="line">中   右</span><br></pre></td></tr></table></figure></li></ol><p>情况 1，3是一类，情况 2 是一类，情况 4 是一类：</p><ul><li>如果中值 &lt; 右值，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</li><li>如果中值 &gt; 右值，[左，中]范围内的值不可能为最小值，可以收缩左边界。</li><li>如果中值 = 右值，右值重复，可以收缩右边界。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>; <span class="comment">//左闭右闭区间，用右开区间不方便判断右值</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;<span class="comment">// left == right 结束</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[r])&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>; <span class="comment">//中值 &gt; 右值，中值不可能为最小值，左边界跳过mid</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])&#123;</span><br><span class="line">                r = mid;<span class="comment">//中值 &lt; 右值，中值可能为最小值，右边界只能取到 mid</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == nums[r])&#123;</span><br><span class="line">                --r;<span class="comment">//中值 = 右值，右值重复，右边界左移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平均时间复杂度O(log n)，当数组中数字全部相等时，最坏时间复杂度O(n)。</p><p>空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;154-寻找旋转排序数组中的最小值-II&quot;&gt;&lt;a href=&quot;#154-寻找旋转排序数组中的最小值-II&quot; class=&quot;headerlink&quot; title=&quot;154. 寻找旋转排序数组中的最小值 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;154. 寻找旋转排序数组中的最小值 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。&lt;/p&gt;
&lt;p&gt;请找出其中最小的元素。&lt;/p&gt;
&lt;p&gt;注意数组中可能存在重复的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>寻找旋转排列数组中的最小值</title>
    <link href="https://hoo334.github.io/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>https://hoo334.github.io/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</id>
    <published>2020-07-22T02:05:01.000Z</published>
    <updated>2020-07-22T06:27:13.437Z</updated>
    
    <content type="html"><![CDATA[<h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>使用二分查找，需要始终保持目标值在搜索范围内，并不断缩小左右边界。</p><p>我们得到的旋转数组类似于下图，为两段单调递增的序列构成，且右边序列最大值小于左边序列最小值。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200722142442327.png" alt="image-20200722142442327"></p><p>在二分查找过程中，我们有以下几种情况：</p><ol><li><p>左值 &lt; 中值，中值 &lt; 右值，最小值在左边，[中，右]范围内的值不可能为最小值，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">右</span><br><span class="line">中</span><br><span class="line">左</span><br></pre></td></tr></table></figure></li><li><p>左值 &lt; 中值，中值 &gt; 右值，最小值在右边，[左，中]范围内的值不可能为最小值，可以收缩左边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中</span><br><span class="line">左</span><br><span class="line">右</span><br></pre></td></tr></table></figure></li><li><p>左值 &gt; 中值，中值 &lt; 右值，最小值在左边界，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左</span><br><span class="line">右</span><br><span class="line">中</span><br></pre></td></tr></table></figure></li></ol><p>情况 1，3 是一类，情况 2 是另一类：</p><ul><li>如果中值 &lt; 右值，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</li><li>如果中值 &gt; 右值，[左，中]范围内的值不可能为最小值，可以收缩左边界。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>; <span class="comment">//左闭右闭区间，用右开区间不方便判断右值</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;<span class="comment">// left == right 结束</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[r])&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>; <span class="comment">//中值 &gt; 右值，中值不可能为最小值，左边界跳过mid</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])&#123;</span><br><span class="line">                r = mid;<span class="comment">//中值 &lt; 右值，中值可能为最小值，右边界只能取到 mid</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(log n)，空间复杂度O(1)。</p><p>参考：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;153-寻找旋转排序数组中的最小值&quot;&gt;&lt;a href=&quot;#153-寻找旋转排序数组中的最小值&quot; class=&quot;headerlink&quot; title=&quot;153. 寻找旋转排序数组中的最小值&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;153. 寻找旋转排序数组中的最小值&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。&lt;/p&gt;
&lt;p&gt;请找出其中最小的元素。&lt;/p&gt;
&lt;p&gt;你可以假设数组中不存在重复元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树II</title>
    <link href="https://hoo334.github.io/2020/07/21/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/"/>
    <id>https://hoo334.github.io/2020/07/21/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/</id>
    <published>2020-07-21T02:32:28.000Z</published>
    <updated>2020-07-21T03:50:13.902Z</updated>
    
    <content type="html"><![CDATA[<h4 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. 不同的二叉搜索树 II</a></h4><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p> <a id="more"></a><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 8</code></li></ul><p>我们枚举根结点的值为 i ，根据 BST 的性质，我们可以知道左子树的结点值集合为 [1 … i - 1]，右子树的结点值集合为 [i + 1 … n]。我们可以使用递归来建立子树。</p><p>我们定义 <code>generateTrees(start, end)</code>函数表示当前值的集合为 [start, end]，返回序列 [start, end]生成的所有可行的 BST。我们在 [start, end] 中枚举根结点 i ，将序列分为 [start, i - 1] 和 [i + 1, end] 递归地调用 generateTrees 函数。我们获得了所有的可行的右子树，最后一步，我们从左右子树集合中任选两课拼接到根结点上。</p><p>当 start &gt; end 时递归，BST 为空，返回空结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            allTrees.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> allTrees;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//枚举根结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">//得到左子树结点</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//得到右子树结点</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line"><span class="comment">//从左右子树结点集合中拿出两个结点连接到根结点</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left : leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right : rightTrees)&#123;</span><br><span class="line">                    TreeNode curTree = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    curTree.left = left;</span><br><span class="line">                    curTree.right = right;</span><br><span class="line">                    allTrees.add(curTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的结果存储了许多 BST 的根结点，我们以 n = 5， i = 3 为例来解释：</p><p>以  3 为根结点，左子树结点集合 为指向 1、2 的两个结点，右子树结点为指向 4、5 的两个结点，左右各取一个结点，新建一个根结点，生成 4 棵以 3 为根结点的 BST。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200721114003250.png" alt="image-20200721114003250"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;95-不同的二叉搜索树-II&quot;&gt;&lt;a href=&quot;#95-不同的二叉搜索树-II&quot; class=&quot;headerlink&quot; title=&quot;95. 不同的二叉搜索树 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-binary-search-trees-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;95. 不同的二叉搜索树 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，生成所有由 1 … &lt;em&gt;n&lt;/em&gt; 为节点所组成的 &lt;strong&gt;二叉搜索树&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>两数之和II-输入有序数组</title>
    <link href="https://hoo334.github.io/2020/07/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://hoo334.github.io/2020/07/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2020-07-20T04:41:41.000Z</published>
    <updated>2020-07-20T04:52:55.070Z</updated>
    
    <content type="html"><![CDATA[<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h4><p>给定一个已按照 <strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><a id="more"></a><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br></pre></td></tr></table></figure><p>初始化两个指针，左指针指向有序数组第一个元素，右指针指向有序数组最后一个元素，计算两个指针指向的元素之和 sum，若 sum &lt; target，则将左指针右移，尝试获得更大的 sum，若 sum &gt; target，则将右指针左移，尝试获得更小的 sum，当左右指针相遇时结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>; i &lt; j; )&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;167-两数之和-II-输入有序数组&quot;&gt;&lt;a href=&quot;#167-两数之和-II-输入有序数组&quot; class=&quot;headerlink&quot; title=&quot;167. 两数之和 II - 输入有序数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;167. 两数之和 II - 输入有序数组&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个已按照 &lt;strong&gt;升序排列&lt;/strong&gt; 的有序数组，找到两个数使得它们相加之和等于目标数。&lt;/p&gt;
&lt;p&gt;函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2&lt;em&gt;。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://hoo334.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>验证栈序列</title>
    <link href="https://hoo334.github.io/2020/07/20/%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/"/>
    <id>https://hoo334.github.io/2020/07/20/%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/</id>
    <published>2020-07-20T04:06:53.000Z</published>
    <updated>2020-07-20T04:47:34.012Z</updated>
    
    <content type="html"><![CDATA[<h4 id="946-验证栈序列"><a href="#946-验证栈序列" class="headerlink" title="946. 验证栈序列"></a><a href="https://leetcode-cn.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">946. 验证栈序列</a></h4><p>给定 <code>pushed</code> 和 <code>popped</code> 两个序列，每个序列中的 <strong>值都不重复</strong>，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code> 。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li><li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li><li><code>pushed</code> 是 <code>popped</code> 的排列。</li></ol><p><strong>方法一：模拟</strong></p><p>我们模拟做题过程中判断是否为出栈序列的方法，将入栈序列中的元素依次入栈，在入栈的过程中，如果栈顶元素与出栈序列的第一个元素相同则将栈顶元素弹出，直到最后栈中元素为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pushed.length, n = popped.length;</span><br><span class="line">        <span class="comment">//入栈序列长度与出栈序列长度不相同</span></span><br><span class="line">        <span class="keyword">if</span>(m != n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//是否出栈完成</span></span><br><span class="line">        <span class="keyword">while</span>(j != n)&#123;</span><br><span class="line">            <span class="comment">//入栈元素与出栈元素不相同，添加元素</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; pushed[i] != popped[j])&#123;</span><br><span class="line">                stack.addLast(pushed[i++]);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//入栈元素与出栈元素相同，先将其入栈，然后再出栈</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; m &amp;&amp; pushed[i] == popped[j])&#123;</span><br><span class="line">                stack.addLast(pushed[i++]);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//栈顶元素与出栈元素相同则出栈</span></span><br><span class="line">            <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peekLast() == popped[j])&#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//无元素入栈，栈顶元素与出栈元素不相同</span></span><br><span class="line">                    <span class="keyword">if</span>(i == m)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">//还有元素入栈，跳出循环，继续进行进栈操作</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p><p><strong>方法二：贪心</strong></p><p>将 pushed 队列中每个数都 push 到栈中，同时检查这个数是不是 popped 序列中下一个要 pop 的值，如果是，就要把它 pop 出来。</p><p>最后，检查是否所有的值都 pop 出来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pushed.length;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : pushed)&#123;</span><br><span class="line">            stack.addLast(x);</span><br><span class="line">            <span class="keyword">while</span>(stack.size() != <span class="number">0</span> &amp;&amp; stack.peekLast() == popped[j])&#123;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;946-验证栈序列&quot;&gt;&lt;a href=&quot;#946-验证栈序列&quot; class=&quot;headerlink&quot; title=&quot;946. 验证栈序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/validate-stack-sequences/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;946. 验证栈序列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定 &lt;code&gt;pushed&lt;/code&gt; 和 &lt;code&gt;popped&lt;/code&gt; 两个序列，每个序列中的 &lt;strong&gt;值都不重复&lt;/strong&gt;，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
      <category term="贪心" scheme="https://hoo334.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>戳气球</title>
    <link href="https://hoo334.github.io/2020/07/19/%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <id>https://hoo334.github.io/2020/07/19/%E6%88%B3%E6%B0%94%E7%90%83/</id>
    <published>2020-07-19T02:59:12.000Z</published>
    <updated>2020-07-19T04:12:49.201Z</updated>
    
    <content type="html"><![CDATA[<h4 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></h4><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。如果你戳破气球 <code>i</code> ，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><a id="more"></a><p><strong>说明:</strong></p><ul><li>你可以假设 <code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins &#x3D;  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   &#x3D; 167</span><br></pre></td></tr></table></figure><p>为了避免讨论边界情况，我们将 nums 数组首尾各加上 一个 数字 1 ，将这个新数组叫做 val。</p><p><strong>方法一：记忆化搜索</strong></p><p>戳气球这个操作会使两个气球从不相邻变为相邻，使得后续操作难以进行，我们倒过来看这些操作，将全过程看作是每次添加一个气球。</p><p>定义方法 solve，令 <code>solve(i, j)</code>表示开区间<code>(i, j)</code>内位置全部填满能够得到的最多硬币数。由于是开区间，因此区间两端的气球编号就是 i 和 j，对应 val[i] 和 val[j]。</p><ul><li>当 <code>i &gt;= j - 1</code> 时，开区间中没有气球，<code>solve(i, j)</code>的值为 0 。</li><li>当<code>i &lt; j - 1</code> 时，我们枚举开区间<code>(i, j)</code>内的全部位置 mid，令 mid 为当前区间第一个添加的气球，此时，区间中只有 三个值 val[i]，val[mid]，val[j]，能得到的硬币数为这三个值的积。mid 将开区间<code>(i, j)</code>分为<code>(i, mid)</code>和<code>(mid, j)</code>两部分，我们递归地计算这两个部分对 <code>solve(i, j)</code>的贡献。</li></ul><p>$$<br>solve(i, j) = \max^{j-1}_{mid=i+1}{val[i]\times val[mid]\times val[j] + solve(i,mid) + solve(mid,j) }\ \  {i &lt; j - 1}<br>$$</p><p>$$<br>solve(i, j)  = 0 \ \  {i \geq j - 1}<br>$$</p><p>为了避免重复计算，我们储存 solve 的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] rec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rec = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">2</span>; i++)&#123;</span><br><span class="line">            Arrays.fill(rec[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rec[left][right] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += solve(left, i) + solve(i, right);</span><br><span class="line">            rec[left][right] = Math.max(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^3)，空间复杂度O(n^2)。</p><p><strong>方法二：动态规划</strong></p><p>我们可以将自顶向下的记忆化搜索变为自底向上的动态规划，令 <code>dp[i][j]</code>表示填满开区间<code>(i, j)</code>能得到的最多硬币数，边界条件为 i &gt;= j - 1，此时<code>dp[i][j] = 0</code>。<br>$$<br>dp[i][j]=\max^{j-1}_{k=i+1}{val[i]\times val[k]\times val[j] + solve(i,k) + solve(k,j) }\ \   {i &lt; j - 1}<br>$$<br>$$<br>dp[i][j]  = 0 \ \  {i \geq j - 1}<br>$$</p><p>最终答案为<code>dp[0][n + 1]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] rec = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从数组尾部开始自底向上动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;<span class="comment">//枚举左边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; j++)&#123;<span class="comment">//枚举右边界</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)&#123;<span class="comment">//枚举开区间(i, j)中的全部位置</span></span><br><span class="line">                    <span class="keyword">int</span> sum = val[i] * val[k] * val[j];</span><br><span class="line">                    sum += rec[i][k] + rec[k][j];</span><br><span class="line">                    rec[i][j] = Math.max(rec[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rec[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^3)，空间复杂度O(n^2)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;312-戳气球&quot;&gt;&lt;a href=&quot;#312-戳气球&quot; class=&quot;headerlink&quot; title=&quot;312. 戳气球&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/burst-balloons/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;312. 戳气球&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;有 &lt;code&gt;n&lt;/code&gt; 个气球，编号为&lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;，每个气球上都标有一个数字，这些数字存在数组 &lt;code&gt;nums&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;现在要求你戳破所有的气球。如果你戳破气球 &lt;code&gt;i&lt;/code&gt; ，就可以获得 &lt;code&gt;nums[left] * nums[i] * nums[right]&lt;/code&gt; 个硬币。 这里的 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 代表和 &lt;code&gt;i&lt;/code&gt; 相邻的两个气球的序号。注意当你戳破了气球 &lt;code&gt;i&lt;/code&gt; 后，气球 &lt;code&gt;left&lt;/code&gt; 和气球 &lt;code&gt;right&lt;/code&gt; 就变成了相邻的气球。&lt;/p&gt;
&lt;p&gt;求所能获得硬币的最大数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>交错字符串</title>
    <link href="https://hoo334.github.io/2020/07/18/%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/07/18/%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-07-18T03:13:56.000Z</published>
    <updated>2020-07-18T03:51:53.671Z</updated>
    
    <content type="html"><![CDATA[<h4 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">97. 交错字符串</a></h4><p>给定三个字符串 <em>s1</em>, <em>s2</em>, <em>s3</em>, 验证 <em>s3</em> 是否是由 <em>s1</em> 和 <em>s2</em> 交错组成的。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>首先我们需要理解「交错」这个概念，s3 由 s1 的部分字符 和 s2 的部分字符交错形成，以示例 1 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;aadbbcbcac&quot; &#x3D; &quot;aa&quot; + &quot;db&quot; + &quot;bc&quot; + &quot;bca&quot; + &quot;c&quot;</span><br><span class="line">s1     s2     s1      s2     s1</span><br></pre></td></tr></table></figure><p>示例2中，s3 中剩下 “accc” ，s1 剩下 “cc” ，s2 剩下”ca”，”cc” 和 “ca” 无法交错形成 “accc”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;aadbbbaccc&quot; &#x3D; &quot;aa&quot; + &quot;dbb&quot; + &quot;b&quot; + ...</span><br><span class="line">s1     s2     s1</span><br></pre></td></tr></table></figure><p>可以将其当作不同路径来理解，下图来自<a href="https://leetcode-cn.com/problems/interleaving-string/solution/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch/" target="_blank" rel="noopener">gousiqi</a></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200718114829025.png" alt="image-20200718114829025"></p><p>首先，s1 和 s2 的长度之和不等于 s3 ，s3 必然不可能为 s1 和 s2 交错形成。我们定义 <code>f(i, j)</code>表示字符串 s1 的前 i 个字符能否与字符串 s2 的前 j 个字符形成字符串 s3 的前 i + j 个字符。如果 s1 的第 i 个字符与 s3 的第 i + j 个字符相等，那么 <code>f(i, j)</code>取决于 s1 的前 i - 1 个字符和 s2 的前 j 个字符能否交错构成 s3 的前 i + j - 1 个字符，表示为<code>f(i - 1, j)</code>。如果 s2 的第 j 个字符与 s3 的第 i + j 个字符相等，那么 <code>f(i, j)</code> 取决于 s1 的前 i 个字符和 s2 的前 j - 1 个字符能否交错构成 s3 的前 i + j - 1个字符，表示为<code>f(i, j - 1)</code>。我们可以得出动态规划方程：<br>$$<br>f(i,j)=[f(i - 1, j)\ and\ s_1[i]=s_3[i+j]]\ or\ [f(i, j - 1)\ and\ s_2[j] = s_3[i+j]]<br>$$<br>边界条件为 <code>f(0, 0) = true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length(), t = s3.length();</span><br><span class="line">        <span class="keyword">if</span>(m + n != t)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p = i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;<span class="comment">//注意字符串的下标与公式的区别</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//两个条件之间是 “或” 的关系</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。</p><p>我们还可以使用滚动数组来优化空间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length(), t = s3.length();</span><br><span class="line">        <span class="keyword">if</span>(m + n != t)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p = i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = dp[j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = dp[j] || dp[j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;97-交错字符串&quot;&gt;&lt;a href=&quot;#97-交错字符串&quot; class=&quot;headerlink&quot; title=&quot;97. 交错字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/interleaving-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;97. 交错字符串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定三个字符串 &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt;, &lt;em&gt;s3&lt;/em&gt;, 验证 &lt;em&gt;s3&lt;/em&gt; 是否是由 &lt;em&gt;s1&lt;/em&gt; 和 &lt;em&gt;s2&lt;/em&gt; 交错组成的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://hoo334.github.io/2020/07/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://hoo334.github.io/2020/07/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2020-07-17T02:02:36.000Z</published>
    <updated>2020-07-17T05:12:40.060Z</updated>
    
    <content type="html"><![CDATA[<p>在有序数组种，常用二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。在二分查找算法的细节主要有两点：「while 循环中的的不等号是否带等号」，「边界的取值问题」。</p><a id="more"></a><h3 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"><span class="keyword">while</span>(...)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">...;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">left = ...;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">right = ...;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mid = left + (right - left) / 2</code> 是为了避免整数溢出，我们剩下的就是要在省略号的地方填上相应的步骤来实现二分查找。</p><h3 id="寻找有序数组"><a href="#寻找有序数组" class="headerlink" title="寻找有序数组"></a>寻找有序数组</h3><p>在有序数组中寻找一个数，如果存在，返回下标，否则返回 -1。</p><p>下面我们看一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> datastructure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 在有序数组中寻找一个整数</span></span><br><span class="line"><span class="comment">    * @param nums，有序数组</span></span><br><span class="line"><span class="comment">    * @param target，需要寻找的目标</span></span><br><span class="line"><span class="comment">    * @return 找到的数值索引，未找到返回 -1</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchNum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>; <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;<span class="comment">//重点：因为左右闭区间，所以当 left == right 时，还有一个值需要判断，需要加上等号</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">//搜索区间变成[mid + 1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">//因为右闭区间,搜索区间为[left, mid - 1]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchNum2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length; <span class="comment">// 搜索区间为 [left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//左闭右开区间，当 left == right 时，区间内已经没有值</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//搜索区间变成[mid + 1, right)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//因为右开区间，搜索区间为[left, mid)，如果为 right = mid - 1，</span></span><br><span class="line">                <span class="comment">//区间为[left, mid - 1)，我们会漏掉 mid - 1位置的值</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">77</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">100</span>&#125;;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            Random random = <span class="keyword">new</span> Random(i*<span class="number">80</span>);</span><br><span class="line">            <span class="keyword">int</span> num = nums[random.nextInt(<span class="number">14</span>)];</span><br><span class="line">            System.out.println(<span class="string">"left &lt;= right: searching "</span> + num + <span class="string">" index: "</span> + binarySearchNum(nums,num));</span><br><span class="line">            System.out.println(<span class="string">"left &lt; right: searching "</span> + num + <span class="string">" index： "</span> + binarySearchNum2(nums,num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 2, 2, 3, 3, 4, 5, 14, 33, 44, 77, 77, 100]</span><br><span class="line">left &lt;&#x3D; right: searching 77 index: 12</span><br><span class="line">left &lt; right: searching 77 index： 11</span><br><span class="line">left &lt;&#x3D; right: searching 3 index: 4</span><br><span class="line">left &lt; right: searching 3 index： 5</span><br><span class="line">left &lt;&#x3D; right: searching 100 index: 13</span><br><span class="line">left &lt; right: searching 100 index： 13</span><br><span class="line">left &lt;&#x3D; right: searching 3 index: 4</span><br><span class="line">left &lt; right: searching 3 index： 5</span><br><span class="line">left &lt;&#x3D; right: searching 1 index: 0</span><br><span class="line">left &lt; right: searching 1 index： 0</span><br></pre></td></tr></table></figure><p><code>num[mid] == target</code> 时，我们已经找到了一个值的下标，直接返回即可。</p><h4 id="关于-left-lt-right-和-left-lt-right"><a href="#关于-left-lt-right-和-left-lt-right" class="headerlink" title="关于 left &lt;= right 和 left &lt; right"></a>关于 left &lt;= right 和 left &lt; right</h4><ul><li><p>当初始化 <code>left = 0, right = nums.length - 1</code> 时，搜索区间为<code>[left, right]</code>，当 <code>left == right</code>时，搜索区间内还有一个值 nums[left] 没有判断，循环条件内使用 left &lt;= right，如果使用 left &lt; right 最后需要加一次判断 nums[left] == target ?</p></li><li><p>当初始化 <code>left = 0, right = nums.length</code> 时，搜索区间为<code>[left, right)</code>，当 <code>left == right</code>时，搜索区间内没有值，循环条件内使用 left &lt; right。</p></li></ul><h4 id="关于left、right-取值问题"><a href="#关于left、right-取值问题" class="headerlink" title="关于left、right 取值问题"></a>关于left、right 取值问题</h4><ul><li><p>当初始化 <code>left = 0, right = nums.length - 1</code> 时，搜索区间为<code>[left, right]</code>，<code>mid = (left + right) / 2</code>，如果<code>nums[mid] &lt; target</code>，那么 target 值在 mid 右侧，left = mid + 1，此时搜索区间为<code>[mid + 1,right]</code>，如果<code>nums[mid] &gt; target</code>，那么 target 值在 mid 左侧，right = mid - 1，此时搜索区间为<code>[left, mid - 1]</code>。</p></li><li><p>当初始化 <code>left = 0, right = nums.length</code> 时，搜索区间为<code>[left, right)</code>，<code>mid = (left + right) / 2</code>，如果<code>nums[mid] &lt; target</code>，那么 target 值在 mid 右侧，left = mid + 1，此时搜索区间为<code>[mid + 1,right)</code>，如果<code>nums[mid] &gt; target</code>，那么 target 值在 mid 左侧，right = mid，此时搜索区间为<code>[left, mid)</code>，如果right =mid - 1，那么搜索区间为<code>[left, mid - 1)</code>，mid -  1 位置的值就不在搜索区间内，这是不对的，会造成错误。</p></li></ul><h3 id="寻找左侧边界"><a href="#寻找左侧边界" class="headerlink" title="寻找左侧边界"></a>寻找左侧边界</h3><p>二分查找数组中从左至右等于 target 的第一个值的下标，没有则返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchLeftBoundNum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length; <span class="comment">// 搜索区间为 [left, right)</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//左闭右开区间，当 left == right 时，区间内已经没有值</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;<span class="comment">//右侧逼近，下一个搜索区间[left, mid)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;<span class="comment">//搜索区间变成[mid + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//因为右开区间，搜索区间为[left, mid)，如果为 right = mid - 1，</span></span><br><span class="line">            <span class="comment">//区间为[left, mid - 1)，我们会漏掉 mid - 1位置的值</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//目前的 nums[left]是从左至右第一个大于等于 target 的值</span></span><br><span class="line">    <span class="keyword">if</span>(left == nums.length)&#123;<span class="comment">//target 大于所有值</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 2, 2, 3, 3, 4, 5, 14, 33, 44, 77, 77, 100]</span><br><span class="line">searching left bound 2 index: 1</span><br><span class="line">searching left bound 77 index: 11</span><br><span class="line">searching left bound 1 index: 0</span><br></pre></td></tr></table></figure><p>在找到 target 时，没有立刻返回，而是缩小搜索区间的右侧，从右侧逼近，达到锁定左侧边界的目的。</p><h3 id="寻找右侧边界"><a href="#寻找右侧边界" class="headerlink" title="寻找右侧边界"></a>寻找右侧边界</h3><p>二分查找数组中从右至左等于 target 的第一个值的下标，没有则返回 -1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static int binarySearchRightBoundNum(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; nums.length; &#x2F;&#x2F; 搜索区间为 [left, right)</span><br><span class="line">    while (left &lt; right) &#123; &#x2F;&#x2F;左闭右开区间，当 left &#x3D;&#x3D; right 时，区间内已经没有值</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;&#x2F;&#x2F;左侧逼近，下一个搜索区间[mid + 1, right)</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;&#x2F;&#x2F;搜索区间变成[mid + 1, right]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;因为右开区间，搜索区间为[left, mid)，如果为 right &#x3D; mid - 1，</span><br><span class="line">            &#x2F;&#x2F;区间为[left, mid - 1)，我们会漏掉 mid - 1位置的值</span><br><span class="line">            right &#x3D; mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 目前的 nums[left] 左边的部分的值都是大于等于 target</span><br><span class="line">    if(left &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F;target 小于所有值</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;返回最后一个等于 target 值的下标</span><br><span class="line">        return nums[left - 1] &#x3D;&#x3D; target ? left - 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 2, 2, 3, 3, 4, 5, 14, 33, 44, 77, 77, 100]</span><br><span class="line">searching right bound 2 index: 3</span><br><span class="line">searching right bound 77 index: 12</span><br><span class="line">searching right bound 1 index: 0</span><br></pre></td></tr></table></figure><p>在找到 target 时，没有立刻返回，而是缩小搜索区间的左侧，从左侧逼近，达到锁定右侧边界的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在有序数组种，常用二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。在二分查找算法的细节主要有两点：「while 循环中的的不等号是否带等号」，「边界的取值问题」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://hoo334.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>搜索插入位置</title>
    <link href="https://hoo334.github.io/2020/07/17/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>https://hoo334.github.io/2020/07/17/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</id>
    <published>2020-07-17T01:54:41.000Z</published>
    <updated>2020-07-17T02:02:50.830Z</updated>
    
    <content type="html"><![CDATA[<h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>看到数组有序，可以想到二分查找，此题查找的是第一个大于等于 target 数值的下标。我们直接使用二分法，利用二分法不断逼近第一个大于等于 target 的下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(log n)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;35-搜索插入位置&quot;&gt;&lt;a href=&quot;#35-搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;35. 搜索插入位置&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-insert-position/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;35. 搜索插入位置&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;你可以假设数组中无重复元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>判断二分图</title>
    <link href="https://hoo334.github.io/2020/07/16/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>https://hoo334.github.io/2020/07/16/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</id>
    <published>2020-07-16T01:41:08.000Z</published>
    <updated>2020-07-16T02:16:17.387Z</updated>
    
    <content type="html"><![CDATA[<h4 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">785. 判断二分图</a></h4><p>给定一个无向图<code>graph</code>，当这个图为二分图时返回<code>true</code>。</p><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p><p><code>graph</code>将会以邻接表方式给出，<code>graph[i]</code>表示图中与节点<code>i</code>相连的所有节点。每个节点都是一个在<code>0</code>到<code>graph.length-1</code>之间的整数。这图中没有自环和平行边： <code>graph[i]</code> 中不存在<code>i</code>，并且<code>graph[i]</code>中没有重复的值。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。</span><br><span class="line">示例 2:</span><br><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>graph</code> 的长度范围为 <code>[1, 100]</code>。</li><li><code>graph[i]</code> 中的元素的范围为 <code>[0, graph.length - 1]</code>。</li><li><code>graph[i]</code> 不会包含 <code>i</code> 或者有重复的值。</li><li>图是无向的: 如果<code>j</code> 在 <code>graph[i]</code>里边, 那么 <code>i</code> 也会在 <code>graph[j]</code>里边。</li></ul><p>对于图中任意两个结点 u 和 v ，如果它们之间有一条边相连，那么 u 和 v 必须属于不同的集合。</p><p>如果给定的无向图连通，那么我们就可以任选一个结点开始，给它染成红色，将其所连的所有结点染成绿色，同一种颜色表示它们在同一个集合里，我们再将绿色结点直接相连的未染色结点染成红色。</p><p>算法流程：</p><ul><li><p>任选一个结点开始，将其染成红色，并从该结点开始对整个无向图进行遍历；</p></li><li><p>在遍历过程中，如果我们通过结点 u 访问到了结点 v （u，v之间有一条边相连），那么会有两种情况：</p><ul><li>如果 v 未染色，将其染成与 u 不同的颜色，并对 v 直接相连的结点进行遍历；</li><li>如果 v 被染色，并且颜色与 u 相同，说明给定的无向图不是二分图，我们直接返回 false；</li></ul></li><li><p>当遍历结束时，说明给定的无向图是二分图，返回 true。</p></li></ul><p>我们可以使用「深度优先搜索」或「广度优先搜索」对无向图进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNCOLORED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        color = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        valid = <span class="keyword">true</span>;</span><br><span class="line">        Arrays.fill(color, UNCOLORED);</span><br><span class="line">        <span class="comment">//DFS</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i] == UNCOLORED)&#123;</span><br><span class="line">                dfs(i, RED, graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> c, <span class="keyword">int</span>[][] graph)</span></span>&#123;</span><br><span class="line">        color[node] = c;</span><br><span class="line">        <span class="comment">//直接相连结点颜色为当前结点颜色相反</span></span><br><span class="line">        <span class="keyword">int</span> cNei = c == RED ? GREEN : RED;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph[node])&#123;</span><br><span class="line">            <span class="comment">//相连结点未被染色</span></span><br><span class="line">            <span class="keyword">if</span>(color[neighbor] == UNCOLORED)&#123;</span><br><span class="line">                dfs(neighbor, cNei, graph);</span><br><span class="line">                <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[neighbor] != cNei)&#123;<span class="comment">//直接相连结点与当前结点颜色相同</span></span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 BFS 实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNCOLORED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        color = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(color, UNCOLORED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i] == UNCOLORED)&#123;</span><br><span class="line">                Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                color[i] = RED;</span><br><span class="line">                <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">                    <span class="keyword">int</span> cNei = color[node] == RED ? GREEN : RED;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph[node])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(color[neighbor] == UNCOLORED)&#123;</span><br><span class="line">                            queue.offer(neighbor);</span><br><span class="line">                            color[neighbor] = cNei;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[neighbor] != cNei)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(N + M)，其中 N 和 M 分别是无向图的点数和边数。</p><p>空间复杂度O(N)，存储结点颜色数组需要 O(N)空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;785-判断二分图&quot;&gt;&lt;a href=&quot;#785-判断二分图&quot; class=&quot;headerlink&quot; title=&quot;785. 判断二分图&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/is-graph-bipartite/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;785. 判断二分图&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个无向图&lt;code&gt;graph&lt;/code&gt;，当这个图为二分图时返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;graph&lt;/code&gt;将会以邻接表方式给出，&lt;code&gt;graph[i]&lt;/code&gt;表示图中与节点&lt;code&gt;i&lt;/code&gt;相连的所有节点。每个节点都是一个在&lt;code&gt;0&lt;/code&gt;到&lt;code&gt;graph.length-1&lt;/code&gt;之间的整数。这图中没有自环和平行边： &lt;code&gt;graph[i]&lt;/code&gt; 中不存在&lt;code&gt;i&lt;/code&gt;，并且&lt;code&gt;graph[i]&lt;/code&gt;中没有重复的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://hoo334.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树</title>
    <link href="https://hoo334.github.io/2020/07/15/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/07/15/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-07-15T01:46:59.000Z</published>
    <updated>2020-07-15T06:29:17.373Z</updated>
    
    <content type="html"><![CDATA[<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h4><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p>给定一个有序序列 1 … n，为了构建出一颗二叉搜索树，我们可以将数字 i 作为树根，将 1 … i - 1作为左子树，将 i + 1 … n 作为右子树。由于根植的不同，我们能保证每颗二叉搜索树是唯一的。</p><p>记<code>f[n]</code> 为整数 1 … n 构成的二叉搜索树种数，得到动态规划方程：<br>$$<br>f[n] = \sum^{n}_{i = 1}{f[i - 1]*f[n - i]}<br>$$<br>边界条件，当序列长度为1（只有根）或为 0（空树）时只有一种情况： f[0] = 1，f[1] = 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;96-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#96-不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;96. 不同的二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-binary-search-trees/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;96. 不同的二叉搜索树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，求以 1 … &lt;em&gt;n&lt;/em&gt; 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>三角形最小路径和</title>
    <link href="https://hoo334.github.io/2020/07/14/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://hoo334.github.io/2020/07/14/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2020-07-14T03:07:48.000Z</published>
    <updated>2020-07-15T02:05:46.938Z</updated>
    
    <content type="html"><![CDATA[<h4 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></h4><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p><strong>相邻的结点</strong> 在这里指的是 <code>下标</code> 与 <code>上一层结点下标</code> 相同或者等于 <code>上一层结点下标 + 1</code> 的两个结点。</p> <a id="more"></a><p>例如，给定三角形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p><p> <strong>说明：</strong></p><p>如果你可以只使用 <em>O</em>(<em>n</em>) 的额外空间（<em>n</em> 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p><p>我们使用 <code>f[i][j]</code>来表示从三角形顶部走到位置<code>(i, j)</code>的最小路径和。这里的 <code>i</code> 和 <code>j</code> 指的是三角形中第<code>i</code>行第<code>j</code>列（从 0 开始编号）的的位置。</p><p>由于每一步只能移动到下一个相邻的结点，要到位置<code>(i, j)</code>，上一步位置就只能在<code>(i - 1, j)</code>或<code>(i - 1, j - 1)</code>中选择。我们在两者之间找一个路径和比较小的来转移，状态方程为：<br>$$<br>f[i][j] = min(f[i -1][j - 1], f[i - 1][j]) + c[i][j]<br>$$<br>其中<code>c[i][j]</code>表示位置<code>(i, j)</code>对应的元素值。</p><p>注意边界条件：</p><ul><li><p>当 j == 0 时，没有左上结点，只能从上一个结点转移过来，状态转移方程为：<br>$$<br>f[i][j] = f[i - 1][j] + c[i][j]<br>$$</p></li><li><p>当 j == i 时，没有上结点，只能从左上结点转移过来，状态转移方程为：</p></li></ul><p>$$<br>f[i][j] = f[i - 1][j - 1] + c[i][j]<br>$$</p><p>最终的答案为 <code>f[n - 1][0]</code> 到 <code>f[n - 1][n - 1]</code> 的最小值，其中  n 是三角形的行数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = triangle.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.get(m - <span class="number">1</span>).size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> up = j != i ? dp[i - <span class="number">1</span>][j] : Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">int</span> upLeft = j - <span class="number">1</span> &gt;= <span class="number">0</span> ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">                dp[i][j] = triangle.get(i).get(j) + Math.min(up, upLeft); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = dp[m - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            min = Math.min(min, dp[m - <span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(n^2)。</p><p>我们可以看到 dp 数组中第 i 行的值只与第 i - 1 行的值有关，我们可以只使用一个一维数组存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = triangle.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.get(m - <span class="number">1</span>).size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>]= triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>, upLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                up = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = up + triangle.get(i).get(j);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">                    dp[j] = upLeft + triangle.get(i).get(j);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = Math.min(up, upLeft) + triangle.get(i).get(j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第 j + 1 个元素的左上元素等于第 j 个元素上方的元素</span></span><br><span class="line">                upLeft = up;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            min = Math.min(min, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;120-三角形最小路径和&quot;&gt;&lt;a href=&quot;#120-三角形最小路径和&quot; class=&quot;headerlink&quot; title=&quot;120. 三角形最小路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/triangle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;120. 三角形最小路径和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相邻的结点&lt;/strong&gt; 在这里指的是 &lt;code&gt;下标&lt;/code&gt; 与 &lt;code&gt;上一层结点下标&lt;/code&gt; 相同或者等于 &lt;code&gt;上一层结点下标 + 1&lt;/code&gt; 的两个结点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>两个数组的交集 II</title>
    <link href="https://hoo334.github.io/2020/07/13/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/"/>
    <id>https://hoo334.github.io/2020/07/13/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/</id>
    <published>2020-07-13T01:38:41.000Z</published>
    <updated>2020-07-13T02:07:46.076Z</updated>
    
    <content type="html"><![CDATA[<h4 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></h4><p>给定两个数组，编写一个函数来计算它们的交集。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出: [2,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong><em>进阶:</em></strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 <em>nums1</em> 的大小比 <em>nums2</em> 小很多，哪种方法更优？</li><li>如果 <em>nums2</em> 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><p><strong>方法一：哈希表</strong></p><p>我们使用哈希表存储每个数字出现的次数。首先遍历第一个数组，统计所有数字及出现的次数。再遍历第二个数组，如果哈希表中存在这个数字，将其出现的次数减一，并将其加入到结果中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ansList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num) &amp;&amp; map.get(num) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ansList.add(num);</span><br><span class="line">                map.put(num, map.get(num) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = ansList.size();</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(m + n)，其中 m 和 n 为两个数组的长度。空间复杂度O(max(m, n))。</p><p><strong>方法二：排序</strong></p><p>如果两个数组是有序的，可以便捷的计算两个数组的交集。首先将两个数组进行排序，然后使用两个指针遍历数组。初始时，两个指针分别指向两个数组的头部，每次比较两个指针指向的两个数组中的数字，如果两个数字相等，将当前数字加入结果中，将两个指针后移；如果两个数字不相等，将较小数字的指针向后移动。当至少一个指针遍历到数组末尾时结束循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] intersection = <span class="keyword">new</span> <span class="keyword">int</span>[Math.min(nums1.length, nums2.length)];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums1.length &amp;&amp; j &lt; nums2.length; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                ++j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    intersection[index++] = nums1[i];</span><br><span class="line">                    ++i;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(intersection, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mlogm + nlogn)，m 和 n 分别是两个数组的长度。</p><p>空间复杂度O(min(m, n))。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;350-两个数组的交集-II&quot;&gt;&lt;a href=&quot;#350-两个数组的交集-II&quot; class=&quot;headerlink&quot; title=&quot;350. 两个数组的交集 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;350. 两个数组的交集 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>地下城游戏</title>
    <link href="https://hoo334.github.io/2020/07/12/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/"/>
    <id>https://hoo334.github.io/2020/07/12/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/</id>
    <published>2020-07-12T03:40:31.000Z</published>
    <updated>2020-07-17T10:03:31.727Z</updated>
    
    <content type="html"><![CDATA[<h4 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">174. 地下城游戏</a></h4><p>一些恶魔抓住了公主（<strong>P</strong>）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（<strong>K</strong>）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为<em>负整数</em>，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 <em>0</em>），要么包含增加骑士健康点数的魔法球（若房间里的值为<em>正整数</em>，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p> <a id="more"></a><p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong></p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 <code>右 -&gt; 右 -&gt; 下 -&gt; 下</code>，则骑士的初始健康点数至少为 <strong>7</strong>。</p><table><thead><tr><th>-2 (K)</th><th>-3</th><th>3</th></tr></thead><tbody><tr><td>-5</td><td>-10</td><td>1</td></tr><tr><td>10</td><td>30</td><td>-5 (P)</td></tr></tbody></table><p> <strong>说明:</strong></p><ul><li>骑士的健康点数没有上限。</li><li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li></ul><p>很容易想到使用动态规划，我们先尝试从左上到右下的顺序进行动态规划，对于每一条路径，我们需要同时记录两个值。第一个是「从出发点到当前点的路径和」，第二个是「从出发点到当前点所需的最小初始值」，这两个值的重要程度相同。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/uTlo1kQfOin2vp3.png" alt="image-20200712115157247"></p><ul><li>绿色路径，「从出发点到当前点的路径和」为 1 ，「从出发点到当前点所需的最小初始值」为 3。</li><li>蓝色路径，「从出发点到当前点的路径和」为 -1 ，「从出发点到当前点所需的最小初始值」为 2。</li></ul><p>我们应该选择绿色路径，因为蓝色路径的路径和太小，需要初始值为 4 才能到达终点 -2，而绿色路径只需要初始值为 3 即可到达终点 -2 。如果我们将终点 -2 换为 0，我们就应该选择蓝色路径，蓝色路径需要初始值为 2 ，绿色路径需要初始值为 3。</p><p>如果从左上到右下进行动态规划，我们无法确定到达(1, 2) 的方案，这样的动态规划是不满足「无后效性」的。</p><p>我们考虑从右下到左上进行动态规划。令<code>dp[i][j]</code>表示从坐标<code>(i, j)</code>到终点所需的最小初始值。当在坐标<code>(i, j)</code>时，如果此时路径和不小于<code>dp[i][j]</code>，我们就能到达终点。这样一来，我们就无需关心路径和，只需关注最小初始值。对于 <code>dp[i][j]</code>，我们只要关心<code>dp[i][j + 1]</code>和<code>dp[i + 1][j]</code>的最小值 <code>minn</code>。记当前格子的值为 <code>dungeon(i, j)</code>，那么在坐标<code>(i, j)</code>的初始值只要达到 <code>minn - dungeon(i, j)</code>即可。同时，初始值还必须大于 1 ，得到状态转移方程：<br>$$<br>dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon(i, j), 1)<br>$$<br>最终答案为 <code>dp[0][0]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length,  n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//dp 边界无效值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//初始条件，最小初始值为 1</span></span><br><span class="line">        dp[m][n - <span class="number">1</span>] = dp[m - <span class="number">1</span>][n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="comment">//找出能到达终点的最小初始值</span></span><br><span class="line">                <span class="keyword">int</span> minn = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//计算 dp[i][j] 的最小初始值</span></span><br><span class="line">                dp[i][j] = Math.max(minn - dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;174-地下城游戏&quot;&gt;&lt;a href=&quot;#174-地下城游戏&quot; class=&quot;headerlink&quot; title=&quot;174. 地下城游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/dungeon-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;174. 地下城游戏&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;一些恶魔抓住了公主（&lt;strong&gt;P&lt;/strong&gt;）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（&lt;strong&gt;K&lt;/strong&gt;）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。&lt;/p&gt;
&lt;p&gt;骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。&lt;/p&gt;
&lt;p&gt;有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为&lt;em&gt;负整数&lt;/em&gt;，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 &lt;em&gt;0&lt;/em&gt;），要么包含增加骑士健康点数的魔法球（若房间里的值为&lt;em&gt;正整数&lt;/em&gt;，则表示骑士将增加健康点数）。&lt;/p&gt;
&lt;p&gt;为了尽快到达公主，骑士决定每次只向右或向下移动一步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>计算右侧小于当前元素的个数</title>
    <link href="https://hoo334.github.io/2020/07/11/%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://hoo334.github.io/2020/07/11/%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2020-07-11T04:02:11.000Z</published>
    <updated>2020-07-11T04:22:54.179Z</updated>
    
    <content type="html"><![CDATA[<h4 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></h4><p>给定一个整数数组 <em>nums<em>，按要求返回一个新数组 *counts</em>。数组 *counts</em> 有该性质： <code>counts[i]</code> 的值是 <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [5,2,6,1]</span><br><span class="line">输出: [2,1,1,0] </span><br><span class="line">解释:</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1).</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1).</span><br><span class="line">6 的右侧有 1 个更小的元素 (1).</span><br><span class="line">1 的右侧有 0 个更小的元素.</span><br></pre></td></tr></table></figure><p>暴力解法（超时）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(1)。</p><p>从暴力解法中可以看出，我们做了许多的重复的统计工作，我们如果从后往前遍历数组，并保存下已经遍历过的数字及它们出现的次数，在下一次遍历时，就不用重复统计。</p><p>使用二叉搜索树也可完成插入并统计的功能，我们从右往左依次遍历数组，并构建二叉树。在插入结点的过程中我们可以统计出右侧小于当前结点元素的个数。</p><p>在一般的二叉树结点上，我们添加了一个 count 变量来统计小于当前结点 val 值的结点个数。。</p><p>递归实现添加结点的算法：</p><ul><li>当走到右结点，统计根结点和根结点左结点的个数，继续插入并统计根结点右侧是否还有比当前结点值小的结点。</li><li>当走到左节点或根结点时，计数器加一，继续插入并统计根结点左侧是否还有比当前结点值小的结点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        Integer[] res = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">        Arrays.fill(res, <span class="number">0</span>);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//反向构造二叉树，统计右边最小数</span></span><br><span class="line">        TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            root = addAndCount(root, <span class="keyword">new</span> TreeNode(nums[i]), res, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">addAndCount</span><span class="params">(TreeNode root, TreeNode node, Integer[] res, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = node;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根结点左边的保存不大于根结点的元素</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt;= node.val)&#123;</span><br><span class="line">            <span class="comment">//不大于根结点值的结点个数加一</span></span><br><span class="line">            root.count++ ;</span><br><span class="line">            <span class="comment">//递归将当前结点插入左子树</span></span><br><span class="line">            root.left = addAndCount(root.left, node, res, i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//统计比当前结点值小的元素个数（根结点 1 + 左节点 root.count）</span></span><br><span class="line">            res[i] += <span class="number">1</span> + root.count;</span><br><span class="line">            <span class="comment">//统计根结点右子树中是否还有比当前结点值小的结点</span></span><br><span class="line">            root.right = addAndCount(root.right, node, res, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.count = <span class="number">0</span>;<span class="comment">//小于 val 值的结点个数</span></span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(nlogn)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;315-计算右侧小于当前元素的个数&quot;&gt;&lt;a href=&quot;#315-计算右侧小于当前元素的个数&quot; class=&quot;headerlink&quot; title=&quot;315. 计算右侧小于当前元素的个数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;315. 计算右侧小于当前元素的个数&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数数组 &lt;em&gt;nums&lt;em&gt;，按要求返回一个新数组 *counts&lt;/em&gt;。数组 *counts&lt;/em&gt; 有该性质： &lt;code&gt;counts[i]&lt;/code&gt; 的值是 &lt;code&gt;nums[i]&lt;/code&gt; 右侧小于 &lt;code&gt;nums[i]&lt;/code&gt; 的元素的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>最佳买卖股票时机含冷冻期</title>
    <link href="https://hoo334.github.io/2020/07/10/%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
    <id>https://hoo334.github.io/2020/07/10/%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</id>
    <published>2020-07-10T03:01:03.000Z</published>
    <updated>2020-07-15T02:40:37.120Z</updated>
    
    <content type="html"><![CDATA[<h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h4><p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><p>将「买入」和「卖出」分开考虑，「买入」为负收益，「卖出」为正收益。我们需要尽可能地降低负收益而提高正收益，我们可以使用动态规划，维护股市中每一天结束后可以获得的「累计最大收益」，并以此进行状态转移，得到最终的答案。</p><p>我们使用 f[i] 表示<strong>第 i 天结束之后</strong>的「累计最大收益」。根据题目描述，我们有三种状态：</p><ol><li><p>有股票 记为 <code>f[i][0]</code>;</p></li><li><p>不在冷冻期，有股票，记为 <code>f[i][1]</code>;</p></li><li><p>不在冷冻期，无股票，记为 <code>f[i][2]</code>;</p></li></ol><p>这里的处于冷冻期指在第 i 天结束之后的状态。也就是说：第 i 天结束之后处于冷冻期，那么第 i + 1 天将无法买入股票。</p><p>状态转移分析：</p><ul><li><p>对于<code>f[i][0]</code>，第 i 天的股票可以是第 i - 1 天已经持有的，对应 <code>f[i - 1][0]</code>；或者是第 i 天买入的，第 i 天能买入股票证明第 i - 1 天没有股票且不能在冷冻期，对应<code>f[i - 1][2]</code>，加上买股票的负收益。因此状态转移方程为：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][2] - prices[i])<br>$$</p></li><li><p>对于<code>f[i][1]</code>，我们在第 i 天结束之后在冷冻期，证明在第 i 天卖出了股票，说明第 i - 1 天必须持有股票，对应的状态为 <code>f[i - 1][0]</code>加上卖出股票的正收益。状态转移方程为：<br>$$<br>f[i][1] = f[i - 1][0] + prices[i]<br>$$</p></li><li><p>对于<code>f[i][2]</code>，我们在第 i 天结束之后不在冷冻期，可能在第 i - 1 天也是没有股票，不在冷冻期的状态转移过来，对应<code>f[i - 1][2]</code>；或者是第 i - 1 天无股票，在冷冻期的状态转移过来，对应<code>f[i - 1][1]</code>。状态转移方程为：<br>$$<br>f[i][2] = max(f[i - 1][2], f[i - 1][1])<br>$$<br>最终的答案为：<br>$$<br>max(f[n - 1][1], f[n - 1][2])<br>$$<br>如果在最后一天手里仍有股票是没有任何意义的。</p><p>我们可以初始化第 0 天的条件：<code>f[0][0]=-prices[0]</code>，<code>&#39;f[0][1]=0</code>，<code>f[0][2]=0</code></p><p>第 0 天有股票的负收益为 -prices[0]，第 0 天无股票的收益为 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)。</p><p>注意到第 i 天的状态只与第 i - 1 天的状态有关，我们可以将空间复杂度优化到常数级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> one = -prices[<span class="number">0</span>], two = <span class="number">0</span>, three = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newOne = Math.max(one, three - prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newTwo = one + prices[i];</span><br><span class="line">            <span class="keyword">int</span> newThree = Math.max(three, two);</span><br><span class="line"></span><br><span class="line">            one = newOne;</span><br><span class="line">            two = newTwo;</span><br><span class="line">            three = newThree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(two, three);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;309-最佳买卖股票时机含冷冻期&quot;&gt;&lt;a href=&quot;#309-最佳买卖股票时机含冷冻期&quot; class=&quot;headerlink&quot; title=&quot;309. 最佳买卖股票时机含冷冻期&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;309. 最佳买卖股票时机含冷冻期&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数数组，其中第 &lt;em&gt;i&lt;/em&gt; 个元素代表了第 &lt;em&gt;i&lt;/em&gt; 天的股票价格 。&lt;/p&gt;
&lt;p&gt;设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/li&gt;
&lt;li&gt;卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="https://hoo334.github.io/2020/07/09/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/07/09/%E5%AD%97%E5%85%B8%E6%A0%91/</id>
    <published>2020-07-09T04:31:04.000Z</published>
    <updated>2020-07-17T11:35:32.581Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Trie-字典树"><a href="#Trie-字典树" class="headerlink" title="Trie 字典树"></a>Trie 字典树</h3><p>Trie 字典树主要用于存储字符串，Trie 的每个 Node 保存一个字符。用链表来描述的话，一个字符串就是一个链表。每个 Node 都保存了它的所有子结点。</p><a id="more"></a><p>下图为 see、pain、panda、dog构成的字典树</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/qdBE8bhZ1YWNljX.png" alt="image-20200716101933071"></p><h4 id="结点设置"><a href="#结点设置" class="headerlink" title="结点设置"></a>结点设置</h4><ol><li>是否存在以该结点为最后字符的单词，标识位 isEnd；</li><li>当前结点的所有子节点，使用Map存储，当字符串中全为小写字母时可以用数组代替。</li></ol><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>将一个单词的每一个字符从头到尾插入字典树，并将最后一个字符的 idEnd 标志位设为 true。</p><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>从根结点开始遍历字典树，判断查找的字符串是否存在于某一条路径中，且字符串最后一个字符对应的字典树中的结点 isEnd 标志位必须为 true，代表这个结点后面没有字符。例如字典树中存在单词 panda 查找 pan 就要返回false，因为 pan 中的字符 n 对应字典树中的结点 isEnd 标志位为 false。</p><h5 id="前缀查找"><a href="#前缀查找" class="headerlink" title="前缀查找"></a>前缀查找</h5><p>与查找类似，对最后一个字符对应字典树的结点标志位没有限制。也就是字典树中存在单词 panda，查找 pan 前缀返回true。</p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>删除操作分为三种情况：</p><ol><li>要删除的单词位另一个单词的前缀，将最后一个字符对应字典树结点的 isEnd 标志位改为 false；</li><li>要删除的单词对应字典树中的<strong>所有</strong>结点<strong>都</strong>没有分支，直接删除整个链表。</li><li>要删除的单词对应字典树中的结点有分支，删除单词对应字典树链表上的最后一个分支结点到末尾结点。</li></ol><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/n83K4Jy1CehpM2k.png" alt="第一种情况"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/e9UgSvrRf7ZcCL5.png" alt="第二种情况"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/wpfGd5lLsO82yQI.png" alt="第三种情况"></p><p>第一张图中存在 panda、pan 两个单词，我们需要删除 pan ，直接将 字母 n 的 isEnd 标志位设为false。</p><p>第二张图中存在 see 这个单词，并且其链表路径上没有任何分支，直接删除整个链表。</p><p>第三张图中存在 pain、panda、pad三个单词，这三个单词在字母 a 处分叉，要删除 pad ，直接将 字符串 pad 中 a 后的字符（d）删除。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> datastructure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 插入单词</span></span><br><span class="line"><span class="comment">    * @param word 需要插入的单词</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        Node current = root;</span><br><span class="line">        <span class="keyword">char</span>[] str = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str)&#123;</span><br><span class="line">            <span class="comment">//获取下一个结点</span></span><br><span class="line">            Node next = current.next.get(c);</span><br><span class="line">            <span class="keyword">if</span>(next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//结点为空</span></span><br><span class="line">                current.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续向下</span></span><br><span class="line">            current = current.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前单词已经存在，则不需要增加size</span></span><br><span class="line">        <span class="keyword">if</span>(!current.isEnd)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            current.isEnd = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 查询字典树中是否存在单词</span></span><br><span class="line"><span class="comment">    * @param word 需要查询的单词</span></span><br><span class="line"><span class="comment">    * @return 存在单词返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        Node current = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            Node node = current.next.get(c);</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 字典树中有 panda，查询 pan 返回 false</span></span><br><span class="line">        <span class="keyword">return</span> current.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 查询字典树中是否存在某个前缀</span></span><br><span class="line"><span class="comment">    * @param prefix 一个字符串前缀</span></span><br><span class="line"><span class="comment">    * @return 存在前缀返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsPrefix</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        Node current = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            Node node = current.next.get(c);</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字典树中有 panda，查询 pan这个前缀，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        Node multiChildNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> multiChildNodeIndex = -<span class="number">1</span>;</span><br><span class="line">        Node current = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            Node child = current.next.get(word.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(child == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//字典树中不存在这个单词</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//维护最后一个分叉结点</span></span><br><span class="line">            <span class="keyword">if</span>(child.next.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                multiChildNodeIndex = i;</span><br><span class="line">                multiChildNode = child;</span><br><span class="line">            &#125;</span><br><span class="line">            current = child;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果单词后面还有子节点,证明该单词是某个单词的前缀</span></span><br><span class="line">        <span class="keyword">if</span>(current.next.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current.isEnd)&#123;</span><br><span class="line">                <span class="comment">//将其单词标识改为false</span></span><br><span class="line">                current.isEnd = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//单词树减一</span></span><br><span class="line">                size-- ;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不存在该单词，该单词只是前缀</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果单词的所有字母都没有多个分支，删除整个单词</span></span><br><span class="line">        <span class="keyword">if</span>(multiChildNodeIndex == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//移除单词的第一个字母（移除整个单词）</span></span><br><span class="line">            root.next.remove(word.charAt(<span class="number">0</span>));</span><br><span class="line">            size-- ;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果单词除了最后一个字母，其他的字母有分支</span></span><br><span class="line">        <span class="keyword">if</span>(multiChildNodeIndex != word.length() - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//移除掉分叉结点后的所有结点</span></span><br><span class="line">            multiChildNode.next.remove(word.charAt(multiChildNodeIndex + <span class="number">1</span>));</span><br><span class="line">            size-- ;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isEnd;<span class="comment">//是否存在以该结点为末尾的单词</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;Character, Node&gt; next;<span class="comment">//子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">            next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isEnd)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isEnd = isEnd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trie tree = <span class="keyword">new</span> Trie();</span><br><span class="line">        tree.add(<span class="string">"panda"</span>);</span><br><span class="line">        tree.add(<span class="string">"pan"</span>);</span><br><span class="line">        tree.add(<span class="string">"pad"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(tree.contains(<span class="string">"pad"</span>));</span><br><span class="line">        System.out.println(tree.contains(<span class="string">"pand"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + tree.size());</span><br><span class="line">        System.out.println(tree.remove(<span class="string">"pad"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + tree.size());</span><br><span class="line">        System.out.println(tree.remove(<span class="string">"pan"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + tree.size());</span><br><span class="line">        System.out.println(tree.remove(<span class="string">"panz"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + tree.size());</span><br><span class="line">        System.out.println(tree.remove(<span class="string">"panda"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + tree.size());</span><br><span class="line">        tree.add(<span class="string">"panz"</span>);</span><br><span class="line">        System.out.println(tree.contains(<span class="string">"panz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Trie-字典树&quot;&gt;&lt;a href=&quot;#Trie-字典树&quot; class=&quot;headerlink&quot; title=&quot;Trie 字典树&quot;&gt;&lt;/a&gt;Trie 字典树&lt;/h3&gt;&lt;p&gt;Trie 字典树主要用于存储字符串，Trie 的每个 Node 保存一个字符。用链表来描述的话，一个字符串就是一个链表。每个 Node 都保存了它的所有子结点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://hoo334.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="字典树" scheme="https://hoo334.github.io/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>恢复空格</title>
    <link href="https://hoo334.github.io/2020/07/09/%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC/"/>
    <id>https://hoo334.github.io/2020/07/09/%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC/</id>
    <published>2020-07-09T02:00:55.000Z</published>
    <updated>2020-07-09T02:37:50.308Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题-17-13-恢复空格"><a href="#面试题-17-13-恢复空格" class="headerlink" title="面试题 17.13. 恢复空格"></a><a href="https://leetcode-cn.com/problems/re-space-lcci/" target="_blank" rel="noopener">面试题 17.13. 恢复空格</a></h4><p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子<code>&quot;I reset the computer. It still didn’t boot!&quot;</code>已经变成了<code>&quot;iresetthecomputeritstilldidntboot&quot;</code>。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典<code>dictionary</code>，不过，有些词没在词典里。假设文章用<code>sentence</code>表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p><a id="more"></a><p><strong>注意：</strong>本题相对原题稍作改动，只需返回未识别的字符数</p><p> <strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">dictionary &#x3D; [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]</span><br><span class="line">sentence &#x3D; &quot;jesslookedjustliketimherbrother&quot;</span><br><span class="line">输出： 7</span><br><span class="line">解释： 断句后为&quot;jess looked just like tim her brother&quot;，共7个未识别字符。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= len(sentence) &lt;= 1000</code></li><li><code>dictionary</code>中总字符数不超过 150000。</li><li>你可以认为<code>dictionary</code>和<code>sentence</code>中只包含小写字母。</li></ul><p>创建一个数组 dp 来记录结果，dp[i]表示句子中前 i 个字符中最少的未识别字符数。dp[0] = 0 代表空字符串时2没有未识别的字符。</p><p>对于句子中前 i 个字符，有两种情况：</p><ul><li>可能由前面的 [0, j) 字符串加上一个单词构成；dp[i] = min(dp[i], dp[j])；</li><li>前 i - 1 个字符加上第 i 个字符 ,dp[i] = dp[i - 1] + 1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">respace</span><span class="params">(String[] dictionary, String sentence)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将单词添加到 HashSet</span></span><br><span class="line">        Set&lt;String&gt; dic = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : dictionary)&#123;</span><br><span class="line">            dic.add(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = sentence.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//默认前面没有单词</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="comment">//构成单词</span></span><br><span class="line">                <span class="keyword">if</span>(dic.contains(sentence.substring(j, i)))&#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^3)，contains 方法时间复杂度O(1)，substring 方法时间复杂度O(n)。空间复杂度O(n)。</p><p>时间复杂度较高的地方就是如何快速判断子串是否存在于词典中，这里使用「字典树 Trie」来进行优化，Trie 时是一种最大程度利用多个字符串前缀信息的数据结构，它可以在 O(w)时间复杂度内判断一个字符串是否是一个字符串集合中某个字符串的前缀，其中 w 代表字符串的长度。</p><p>我们将所有单词「反序」插入到字典树中，然后在每次判断子串末尾是否是一个单词时，从子串末尾i 开始遍历，同时在 Trie 上从根结点开始出发，当走到sentence[j] 在 Trie 上没有相应的位置，说明 sentence[j…i - 1]不是一个单词，退出循环。对于判断字典树结点是否为叶子结点，我们在单词末尾的结点上打上一个 isEnd 的标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Trie[] next;<span class="comment">//next结点数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEnd;<span class="comment">//结点是否为叶子结点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        next = <span class="keyword">new</span> Trie[<span class="number">26</span>];<span class="comment">//一个结点最多有 26 个字母</span></span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将字符串 s 倒序插入字典树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Trie curPos = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = s.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(curPos.next[t] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//新建结点</span></span><br><span class="line">                curPos.next[t] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向下移动</span></span><br><span class="line">            curPos = curPos.next[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个结点 isEnd 设为 true</span></span><br><span class="line">        curPos.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">respace</span><span class="params">(String[] dictionary, String sentence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sentence.length();</span><br><span class="line">        <span class="comment">//生成字典树</span></span><br><span class="line">        Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span>(String word : dictionary)&#123;</span><br><span class="line">            root.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//初始化 dp 数组</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//默认子串最后没有单词</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            Trie curPos = root;</span><br><span class="line">            <span class="comment">//逐个判断子串末尾的字符是否在字典树中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = sentence.charAt(j - <span class="number">1</span>) - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(curPos.next[t] == <span class="keyword">null</span>)&#123;<span class="comment">//有一个字符不在字典树的路径中</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curPos.next[t].isEnd)&#123;<span class="comment">//到达字典树末尾</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i] == <span class="number">0</span>)&#123;<span class="comment">// 0 为最小值，直接退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//继续判断子串中前一个字符</span></span><br><span class="line">                curPos = curPos.next[t];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)。空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;面试题-17-13-恢复空格&quot;&gt;&lt;a href=&quot;#面试题-17-13-恢复空格&quot; class=&quot;headerlink&quot; title=&quot;面试题 17.13. 恢复空格&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/re-space-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题 17.13. 恢复空格&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子&lt;code&gt;&amp;quot;I reset the computer. It still didn’t boot!&amp;quot;&lt;/code&gt;已经变成了&lt;code&gt;&amp;quot;iresetthecomputeritstilldidntboot&amp;quot;&lt;/code&gt;。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典&lt;code&gt;dictionary&lt;/code&gt;，不过，有些词没在词典里。假设文章用&lt;code&gt;sentence&lt;/code&gt;表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="字典树" scheme="https://hoo334.github.io/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>跳水板</title>
    <link href="https://hoo334.github.io/2020/07/08/%E8%B7%B3%E6%B0%B4%E6%9D%BF/"/>
    <id>https://hoo334.github.io/2020/07/08/%E8%B7%B3%E6%B0%B4%E6%9D%BF/</id>
    <published>2020-07-08T00:49:30.000Z</published>
    <updated>2020-07-08T01:03:00.980Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题-16-11-跳水板"><a href="#面试题-16-11-跳水板" class="headerlink" title="面试题 16.11. 跳水板"></a><a href="https://leetcode-cn.com/problems/diving-board-lcci/" target="_blank" rel="noopener">面试题 16.11. 跳水板</a></h4><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为<code>shorter</code>，长度较长的木板长度为<code>longer</code>。你必须正好使用<code>k</code>块木板。编写一个方法，生成跳水板所有可能的长度。</p><p>返回的长度需要从小到大排列。</p><a id="more"></a><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">shorter &#x3D; 1</span><br><span class="line">longer &#x3D; 2</span><br><span class="line">k &#x3D; 3</span><br><span class="line">输出： &#123;3,4,5,6&#125;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt; shorter &lt;= longer</li><li>0 &lt;= k &lt;= 100000</li></ul><p>提示中给出了相关信息，我们考虑特殊情况：</p><ol><li>k == 0，直接返回一个空数组；</li><li>shorter == longer，直接返回 shorter * k，只存在这一个长度。</li></ol><p>剩下的一般情况 shorter &lt; longer 且 k != 0，我们直接可以使用一次循环即可，数组第一个元素为 shorter * k，第二个元素为 shorter * (k - 1) + longer，第三个元素为 shorter * (k - 2) + longer * 2 … 最后一个元素为 longer * k，一共 k + 1 个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] divingBoard(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(shorter == longer)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;shorter * k&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)&#123;</span><br><span class="line">            ans[i] = shorter * (k - i) + longer * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;面试题-16-11-跳水板&quot;&gt;&lt;a href=&quot;#面试题-16-11-跳水板&quot; class=&quot;headerlink&quot; title=&quot;面试题 16.11. 跳水板&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/diving-board-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题 16.11. 跳水板&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为&lt;code&gt;shorter&lt;/code&gt;，长度较长的木板长度为&lt;code&gt;longer&lt;/code&gt;。你必须正好使用&lt;code&gt;k&lt;/code&gt;块木板。编写一个方法，生成跳水板所有可能的长度。&lt;/p&gt;
&lt;p&gt;返回的长度需要从小到大排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>路径总和</title>
    <link href="https://hoo334.github.io/2020/07/07/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>https://hoo334.github.io/2020/07/07/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</id>
    <published>2020-07-07T01:20:54.000Z</published>
    <updated>2020-07-07T01:39:59.143Z</updated>
    
    <content type="html"><![CDATA[<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></h4><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><a id="more"></a><p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure><p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p><p>此题可以转化为 是否存在从当前结点 root 的子结点到叶子结点的路径，满足路径和为 sum - root.val 。若当前结点为叶子结点，那么我们直接判断 sum 是否等于 val 即可。如果不是叶子结点，我们递归地调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意根结点为空的条件。</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//判断路径总和</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum == root.val;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(log n)，最坏O(n)。</p><p>我们还可以使用广度优先搜索的方式，记录从根结点到当前结点的路径和。我们使用两个队列。分别存储将要遍历的结点，以及根结点到这些结点的路径和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; qt = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; qi = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        qt.offer(root);</span><br><span class="line">        qi.offer(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!qt.isEmpty())&#123;</span><br><span class="line">            TreeNode now = qt.poll();</span><br><span class="line">            <span class="keyword">int</span> val = qi.poll();</span><br><span class="line">            <span class="keyword">if</span>(now.left == <span class="keyword">null</span> &amp;&amp; now.right == <span class="keyword">null</span> &amp;&amp; val == sum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(now.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                qt.offer(now.left);</span><br><span class="line">                qi.offer(now.left.val + val);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(now.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                qt.offer(now.right);</span><br><span class="line">                qi.offer(now.right.val + val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;112-路径总和&quot;&gt;&lt;a href=&quot;#112-路径总和&quot; class=&quot;headerlink&quot; title=&quot;112. 路径总和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/path-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;112. 路径总和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 叶子节点是指没有子节点的节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
