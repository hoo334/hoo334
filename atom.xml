<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2020-05-23T08:38:59.099Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字符串Hard</title>
    <link href="https://hoo334.github.io/2020/05/23/%E5%AD%97%E7%AC%A6%E4%B8%B2Hard/"/>
    <id>https://hoo334.github.io/2020/05/23/%E5%AD%97%E7%AC%A6%E4%B8%B2Hard/</id>
    <published>2020-05-23T08:24:51.000Z</published>
    <updated>2020-05-23T08:38:59.099Z</updated>
    
    <content type="html"><![CDATA[<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h4><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;</span><br><span class="line">输出: &quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>如果 S 中不存这样的子串，则返回空字符串 <code>&quot;&quot;</code>。</li><li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p>我们可以用滑动窗口的思想解决这个问题，在滑动窗口类型的问题中都会有两个指针。一个用于延伸现有窗口的 right 指针，和一个用于收缩窗口的 left 指针。在任意时刻，只有一个指针移动，另一个保持静止。我们在 s 上滑动窗口，通过 right 指针不断扩张窗口，当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩直到得到最小窗口。</p><p>如何判断滑动窗口[left,right)是否包含字符串 t 中所有字符呢？当让我们可以暴力统计，但这样效率太低。我们使用两个辅助数组 ，winFreq 表示窗口中的字符统计数组，tFreq 表示字符串 t 中的字符统计数组。维护变量 distance，表示滑动窗口内部包含了 t 中字符的个数，窗口内单个字符个数等于 t 中对应字符个数时不再增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> tLen = t.length();</span><br><span class="line">        <span class="keyword">if</span>(sLen == <span class="number">0</span> || tLen == <span class="number">0</span> || tLen &gt; sLen)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArrayS = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charArrayT = t.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] winFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span>[] tFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : charArrayT)&#123;</span><br><span class="line">            tFreq[c] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//distance 表示滑动窗口内部包含了 t 中字符的个数，窗口内单个字符个数等于 t 中对应字符个数时不再增加</span></span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = sLen + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//[left, right)滑动窗口长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; sLen)&#123;</span><br><span class="line">            <span class="keyword">char</span> charRight = charArrayS[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右边界元素在 t 中不出现</span></span><br><span class="line">            <span class="keyword">if</span>(tFreq[charRight] == <span class="number">0</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右边界元素在 t 中出现</span></span><br><span class="line">            <span class="keyword">if</span>(winFreq[charRight] &lt; tFreq[charRight])&#123;</span><br><span class="line">                distance++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//窗口字符减一，窗口右边界右移</span></span><br><span class="line">            winFreq[charRight]++;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左边界向右移动，滑动窗口此时已经包含 t 中所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(distance == tLen)&#123;</span><br><span class="line">                <span class="comment">//统计最小子串的开始位置及长度</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; minLen)&#123;</span><br><span class="line">                    minLen = right - left;</span><br><span class="line">                    begin = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//左边界元素在 t 中没有出现</span></span><br><span class="line">                <span class="keyword">char</span> charLeft = charArrayS[left];</span><br><span class="line">                <span class="keyword">if</span>(tFreq[charLeft] == <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左边界元素在 t 中出现</span></span><br><span class="line">                <span class="keyword">if</span>(winFreq[charLeft] == tFreq[charLeft])&#123;</span><br><span class="line">                    distance--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//窗口字符减一，窗口左边界右移</span></span><br><span class="line">                winFreq[charLeft]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minLen == sLen + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + minLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以优化空间只使用 tFreq 一个数组，将 distance 设置为 tLen ，对distance 使用减法，当distance == 0时表示窗口中含有字符串 t 中所有字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> tLen = t.length();</span><br><span class="line">        <span class="keyword">if</span>(sLen == <span class="number">0</span> || tLen == <span class="number">0</span> || tLen &gt; sLen)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArrayS = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charArrayT = t.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] tFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : charArrayT)&#123;</span><br><span class="line">            tFreq[c] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//distance 表示滑动窗口内部包含了 t 中字符的个数，窗口内单个字符个数等于 t 中对应字符个数时不再增加</span></span><br><span class="line">        <span class="keyword">int</span> distance = tLen;</span><br><span class="line">        <span class="keyword">int</span> minLen = sLen + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//[left, right)滑动窗口长度</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right &lt; sLen)&#123;</span><br><span class="line">            <span class="keyword">char</span> charRight = charArrayS[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右边界元素在 t 中出现</span></span><br><span class="line">            <span class="keyword">if</span>(tFreq[charRight] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                distance--;</span><br><span class="line">            &#125;</span><br><span class="line">            tFreq[charRight]--;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左边界向右移动，滑动窗口此时已经包含 t 中所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(distance == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//统计最小子串的开始位置及长度</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; minLen)&#123;</span><br><span class="line">                    minLen = right - left;</span><br><span class="line">                    begin = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//左边界元素在 t 中出现</span></span><br><span class="line">                <span class="keyword">char</span> charLeft = charArrayS[left];</span><br><span class="line">                <span class="keyword">if</span>(tFreq[charLeft] == <span class="number">0</span>)&#123;</span><br><span class="line">                    distance++;</span><br><span class="line">                &#125;</span><br><span class="line">                tFreq[charLeft]++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minLen == sLen + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + minLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode hard 字符串总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="滑动窗口" scheme="https://hoo334.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://hoo334.github.io/2020/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://hoo334.github.io/2020/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-05-10T03:44:06.000Z</published>
    <updated>2020-05-12T13:54:13.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><h3 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h3><p>操作系统特征：<strong>并发</strong>和<strong>共享</strong>。</p><h3 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h3><ul><li>资源管理：处理机管理、存储器管理、文件管理、设备管理。</li><li>用户与硬件的接口：命令接口、程序接口（系统调用）。</li></ul><h3 id="操作系统的分类和发展"><a href="#操作系统的分类和发展" class="headerlink" title="操作系统的分类和发展"></a>操作系统的分类和发展</h3><ol><li>手工操作阶段（无操作系统）</li><li>批处理阶段（操作系统开始阶段）解决人机矛盾和CPU和I/O速度不匹配的问题。分为单道批处理和多道批处理系统（内存中只能保持一道作业和能保持多道作业）。</li><li>分时操作系统。将 CPU 时间分为许多时间片，采用时间片轮转法，支持多道程序设计的系统。</li><li>实时操作系统。</li><li>网络操作系统和分布式操作系统。</li></ol><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>中断也称为外中断，指来自 CPU 执行指令以外的事情发生，如 I/O 中断。时钟中断表示固定的时间片已到。</p><p>异常也称为内中断，指源自CPU执行指令或内存内部的时间，如程序的非法操作码、地址越界、算术溢出、缺页等引起的事件。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用可视为特殊的公共子程序。凡是与资源有关的操作（如存储分配、进行 I/O 传输及管理文件等），都必须通过系统调用方式向操作系统提出服务请求。</p><h3 id="核心态与用户态"><a href="#核心态与用户态" class="headerlink" title="核心态与用户态"></a>核心态与用户态</h3><p>系统调用需要使用某些特权指令才能完成，需要由操作系统内核程序负责完成。用户程序通过执行访管指令来发起系统调用，请求操作系统提供服务。执行操作系统内核应用程序时，CPU 会在核心态，执行用户程序时在用户态。</p><p>用户态转向核心态：系统调用、发生中断和异常、执行特权指令、进程状态变换。</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程的特征：动态性、并发性、独立性、异步性、结构性。进程实体都是由程序段、数据段和进程控制块三部分组成的。</p><h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><p>运行态：单处理机环境下，每个时刻最多只能有一个进程处于运行态。</p><p>就绪态：进程已经准备运行，等待 CPU 调度。</p><p>阻塞态：进程正在等待某一事件而暂停运行。</p><p>进程三大状态之间的转换忽略。</p><h3 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h3><p>引入线程的目的是为了更好地使用多道程序并发执行，提高资源利用率和系统吞吐率。引进线程地目的则是为了减少程序在并发执行时所付出地时空开销，提高操作系统地并发性能。</p><h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><ol><li>作业调度。又称高级调度，从外存上处于后备状态地作业中挑选一个或多个作业，给他们分配内存、输入/输出等必要的资源，并建立相应的进程。</li><li>内存调度。又称中级调度，其作用是提高内存利用率和系统吞吐量。将暂时不能运行的进程调至外存等待，当运行条件已经具备，再将就绪进程重新调入内存。</li><li>进程调度。又称低级调度，按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</li></ol><h3 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h3><h4 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h4><p>FCFS 调度算法既可以用于作业调度，又可以用于进程调度。算法简单，效率较低。<strong>对长作业比较有利，对短作业不利；有利于 CPU 繁忙型作业，不利于 I/O繁忙型作业</strong>。</p><h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><p>短作业优先算法从后备队列中选择一个或若干估计运行时间最短作业，将它们调入内存运行。对长作业不利，会导致“饥饿”现象，SJF 调度算法的平均等待时间、平均周转时间最少。</p><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p>既可用于作业调度，又可用于进程调度，优先级描述作业运行的紧迫程度。按高优先级进程能否抢占正在执行的进程分为剥夺式优先级调度算法和非剥夺优先级调度算法。根据优先级是否改变分为动态优先级和静态优先级。</p><h4 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h4><p>用于作业调度，是对FCFS调度算法和SJF调度算法的一种综合平衡，同时还考虑了每个作业的等待时间和估计运行时间。<br>$$<br>响应比R_p=\frac{等待时间+要求服务时间}{要求服务时间}<br>$$</p><h4 id="时间片轮转法"><a href="#时间片轮转法" class="headerlink" title="时间片轮转法"></a>时间片轮转法</h4><p>主要适用于分时系统，系统将所搜就绪进程按时间的先后顺序排成一个队列，进程调度程序选择就绪进程依次执行一个时间片。时间片很大时退化为 FCFS 算法，时间片很小时导致进程切换开销过大。</p><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p>时间片轮转法和优先级调度算法的综合与发展。通过动态调整进程优先级和时间片大小，多级反馈队列可以兼顾多方面的系统目标。设置多个就绪队列，并为每个队列赋予不同的优先级，在优先级越高的队列中，每个进程运行的时间片越小。</p><h3 id="进程的同步"><a href="#进程的同步" class="headerlink" title="进程的同步"></a>进程的同步</h3><h4 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h4><p>临界资源：一次只允许一个进程使用的资源称为临界资源。</p><p>临界区：访问临界资源的那段代码。</p><p>同步：直接制约关系，为完成某任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程之间的直接制约关系源于它们之间的合作。</p><p>互斥：间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界区资源的进程退出临界区后，另一个进程才允许访问此临界资源。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个进程因竞争资源而造成的一种相互等待的情况，若无外力作用，这些进程都将无法向前推进。</p><h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><ul><li>互斥条件</li><li>不可抢占条件</li><li>请求并保持条件</li><li>循环等待条件</li></ul><h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><ol><li>死锁预防，破环产生死锁 4 个条件中的一个或几个。</li><li>死锁避免，在动态分配资源过程中，用某种方法防止系统进入不安全状态。<strong>银行家算法</strong></li><li>死锁的检测及解除，通过系统检查出死锁的发生，采取某种措施解除死锁。</li></ol><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h3><h4 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h4><ol><li>内存空间的分配与回收，由操作系统完成主存储器空间的分配与管理。</li><li>地址转换，在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，存储器管理须提供地址变换功能，将逻辑地址转换为响应的物理地址。</li><li>内存空间的扩充，利用虚拟存储技术</li><li>存储保护，保证各道作业在各自的存储空间内运行，互不干扰。</li></ol><h4 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h4><p>将源程序变为可在内存中执行的程序，一般需要以下几个步骤：</p><ul><li>编译，将用户源代码编译成若干目标模块，形成<strong>逻辑地址</strong>。</li><li>链接，将编译后的目标模块及所需要的库函数链接在一起，形成整个完整的装入模块。</li><li>装入，将完整的装入模块装入内存。</li></ul><p>链接分为三种：</p><ol><li>静态链接，在程序运行前，链接库函数。</li><li>装入时动态链接，在程序装入内存时，将库函数链接。</li><li>运行时动态链接，在程序执行时，将库函数链接。</li></ol><p>装入分三种：</p><ol><li>绝对装入，逻辑地址和物理地址完全相同。</li><li>可重定位装入。将装入模块装入内存适当的位置，装入时对指令和数据的修改过程称为重定位。地址变化通常是在装入时一次完成。</li><li>动态运行时装入，装入程序把装入模块装入内存后，并不立即把模块中的相对地址转换为绝对地址，在程序运行的过程中才进行地址的转换。</li></ol><h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><ol><li>单一连续分配。在内存中永远只有一道程序，不会产生越界访问。</li><li>固定分区分配。将内存划分为若干固定大小的区域，每个分区只装入一道作业。</li><li>动态分区分配。在进程装入内存时，根据进程的大小动态地建立分区。</li></ol><p>动态分区的分配策略：</p><ul><li>首次适应算法，空闲分区按<strong>地址递增</strong>的次序链接，分配时按顺序查找，找到大小能满足要求的第一个空闲分区。</li><li>最佳适应算法，空闲分区按<strong>分区大小递增</strong>的次序链接，找到第一个能满足要求的分区。</li><li>最坏适应算法，空闲分区按<strong>分区大小递减</strong>的次序链接，找到第一个能满足要求的分区。</li><li>临近适应算法，分配内存时从上一次查找结束的位置开始继续查找。</li></ul><h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><p>非连续分配允许将一个程序分散地装入不相邻的内存分区。</p><p>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存块中的空间。</p><h5 id="1-分页"><a href="#1-分页" class="headerlink" title="1. 分页"></a>1. 分页</h5><p><strong>进程中的块称为页(Page)，内存中的块称为页框(Page Frame，或页帧)</strong>。外存也以同样的单位进行划分，直接称为块(Block)。进程在执行时需要申请主存空间，即为每个页面分配主存中的可用页框。</p><p>&emsp;&emsp;页面大小应该是2的整数幂。页面太小会使进程的页面过多，页表过长，占用大量的内存，增加硬件地址转换的开销，降低页面换人/换出的效率；页面过大会使内部碎片增多，降低内存利用率。</p><p>&emsp;&emsp;为了便于内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，它记录页面在内存中对应的物理块号，<strong>页表一般存放在内存中</strong>。页表由页表项组成，<strong>页表项 = 页号 + 页框号</strong>。<strong>物理地址 = 页内地址 + 页框号 &times; 页面大小</strong></p><h5 id="2-分段"><a href="#2-分段" class="headerlink" title="2. 分段"></a>2. 分段</h5><p>段式管理按照用户进程中的自然段划分逻辑空间。在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，这个工作由编译程序完成。</p><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><h4 id="虚拟内存基本概念"><a href="#虚拟内存基本概念" class="headerlink" title="虚拟内存基本概念"></a>虚拟内存基本概念</h4><h5 id="传统存储管理方式的特征"><a href="#传统存储管理方式的特征" class="headerlink" title="传统存储管理方式的特征"></a>传统存储管理方式的特征</h5><p>1）一次性。作业必须一次性全部装入内存，才开始运行。</p><p>2）驻留性。作业被装入内存后，就一直驻留在内存中，可能造成进程长时间阻塞。</p><h5 id="局部性原则"><a href="#局部性原则" class="headerlink" title="局部性原则"></a>局部性原则</h5><p>1）时间局部性。程序中某条指令一旦执行，不久后该指令可能再次执行。</p><p>2）空间局部性。一旦程序访问了某个存储单元，不久后，其附近的存储单元也被访问。</p><h5 id="虚拟存储器的主要特性"><a href="#虚拟存储器的主要特性" class="headerlink" title="虚拟存储器的主要特性"></a>虚拟存储器的主要特性</h5><p>1）多次性。作业可分多次调入内存执行。</p><p>2）对换性。在作业运行过程中允许进行换入和换出。</p><p>3）虚拟性。从逻辑上扩充内存的容量。</p><h5 id="虚拟存储技术的实现"><a href="#虚拟存储技术的实现" class="headerlink" title="虚拟存储技术的实现"></a>虚拟存储技术的实现</h5><p>虚拟存储系统<strong>只能基于非连续分配技术</strong>，连续分配方式时，会使相当一部分内存空间处于暂时或者“永久”空闲的状态，严重造成内存资源的浪费。</p><p>1）请求分页存储管理</p><p>2）请求分段存储管理</p><p>3）请求段页式存储管理</p><p>不管哪种方式，都需要一定的<strong>硬件的支持</strong>，一般需要的支持有以下几个方面：</p><ul><li>一定容量的<strong>内存</strong>和<strong>外存</strong></li><li><strong>页表机制(或段表机制)</strong>，作为主要的数据结构</li><li><strong>中断机制</strong>，当用户程序要访问的部分尚未调入内存时，则产生中断</li><li><strong>地址变换机制</strong>，逻辑地址和物理地址的转换。</li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><h5 id="最佳-OPT-置换算法"><a href="#最佳-OPT-置换算法" class="headerlink" title="最佳(OPT)置换算法"></a>最佳(OPT)置换算法</h5><p>淘汰以后永久不使用的页面或者在最长时间内不再被访问的页面，以便保证获得最低的缺页率。由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因此该算法无法实现。</p><h5 id="先进先出-FIFO-页面置换算法"><a href="#先进先出-FIFO-页面置换算法" class="headerlink" title="先进先出(FIFO)页面置换算法"></a>先进先出(FIFO)页面置换算法</h5><p>优先淘汰最早进入内存的页面，即在内存中驻留时间最久的页面。</p><h5 id="最近最久未使用-LRU-置换算法"><a href="#最近最久未使用-LRU-置换算法" class="headerlink" title="最近最久未使用(LRU)置换算法"></a>最近最久未使用(LRU)置换算法</h5><p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近将来可能也不会被访问。</p><h5 id="时钟-CLOCK-置换算法"><a href="#时钟-CLOCK-置换算法" class="headerlink" title="时钟(CLOCK)置换算法"></a>时钟(CLOCK)置换算法</h5><p>简单的CLOCK算法给每帧关联一个附加位，称为<strong>使用位</strong>。当某页首次装入主存时，将该帧的使用位置为1。</p><h4 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h4><p>在页面置换算法中，<strong>刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存</strong>，这种频繁的页面调度行为称为<strong>抖动</strong>。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件三种分配方式比较"><a href="#文件三种分配方式比较" class="headerlink" title="文件三种分配方式比较"></a>文件三种分配方式比较</h3><table><thead><tr><th></th><th>访问第 n 条记录</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>连续分配</td><td>访问磁盘 1 次</td><td>顺序存取速度快，文件定长时可按文件起始地址及记录长度进行随机访问。</td><td>文件存储需要连续 的存储空间，会产生碎片，不利于文件的动态扩充</td></tr><tr><td>链式分配</td><td>访问磁盘 n 次</td><td>可解决外存的随便化问题，提高外存空间的利用率，动态增长较方便</td><td>只能按照文件的指针链顺序访问，查找效率低，指针信息存放消耗外存空间</td></tr><tr><td>索引分配</td><td>m 级需访问磁盘 m+1 次</td><td>可以随机访问，文件易于增删</td><td>索引表增加存储空间的开销，索引表的查找策略对文件系统效率影响较大</td></tr></tbody></table><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><table><thead><tr><th></th><th>描述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>先来先服务(FCFS)算法</td><td>按磁盘请求队列中的磁道号依次移动</td><td>公平、简单</td><td>平均寻道距离大，仅应用在磁盘I/O较少的 场合</td></tr><tr><td>最短寻找时间优先(SSTF)算法</td><td>选择离当前磁头距离最近的磁道</td><td>性能比“先来先服务”好</td><td>不能保证平均寻道时间最短，可能导致“饥饿”现象</td></tr><tr><td>扫描(SCAN)算法</td><td>按磁头移动方向移动到最边缘的磁道，然后反向</td><td>寻道性能较好，可避免“饥饿”现象</td><td>不利于远离磁头一端的访问请求</td></tr><tr><td>循环扫描(C-SCAN)算法</td><td>按磁头移动方向移动到最边缘的磁道，然后从另一端开始重新扫描</td><td>消除了对两端磁道请求的不公平</td><td>—</td></tr></tbody></table><h2 id="I-O-管理"><a href="#I-O-管理" class="headerlink" title="I/O 管理"></a>I/O 管理</h2><h3 id="I-O-控制方式"><a href="#I-O-控制方式" class="headerlink" title="I/O 控制方式"></a>I/O 控制方式</h3><ul><li>程序直接控制方式，每读一个字，CPU 对外设状态进行循环检查。CPU和I/O设备只能串行工作，CPU的利用率相对低。</li><li>中断驱动方式，允许I/O设备主动打断CPU的运行并请求服务，使得其向I/O控制器发送读命令后 CPU 继续做其它有用的工作。比程序直接控制更有效，但由于<strong>数据中的每个字在存储器与I/O控制器之间的传输都必须经过CPU</strong>，这就导致了中断驱动方式仍然会耗很多CPU时间。</li><li>DMA 方式，<strong>I/O设备和内存之间开辟直接的数据通路</strong>。</li><li>通道控制方式，I/O通道是专门负责输入/输出的处理机。I/O通道方式是DMA方式的发展，它<strong>可以减少CPU的干预</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      操作系统复试
    
    </summary>
    
    
      <category term="复试" scheme="https://hoo334.github.io/categories/%E5%A4%8D%E8%AF%95/"/>
    
    
      <category term="OS" scheme="https://hoo334.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>微机原理复习</title>
    <link href="https://hoo334.github.io/2020/05/09/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
    <id>https://hoo334.github.io/2020/05/09/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-05-09T06:02:10.000Z</published>
    <updated>2020-05-10T01:44:05.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机工作原理"><a href="#计算机工作原理" class="headerlink" title="计算机工作原理"></a>计算机工作原理</h3><p>冯诺依曼计算机体系结构：输入设备、输出设备、存储器、运算器和控制器。</p><h3 id="8086"><a href="#8086" class="headerlink" title="8086"></a>8086</h3><p>共 20 根地址线，16根数据线。地址线 20 根代表可寻址的空间为 1MB，数据线为 16 根代表处理器字长为 16位。</p><h4 id="地址线和数据线"><a href="#地址线和数据线" class="headerlink" title="地址线和数据线"></a>地址线和数据线</h4><ul><li>AD0 — AD7 低 8 位地址和低 8 位数据信号分时复用，传递地址信号位单向，传送数据信号时为双向。</li><li>A16 — A19 高 4 位地址信号，与状态信号分时复用。</li><li>A8 — A15  8 位地址信号。</li></ul><h4 id="控制信号和状态信号"><a href="#控制信号和状态信号" class="headerlink" title="控制信号和状态信号"></a>控制信号和状态信号</h4><p><img src="https://i.loli.net/2020/05/09/SEzlOaAqhcmHfRM.png" alt="image-20200509141827458"></p><h4 id="内部寄存器"><a href="#内部寄存器" class="headerlink" title="内部寄存器"></a>内部寄存器</h4><p>含 14 个 16 位寄存器，按功能可分为三类：8 个通用寄存器、4 个段寄存器和 2 个控制寄存器。</p><h5 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h5><ul><li><p>数据寄存器：AX、BX、CX、DX。</p></li><li><p>地址指针寄存器：SP、BP。</p></li><li><p>变址寄存器：SI、DI。</p></li></ul><p>AX：累加器。所有 I/O 指令都通过 AX 与接口传送信息，中间运算结果也多放于 AX 中。</p><p>BX：基址寄存器。在间接寻址中用于存放基地址。</p><p>CX：计数寄存器。用于在循环或串操作指令中存放计数值。</p><p>DX：数据寄存器。在间接寻址的 I/O 指令中存放 I/O 端口地址，在 32 位乘除法运算时，存放高 16 位数。</p><p>SP：堆栈指针寄存器，其内容为栈顶的偏移地址。</p><p>BP：基址指针寄存器，常用于在访问内存时存放内存单元的偏移地址。</p><p>BX 用于数据段，BP 用于堆栈段。</p><p>SI：源变址寄存器</p><p>DI：目标变址寄存器</p><h5 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h5><ul><li>CF 进位标志位；</li><li>PF 奇偶标志位；</li><li>AF 辅助进位位；</li><li>ZF 零标志位，当运算结果为零时置 1 ；</li><li>SF 符号标志位，运算结果最高位为 1 时，SF = 1；</li><li>OF 溢出标志位。</li><li></li></ul><h5 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h5><ul><li>CS 代码段寄存器，存放代码段的段基地址。</li><li>DS 数据段寄存器，存放数据段的段基地址。</li><li>ES 附加段寄存器，存放数据段的段基地址。</li><li>SS 堆栈段寄存器，存放堆栈段的段基地址。</li></ul><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><p>例如 MOV AX，1200H。仅适合于源操作数。</p><h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>例如 MOV AX，BX。参加操作的操作数在 CPU 的通用寄存器中。</p><h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>例如 MOV AX，[1200H]。指令中直接给出操作数的偏移地址。</p><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>例如 MOV AX，[BX]。参加操作的操作数放在内存中，其偏移地址为指令中寄存器的内容。</p><p>存放偏移地址的寄存器称为间址寄存器，它们分别是 BX，BP，SI，DI。</p><p>操作数的段地址取决于选择哪一个间址寄存器。当选择 BX，SI，DI 时默认在数据段。当选择 BP 时默认在堆栈段。</p><h4 id="寄存器相对寻址"><a href="#寄存器相对寻址" class="headerlink" title="寄存器相对寻址"></a>寄存器相对寻址</h4><p>例如 MOV AX，[BX+DATA]。操作数的偏移地址为寄存器的内容加上一个位移量。</p><p>基址寄存器为 BX 时默认在数据段；基址寄存器为 BP 时，默认在堆栈段。</p><h4 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h4><p>例如 MOV AX，[BP+DI+DATA]。操作数的偏移地址为基址寄存器内容+变址寄存器内容+位移量。操作数的段地址由选择的基址寄存器决定。</p><h3 id="8086-指令系统"><a href="#8086-指令系统" class="headerlink" title="8086 指令系统"></a>8086 指令系统</h3><p>从功能上包括六大类：</p><p>数据传送、算术运算、逻辑运算和移位、串操作、程序控制和处理器控制。</p><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><p>包括通用数据传送、输入输出、地址传送和标志位操作。</p><h5 id="通用数据传送"><a href="#通用数据传送" class="headerlink" title="通用数据传送"></a>通用数据传送</h5><p><strong>该类指令的执行对标志位不产生影响。</strong></p><p>mov 指令</p><p>MOV dest,   src</p><p>两操作数 字长必须相同，两操作数<strong>不允许同时为存储器操作数</strong>、不允许同时为段寄存器，在源操作数是立即数时，目标操作数不能是段寄存器。</p><p>入栈/出栈指令</p><p>PUSH oprd </p><p>POP oprd</p><p>oprd 为 16 位寄存器或存储器两单元，不能为立即数。</p><p>交换指令</p><p>XCHG REG, MEM/REG</p><p>两个操作数必须有一个是寄存器操作数，不允许使用段寄存器。</p><p>查表指令</p><p>XLAT</p><p>用 BX 的内容代表表格首地址，AL 内容为表内位移量，BX+AL得到要查找元素的偏移地址。将 BX+AL 所指单元的内容送 AL。</p><h5 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h5><p>输入指令：IN acc，PORT</p><p>输出指令：OUT PORT，acc</p><p>根据端口地址码的长度，指令有两种不同的端口地址表现形式。</p><ul><li>直接寻址。端口地址为 8 位时，指令中直接给出 8 位端口地址，寻址 256 个端口。</li><li>间接寻址。端口地址为 16 位时，指令中的端口地址必须由 DX 指定；可寻址 64K 个端口。</li></ul><h5 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h5><p>取偏移地址指令 LEA。计算 MEM 相对于 REG 的偏移地址。</p><p>LEA REG,   MEM</p><p>将变量的 16 位偏移地址取出送目标寄存器。源操作数必须是一个存储器操作数，目标操作数通常是间址寄存器。</p><h4 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h4><p>算术运算指令的执行大多对状态标志位会产生影响。</p><h5 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h5><p>普通加法指令 </p><p>ADD oprd1,oprd2 </p><p>oprd1 = oprd1 + oprd2</p><p>带进位的加法指令 </p><p>ADC oprd1,oprd2 </p><p>oprd1 = oprd1+oprd2+CF</p><p>自增指令</p><p>INC oprd</p><p>oprd += 1</p><h5 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h5><p>普通减法指令</p><p>SUB oprd1, oprd2</p><p>oprd1 = oprd1 - oprd2</p><p>考虑借位的减法指令</p><p>SBB oprd1, oprd2</p><p>oprd1 = oprd1 - oprd2 - CF</p><p>自减指令</p><p>DEC oprd</p><p>oprd -= 1</p><p>取反指令</p><p>NEG oprd</p><p>oprd = 0-oprd</p><p>比较指令</p><p>CMP oprd1, oprd2</p><p>oprd1 - oprd2</p><p><strong>影响标志位</strong> 如果 oprd1 &gt; oprd2 则 CF = 0 </p><h5 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h5><p>无符号乘法指令 MUL</p><p>MUL oprd</p><p>oprd 为字节数   AX = AL * oprd</p><p>oprd 为 16 位数 DX AX = AX * oprd</p><h5 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h5><p>DIV oprd</p><p>若 oprd 是字节数 执行 AL / oprd。结果 AL 为商， AH 为余数</p><p>若 oprd 是双字节数执行 DX AX / oprd。结果 AX 为商，DX 为余数。</p><h4 id="逻辑运算和移位指令"><a href="#逻辑运算和移位指令" class="headerlink" title="逻辑运算和移位指令"></a>逻辑运算和移位指令</h4><h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p>AND oprd1, oprd2</p><p>OR oprd1, oprd2</p><p>NOT oprd 操作数按位取反再送回原地址，操作数不能为立即数，指令的执行对标志位无影响。</p><p>XOR oprd1, oprd2 两操作数异或，结果送目标地址</p><p>TEST oprd1, oprd2 将执行 “与” 操作，但运算的结果不送回目标地址。</p><h5 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h5><p>逻辑左移 SHL 、逻辑右移 SHR：将移动的位补 0 ，移除的位到 CF。</p><p>算术左移SAL、算术右移SAR：符号位不动，移动的位补 0 ，移除的位到 CF 。</p><p>不带进位循环左移ROL、不带进位循环右移ROR：将移除的位同时加到 CF 和被移动的位。</p><p>带进位循环左移 RCL、带进位循环右移 RCR：CF 参与循环移位，向左循环移位则 CF 在最左边（向右循环则 CF 在最右边）。</p><h4 id="程序控制指令"><a href="#程序控制指令" class="headerlink" title="程序控制指令"></a>程序控制指令</h4><h5 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h5><p>无条件转移指令 JMP oprd 。oprd 是 16 位偏移地址。</p><p>条件转移指令</p><p>JC/JNC、JZ/JNZ、JO/JNO、JP/JPE分别判断 CF、ZF、OF、PF 是否为 1 /为 0 。</p><h5 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h5><p>LOOP 循环次数由 CX 决定。用法 LOOP Label</p><h5 id="过程调用和返回"><a href="#过程调用和返回" class="headerlink" title="过程调用和返回"></a>过程调用和返回</h5><p>调用 CALL PROC</p><p>返回 RET，一般位于子程序的最后</p>]]></content>
    
    <summary type="html">
    
      微机原理复习
    
    </summary>
    
    
      <category term="复试" scheme="https://hoo334.github.io/categories/%E5%A4%8D%E8%AF%95/"/>
    
    
      <category term="计算机组成原理" scheme="https://hoo334.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>二分查找 Hard</title>
    <link href="https://hoo334.github.io/2020/04/29/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEHard/"/>
    <id>https://hoo334.github.io/2020/04/29/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEHard/</id>
    <published>2020-04-29T02:43:05.000Z</published>
    <updated>2020-05-24T03:13:54.653Z</updated>
    
    <content type="html"><![CDATA[<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></h4><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure><p>先考虑一个有序数组中查找中位数的情况：当数组元素为奇数时，取最中间的一个元素；当数组元素为偶数时，取最中间的两个元素的平均值。</p><p>有两个有序数组时我们先计算出总数组的长度，在两个数组中间画一条分割线，当两条分割线左侧的元素个数为总数组长度的一半时，在分割线左右的四个元素则是构成中位数的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length &gt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="comment">//分割线左边的所有元素需要满足的个数(m + n + 1) / 2</span></span><br><span class="line">        <span class="keyword">int</span> totalLeft = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//在 nums1 的区间 [0, m]里查找恰当的分割线</span></span><br><span class="line">        <span class="comment">//使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="comment">//在较小长度的数组使用二分查找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//向上取整</span></span><br><span class="line">            <span class="keyword">int</span> i = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line">            <span class="comment">//搜索分割线位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] &gt; nums2[j])&#123;<span class="comment">//不满足交叉小于的情况</span></span><br><span class="line">                <span class="comment">//下一轮搜索区间 [left, i - 1]</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间 [i, right]</span></span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line">        <span class="keyword">int</span> nums1LeftMax = i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">        <span class="keyword">int</span> nums2LeftMax = j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> nums2RightMIn = j == n ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((m + n) % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums1LeftMax, nums2LeftMax);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)((Math.max(nums1LeftMax,nums2LeftMax) + Math.min(nums1RightMin, nums2RightMIn))) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是 O( log( min(<em>m</em>,n) ) )，空间复杂度：O(1)。</p><h4 id="1095-山脉数组中查找目标值"><a href="#1095-山脉数组中查找目标值" class="headerlink" title="1095. 山脉数组中查找目标值"></a><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></h4><p>（这是一个 <strong>交互式问题</strong> ）</p><p>给你一个 <strong>山脉数组</strong> <code>mountainArr</code>，请你返回能够使得 <code>mountainArr.get(index)</code> <strong>等于</strong> <code>target</code> <strong>最小</strong> 的下标 <code>index</code> 值。</p><p>如果不存在这样的下标 <code>index</code>，就请返回 <code>-1</code>。</p><p>何为山脉数组？如果数组 <code>A</code> 是一个山脉数组的话，那它满足如下条件：</p><p><strong>首先</strong>，<code>A.length &gt;= 3</code></p><p><strong>其次</strong>，在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 <code>i</code> 使得：</p><ul><li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li><li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul><p>你将 <strong>不能直接访问该山脉数组</strong>，必须通过 <code>MountainArray</code> 接口来获取数据：</p><ul><li><code>MountainArray.get(k)</code> - 会返回数组中索引为<code>k</code> 的元素（下标从 0 开始）</li><li><code>MountainArray.length()</code> - 会返回该数组的长度</li></ul><p><strong>注意：</strong></p><p>对 <code>MountainArray.get</code> 发起超过 <code>100</code> 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p><p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “<strong>答案</strong>”：<a href="https://leetcode-cn.com/playground/RKhe3ave，请注意这" target="_blank" rel="noopener">https://leetcode-cn.com/playground/RKhe3ave，请注意这</a> <strong>不是一个正确答案</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：array &#x3D; [1,2,3,4,5,3,1], target &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：array &#x3D; [0,1,2,4,2,1], target &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line">解释：3 在数组中没有出现，返回 -1。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li><li><code>0 &lt;= target &lt;= 10^9</code></li><li><code>0 &lt;= mountain_arr.get(index) &lt;= 10^9</code></li></ul><p>山脉数组表示数组中间存在一个最大的数，它左边的数都是单调递增，右边的数都是单调递减。如果是已经排序的数组我们可以想到二分查找，那么山脉数组能不能也使用二分查找呢？</p><p>答案是可以，只要我们找到最高点的下标，将山脉数组分成左边一个单调递增的数组，右边分为一个单调递减的数组，然后分别对这两个数组进行二分查找。</p><p>问题的关键是如何找到最高点的下标，常规的做法是直接遍历一遍数组找到最大值的下标。更巧妙的方法是使用类似二分查找的方法来找到最高点的下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"><span class="comment">//计算中间点的下标</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mountainArr[mid] &lt; mountainArr[mid+1] </span></span><br><span class="line"><span class="comment">//mountainArr[mid+1]比其左侧的值都大,其左侧的值不可能为最高点</span></span><br><span class="line"><span class="keyword">if</span>(mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="number">1</span>))&#123;</span><br><span class="line"><span class="comment">//下一轮搜索区间[mid+1, right]</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123; <span class="comment">//mountainArr[mid] &gt;= mountainArr[mid+1] </span></span><br><span class="line">   <span class="comment">//mountainArr[mid]比其左侧的值都大,其右侧的值不可能为最高点</span></span><br><span class="line"><span class="comment">//下一轮搜索区间[left, mid]</span></span><br><span class="line">right = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到了最高点后，先在左边递增的部分寻找目标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(mountainArr.get(mid) &lt; target)&#123;</span><br><span class="line">          <span class="comment">//target 比 mountainArr[mid+1]左侧的值都大,其左侧的值不可能为target</span></span><br><span class="line">          <span class="comment">//下一轮搜索区间[mid+1, right]</span></span><br><span class="line">          left = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//target 比 mountainArr[mid]右侧的值都小,其右侧的值不可能为target</span></span><br><span class="line">          <span class="comment">//下一轮搜索区间[left, mid]</span></span><br><span class="line">          right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没找到就在右边递减的部分寻找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(mountainArr.get(mid) &lt; target)&#123;</span><br><span class="line">          <span class="comment">//target 比 mountainArr[mid-1]右侧的值都大,其右侧的值不可能为target</span></span><br><span class="line">        <span class="comment">//下一轮搜索区间[left, mid - 1]</span></span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">//target 比 mountainArr[mid]左侧的值都小,其左侧的值不可能为target</span></span><br><span class="line">       <span class="comment">//下一轮搜索区间[mid, right]</span></span><br><span class="line">         <span class="comment">//[left(mid), right] --&gt; [left, right(mid)] 将下取整改为上取整</span></span><br><span class="line">         <span class="comment">//否则为死循环</span></span><br><span class="line">      left = mid;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将整合所有部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is MountainArray's API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * interface MountainArray &#123;</span></span><br><span class="line"><span class="comment"> *     public int get(int index) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     public int length() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = mountainArr.length();</span><br><span class="line">        <span class="keyword">int</span> peekIndex = findPeekIndex(mountainArr, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mountainArr.get(peekIndex) == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> peekIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = findSortedArray(target, mountainArr, <span class="number">0</span>, peekIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findReverseArray(target, mountainArr, peekIndex + <span class="number">1</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findPeekIndex</span><span class="params">(MountainArray mountainArr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[mid+1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[left, mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left == right</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSortedArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mountainArr.get(mid) &lt; target)&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[mid+1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[left, mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mountainArr.get(left) == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findReverseArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mountainArr.get(mid) &lt; target)&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[mid, right]</span></span><br><span class="line">                <span class="comment">//[left(mid), right] --&gt; [left, right(mid)] 将下取整改为上取整</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mountainArr.get(left) == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode hard 二分查找总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>二分查找 Medium</title>
    <link href="https://hoo334.github.io/2020/04/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEMedium/"/>
    <id>https://hoo334.github.io/2020/04/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEMedium/</id>
    <published>2020-04-27T01:21:09.000Z</published>
    <updated>2020-05-11T10:04:14.139Z</updated>
    
    <content type="html"><![CDATA[<h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><p>由于题目要求时间复杂度为O(log n)，这提示我们使用二分查找。</p><p>数组本身不是有序的，进行旋转后只是局部有序的，还能二分查找吗？</p><p>可以发现，我们将数组从中间分成左右两部分后，左右部分中一定有一个部分是有序的。例如示例中我们从 <code>6</code> 这个位置分开为<code>[4,5,6]</code> 和 <code>[7,0,1,2]</code> ，其中左边 <code>[4,5,6]</code> 这个部分的数组是有序的。</p><p>这启示我们可以在常规二分查找上改动，每次判断分割出来的两个部分，哪个是有序的，根据有序的部分改变二分搜索的上下界。</p><ul><li>如果 <code>[1, mid-1]</code> 是有序数组，且 <code>target</code>  的大小满足 <code>[nums[l], nums[mid])</code> ，则我们将搜索范围缩小到 <code>[1, mid-1]</code> ，否则在<code>[mid+1, r]</code> 中寻找。</li><li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code>  的大小满足 <code>[nums[mid+1], nums[r])</code> ，则我们将搜索范围缩小到 <code>[mid+1, r]</code> ，否则在<code>[1, mid-1]</code> 中寻找。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//左边部分有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="comment">//target 在有序部分</span></span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt;= nums[mid])&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//target 不在有序部分</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//右边部分有序</span></span><br><span class="line">                 <span class="comment">//target 在有序部分</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; target &lt;= nums[n-<span class="number">1</span>])&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//target 不在有序部分</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(logN)，空间复杂度 O(1)。</p><h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li></ul><p>采用快速幂等法。有递归和迭代两个版本。</p><p><strong>递归版本</strong></p><p>快速幂算法的本质是分治算法。例如在计算 x^64 时我们可以看作求 x^32 的平方，进而可以看作求 x^16 的四次方……</p><p>再来看一般情况如果需要求 x^77 ，可以看作 x^38 * x^38 *x，对 x^38 可以看作 x^19 的平方，x^19 可以看作 x^9 * x^9 * x……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="comment">// n 为负数时，求 -n 次方并取倒数</span></span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//n 不是偶数时需要乘 x</span></span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(logN)，空间复杂度 O(logN)。</p><p><strong>迭代版本</strong></p><p>以 x^77 为例，首先看 77 这个整数，77化为二进制得到1001101，我们可以将 77 表示为 64+8+4+1。我们只需算出 x 的 2 的指数倍次方的结果就可以表示 x 的所有次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="keyword">while</span>(N != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (N &amp; <span class="number">1</span>) == <span class="number">1</span> )&#123;</span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 计算 x 的 2 的指数次方结果</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            N = N &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(logN)，空间复杂度 O(1)。</p><p>迭代法真是妙蛙种子吃着妙脆角妙进了米奇妙妙屋，妙到家了。</p>]]></content>
    
    <summary type="html">
    
      Leetcode medium 二分查找总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://hoo334.github.io/2020/04/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://hoo334.github.io/2020/04/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-22T01:49:06.000Z</published>
    <updated>2020-04-22T02:36:55.666Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。每次遍历一次都使一个元素归位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="comment">//外层循环 N-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">//内层循环 N-i-1 次。第 i 次遍历整个数组需要交换 N-i-1 次。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;N-i; j++)&#123;</span><br><span class="line">                <span class="comment">//比较和交换</span></span><br><span class="line">                <span class="keyword">if</span>(a[j].compareTo(a[j-<span class="number">1</span>]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    Comparable temp = a[j];</span><br><span class="line">                    a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">                    a[j-<span class="number">1</span>] =temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h3><p>选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小元素，存放到排序序列的前部分，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="comment">// 找出未排序序列中的最小元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[min].compareTo(a[j]) &gt; <span class="number">0</span>) min = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使未排序序列中的最小值归位</span></span><br><span class="line">            Comparable temp = a[min];</span><br><span class="line">            a[min] = a[i];</span><br><span class="line">            a[i] = temp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将第 i 个元素与前面的 0 ~ i-1 个元素比较,若比其中的元素小则依次交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span> &amp;&amp; a[j].compareTo(a[j-<span class="number">1</span>])&lt;<span class="number">0</span> ;j--)&#123;</span><br><span class="line">               Comparable temp = a[j];</span><br><span class="line">               a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">               a[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h +<span class="number">1</span>;  <span class="comment">//h = 1,4,13,40 ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将数组变为 h 有序，即相隔 h 个元素 的元素构成一组，组内有序，</span></span><br><span class="line"><span class="comment">        将 h 的值逐渐缩小则数组有序。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h; i&lt;N; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=h &amp;&amp; a[j].compareTo(a[j-h])&lt;<span class="number">0</span>; j-=h)&#123;</span><br><span class="line">                    Comparable temp = a[j];</span><br><span class="line">                    a[j] = a[j-h];</span><br><span class="line">                    a[j-h] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组a[lo...hi]排序</span></span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a,lo,mid);</span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);</span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将a[lo..mid] 和a[mid+1..hi]归并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//将a[lo..hi] 复制到aux[lo..hi]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo; k&lt;=hi; ++k)</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> i = lo, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo; k&lt;=hi; ++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++]; <span class="comment">//左半边用尽</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];<span class="comment">//右半边用尽</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(aux[i].compareTo(aux[j]) &lt; <span class="number">0</span>) a[k] = aux[i++];</span><br><span class="line">                      <span class="keyword">else</span> a[k] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//将左半部分排序</span></span><br><span class="line">        sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将右半部分排序</span></span><br><span class="line">        sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[]a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组切分为a[lo..i-1], a[i], a[i+1..hi]</span></span><br><span class="line">        <span class="keyword">int</span> i=lo,j=hi;</span><br><span class="line">        <span class="comment">//选取第一个元素为基准点</span></span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i，j 相遇停止</span></span><br><span class="line">        <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//先从左边开始，不能保证你最后和基准点交换的那个数，是小于等于左边的。例如 2，1，4，9</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//找出右边比基准点小的元素的下标</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; i &amp;&amp; a[j].compareTo(v) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找出左边比基准点大的元素的下标</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i].compareTo(v) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="comment">//交换a[i] 和 a[j]</span></span><br><span class="line">                Comparable temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] =temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i，j 相遇，基准点的位置已经找到，将a[v] 与 a[i] 交换。</span></span><br><span class="line">        Comparable temp = a[lo];</span><br><span class="line">        a[lo] = a[j];</span><br><span class="line">        a[j] =temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回基准点的下标</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点开始，从下至上，从右至左向下调整。</span></span><br><span class="line">            adjustDown(a,i,a.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换堆顶元素与最后一个元素，最大的元素归位。由于破坏了大根堆的特性需要重新调整堆顶元素。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a.length-<span class="number">1</span>; j&gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="comment">//交换元素</span></span><br><span class="line">            Comparable temp = a[<span class="number">0</span>];</span><br><span class="line">            a[<span class="number">0</span>] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向下调整大根堆</span></span><br><span class="line">            adjustDown(a,<span class="number">0</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(Comparable[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>*i+<span class="number">1</span>; k&lt;length; k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到两个子结点中较大的一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; a[k].compareTo(a[k+<span class="number">1</span>])&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果子结点的值大于父结点的值，将父结点向下调整，继续向下调整</span></span><br><span class="line">            <span class="keyword">if</span>(a[k].compareTo(temp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//父结点的值设置为子结点的值</span></span><br><span class="line">                a[i] = a[k];</span><br><span class="line">                <span class="comment">//对当前结点继续向下调整</span></span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将 temp 值放到最终的位置</span></span><br><span class="line">        a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>]]></content>
    
    <summary type="html">
    
      排序算法总结
    
    </summary>
    
    
      <category term="数据结构" scheme="https://hoo334.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://hoo334.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>DFS &amp; BFS Medium</title>
    <link href="https://hoo334.github.io/2020/04/20/DFS&amp;BFSMedium/"/>
    <id>https://hoo334.github.io/2020/04/20/DFS&amp;BFSMedium/</id>
    <published>2020-04-20T03:28:20.000Z</published>
    <updated>2020-04-29T03:17:36.443Z</updated>
    
    <content type="html"><![CDATA[<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h4><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure><p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1 ，则以其为起始结点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对网格中的每个 1 都做深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//发现一个岛屿</span></span><br><span class="line">                    ++ count;</span><br><span class="line">                    <span class="comment">//将该 1 相连的 1 全部置为 0</span></span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">//将第 r 行，第 c 列的 1 相邻的 1 全部置为 0</span></span><br><span class="line">        grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(r-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="string">'1'</span>) dfs(grid, r-<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span>(r+<span class="number">1</span> &lt;rows &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) dfs(grid, r+<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span>(c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="string">'1'</span>)dfs(grid, r, c-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(c+<span class="number">1</span> &lt; cols &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>)dfs(grid, r, c+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//发现一个岛屿</span></span><br><span class="line">                    grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                    ++count;</span><br><span class="line">                    </span><br><span class="line">                    Queue&lt;Integer&gt; neighbors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    neighbors.add(i*cols+j);</span><br><span class="line">                    <span class="comment">//BFS</span></span><br><span class="line">                    <span class="keyword">while</span>(! neighbors.isEmpty())&#123;</span><br><span class="line">                        <span class="comment">//得到保存的行列信息</span></span><br><span class="line">                        <span class="keyword">int</span> id = neighbors.remove();</span><br><span class="line">                        <span class="keyword">int</span> r = id / cols;</span><br><span class="line">                        <span class="keyword">int</span> c = id % cols;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//将第 i 行，第 j 列的 1 相邻的 1 全部置为 0</span></span><br><span class="line">                        <span class="keyword">if</span>(r-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add((r-<span class="number">1</span>)*cols+c);</span><br><span class="line">                            grid[r-<span class="number">1</span>][c] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(r+<span class="number">1</span> &lt;rows &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add((r+<span class="number">1</span>)*cols+c);</span><br><span class="line">                            grid[r+<span class="number">1</span>][c] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add(r*cols + c - <span class="number">1</span>);</span><br><span class="line">                            grid[r][c-<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(c+<span class="number">1</span> &lt; cols &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add(r*cols + c + <span class="number">1</span>);</span><br><span class="line">                            grid[r][c+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode medium DFS &amp; BFS 总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://hoo334.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>动态规划 Medium</title>
    <link href="https://hoo334.github.io/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92Medium/"/>
    <id>https://hoo334.github.io/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92Medium/</id>
    <published>2020-04-19T01:43:48.000Z</published>
    <updated>2020-05-12T02:18:44.738Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p>在看这个问题之前我们首先来看看如何判断回文字符串，我们很容易写出下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=s.length()-<span class="number">1</span>; i&lt;j; ++i,--j)&#123;</span><br><span class="line"><span class="keyword">if</span>(s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，回文字符串是关于一个字符或者最中心的两个字符左右对称的。</p><ul><li>当字符串中字符数为奇数时关于最中心的字符对称，例如 abcba 关于字符 c 对称。</li><li>当字符串中字符数为偶数时关于最中心的两个字符之间的空格对称，例如 abba 关于 bb 对称。</li></ul><p>一个字符数为 n 的字符串可以关于 n 个单字符对称，关于 n-1 个两个字符对称。我们只需遍历 2n - 1 次即可得到所有回文字符串，在遍历时记录最长回文字符串的位置即可找出最长回文子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length()&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, end=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); ++i)&#123;</span><br><span class="line">        <span class="comment">//关于单个字符对称</span></span><br><span class="line">       <span class="keyword">int</span> len1 = expandAround(s,i,i);</span><br><span class="line">        <span class="comment">//关于中心两个字符对称</span></span><br><span class="line">       <span class="keyword">int</span> len2 = expandAround(s,i,i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//取最大长度</span></span><br><span class="line">       <span class="keyword">int</span> len = Math.max(len1,len2);</span><br><span class="line">        <span class="comment">//记录最长回文子串的起始位置</span></span><br><span class="line">       <span class="keyword">if</span>(len &gt; end-start)&#123;</span><br><span class="line">       start = i - (len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        end = i + len/<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回子串</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 求字符串 s 中，left right 开始的对称点的回文字符串长度。</span></span><br><span class="line"><span class="comment">* 当 left == right 时，关于单个字符对称，当 left + 1 == right 时关于s[left],s[right]这两个中心字* 符对称。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAround</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left &gt;=<span class="number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">        left--;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> right-left-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(n^2)，空间复杂度O(1)。</p><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://i.loli.net/2020/04/27/ymcKdA4V1LXFkaP.png" alt="img"></p><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= m, n &lt;= 100</code></p></li><li><p>题目数据保证答案小于等于 <code>2 * 10 ^ 9</code></p></li></ul><p>我们使用 <code>dp[i][j]</code> 来存储到达 <code>(i,j)</code> 的最多路径，由于机器人只能向下或向右，则 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code> 。对于第一行 <code>dp[0][]</code> 和第一列 <code>dp[][0]</code> 只能有一条路径到达，所以它们的值全部为 1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] counts = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="comment">//第一行和第一列全为 1 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)counts[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)counts[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;m; j++)&#123;</span><br><span class="line">                <span class="comment">//dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line">                counts[i][j] = counts[i-<span class="number">1</span>][j] + counts[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(mn)，空间复杂度为 O(mn)。</p><p>优化空间复杂度 为 O(n)</p><p>由于只需要<code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code> ，我们只用使用一个一维数组存储上一行的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="comment">//cur[j] 为 dp[i-1][j]，cur[j-1] 为 dp[i][j-1]。</span></span><br><span class="line">                cur[j] += cur[j-<span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(mn)，空间复杂度为 O(n)。</p><h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></h4><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://i.loli.net/2020/04/27/ymcKdA4V1LXFkaP.png" alt="img"></p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>说明：</strong>m 和 <em>n</em> 的值均不超过 100。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p>此题相比 <a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a> 多了一个障碍物判断。第一行第一列中只要有一个障碍物，后面的路径数全部为 0 。如果位置 <code>(i,j)</code>  上有障碍物，则路径数直接为 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] counts = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="comment">//初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                counts[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                counts[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;m; j++)&#123;</span><br><span class="line">                <span class="comment">//有障碍物直接为 0 </span></span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    counts[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//dp</span></span><br><span class="line">                    counts[i][j] = counts[i-<span class="number">1</span>][j]+counts[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(mn)，空间复杂度为 O(mn)。</p><h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a></h4><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p>动态转移方程为：<code>dp[i] = MIN(dp[i], dp[i - j * j] + 1)</code>，<code>i</code>表示当前数字，<code>j*j</code>表示平方数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure><p>使用 dp 数组来保存以当前下标为和的完全平方数的个数。依次对每个数判断是否可以使用之前的dp数组中的值加一个较大的完全平方数得到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="comment">//最坏的情况，全部由 1 相加得到</span></span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; i-j*j&gt;=<span class="number">0</span>; ++j)&#123;</span><br><span class="line">                <span class="comment">//尝试由 i-1, i-4, i-9 ...得到 i </span></span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n*sqrt(n))，空间复杂度为 O(n)。</p><h4 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. 摆动序列</a></h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为<strong>摆动序列。</strong>第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反, <code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong><br>你能否用 O(<em>n</em>) 时间复杂度完成此题?</p><p>每当我们选择一个元素作为摆动序列的一部分时，这个元素要么是上升的，要么是下降的，这取决于前一个元素的大小。</p><p>我们使用两个数组来 dp，up[i] 存的是目前为止的以第 i 个元素结尾的上升摆动序列的长度。</p><p>类似的，down[i] 存的是目前为止以第 i 个元素结尾的下降摆动序列的长度。</p><p>数组中的任何元素都对应下面三种可能状态中的一种：</p><ol><li>上升的位置，意味着 nums[i] &gt; nums[i - 1]</li><li>下降的位置，意味着 nums[i] &lt; nums[i - 1]</li><li>相同的位置，意味着 nums[i] == nums[i - 1]</li></ol><p>如果为情况 1 ，意味着在这里摆动上升，前一个数字肯定处于下降的位置。所以 up[i] = down[i-1]+1, down[i] = down[i-1]。</p><p>如果为情况 2， 意味着在这里摆动下降，前一个数字肯定处在上升的位置。所以 down[i] = up[i-1]+1, up[i] = up[i-1]。</p><p>如果为情况 3，up[i] = up[i-1], down[i] = down[i-1]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        up[<span class="number">0</span>] = down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="comment">//情况1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                up[i] = down[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>])&#123; <span class="comment">//情况 2</span></span><br><span class="line">                down[i] = up[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//情况 3</span></span><br><span class="line">                down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">                up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up[nums.length-<span class="number">1</span>], down[nums.length-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n)，空间复杂度为 O(n)。</p><p>优化：我们只需要 up[i-1] 和 down[i-1] ，只需要两个变量来保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                up = down + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                down = up + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n)，空间复杂度为 O(1)。</p><h4 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a></h4><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n &#x3D; 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n &#x3D; 10</span><br><span class="line"> 输出：4</span><br><span class="line"> 解释: 有四种方式可以凑成总金额:</span><br><span class="line">10&#x3D;10</span><br><span class="line">10&#x3D;5+5</span><br><span class="line">10&#x3D;5+1+1+1+1+1</span><br><span class="line">10&#x3D;1+1+1+1+1+1+1+1+1+1</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>注意:</p><p>你可以假设：</p><ul><li>0 &lt;= n (总金额) &lt;= 1000000</li></ul><p>完全背包问题即不限定硬币的个数去组合硬币达到指定的值。</p><p>这道题为求组合成指定数额有几种情况，我们设置 dp 数组：dp[k]  为组成 k 面额的硬币情况数。</p><p>设置基本情况：dp[0] = 1，这里 dp[0] 的含义不是 组成 0 的硬币种类为 0，二是作为完美能被一个硬币表示的情况为 1。即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while k - coin &#x3D;&#x3D; 0 :</span><br><span class="line">dp[k] +&#x3D; dp[k - coin];</span><br><span class="line">&#x3D;&gt;</span><br><span class="line">dp[k] +&#x3D; dp[0];</span><br></pre></td></tr></table></figure><p>我们可以得到 dp 方程 dp[k] += dp[k-coin]；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">25</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//刚好可以用一个硬币凑成的情况</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;<span class="number">4</span>; ++c)&#123;</span><br><span class="line">            <span class="keyword">int</span> coin = coins[c];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=coin; i&lt;=n; ++i)&#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - coin]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n)，空间复杂度为 O(n)。</p><p>coins 数组中的硬币顺序必须是由大到小。</p><p>如果硬币由小到大，我们求6的硬币情况数时，我们观察一下流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">前面5种情况数：dp[1,5] &#x3D; [1,1,1,1,2];</span><br><span class="line"></span><br><span class="line">coin &#x3D; 1:</span><br><span class="line">dp[6] +&#x3D; (dp[6 - coin] &#x3D;&gt; dp[5] &#x3D;&gt; 2);</span><br><span class="line">即拿到coin(1)的情况有两种 :</span><br><span class="line">coin(1,1,1,1,1) + coin(1);</span><br><span class="line">coin(5) + coin(1);</span><br><span class="line"></span><br><span class="line">coin &#x3D; 5:</span><br><span class="line">dp[6] +&#x3D; (dp[6 - coin] &#x3D;&gt; dp[1] &#x3D;&gt; 1);</span><br><span class="line">即拿到coin（5）的情况有一种:</span><br><span class="line">coin(1) + coin(5);</span><br><span class="line">但是事实却是6的情况只有两种，（1，1，1，1，1，1）和（1，5）。这里是把（1，5）和（5，1）前后顺序不同的情况重复算了1次。因此我们应该去考虑硬币顺序带来的影响。</span><br></pre></td></tr></table></figure><p>正确答案：<br>于是我们先遍历硬币，保证在考虑一枚硬币的情况时，没有较大的硬币影响，这样，我们最终每种组合情况，都是以硬币的面额大小非递减组合。保证了同样的情况，调换顺序后重复计算的情况。</p><p>这时候，我们求6的硬币情况数时，我们观察一下流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">coin &#x3D; 1:</span><br><span class="line">前面5种情况数：dp[1,5] &#x3D; [1,1,1,1,1];</span><br><span class="line"></span><br><span class="line">dp[6] +&#x3D; (dp[6 - coin] &#x3D;&gt; dp[5] &#x3D;&gt; 1);</span><br><span class="line">即拿到coin(1)的情况有一种 :</span><br><span class="line">coin(1,1,1,1,1) + coin(1);</span><br><span class="line"></span><br><span class="line">coin &#x3D; 5:</span><br><span class="line">前面5种情况数：dp[1,5] &#x3D; [1,1,1,1,2];</span><br><span class="line"></span><br><span class="line">dp[6] +&#x3D; (dp[6 - coin] &#x3D;&gt; dp[1] &#x3D;&gt; 1);</span><br><span class="line">即拿到coin（5）的情况有一种:</span><br><span class="line">coin(1) + coin(5);</span><br><span class="line">此时，硬币组合情况，的确为正确的情况。</span><br></pre></td></tr></table></figure><p>参考：<a href="https://leetcode-cn.com/problems/coin-lcci/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-eddiev/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-lcci/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-eddiev/</a></p>]]></content>
    
    <summary type="html">
    
      Leetcode medium 动态规划总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>二叉树 Hard</title>
    <link href="https://hoo334.github.io/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91Hard/"/>
    <id>https://hoo334.github.io/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91Hard/</id>
    <published>2020-04-18T08:18:51.000Z</published>
    <updated>2020-04-29T03:17:20.656Z</updated>
    
    <content type="html"><![CDATA[<h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></h4><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 后序遍历 “左右根”。需要一个栈来保存根结点，</span></span><br><span class="line"><span class="comment">    * 还需要一个指针来记录上一个访问的结点来判断是否访问过根结点的右子结点。</span></span><br><span class="line"><span class="comment">    * 当访问过树的最右叶子结点后，弹出根结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode lastPrintNode = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">while</span>(root != <span class="keyword">null</span> || ! s.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//根结点入栈</span></span><br><span class="line">               s.push(root);</span><br><span class="line">               <span class="comment">//继续入栈根结点的左子结点</span></span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//无左子结点，将根结点复制一份</span></span><br><span class="line">               root = s.peek();</span><br><span class="line">               <span class="comment">//查看右子结点是否为空或右子结点已经访问过</span></span><br><span class="line">               <span class="keyword">if</span>(root.right == <span class="keyword">null</span> || root.right == lastPrintNode)&#123;</span><br><span class="line">                   <span class="comment">//根结点出栈</span></span><br><span class="line">                    s.pop(); </span><br><span class="line">                   <span class="comment">//访问根结点</span></span><br><span class="line">                    res.add(root.val); </span><br><span class="line">                   <span class="comment">//更新上一个访问过的结点</span></span><br><span class="line">                    lastPrintNode = root; </span><br><span class="line">                   <span class="comment">//取根结点的根节点访问</span></span><br><span class="line">                    root = <span class="keyword">null</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">//右子结点不为空，访问右子结点</span></span><br><span class="line">                   root = root.right;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode 二叉树hard
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树 Medium</title>
    <link href="https://hoo334.github.io/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91Medium/"/>
    <id>https://hoo334.github.io/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91Medium/</id>
    <published>2020-04-18T08:04:11.000Z</published>
    <updated>2020-05-22T01:00:27.593Z</updated>
    
    <content type="html"><![CDATA[<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h4><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 中序遍历 “左根右”。需要一个栈来保存根结点。</span></span><br><span class="line"><span class="comment">    * 当访问过树的最左叶子结点后，弹出根结点，访问根结点，继续访问根节点的右子结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环条件：栈中元素不为空。树的根结点非空</span></span><br><span class="line">       <span class="keyword">while</span>(root != <span class="keyword">null</span> || ! s.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//根结点入栈</span></span><br><span class="line">               s.push(root);</span><br><span class="line">               <span class="comment">//继续入栈根结点的左子结点</span></span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//无左子结点，将根结点出栈</span></span><br><span class="line">               root = s.pop();</span><br><span class="line">               <span class="comment">//访问根结点</span></span><br><span class="line">               res.add(root.val);</span><br><span class="line">               <span class="comment">//继续访问根结点的右子结点</span></span><br><span class="line">               root = root.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h4><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>采用层次遍历，使用一个队列存储结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(! queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//获取当前层的结点数</span></span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">                <span class="comment">//取出队头结点，将其加入当前层的结果中</span></span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                level.add(t.val);</span><br><span class="line">                <span class="comment">//如果有左右子结点，将它们加入队尾</span></span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) queue.add(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) queue.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//保存每一层的结果</span></span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设树上有 n 个结点，时间复杂度 O(n)，空间复杂度O(n)。</p><h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h4><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>在数据结构课程中我们学过通过前序遍历序列和中序遍历序列构造二叉树的方法：</p><ol><li>从先序遍历序列中拿出一个结点 x 。</li><li>建立根结点，在中序遍历序列中找出结点 x 的位置，确定以结点 x 为根结点的左右子树结点数。</li><li>重复步骤 1 和步骤 2 递归建立结点 x 的左右子树。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用一个 HashMap 存储中序遍历结点的下标，在寻找结点下标时只用常数时间。</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = preorder.length;</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//建立 HashMap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//递归建立二叉树</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, inorder, <span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preorder_left, <span class="keyword">int</span> preorder_right, <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder_left &gt; preorder_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//确定二叉树根结点（先序遍历最左结点）</span></span><br><span class="line">        <span class="keyword">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">//找到根结点在中序遍历序列中的下标</span></span><br><span class="line">        <span class="keyword">int</span> inorder_root = indexMap.get(preorder[preorder_root]);</span><br><span class="line"><span class="comment">//建立根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preorder_root]);</span><br><span class="line"><span class="comment">//确定根结点左子树结点的个数</span></span><br><span class="line">        <span class="keyword">int</span> leftSubTreeSize = inorder_root - inorder_left;</span><br><span class="line"><span class="comment">//递归建立左子树</span></span><br><span class="line">        root.left = buildTree(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + leftSubTreeSize, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//递归建立右子树</span></span><br><span class="line">        root.right = buildTree(preorder, inorder, preorder_left + leftSubTreeSize + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度O(n)。</p><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></h4><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p><p> <strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 前序遍历 “根左右”。需要一个栈来保存已经访问过的根结点。</span></span><br><span class="line"><span class="comment">    * 当已经访问过树的最左叶子结点后，弹出根结点，继续访问根结点的右子结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="comment">//循环条件：栈中元素不为空。树的根节点非空</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || ! s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//访问根节点</span></span><br><span class="line">                ans.add(root.val);</span><br><span class="line">                <span class="comment">//保存根节点</span></span><br><span class="line">                s.push(root);</span><br><span class="line">                <span class="comment">//访问根结点的左子结点</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无左子结点，弹出根结点</span></span><br><span class="line">                root = s.pop();</span><br><span class="line">                <span class="comment">//继续访问右子结点</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></h4><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure><p>第一感觉就是用层次遍历，保存每一层的最后一个结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"><span class="comment">//层次遍历使用的队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(! queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// len 为层次遍历时每一层的结点个数</span></span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                <span class="comment">// 是否为最后一个结点</span></span><br><span class="line">                <span class="keyword">if</span>(i == len-<span class="number">1</span>)&#123;</span><br><span class="line">                res.add(t.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将左右子结点加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) queue.add(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) queue.add(t.right);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以模仿二叉树遍历，只是先遍历右子结点然后遍历左子结点。同时在遍历的过程中保存每一层的第一个结点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            假设二叉树深度为 i ，res 数组的大小为 i。</span></span><br><span class="line"><span class="comment">            当 res.size() 小于当前访问的层数时就代表这是最右侧结点。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt; level)&#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先遍历右子结点</span></span><br><span class="line">            helper(root.right, level+<span class="number">1</span>, res);</span><br><span class="line">            <span class="comment">//后遍历左子结点</span></span><br><span class="line">            helper(root.left, level+<span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><p>思路一</p><p>我们可以遍历所有结点，并判断 p 或 q 是否在它的左右子树上，或者这个结点就是 p 或 q 。定义 fx表示 x 结点的子树中是否包含 p 节点或 q节点。fl 代表 x 结点的左子树上是否有 p 或 q 结点，fr 代表 x 结点的右子树上是否有 p 或 q 结点。我们有两种情况：</p><ul><li>p 和 q 分别在 x 结点的左右子树上，即 fl &amp;&amp; fr == true</li><li>结点 x 就是 p 或 q，此时 x== p || x==q 为true，若在 x 结点的左子树或右子树上找到另一个结点，则 x 就是最近公共祖先。</li></ul><p>总结判断条件：(f1 &amp;&amp; fr) || [ (x==p || x==q) &amp;&amp; ( fl || fr) ] 。由于是自底向上判断的，在所有满足条件的公共祖先中一定是深度最大的祖先被访问到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode res;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//先判断左右子树，再判断当前结点情况</span></span><br><span class="line">        <span class="keyword">boolean</span> left = dfs(root.left, p, q);</span><br><span class="line">        <span class="keyword">boolean</span> right = dfs(root.right, p, q);</span><br><span class="line">        <span class="comment">//判断条件</span></span><br><span class="line">        <span class="keyword">if</span>((left &amp;&amp; right) || (root.val == p.val || root.val == q.val) &amp;&amp; (left || right))&#123;</span><br><span class="line">            res = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回 x 结点的左右子树 是否包含 p 或 q 结点</span></span><br><span class="line">        <span class="keyword">return</span> left || right || root.val == p.val || root.val == q.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode 二叉树medium
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数组 Medium</title>
    <link href="https://hoo334.github.io/2020/04/17/%E6%95%B0%E7%BB%84Medium/"/>
    <id>https://hoo334.github.io/2020/04/17/%E6%95%B0%E7%BB%84Medium/</id>
    <published>2020-04-17T02:51:13.000Z</published>
    <updated>2020-04-29T03:16:06.969Z</updated>
    
    <content type="html"><![CDATA[<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h4><p>给你 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://i.loli.net/2020/04/21/23RAHzps9cYvGKC.jpg" alt="img"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure><p>使用双指针。左指针为 i，右指针为 j 。水的容量为 (j - i) * min(i , j) 。我们需要维护一个容器的容量的最大值。我们需要找出最大的容量。此时需要向中间移动左右指针中比较小的那个值。证明：一般 i &lt; j ，容器的容量为  <code>min(height[i] , height[j])*(j-i)</code> , 如果我们将两个指针中的比较高的值向中间移动，那么得到的容量一定小于前面算出的容量（j 变小了，i 不变，两个边界最小值不变）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=height.length-<span class="number">1</span>; i&lt;=j ;)&#123;</span><br><span class="line">            <span class="comment">//维护最大容量</span></span><br><span class="line">            max = Math.max(max, (j-i) * Math.min(height[i], height[j]) );</span><br><span class="line">            <span class="comment">//移动高度较小的指针</span></span><br><span class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure><p>对于数组中任意一个位置 i，最远到达的位置为 i + nums[i] 。实时维护一个可到达的最远位置 rightmax，如果rightmax 大于数组最后一个位置的下标即可返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rightmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">                 <span class="comment">//最远可到达 rightmax </span></span><br><span class="line">            <span class="keyword">if</span>(i &lt;= rightmax)&#123;</span><br><span class="line">            <span class="comment">//实时更新 rightmax 的值</span></span><br><span class="line">            rightmax = Math.max(rightmax , i+nums[i]);</span><br><span class="line">                <span class="comment">//大于最后一个位置的下标返回 true</span></span><br><span class="line">            <span class="keyword">if</span>(rightmax &gt;= n-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。</p><p>如果某个 <strong>连续</strong> 子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p><p>请返回这个数组中「优美子数组」的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,1,1], k &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,4,6], k &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line">解释：数列中不包含任何奇数，所以不存在优美子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,1,2,2,1,2,2,2], k &#x3D; 2</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50000</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><p>在这个题目中偶数是没有用的，我们可以建立一个 odd 数组来记录第 i 个奇数的下标，假设当前枚举到第 i 个，那么 <code>[odd[i], odd[i+k-1]]</code> 这个子数组恰好包含 k 个奇数。这个范围左侧的奇数下标为 odd[i-1], 右侧的奇数下标为 odd[i+k]。如果<code>[odd[i], odd[i+k-1]]</code> 这个包含 k 个奇数的子数组左右侧都右偶数，那么满足条件的包含 k 个奇数的子数组个数为  (<em>odd</em>[<em>i</em>]−<em>odd</em>[<em>i</em>−1])∗(<em>odd</em>[<em>i</em>+<em>k</em>]−<em>odd</em>[<em>i</em>+<em>k</em>−1]) 。我们只要遍历一遍 odd 数组即可求解答案。</p><p>边界处理：</p><ol><li>当 nums[0] 为奇数时，odd[1] = 0，此时左边没有偶数 odd[1] - odd[0] 应该为 1（只有 nums[0] 为子数组左侧边界）。此时 odd[0] = -1。</li><li>当记录最后一个奇数时（假设这是第 index 个奇数，对应 nums 数组中的下标为 x）， odd[index] = x, odd[index+1] = nums.length。odd 数组最后一个元素记录的是数组中所有元素的数量。</li></ol><p>以示例 3 来解释：我们生成的 odd 数组为 [-1, 3, 6, 10]，对其遍历一遍得到结果 (3 - (-1)) * (10-6) = 16。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] odd = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成 odd 数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>)odd[++index] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//边界处理</span></span><br><span class="line">        odd[<span class="number">0</span>] = -<span class="number">1</span>; odd[++index] = n;</span><br><span class="line"><span class="comment">//计算结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+k &lt;= index; ++i)&#123;</span><br><span class="line">            ans += (odd[i] - odd[i-<span class="number">1</span>])*(odd[i+k] - odd[i+k-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题56-I-数组中数字出现的次数"><a href="#面试题56-I-数组中数字出现的次数" class="headerlink" title="面试题56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56 - I. 数组中数字出现的次数</a></h4><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>2 &lt;= nums &lt;= 10000</code></li></ul><p>一个整型数组 <code>nums</code> 里除一个数字之外，其他数字都出现了两次。这个问题我们直接将 <code>nums</code> 数组中所有数字异或即可得到结果。现在只出现一次的数字有两个，我们再将所有数字进行异或即可得到两个只出现一次的数字的异或结果。</p><p>如果将这两个数字分别分成两组，一组里面含有一个出现一次的数字。我们直接将两组中的所有数字异或即可得到结果。</p><p>如何分组？我们从两个只出现一次的数字的异或结果入手，找出两个数字中不同的<strong>位</strong>（该位为 1 ）， 按照这个不同的位将所有数字分为两组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如 [4,1,4,6] 数组中所有数字异或的结果为 1 ^ 6 &#x3D; 7</span><br><span class="line">将 7 表示为二进制 0111（忽略前面的 28 个 0）</span><br><span class="line">我们可以将数字的最后三位中任选一位作为分组的判断。</span><br><span class="line">例如将倒数第一位为 0 分为第一组 得到[4,4,6]</span><br><span class="line">将倒数第一位为 1 分为第二组 得到[1]</span><br><span class="line">分别将这两组中的数字全部异或即可得到结果 1 和 6。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//计算两个只出现一次数字的异或结果</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ret ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出用来分组的那一位</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((idx &amp; ret) == <span class="number">0</span>)&#123;</span><br><span class="line">            idx = idx &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//分组异或计算结果</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; idx) == <span class="number">0</span>)&#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode medium 数组总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Object</title>
    <link href="https://hoo334.github.io/2020/04/14/Object/"/>
    <id>https://hoo334.github.io/2020/04/14/Object/</id>
    <published>2020-04-14T12:46:18.000Z</published>
    <updated>2020-04-19T00:39:31.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-lang-Object"><a href="#java-lang-Object" class="headerlink" title="java.lang.Object"></a>java.lang.Object</h1><p>类Object是类层次结构的根。 每个类都有Object作为超类。 所有对象，包括数组，实现这个类的方法。</p><h3 id="类层次结构"><a href="#类层次结构" class="headerlink" title="类层次结构"></a>类层次结构</h3><p><img src="https://i.loli.net/2020/04/14/6IRKvZyzNhxYTgk.png" alt="image-20200414205022670"></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>public Object(){}</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives"></a>registerNatives</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中有两种方法：Java 方法和本地方法。Java 方法是由 Java 语言编写，编译成字节码，存储在 class 文件中。本地方法是由其他语言（比如 C 、C++ 、汇编）编写的，编译成和处理器相关的机器代码。本地方法保存在动态链接库中，格式是各个平台专有的。Java 方法是平台无关的，但本地方法不是。运行中的 Java 程序调用本地方法是，虚拟机装载包含这个本地方法的动态库。本地方法是联系 Java 程序和底层主机操作系统的连接方法。</p><p>本地方法的实现是由其他语言编写并保存在动态链接库中，因此在 Java 类中不需要方法实现。registerNatives() 本质上就是一个本地方法，但这又是一个区别于一般本地方法的本地方法，从本地方法名可以猜测出该方法是用来注册本地方法的。上述代码的功能就是先定义了registerNatives()方法，然后当该类被加载的时候，调用该方法完成对该类中本地方法的注册。</p><p>凡是包含registerNatives()本地方法的类，同时也包含了其他本地方法。所以，显然，当包含registerNatives()方法的类被加载的时候，<strong>注册的方法就是该类所包含的除了registerNatives()方法以外的所有本地方法</strong>。</p><p>一个Java程序要想调用一个本地方法，需要执行两个步骤：第一，通过System.loadLibrary()将包含本地方法实现的动态文件加载进内存；第二，当Java程序需要调用本地方法时，虚拟机在加载的动态文件中定位并链接该本地方法，从而得以执行本地方法。registerNatives()方法的作用就是取代第二步，让程序主动将本地方法链接到调用方，当Java程序需要调用本地方法时就可以直接调用，而不需要虚拟机再去定位并链接。</p><h4 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><p>返回运行时类的Object 。 返回Class对象被 static synchronized 所表示的类方法修饰。<br>实际结果的类型是Class&lt;? extends |X|&gt;，其中|X| 是getClass被调用时静态类型的擦除。 例如，下列代码不需要强制转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number n = <span class="number">0</span>; </span><br><span class="line">Class&lt;? extends Number&gt; c = n.getClass();</span><br></pre></td></tr></table></figure><h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>返回该对象的哈希码值。 为其他哈希表提供支持，例如 java.util.HashMap 。<br>一般 hashCode 满足以下规则：</p><ul><li><p>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用，hashCode方法都必须始终返回同一个值。在一个应用程序与另一个应用程序的执行过程中，执行hashCode方法所返回的值可以不一致。</p></li><li><p>如果两个对象由 equals() 判断为 true ，那么他们的哈希码值必须相等。</p></li><li><p>如果两个对象由 equals() 判断为 false ，那么他们的哈希码值可以相等。应该为不同的对象生成不同的哈希码来提高哈希表的性能。哈希码值一般是将对象地址转成一个整数来得到。</p></li></ul><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断某个其他对象是否 “等于” 这个对象。默认比较的是两个对象的地址，当且仅当 this 和 obj 同时指向同一个对象时返回 true。</p><p>按照约定，equals要满足以下规则。</p><ul><li><strong>自反性</strong>:  x.equals(x) 一定是true</li><li><strong>对null</strong>:  x.equals(null) 一定是false</li><li><strong>对称性</strong>:  x.equals(y)  和 y.equals(x)结果一致</li><li><strong>传递性</strong>:  a 和 b equals , b 和 c  equals，那么 a 和 c也一定equals。</li><li><strong>一致性</strong>:  在某个运行时期间，2个对象的状态的改变不会影响equals的决策结果，那么，在这个运行时期间，无论调用多少次equals，都返回相同的结果。</li></ul><p>通常 equals 方法被重写时，必须重写 hashcode 方法。如果重写了 equals 方法，没有重写 hashcode 方法，判断两个值相等的对象时，当 equals 方法判断为 true（对象的值相等则为 true）时，由于两个值相等的对象地址不一样，所以生成的 hashcode 也不一样。违反了 hashcode 的规则：equals 为 true 两个对象的哈希码值必须相等。</p><h4 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>创建并返回此对象的副本。按照惯例，返回的对象应该通过调用<code>super.clone</code>获得。</p><p><code>clone</code>的方法<code>Object</code>执行特定的克隆操作。  首先，如果此对象的类不实现接口<code>Cloneable</code>  ，则抛出<code>CloneNotSupportedException</code> 。  请注意，所有数组都被认为是实现接口<code>Cloneable</code>  ，并且数组类型<code>T[]</code>的<code>clone</code>方法的返回类型是<code>T[]</code>  ，其中T是任何引用或原始类型。  否则，该方法将创建该对象的类的新实例，并将其所有字段初始化为完全符合该对象的相应字段的内容，就像通过赋值一样。  这些字段的内容本身不被克隆。 因此，该方法执行该对象的“浅拷贝”，而不是“深度拷贝”操作。 </p><p><code>Object</code>类本身并不实现接口<code>Cloneable</code>  ，因此在类别为<code>Object</code>的对象上调用<code>clone</code>方法将导致运行时抛出异常</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>返回一个代表对象的字符串。这个字符串中含有对象的相关信息，便于阅读。建议所有的子类重写这个方法。</p><p>Object 类的 toString 方法返回对象的类名 + ‘@’ + 对象的哈希码值得十六进制数。</p><h4 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>唤醒<strong>任意</strong>一个正在等待该对象的监视器的线程。一个线程通过调用 wait 方法来等待对象的监视器。被唤醒的线程只有在当前线程放弃了对象的锁之后才能被执行。被唤醒的线程与其他线程平等竞争对象的锁。该方法只能由作为该对象的监视器的所有者线程调用。</p><p>线程有三种方式称为对象监视器的所有者：</p><ol><li><p>通过执行对象的同步方法。</p></li><li><p>通过执行对象的同步语句（锁住此对象）。</p></li><li><p>执行类的同步静态方法。</p></li></ol><h4 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>唤醒<strong>所有</strong>一个正在等待该对象的监视器的线程。一个线程通过调用 wait 方法来等待对象的监视器。</p><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>使当前线程阻塞直到另一个线程调用此对象的 notify 方法或 notifyAll 方法或指定的时间已过，当前线程变为就绪状态。当前线程必须拥有此对象的监视器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                               <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           timeout++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       wait(timeout);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>与只有一个参数的 wait 方法类似，更加精细地控制等待被唤醒的时间直到放弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使当前线程阻塞直到另一个线程调用此对象的 notify 方法或 notifyAll 方法。</p><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>当垃圾收集器确定不再有该对象的引用时调用。finalize 方法通常的目的是在对象不可撤销丢弃之前执行清除动作。甚至finalize 方法可以让此对象再次可用于其他线程而避免被垃圾收集器清除。finalize 方法只能调用一次。</p><p>参考：</p><p><a href="https://blog.csdn.net/Saintyyu/article/details/90452826" target="_blank" rel="noopener">https://blog.csdn.net/Saintyyu/article/details/90452826</a></p>]]></content>
    
    <summary type="html">
    
      JDK 源码分析
    
    </summary>
    
    
      <category term="JDK 源码分析" scheme="https://hoo334.github.io/categories/JDK-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="java.lang包" scheme="https://hoo334.github.io/tags/java-lang%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>数组 Easy</title>
    <link href="https://hoo334.github.io/2020/04/09/%E6%95%B0%E7%BB%84Easy/"/>
    <id>https://hoo334.github.io/2020/04/09/%E6%95%B0%E7%BB%84Easy/</id>
    <published>2020-04-09T01:41:01.000Z</published>
    <updated>2020-05-14T00:26:57.946Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h4><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p>以 num[i] 为 HashMap 的 key，i 为 HashMap 的 value。每遍历到一个新的 nums[i] 判断 HashMap 中是否包含值为 target - nums[i] 的 key，如果包含则取出 key 的 value ，返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; numMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(numMap.containsKey(target-nums[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,numMap.get(target-nums[i])&#125;;</span><br><span class="line"></span><br><span class="line">            numMap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h4><p>给定一个排序数组，你需要在<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地</a></strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>我们使用i，j两个二指针， j 在前面走。如果 j 指向的元素等于 i 指向的元素 j 直接向前移，如果 j 指向的元素不等于 i 指向的元素，i 向前移 ，将 j 指向的元素赋给 i ，j向前移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;nums.length;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] != nums[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-i != <span class="number">1</span>)&#123;</span><br><span class="line">                nums[++i]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ++i; <span class="comment">//i，j相邻 直接 ++i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h4><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>使用异或，2^2 = 0，0 ^ n = n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h4><p>给定一个已按照<strong><em>升序排列\</em></strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br></pre></td></tr></table></figure><p>双指针左右向数组中间移动，直到它们的和为 target。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=numbers.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[j]+numbers[i] &gt;target)&#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[j]+numbers[i] &lt;target)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></h4><p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>由于多数元素出现的次数比其他元素出现次数的总和还要多，我们可以设置一个计数 count 和 返回结果 majority ，</p><p>当出现的元素和 majority 相同时 count 加一， 当出现的元素和 majority 不同时 count 减一， 当 count 为 0 时更换 majority 为当前遍历的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                majority = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[i] == majority)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">268. 缺失数字</a></h4><p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><p>利用 2 ^2 = 0 ， 0 ^ 2 = 2 异或运算的特性，我们可以在线性时间复杂度找出缺失的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        res=res^(i+<span class="number">1</span>)^nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303. 区域和检索 - 数组不可变</a></h4><p>给定一个整数数组  <em>nums*，求出数组从索引 *i</em> 到 <em>j</em> (<em>i</em> ≤ <em>j</em>) 范围内元素的总和，包含 <em>i, j</em> 两点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>你可以假设数组不可变。</li><li>会多次调用 <em>sumRange</em> 方法。</li></ol><p>注意到 “假设数组不可变” 这个条件，我们可以自然地想到直接将一些区域和存储起来，多次调用 <em>sumRange</em> 方法时只用 O(1) 时间复杂度就可以得到结果。</p><p>在数组初始化的时候生成一个前 n 项和的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">     <span class="comment">//sum[i] 代表前 i (i&gt;=1) 个元素的和      </span></span><br><span class="line">     sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第i+1个 到 j+1个元素的和</span></span><br><span class="line">     <span class="keyword">return</span> sum[j+<span class="number">1</span>] - sum[i];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">392. 判断子序列</a></h4><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>你可以认为 <strong>s</strong> 和 <strong>t</strong> 中仅包含英文小写字母。字符串 <strong>t</strong> 可能会很长（长度 ~= 500,000），而 <strong>s</strong> 是个短字符串（长度 &lt;=100）。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><p><strong>示例 1:</strong><br><strong>s</strong> = <code>&quot;abc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p><p>返回 <code>true</code>.</p><p><strong>示例 2:</strong><br><strong>s</strong> = <code>&quot;axc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p><p>返回 <code>false</code>.</p><p>最直观的办法就是维护两个指针，判断子序列中的所有字符是否在原始字符串中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;t.length() &amp;&amp; j&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子字符串被全部匹配</span></span><br><span class="line">        <span class="keyword">return</span> j == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></h4><p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为<em>O(n)</em>的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><p>将当前元素的值的绝对值作为下标，将以当前元素为下标的数组元素值置位为负，再遍历一次数组即可找出所有未出现的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = Math.abs(nums[i])-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="532-数组中的K-diff数对"><a href="#532-数组中的K-diff数对" class="headerlink" title="532. 数组中的K-diff数对"></a><a href="https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/" target="_blank" rel="noopener">532. 数组中的K-diff数对</a></h4><p>给定一个整数数组和一个整数 <strong>k</strong>, 你需要在数组里找到<strong>不同的</strong> k-diff 数对。这里将 <strong>k-diff</strong> 数对定义为一个整数对 (i, j), 其中 <strong>i</strong> 和 <strong>j</strong> 都是数组中的数字，且两数之差的绝对值是 <strong>k</strong>.</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3, 1, 4, 1, 5], k &#x3D; 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。</span><br><span class="line">尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:[1, 2, 3, 4, 5], k &#x3D; 1</span><br><span class="line">输出: 4</span><br><span class="line">解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 3, 1, 5, 4], k &#x3D; 0</span><br><span class="line">输出: 1</span><br><span class="line">解释: 数组中只有一个 0-diff 数对，(1, 1)。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>数对 (i, j) 和数对 (j, i) 被算作同一数对。</li><li>数组的长度不超过10,000。</li><li>所有输入的整数的范围在 [-1e7, 1e7]。</li></ol><p>我们先将整数数组排序， 从第一个元素开始 向右寻找 diff 为 k 的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//去掉相同元素</span></span><br><span class="line">        <span class="keyword">for</span>(;i&gt;<span class="number">0</span>&amp;&amp;i&lt;nums.length&amp;&amp;nums[i]==nums[i-<span class="number">1</span>];i++);</span><br><span class="line">　　　　　　　<span class="comment">//向右寻找</span></span><br><span class="line">        j=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;nums.length&amp;&amp;nums[j]-nums[i]&lt;k;j++);</span><br><span class="line">        <span class="comment">//找到一对 j-i==k</span></span><br><span class="line">        <span class="keyword">if</span>(j&lt;nums.length&amp;&amp;nums[j]-nums[i]==k)</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode easy 数组总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>动态规划 Easy</title>
    <link href="https://hoo334.github.io/2020/04/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92Easy/"/>
    <id>https://hoo334.github.io/2020/04/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92Easy/</id>
    <published>2020-04-08T03:20:53.000Z</published>
    <updated>2020-04-29T03:17:28.729Z</updated>
    
    <content type="html"><![CDATA[<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h4><p>难度简单1831收藏分享切换为英文关注反馈</p><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>设f(k) 表示连续以下标为 k 的元素结尾的连续子数组的和，f(k) = max( nums[k], nums[k] + f(k-1) ),如果f(k) &lt; 0 ，从当前元素开始求和。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化连续子数组的最大和，当前子数组的最大和。</span></span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">    <span class="comment">//尝试向当前子数组后加入 nums[i]，如果当前子数组和为负，</span></span><br><span class="line">        <span class="comment">//则以当前元素作为第一个元素开始重新计算连续子数组。</span></span><br><span class="line">        sum = Math.max(nums[i],sum+nums[i]);</span><br><span class="line">        <span class="comment">//取最大值。</span></span><br><span class="line">        max = Math.max(max,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h4><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><ol><li>有一个台阶只有一种选择；</li><li>有两个台阶有 2 阶、1阶 + 1阶两种选择；</li><li>有三个台阶有也有两种选择：从第二个台阶爬一阶，从第一个台阶一次爬两阶。爬上第二个台阶有两种方法，故通过第二个台阶到第三个台阶有两种方法，加上从第一个台阶到第三个台阶有一种方法故有三种方法。</li></ol><p>设 f(n) 为爬上第 n 个台阶的方法总数，则有 f(n) = f(n-1) + f(n-2)；第 n 个台阶的方法数由第 n-1 个台阶和第 n-2 个台阶的方法数组成，即可以从 n-1 个台阶爬一个台阶到第 n 阶和从第 n-2 个台阶爬两个台阶到第 n 个台阶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ;i &lt; n ; ++i)&#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h4><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p>假设我们在第 i 天之前买一张股票，想要在第 i 天卖掉它，我们肯定在前 i-1 天中选择一天价格最低的时候买入，在股票价格最高的时候卖出。但是如果在前 i-1 天中的某一天可以获得比第 i 天获得的更大利润就不能选择第 i 天卖出而要选择前 i-1 天中的最大利润。第 i 天能获得的最大利润 = max( 前 i-1 天的最大利润，第 i 天的股票价格 - 前 i-1 天股票的最低价格)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>,min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;prices.length;++i)&#123;</span><br><span class="line">        max=Math.max(max,prices[i]-min);</span><br><span class="line">        min=Math.min(prices[i],min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><p>以示例 2 为例：</p><ol><li>当只有一个数 2 时我们只能偷2；</li><li>当有两个数 2，7 时我们选择偷 7 ；</li><li>当有2，7，9 时，我们比较 2+9 和7 谁大就取谁，偷 2+9 =11；</li><li>当有2，7，9，3 时我们有 11 和（3+7）比较 选择 11 ；</li><li>当2，7，9，3，1 时 11 和 11 +1 我们选择 12。</li></ol><p>设 f(n) 为偷盗前 n 个房屋的最高金额，则 f(n) = max( f(n-1), f(n-2) + num)。即偷盗前 n 个房屋可以有偷第 n 个房屋和不偷第 n 个房屋两种选择，取其中金额最大的一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preMax = <span class="number">0</span>, curMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = curMax;</span><br><span class="line">        curMax = Math.max(preMax + x , curMax);</span><br><span class="line">        preMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></h4><p>数组的每个索引做为一个阶梯，第 <code>i</code>个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>(索引从0开始)。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: cost &#x3D; [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><code>cost</code> 的长度将会在 <code>[2, 1000]</code>。</li><li>每一个 <code>cost[i]</code> 将会是一个Integer类型，范围为 <code>[0, 999]</code>。</li></ol><p>如果我们需要到达第 i 个台阶，我们有两种选择：</p><ol><li>从第 i-2 个台阶到达第 i 个台阶，花费为到达第 i-2 个台阶的最小花费 + cost[i]；</li><li>从第 i-1 个台阶到达第 i 个台阶，花费为到达第 i-2 个台阶的最小花费 + cost[i]；</li></ol><p>到达第 i 个台阶的最小代价为这两种花费的最小值。</p><p>即 <code>cost[i] = min( minPrice[i-1], minPrice[i-2] ) + cost[i]</code>。由于只要使用到前两个台阶的最小代价，所以只用维护两个变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//pre 为前 1 个台阶的最小花费，pre2 为前 2 个台阶的最小花费。</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, pre2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cost.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = cost[i] + Math.min(pre,pre2);</span><br><span class="line">            pre2 = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(pre,pre2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode easy 动态规划总结
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>事务管理与恢复</title>
    <link href="https://hoo334.github.io/2020/04/06/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>https://hoo334.github.io/2020/04/06/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%8E%E6%81%A2%E5%A4%8D/</id>
    <published>2020-04-06T01:27:11.000Z</published>
    <updated>2020-05-11T04:48:03.227Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h4><p>​    对于用户而言，事务是具有完整逻辑意义的数据库操作序列的集合。对于数据库管理系统而言，事务则是一个读写操作序列。这些操作是一个不可分割的逻辑工作单元，要么都做，要么都不做。</p><p>​    通常有有两种类型的事务结束语句：</p><p>​    1）事务提交（commit）：将成功完成事务的执行结果（即更新）永久化，并释放事务占有的全部资源。</p><p>​    2）事务回滚（rollback）：中止当前事务、撤销其对数据库所做的更新，并释放事务占有的全部资源。</p><p>​    </p><p>SQL Server 数据库提供了 3 种类型的事务模式：显式事务、隐式事务及自定义事务。</p><p>​    显式事务是指用户使用了 Transact-SQL 事务语句所定义的事务，其事务语句包括：</p><p>​    事务开始：begin transaction</p><p>​    事务提交：commit transaction，commit work</p><p>​    事务回滚：rollback transaction，rollback work</p><p>​    隐式事务是指事务提交或回滚后，SQL Server 自动开始新的事务。该类事务不需要采用 begin transaction 语句标识事务的开始。</p><p>​    自动定义事务模式：当一个语句成功执行后，它被自动提交，而当执行过程中出错时，则被自动回滚。</p><h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h4><p>​    1）原子性（Atomicity）。事务的所有操作要么全部被执行，要么都不执行。</p><p>​    2）一致性（Consistency）。一个单独执行的事务应保证其执行结果的一致性，即总是将数据库从一个一致性状态转化到另一个一致性状态。</p><p>​    3）隔离性（Isolation）。当多个事务并发执行时，一个事务的执行不能影响另一个事务，即并发执行的各个事务不能相互干扰。</p><p>​    4）持久性（Durability）。一个事务提交成功后，它对数据库的改变必须是永久的，即使随后系统出现故障。</p><h4 id="事务并发执行与调度"><a href="#事务并发执行与调度" class="headerlink" title="事务并发执行与调度"></a>事务并发执行与调度</h4><p>​    数据库管理系统允许多个事务并发执行，其主要优点是增加系统吞吐量和减少平均响应时间。</p><p>​    </p><p>​    并发事务带来的问题：</p><p>​    1）<strong>脏读（Dirty Read）</strong>：一个事务正在访问数据并对数据进行修改，修改还没有提交到数据库，这是另外一个事务访问了这个数据，然后使用了这个数据。这个数据更改之前的数据，另一个事务读到的数据是“脏数据”，依靠“脏数据”所做的操作是不正确的。</p><p>　2）<strong>丢失修改（Lost to modify）</strong>：一个事务读取一个数据时，另外一个事务也访问了该数据，在第一个事务中修改数据后，第二个事务也修改了这个数据。第一个事务内的修改结果丢失，因此称作丢失修改。例如事务1读取某表中的数据 A=20 ，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改丢失。</p><p>　3）<strong>不可重复读（Unrepeatable read）</strong>：在一个事务内多次读同一个数据在这个事务还没有结束时，另一个事务也访问该数据。在第一个事务的两次读之间，另一个事务可能已经修改了数据，导致两次读取的数据可能不太一样。</p><p>　4）<strong>幻读（Phanatom read）</strong>：幻读与不可重复读类似。发生在一个事务读了几行数据，接着另一个并发 事务插入了一些数据。在随后的查询中第一个事务就会发现多了一些原本不存在的记录，好像发生了幻觉。    </p><h4 id="事务调度及正确性准则"><a href="#事务调度及正确性准则" class="headerlink" title="事务调度及正确性准则"></a>事务调度及正确性准则</h4><p>​    事务并发执行顺序是随机的，将由多个事务操作组成的随机执行序列称为一个调度。对于一组事务操作组成的调度序列而言，应满足下列条件：</p><p>​    1）该调度包括该组事务的全部操作；</p><p>​    2）属于同一个事务的操作应保持在原事务中的执行顺序。</p><p>​    串行调度：在调度 S 中，如果属于同一事务的操作都是相邻的，则称 S 是串行调度。</p><p>​    冲突操作：在一个调度 S 中，如果 A 和 B 是不同事务在相同数据对象上的操作，并且其中至少有一个是写操作，则称 A 与 B 是冲突操作。</p><p>​    冲突等价：如果一调度 S 可以经过交换一系列非冲突操作执行的顺序而得到一个新的调度 S‘ ，则称 S 与 S’ 是冲突等价的。</p><p>​    冲突可串行化：如果一调度 S 与一串行调度是冲突等价 的，则称 S 是冲突可串行化的。</p><h5 id="判断调度是否可串行化的方法"><a href="#判断调度是否可串行化的方法" class="headerlink" title="判断调度是否可串行化的方法"></a>判断调度是否可串行化的方法</h5><p><img src="https://i.loli.net/2020/04/06/KOWfz9e1juAwros.png" alt="image-20200406101649482"></p><p><img src="https://i.loli.net/2020/04/06/4C2VSsKYmMUngI8.png" alt="image-20200406101753978"></p><p><img src="https://i.loli.net/2020/04/06/W5y9jOtbTdmeuCz.png" alt="image-20200406101814976"></p><p><img src="https://i.loli.net/2020/04/06/1uJ9kfFZqtl7VEz.png" alt="image-20200406101908368"></p><p>​    图 10-2(a) 中，对于 A 的并发访问：R1(A), W1(A), R2(A), W2(A)，存在 W1(A)后执行R2(A)，W1(A)后执行W2(A)。故 T1 -&gt; T2。优先图中无环可以串行化。</p><p>​    图 10-2(b) 中，对于 A 的并发访问：R2(A), W2(A), R1(A), W1(A) ，存在 W2(A)后执行R1(A)，W2(A)后执行W1A)。故 T2 -&gt; T1。优先图中无环可以串行化。</p><p>​    图10-8 中，对于 A 的并发访问：R4(A), W4(A), R6(A), W6(A)，存在 W4(A)后执行R6(A)，W4(A)后执行W6(A)。故 T4-&gt; T6。对于 B 的并发访问：R6(B), W6(B), R4(B), W4(B)，存在 W6(B)后执行R4(B)，W6(B)后执行W4(B)。故 T6-&gt; T4。优先图中有环，不可串行化。</p><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="基于封锁的协议"><a href="#基于封锁的协议" class="headerlink" title="基于封锁的协议"></a>基于封锁的协议</h4><p>​    并发控制机制大体上可分为悲观的和乐观的两种。悲观的并发控制方法认为数据库 的一致性经常会收到破坏，因此在事务访问数据对象前采取一定措施加以控制，只有得到访问许可时，才能访问数据对象，如<strong>基于封锁的并发控制方法</strong>。而乐观的并发控制方法则认为数据库的一致性通常不会得到破坏，故事务执行时可直接访问数据对象，只在事务结束时才验证数据库的一致性是否会遭到破坏，如基于有效性验证方法。</p><p>​    基于封锁的并发控制方法的基本思想是：当事务 <em>T</em> 需访问数据对象 <em>Q</em> 时，先申请对 <em>Q</em> 的锁。如批准获得，则 <em>T</em> 继续执行，且此后不允许其他任何事物修改 <em>Q</em>，直到事务 <em>T</em> 释放 <em>Q</em> 上的锁为止。</p><p>​    基本锁类型：</p><p>​    1）共享锁（Shared Lock，记为 S ）：如果事务 <em>T</em> 获得的对象 <em>Q</em> 上的共享锁，则 <em>T</em> 可读 <em>Q</em> 但不能写 <em>Q</em> 。</p><p>​    2）排他锁（eXclusive lock，记为 X ）：如果事务 <em>T</em> 获得的对象 <em>Q</em> 上的排他锁，则 <em>T</em> 可读 <em>Q</em> 又能写 <em>Q</em> 。</p><p>​    <strong>一个数据对象 <em>Q</em> 上可能有多个（被不同事务拥有的）共享锁，但任何时候只能有一个排他锁。</strong></p><p><img src="https://i.loli.net/2020/04/06/sNHdY7A2PhBy3ET.png" alt="image-20200406104004431"></p><p><img src="https://i.loli.net/2020/04/06/JX7bQ8va4hoMHNK.png" alt="image-20200406104529309"></p><p>​    图10-13 中的调度存在以下问题：</p><p>​    1）脏读。T2 步骤 11 读了 T1 修改后的数据，而T1 在步骤 12 回滚了。</p><p>​    2）不可重复读。如 T3 两次读到 A 的值不同。</p><p>​    3）不可串行化。</p><p>​    出现上述问题的原因是<strong>事务过早地释放了锁</strong>，如果规定事务在结束后才释放其持有地锁则可以保证调度的可串行性。但这会导致系统性能下降。</p><h4 id="两阶段封锁协议"><a href="#两阶段封锁协议" class="headerlink" title="两阶段封锁协议"></a>两阶段封锁协议</h4><p>​    两阶段封锁协议要求每个事务分两个阶段提出申请锁和解锁申请。</p><p>​    1）增长阶段：事务可以获得锁，但不能释放锁。</p><p>​    2）缩减阶段：事务可以释放锁，但不能获得新锁。</p><p>​    一开始，事务处于增长阶段，事务根据需要获得锁。一旦该事务释放了锁，它就进入了缩减阶段，不能再发出加锁请求。</p><p>​    两阶段封锁协议能保证冲突可串行化。对于任何事务，调度中该事务获得其最后加锁的时刻（增长阶段结束点）称为事务的封锁点。多个事务可以根据它们的封锁点进行排序，而这个顺序就是并发事务的一个冲突可串行化顺序。</p><p><img src="https://i.loli.net/2020/04/06/6OxDya25XE3bVAo.png" alt="image-20200406105546498"></p><p>​    图10-14 采用了两阶段封锁，允许 T4 在获得全部锁后（A 和 B 上的排他锁）提前释放部分锁（步骤 7 释放了 A 上的排他锁），T5得以提前执行，从而提高了 T4 和 T5 的并发度，该调度是可串行化 的。</p><p>​    两阶段封锁保证了并发执行事务的正确性，但仍存在两个主要问题：</p><p>​    1）可能导致死锁，即持有锁的事务出现相互等待都不能继续执行。解除死锁的一个简单方法是超时机制。如果一个事务为某个锁等待的时间过长，可以悲观得认为死锁已经发生，回滚该事务并重启。</p><p>​    2）不能避免读脏数据。</p><p>​    另一个两阶段封锁得变体是强两阶段封锁协议，它要求事务提交之前不得释放任何锁。事务可以按其提交得顺序串行化。</p><h4 id="封锁协议总结"><a href="#封锁协议总结" class="headerlink" title="封锁协议总结"></a>封锁协议总结</h4><p>在运用 X 锁和 S 锁这两种基本封锁对数据对象加锁时，还要约定一些规则。例如，何时申请 X 锁和 S 锁、封锁时间、何时释放等。这些规则称为封锁协议。</p><p>对并发操作的不正确调度可能会带来脏读、丢失修改、不可重复读等不一致性问题。三级封锁协议分别在不同程度上解决了这些问题，为并发操作的正确调度提供一定的保证。</p><ol><li>一级封锁协议，事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。</li><li>二级封锁协议，在一级封锁协议基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁。</li><li>三级封锁协议，在一级封锁协议基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。</li></ol><p><img src="https://i.loli.net/2020/05/11/RkMmTrJnKHz3OWl.png" alt="image-20200511093025700"></p><p>总结：三个等级的封锁协议都是事务结束后释放 X 锁，不同的是一级封锁对于读取数据不加 S 锁，二级封锁加 S 锁，但在读取操作结束后就释放，三级封锁加 S 锁，在事务结束后释放。一级封锁保证不会丢失修改，二级封锁保证不会丢失修改和脏读，三级封锁保证不会丢失修改、脏读和可重复读。</p><p><img src="https://i.loli.net/2020/05/11/GvaPKLouCjOWF9s.png" alt="image-20200511095857695"></p><h4 id="活锁与死锁"><a href="#活锁与死锁" class="headerlink" title="活锁与死锁"></a>活锁与死锁</h4><p>活锁就是一个事务一直处于“饥饿”状态。死锁即为临界资源的循环占用。</p><p><img src="https://i.loli.net/2020/05/11/F5Vo6EMKPB9akYb.png" alt="image-20200511100149015"></p><p>避免出现“饥饿”现象的最简方法为采用 FCFS 策略。</p><p>避免死锁的方法有<strong>预防死锁</strong>和<strong>诊断并解除死锁</strong>两种。</p><p>预防死锁：</p><ol><li>一次封锁法，每个事务必须一次将所有使用的数据全部加锁。</li><li>顺序封锁法，对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁。</li></ol><p>诊断和解除死锁</p><ol><li>超时法，如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。</li><li>等待图法，出现环则发现死锁。</li></ol><h4 id="封锁的粒度"><a href="#封锁的粒度" class="headerlink" title="封锁的粒度"></a>封锁的粒度</h4><p>封锁对象的大小称为封锁粒度。封锁对象可以是逻辑单元，也可以是物理单元。封锁粒度与系统的并发度和并发控制的开销密切相关，封锁的粒度越大，并发度越小，系统的开销也越小；封锁的粒度越小，并发度较高，系统开销也较大。</p><h5 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h5><p>多粒度树的根结点是整个数据库，表示最大的数据粒度。叶节点表示最小的数据粒度。</p><p>多粒度封锁协议允许多粒度树中的每个结点被独立地加锁，对一个结点加锁意味着这个结点所有子节点也被加以同样类型的锁。在多粒度封锁中，一个数据对象可能以两种方式封锁：显式封锁和隐式封锁。显示封锁是应事务的要求直接加到数据对象上的锁；隐式封锁是该数据对象没有被独立加锁，由于其上级结点加锁而使该数据对象加上了锁。</p><p><img src="https://i.loli.net/2020/05/11/Mix5FDt8dfVoYwX.png" alt="image-20200511122559581"></p><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>意向共享锁（Intent Share Lock，IS 锁）意向排他锁（Intent Exclusive Lock，IX 锁）；共享意向排他锁（Share Intent Exclusive Lock，SIX 锁）。</p><ol><li>IS 锁，如果对一个数据对象加 IS 锁，表示它的子结点拟加 S 锁。</li><li>IX 锁，如果对一个数据对象加 IX 锁，表示它的子结点拟加 X 锁。</li><li>SIX 锁，如果对一个数据对象加 SIX 锁，表示对它加 S 锁，再加 IX 锁。</li></ol><p>在具有意向锁的多粒度封锁方法中，任意事务 T 要对一个数据对象加锁，必须先对它的上层结点加意向锁。申请封锁时应该按自上而下的次序进行，释放封锁时则应该按自下而上的次序进行。</p><p><img src="https://i.loli.net/2020/05/11/WrXlch5Ly9KAwoS.png" alt="image-20200511123052840"></p><p>图 b 中，所谓锁的强度是指它对其他锁的排斥程度。一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然。</p><h4 id="其他并发控制机制"><a href="#其他并发控制机制" class="headerlink" title="其他并发控制机制"></a>其他并发控制机制</h4><p>并发控制的方法除了封锁技术外还有时间戳方法、乐观控制法和多版本并发控制等。</p><p>时间戳方法给每一个事务盖上一个时标，即事务开始执行的时间。每个事务具有唯一的时间戳，并按照这个时间戳来解决事务的冲突操作。</p><p>乐观控制阀认为书屋执行时很少发生冲突，不对事务进行特殊的管制，而是让它自由执行，事务提交前再进行正确性检查。如果发生冲突则回滚事务。</p><p>多版本并发控制是指数据库中通过维护数据对象的多个版本信息来实现高效并发控制的一种策略。</p><h3 id="恢复与备份"><a href="#恢复与备份" class="headerlink" title="恢复与备份"></a>恢复与备份</h3><h4 id="故障分类及恢复策略"><a href="#故障分类及恢复策略" class="headerlink" title="故障分类及恢复策略"></a>故障分类及恢复策略</h4><p>​    1）事务故障。事务未运行至正常终止点就夭折了。</p><p>​    2）系统故障。突发事件导致系统停止运行。</p><p>​    3）介质故障。硬件损坏。</p><p>​    4）其他故障。有人攻击。</p><h4 id="事务访问数据方式"><a href="#事务访问数据方式" class="headerlink" title="事务访问数据方式"></a>事务访问数据方式</h4><p>​    对于一个事务而言，它是通过 3 个地址空间同数据库进行交互：</p><p>​    1）保存数据库元素的磁盘块空间——物理数据库。</p><p>​    2）缓冲区管理器所管理的内存地址空间——数据缓冲区。</p><p>​    3）事务的局部地址空间——事务工作区。</p><p>​    当事务要读取数据库元素时，首先必须将该元素从物理数据库读取到数据缓冲区中，除非它已经在缓冲区中，然后再将缓冲区中的内容读到事务工作区中。</p><p><img src="https://i.loli.net/2020/04/06/GZAjXMbNu4z7apB.png" alt="image-20200406111338451"></p><p><img src="https://i.loli.net/2020/04/06/TcfswaB6NqoKzdp.png" alt="image-20200406111426865"></p><h4 id="基于日志的故障恢复策略"><a href="#基于日志的故障恢复策略" class="headerlink" title="基于日志的故障恢复策略"></a>基于日志的故障恢复策略</h4><p>​    日志是 DBMS 记录数据库全部更新操作的序列文件。通常一个数据库系统只有一个日志文件，为所有事务共享，其主要特点有：</p><p>​    1）日志文件记录了数据库的全部更新顺序。</p><p>​    2）每条日志都记录在日志的尾部，故日志文件是一个追加文件。</p><p>​    3）DBMS 允许事务的并发执行导致日志文件是“交错的”。</p><p>​    4）属于单个事务的日志顺序与该事务的更新操作顺序是一致的。</p><p>​    5）日志记录通常是先写到日志缓冲区中，然后写到稳定存储器中。</p><p>​    数据库中的日志记录有两种类型：</p><p>​    1）记录数据更新操作的日志记录，包括 update，insert 和 delete 操作。</p><p>​    2）记录事务操作的日志记录，包括start，commit 和 abort 操作。</p><p>​    它们的具体记录格式如下：</p><p>​    &lt; Ti, A, V1,V2 &gt; 表示 Ti 对数据元素 A 执行了更新操作，V1为 A 更新前的值，V2表示 A 更新后的值。</p><p>​    &lt; Ti, START &gt; 表示事务 Ti 已经开始。此时 DBMS 完成对事务的初始化工作，如分配事务工作区等。</p><p>​    &lt; Ti, COMMIT &gt; 表示事务 Ti 已经提交。</p><p>​    &lt; Ti, ABORT &gt; 表示事务已经终止，即事务执行失败。</p><p>​    为了保证数据库能运用日志进行恢复，要求日志文件必须放到稳定存储器上，并且要求每条日志记录必须在其所包含数据元素的更新值写到稳定存储器之前写到稳定存储器上，即<strong>先写日志</strong>规则。</p><h5 id="UNDO-操作"><a href="#UNDO-操作" class="headerlink" title="UNDO 操作"></a>UNDO 操作</h5><p>​    事务 T 执行过程中修改了数据库后，可能由于某种原因事务中止或系统崩溃，可使用 UNDO 恢复技术将 T 修改的全部数据对象值恢复到 T 开始前的状态。</p><p>​    对于要 UNDO 的事务 T ，日志中记录有 &lt;T, START&gt; 以及 T 对数据库的所有更新操作的日志记录。UNDO 过程为：从 T 的最后一条更新日志开始，从日志尾向日志头（反向）依次将 T 更新的数据元素恢复为旧值（V1）。</p><p>​    之所以需要 UNDO ，是因为故障发生时未提交事务的修改可能已写到磁盘上。</p><h5 id="REDO-操作"><a href="#REDO-操作" class="headerlink" title="REDO 操作"></a>REDO 操作</h5><p>​    REDO 操作时对已提交事务进行重做，将数据库状态恢复到事务结束后的状态。</p><p>​    对于要 REDO 的事务 T，日志中已经记录了 &lt;T, START&gt;  ，T 的所有更新操作日志以及 &lt;T, COMMIT&gt;。REDO 的过程为：从 T 的第一条更新日志记录来时，从日志头向日志尾（顺向）依次将 T 更新的数据元素值恢复为新值（V2）。</p><p>​    需要 REDO 的原因是，故障发生时可能有些已提交事务的更新数据还未写到磁盘上。</p><h5 id="并发执行事务的基本恢复过程"><a href="#并发执行事务的基本恢复过程" class="headerlink" title="并发执行事务的基本恢复过程"></a>并发执行事务的基本恢复过程</h5><p>​    1）分析阶段。从日志头开始顺向扫描日志，以确定重做事务集和撤销事务集。将既有  &lt;T, START&gt;又有 &lt;T, COMMIT&gt; 日志记录的事务 T 加入重做事务集。将只有  &lt;T, START&gt;没有 &lt;T, COMMIT&gt; 日志记录的事务 T 加入撤销事务集。</p><p>​    2）撤销阶段。从日志尾反向扫描日志，对每一条属于撤销事务集中的事务更新操作日志依次执行 UNDO 操作。</p><p>​    3）重做阶段。从日志头顺向扫描日志，对每一条属于重做事务集中的事务更新操作日志依次执行 REDO 操作。</p><h4 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h4><p>​    检查点是周期性地向日志中写一条检查点记录并记录所有当前活跃的事务，为恢复管理器提供信息，以决定从日志的何处开始恢复。在日志记录中使用 &lt; Checkpoint L &gt;来指定检查点 L 。</p><p>​    图10-19 是系统崩溃时的不同事务状态类型，其中 Tc 为完成最近检查点时刻，Tf 为故障发生时刻。 </p><p><img src="https://i.loli.net/2020/04/06/TgmJlz6Qevkprni.png" alt="image-20200406114406231"></p><h4 id="备份与介质故障恢复"><a href="#备份与介质故障恢复" class="headerlink" title="备份与介质故障恢复"></a>备份与介质故障恢复</h4><p>​    动态备份是指备份操作与用户事务的执行并发进行，备份期间允许对数据库进行存取或修改。静态备份则要等待用户事务结束然后备份。</p><p>​    具体进行数据备份时可以有两种方式，一种是全备份，一种是增量备份。</p><p>​    全备份是指每次备份全部数据库，而增量备份只备份上次备份后更新过的数据。</p>]]></content>
    
    <summary type="html">
    
      本文是复习数据库整理的资料
    
    </summary>
    
    
      <category term="数据库" scheme="https://hoo334.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>E-R 模型</title>
    <link href="https://hoo334.github.io/2020/04/05/E-R-%E6%A8%A1%E5%9E%8B/"/>
    <id>https://hoo334.github.io/2020/04/05/E-R-%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-04-05T14:23:02.000Z</published>
    <updated>2020-04-22T07:03:28.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库设计过程"><a href="#数据库设计过程" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h3><p>​    1）需求分析：了解和分析系统将要提供的功能及未来数据库的用户需求。</p><p>​    2）概念设计：根据需求分析中得到的信息，设计者此阶段须选择适当的数据模型将这些需求转化为数据库的概念模式。例如 <strong>E - R 模型</strong> 是概念设计。</p><p>​    3）逻辑设计：将概念设计转化为所选择的数据库管理系统支持的逻辑数据模型，即数据库模式。逻辑数据库设计的任务是将 E - R 模型转化为关系数据库模式。</p><p>​    4）模式求精：对已得到的关系数据库模式进行分析找出潜在的问题并加以改进和优化。</p><p>​    5）物理设计：为逻辑数据库选取一个最适合现实应用的物理结构。</p><p>​    6）应用与安全设计：数据库系统必须指出哪些用户可以访问数据库以及他们通过哪些存储过程访问数据库。</p><h3 id="E-R-模型基本概念及表示"><a href="#E-R-模型基本概念及表示" class="headerlink" title="E - R 模型基本概念及表示"></a>E - R 模型基本概念及表示</h3><h4 id="实体与实体集"><a href="#实体与实体集" class="headerlink" title="实体与实体集"></a>实体与实体集</h4><p>​    实体是客观世界中可区别于其他事物的“事物”或“对象”。</p><p>​    实体的两个特征：独立存在（一个实体的存在不依赖于其他实体）、可区别于其他实体。</p><p>​    实体集是指具有相同类型及相同性质（或属性）的实体集合。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>​    实体是通过一组属性来描述的，属性是实体集中每个实体都具有的描述性性质。在已实体集中，所有实体都具有相同的属性。</p><p>​    每个属性所允许的取值范围或集合称为该属性的<strong>域</strong>。</p><p>​    E - R 模型中的属性可按如下类型划分：</p><p>​    1）简单属性和复合属性。简单属性是指不能再分为更小部分的属性。复合属性指可以进一步划分为更小部分的属性。</p><p>​    2）单值属性和多值属性。如果某属性对一个特定实体任何时候都只能有单独的一个值，则称该属性为单值属性，否则为多值属性。例如一个studentNo 属性只对应一个学号，为单值属性。一个phoneNumber属性可能有不同数目的值，为多值属性。</p><p>​    3）空值（NULL）属性。当某个属性上没有值时可以使用 NULL 值。</p><p>​    4）派生属性，这类属性的值可以从其他属性的值派生出来。例如实体集 Student 的 age 属性表示学生的年龄，它可以由当前日期和生日属性的值计算得到。</p><p>​    在 E - R 图中，实体集用矩形表示，属性用椭圆表示，多值属性用双椭圆表示，派生属性用虚线椭圆表示，属性与实体之间用连线表示。</p><p><img src="https://i.loli.net/2020/04/05/2lqtAhLbzMSsjE4.png" alt="image-20200405101025891"></p><h4 id="联系与联系集"><a href="#联系与联系集" class="headerlink" title="联系与联系集"></a>联系与联系集</h4><p>​    联系集是 n （n &gt;= 2）个实体集上的数学关系，这些实体集不必互异。</p><p>​    参与联系的实体集的数目称为联系集的度。</p><p>​    下图中，Student 与 Course 之间有 Enroll 联系集，选课联系集上有 Score 属性。课程里面的 PriorCourse 属性参照 Course 关系。 </p><p><img src="https://i.loli.net/2020/04/05/kKAVRhcFCMYjawT.png" alt="image-20200405101234923"></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="映射约束"><a href="#映射约束" class="headerlink" title="映射约束"></a>映射约束</h4><p>​    映射基数指一实体集中的一个实体通过一个联系集能同时与另一个实体集相联系的实体数目。在二元联系中，共有 4 种映射基数：1：1（一对一）、1：m（一对多）、m：1（多对一）、m：n（多对多）。</p><p>​    在 E - R 图中，“—&gt;”指向参与联系集中“一”方实体集，线段“—”表示参与联系集中的“多”方实体集。</p><h4 id="码约束"><a href="#码约束" class="headerlink" title="码约束"></a>码约束</h4><h5 id="实体集的码"><a href="#实体集的码" class="headerlink" title="实体集的码"></a>实体集的码</h5><p>​    码是一个或多个属性的集合。</p><p>​    超码是一个或多个属性的集合，超码中的这些属性可以让我们在一个实体集中唯一地标识一个实体。</p><p>​    候选码是极小的超码集，也就是它的任意真子集都不是超码，而他本身是超码。</p><p>​    主码是被选中用来在一个关系中区分不同元组的候选码。</p><h5 id="联系集的码"><a href="#联系集的码" class="headerlink" title="联系集的码"></a>联系集的码</h5><p>​    二元联系集的主码选择依赖于联系集的映射基数，具体如下。</p><p>​    1）一对一：主码可以使用参与联系集中的任何一方实体集的主码；</p><p>​    2）一对多和多对一：主码由“多的一方实体集的主码组成；</p><p>​    3）多对多：主码由参与联系集中所有实体集的主码组成。</p><h4 id="参与约束"><a href="#参与约束" class="headerlink" title="参与约束"></a>参与约束</h4><p>​    如果实体集 A 中的每个实体都参与到联系集 R 中至少一个联系中，则称实体集 A 全部参与联系集 R。</p><h4 id="存在依赖与弱实体集"><a href="#存在依赖与弱实体集" class="headerlink" title="存在依赖与弱实体集"></a>存在依赖与弱实体集</h4><p>​    存在一类实体集，其属性不足以形成主码，它们必须依赖于其他实体集的存在而存在，称这样的实体集为<strong>弱实体集</strong>。与此相对，其属性可以形成主码的实体集称为<strong>强实体集</strong>。弱实体集所依赖的强实体集称为<strong>标识实体集</strong>。弱实体集必须与一个标识实体集相关联才有意义，该实体集称为<strong>标识实体集</strong>。</p><p>​    对于弱实体集，必须满足下列限制：</p><p>​    1）标识实体集和弱实体集必须是一对多联系集。</p><p>​    2）弱实体集在标识联系集中是全部参与。</p><p>​    E - R 图使用双矩形表示弱实体集，双菱形表示标识联系，用虚下划线表示弱实体集的部分码。下图描述了 CourseClass 及其标识实体集 Course 之间的标识联系集 Arrange 。注意标识联系集没有描述性属性，因为任何所需的属性都可和弱实体相关联。</p><p><img src="https://i.loli.net/2020/04/05/JW8oG15VvgYqley.png" alt="image-20200405103558371"></p><h3 id="E-R-模型转化为关系模型"><a href="#E-R-模型转化为关系模型" class="headerlink" title="E - R 模型转化为关系模型"></a>E - R 模型转化为关系模型</h3><h4 id="E-R-模型转化方法"><a href="#E-R-模型转化方法" class="headerlink" title="E - R 模型转化方法"></a>E - R 模型转化方法</h4><p>​    1）强实体集转化方法：将实体集的每个属性对应为关系模式的属性，实体集的码作为关系模式的码。</p><p>​    2）弱实体集转化方法：弱实体集对应的关系模式属性由弱实体集本身的描述属性加上所依赖的强实体集的主码属性组成。<strong>主码由所依赖的强实体集主码和弱实体集的部分码组成</strong>。</p><p>​    3）联系集转化方法    </p><p>​        联系集一般转化方法：一个联系集转化为一个关系模式。联系集的主码设置见“联系集的主码“。</p><p>​        一对多或多对一联系集的转化：在 ”多“ 方的实体集中添加 ”一“ 方的主码，使 ”一“ 方的主码成为 ”多“ 方 的外码。</p><p>​    4）复合属性及多值属性转化方法：对于复合属性，应为每个子属性创建一个单独的属性，而不是为复合属性自身创建的一个单独的属性。</p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><img src="https://i.loli.net/2020/04/14/Kfh8vNiTAQraPkX.png" alt="image-20200414081715392"></p><p>​    <img src="https://i.loli.net/2020/04/14/cdBWLxwvRQb9FnV.png" alt="image-20200414081741823"></p><p><img src="https://i.loli.net/2020/04/14/Ex5MTBGdXacLkyV.png" alt="image-20200414081901050"></p><p><img src="https://i.loli.net/2020/04/14/jGQMRbT2FCctdne.png" alt="image-20200414081801666"></p><p><img src="https://i.loli.net/2020/04/14/GPsadUnVFbQJm9l.png" alt="image-20200414081819570"></p><p><img src="https://i.loli.net/2020/04/14/eAio7uRHx3bcEQX.png" alt="image-20200414081934207"></p><p><img src="https://i.loli.net/2020/04/14/roiPmwSHdhaqDV4.png" alt="image-20200414101333649"></p><p><img src="https://i.loli.net/2020/04/14/a1hWbyZrOe6kMSC.png" alt="image-20200414101352852"></p><p><img src="https://i.loli.net/2020/04/14/IqghOSjkUmcQD7M.png" alt="image-20200414101445958"></p><p><img src="https://i.loli.net/2020/04/14/jJVGegbAKdwCi1S.png" alt="image-20200414101457645"></p>]]></content>
    
    <summary type="html">
    
      本文为复习数据库整理的资料。
    
    </summary>
    
    
      <category term="数据库" scheme="https://hoo334.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库完整性与安全性</title>
    <link href="https://hoo334.github.io/2020/04/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>https://hoo334.github.io/2020/04/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/</id>
    <published>2020-04-05T14:23:02.000Z</published>
    <updated>2020-04-25T02:19:45.614Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h3><h4 id="SQL-存取控制机制"><a href="#SQL-存取控制机制" class="headerlink" title="SQL 存取控制机制"></a>SQL 存取控制机制</h4><p>​    SQL 支持受控的存取保护，即在自主存取控制中，用户对于不同的数据对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户。因此自主存取控制非常灵活。</p><p>​    自主存取控制通过 SQL 的 grant 和 revoke 语句实现。</p><p>​    用户权限是由两个要素组成的：数据对象和操作对象。</p><p>​    用户的存取权限：该用户可以在哪些数据对象上进行哪些类型的操作。定义存取权限称为授权。</p><p>​    自主存取控制能够通过授权机制有效地控制其他用户对敏感数据的存取。</p><h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><p>​    创建用户语句 create user 的语法如下：</p><p><img src="https://i.loli.net/2020/04/05/PMcSmGxa3O7JzBb.png" alt="image-20200405154743908"></p><p>​    只有系统的超级用户才有权创建一个新的数据库用户。新创建的数据库用户有 3 种权限 connect、resource 和 dba。默认为 connect 权限，拥有 connect 权限的用户不能创建新用户、模式和基本表，只能登录数据库。然后由 dba 或其他用户给他转授权限。拥有 resource 权限的用户可以创建基本表和视图，并称为所创建对象的属主，但不能创建模式和新用户。数据库对象的属主可以使用 grant 语句把该对象上的存取权限授予其他用户。拥有 dba 权限的用户是系统中的超级用户，可以创建新用户、模式、基本表和视图等；dba 拥有所有数据库对象的存取权限，还可以将这些权限授予给一般用户。</p><h5 id="权限的授予与收回"><a href="#权限的授予与收回" class="headerlink" title="权限的授予与收回"></a>权限的授予与收回</h5><p>​    grant 和 revoke 有两种权限：目标权限和命令权限。</p><h6 id="命令权限的授予与收回"><a href="#命令权限的授予与收回" class="headerlink" title="命令权限的授予与收回"></a>命令权限的授予与收回</h6><p>​    命令级权限主要指 DDL 操作权限。命令权限的授予语句 grant 和 收回语句 revoke 的语法分别为：</p><p><img src="https://i.loli.net/2020/04/05/jWhtYLXsdeT6iAE.png" alt="image-20200405155559635"></p><p>​    其中 &lt; command_list &gt; 可以是 create database、create default、create function、create procedure、create rule、create table、create view、create index、backup database 和 backup log 等。</p><p>​    一次可以授予多种权限，授予多种权限时，权限之间用逗号分隔。</p><p>​    all：表示上述所有权限。</p><p>​    public：表示所有用户。</p><p>​    &lt; username_list &gt;：指定的用户名列表。如果将某组权限同时授予多个用户，则用户名之间用逗号分隔。</p><h6 id="目标权限的授予与收回"><a href="#目标权限的授予与收回" class="headerlink" title="目标权限的授予与收回"></a>目标权限的授予与收回</h6><p>​    目标权限主要指对对象的 DML 操作权限。对象权限的授予语句 grant 和收回语句 revoke 的语法分别为：</p><p><img src="https://i.loli.net/2020/04/05/iEl5Mm3Tw8tWVQ6.png" alt="image-20200405160348795"></p><p>​    其中 &lt; command_list &gt; 可以是 update、select、insert、delete、execute 和 all 。execute 针对存储过程授予执行权限，update、select、insert、delete 针对基本表和视图授权， all 指全部的权限。</p><p>​    cascade ：级联收回。</p><p>​    restrict：默认值，若转赋了权限，则不能收回。</p><p>​    with grant option：将指定对象上的目标权限授予其他安全账户的能力，但是不允许循环授权。即不允许将其得到的权限授予其祖先。</p><h3 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h3><h4 id="完整性约束条件"><a href="#完整性约束条件" class="headerlink" title="完整性约束条件"></a>完整性约束条件</h4><p>​    完整性约束条件作用的对象可以是关系、元组、列 3 种。列约束主要是列的类型、取值范围、精度、是否允许空值等的约束条件。元组约束是元组中属性间的联系的约束。关系约束是若干元组间、关系集合上以及关系之间的约束。</p><p>​    完整性约束条件涉及的这 3 类对象，其状态可以是静态的，也可以是动态的。</p><p>​    静态约束是指数据库每一确定状态时的数据对象所应满足的约束条件，它反映数据库状态合理性的约束，这是最重要的一类完整性约束。</p><p>​    静态约束主要表现在：</p><p>​    1）静态列级约束：对一个列的取值域的说明。对数据类型（类型，长度、单位、精度等）、数据格式、对取值范围或取值集合的约束、对空值的约束和其他约束。</p><p>​    2）静态元组约束：规定元组的各个列之间的约束关系。</p><p>​    3）静态关系约束：在一个关系的各个元组之间或若干关系之间存在各种联系或约束。常见的静态关系约束有：<strong>实体完整性约束、参照完整性约束和函数依赖约束</strong>。</p><p>​    </p><p>​    动态约束是指数据库从一种状态转变为另一种状态时的新、旧值之间所应满足的约束条件，它是反映数据库状态变迁的约束。</p><p>​    动态约束主要表现在：</p><p>​    1）动态列级约束。修改列定义或列值时应满足的约束条件。<strong>包括修改列定义时的约束</strong>（将允许空值的列修改为不允许空值，记录中有一列为空值，拒绝修改）<strong>修改列值时的约束</strong>（修改列值有时需要参照其旧值）。</p><p>​    2）动态元组约束：指需改元组的值时元组中各个字段间需要满足某种约束条件。</p><p>​    3）动态关系约束：动态关系约束是加在关系变化前后状态上的限制条件。例如，事物一致性、原子性等约束条件。</p><p>​    </p><p>​    完整性约束又可以分为立即执行的约束和延迟执行的约束。</p><p>​    立即执行约束：检查是否违背完整性约束的时机是在一条语句执行完后立即检查。</p><p>​    延迟执行约束：需要延迟到整个事务执行结束后再进行检查。</p><p>​    </p><h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>​    实体完整性要求基本表的主码值唯一且不允许为空值。primary key 指定</p><p>​    实体完整性的检查和违约处理：</p><p>​    1）检查主码是否唯一。如果不唯一则拒绝插入或修改。（索引或顺序查找）</p><p>​    2）检查主码的各个属性是否为空，只要有一个为空则拒绝插入或修改。</p><h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><p>​    参照完整性为若干个表中的相应元组建立联系。参照完整性定义是使用 create table 语句中的 foreign key 和 references 短语来实现，或通过 alter table 语句中的 add foreign key 来实现。</p><p>​    参照完整性的检查和违约处理：</p><p>​    1）拒绝执行。如果发生了违约，阻止操作。</p><p>​    2）级联操作。当删除或修改被参照关系的某个元组造成了与参照关系的不一致时，则删除或修改参照表中所有不一致的元组。级联操作必须在定义外码时给出定义（在外码定义最后追加 on delete/update cascade）。</p><p>​    3）设置为空值。如果外码可以为空，发生了违约则将外码置空。</p><p>​    4）置空值删除。删除被参照关系的元组，并将被参照关系中相应元组的外码置空值。</p><h4 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h4><h5 id="属性上的约束"><a href="#属性上的约束" class="headerlink" title="属性上的约束"></a>属性上的约束</h5><p>​    包括：列值非空、列值唯一、设置默认值和满足 check 定义。如果不满足则拒绝相应的操作。</p><p>​    以上约束分别通过 not null、unique、default+默认值、check 实现。</p><h5 id="元组上的约束"><a href="#元组上的约束" class="headerlink" title="元组上的约束"></a>元组上的约束</h5><p>​    元组上的约束可以设置不同属性之间的取值相互约束条件，也是用 check 实现。插入元组或修改属性的值时，RDBMS 检查元组上的约束条件是否满足，否则拒绝操作。</p><p><img src="https://i.loli.net/2020/04/05/fNQagDl4ZItoTWi.png" alt="image-20200405164250636"></p><p>​    第一个 check 为属性上的约束，放在属性定义后，第二个 check 为元组上的约束。    </p><h4 id="完整性约束的修改"><a href="#完整性约束的修改" class="headerlink" title="完整性约束的修改"></a>完整性约束的修改</h4><p>​    要修改约束必须先删除约束，然后加入新的约束。</p><p><img src="https://i.loli.net/2020/04/05/n9JVSWwL5aC14o8.png" alt="image-20200405164505007"></p><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>​    若要对 select 语句返回的结果值进行逐行处理，必须使用游标。可对游标的当前位置进行更新、查询和删除，使用游标必须经历 5 个步骤：</p><p>​    1）定义游标：declare；</p><p>​    2）打开游标：open；</p><p>​    3）逐行提取游标集中的行：fetch；</p><p>​    4）关闭游标：close；</p><p>​    5）释放游标：deallocate；</p><h4 id="游标的使用"><a href="#游标的使用" class="headerlink" title="游标的使用"></a>游标的使用</h4><h5 id="定义游标"><a href="#定义游标" class="headerlink" title="定义游标"></a>定义游标</h5><p><img src="https://i.loli.net/2020/04/05/vcoWwbID6UaBy2i.png" alt="image-20200405165033658"></p><p>​    read only 表示当前游标集中的元组仅可以查询，不可以修改。update表示可以对当前游标集中的元组进行更新操作，如果有 of &lt; columnName_list &gt;，表示仅可以对游标集中指定的属性列进行更新操作。</p><h5 id="打开游标"><a href="#打开游标" class="headerlink" title="打开游标"></a>打开游标</h5><p>​    系统按照游标的定义从数据库中将数据检索出来，放在内存的游标集中，并为游标集指定一个游标，该游标指向游标集中的第一个元组。</p><p>​    打开游标的语法：open &lt; cursorName &gt;</p><h5 id="获取当前游标值"><a href="#获取当前游标值" class="headerlink" title="获取当前游标值"></a>获取当前游标值</h5><p>​    要对当前游标所指向的元组进行操作，必须获取当前游标所指向的元组，其语法是</p><p>​    fetch &lt; cursorName &gt; into &lt; @variableName_list &gt;</p><p>​    <strong>获取当前游标的值，必须将当前游标所指向的元组的各个属性值分别用变量接收，其变量个数、数据类型必须与定义游标中的 select 子句所定义的属性（或表达式）个数数据类型相一致。</strong></p><p>​    SQL Server 中，变量名前面必须使用 @ 符号，使用一个 @ 符号位局部变量，使用两个 @ 为全局变量。</p><p>​    执行一次该语句，系统将当前游标所指向的元组属性放到变量中，然后游标自动下移一个元组。当游标移至尾部，则不可以再读取游标，必须关闭游标再重新打开游标。可以通过检查全局变量 @@FETCH_STATUS 来判断是否已经读完游标集中所有行。</p><p>​    @@FETCH_STATUS 的值有：</p><p>​    0 ：fetch 语句成功，表示已经从游标集中获取了元组值。</p><p>​    1：fetch 语句失败或此行不在结果集中。</p><p>​    2：被提取的行不存在。</p><h5 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h5><p>​    close  &lt; cursorName &gt;</p><h5 id="释放游标所占用的存储空间"><a href="#释放游标所占用的存储空间" class="headerlink" title="释放游标所占用的存储空间"></a>释放游标所占用的存储空间</h5><p>deallocate  &lt; cursorName &gt;</p><h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><p><img src="https://i.loli.net/2020/04/05/NUanJEF7lpHYyhA.png" alt="image-20200405195554371"></p><h4 id="对当前游标集的修改"><a href="#对当前游标集的修改" class="headerlink" title="对当前游标集的修改"></a>对当前游标集的修改</h4><p>​    可以对当前游标集中的元组执行删除和更新操作。</p><h5 id="删除游标集中的当前行"><a href="#删除游标集中的当前行" class="headerlink" title="删除游标集中的当前行"></a>删除游标集中的当前行</h5><p>​    delete from &lt; tableName &gt; where current of &lt; cursorName  &gt;</p><h5 id="更新游标集中的当前行"><a href="#更新游标集中的当前行" class="headerlink" title="更新游标集中的当前行"></a>更新游标集中的当前行</h5><p>​    update &lt; tableName &gt;</p><p>​    set &lt; columnName &gt;=&lt; expr &gt;[,&lt; columnName &gt;=&lt; expr &gt;…]</p><p>​    where current of &lt; cursorName &gt;</p><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>​    存储过程是为了完成特定功能汇集而成的一组命名了的 SQL 语句集合，该集合编译后存放在数据库中，可按实际情况重新编译。</p><p>​    使用存储过程的优点：将业务操作封装、便于事务管理、实现一定程度的安全性保护、特别适合统计和查询操作、减少网络通信量。</p><h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><p><img src="https://i.loli.net/2020/04/05/vXtEcyQObCRpxT6.png" alt="image-20200405200322658"></p><p>​    output：输出参数，被调用者获取使用。</p><h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><p>​    存储过程创建后存放在数据库中，当要使用存储过程时，必须执行命令 execute。</p><p><img src="https://i.loli.net/2020/04/05/GlUWZ8rtMVhSO5y.png" alt="image-20200405200618013"></p><h4 id="修改和删除存储过程"><a href="#修改和删除存储过程" class="headerlink" title="修改和删除存储过程"></a>修改和删除存储过程</h4><h5 id="修改存储过程"><a href="#修改存储过程" class="headerlink" title="修改存储过程"></a>修改存储过程</h5><p><img src="https://i.loli.net/2020/04/05/z1no7G8baR5Yp9t.png" alt="image-20200405200745811"></p><p><img src="https://i.loli.net/2020/04/05/s79bqRDMnWKrEvm.png" alt="image-20200405200755212"></p><h5 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h5><p>​    drop procedure &lt; procedureName &gt;</p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>​    触发器是用户定义在关系表上的一类由事件驱动的存储过程，由服务器自动激活。触发器可以进行更为复杂的检查和操作，具有更精细和强大的数据控制能力。</p><p>​    有两个特殊的表用在触发器语句中，不同的数据库其名称不一样。以SQL Server 为例介绍触发器。</p><p>​    1）deleted 表。存储 delete 和 update 语句执行时所影响的行的拷贝，在 delete 和 update 语句执行前被作用的行转移到 deleted 表中，即将被删除的元组或修改前的元组值存入该表中。</p><p>​    2）inserted 表。存储 insert 和 update 语句执行时所映像的行的拷贝，在 insert 和 update 语句执行期间，新行被同时加到 inserted 表和触发器中，即将被插入的元组或修改后的元组存入该表中，同时也更新基本表。</p><h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><p><img src="https://i.loli.net/2020/04/05/KzmCBDclWnp6hxR.png" alt="image-20200405201801494"></p><p>​    &lt;insert|update|delete&gt; ：触发器事件。</p><h4 id="修改和删除触发器"><a href="#修改和删除触发器" class="headerlink" title="修改和删除触发器"></a>修改和删除触发器</h4><p>​    修改触发器：</p><p><img src="https://i.loli.net/2020/04/05/rSV8gNdlaT6vQwx.png" alt="image-20200405202018722"></p><p>​    删除触发器：</p><p>​    drop trigger &lt; triggerName &gt;</p><h4 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h4><p>​    触发器常用于保证完整性，并在一定程度上实现安全性，如用触发器来进行审计。</p>]]></content>
    
    <summary type="html">
    
      复习数据库整理的资料
    
    </summary>
    
    
      <category term="数据库" scheme="https://hoo334.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>利用gradle添加依赖</title>
    <link href="https://hoo334.github.io/2020/04/04/Gradle%E4%BE%9D%E8%B5%96%E4%B8%8B%E8%BD%BD/"/>
    <id>https://hoo334.github.io/2020/04/04/Gradle%E4%BE%9D%E8%B5%96%E4%B8%8B%E8%BD%BD/</id>
    <published>2020-04-04T06:39:13.000Z</published>
    <updated>2020-04-04T10:14:40.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用gradle添加依赖"><a href="#利用gradle添加依赖" class="headerlink" title="利用gradle添加依赖"></a>利用gradle添加依赖</h1><p>1、新建一个gradle项目</p><p>可以看到build.gradle</p><p><img src="https://i.loli.net/2020/04/04/qxOINuGoR7pAsE2.png" alt="img"></p><p> 2、编写gradle.properties</p><p><img src="https://i.loli.net/2020/04/04/Bj2opT4nKwUvLyq.png" alt="img"></p><p> 3、修改build.gradle编译jar，利用${key} 来获取key的值</p><p><img src="https://i.loli.net/2020/04/04/AjhOQ9rK3IHnL8D.png" alt="img"></p><p> 4、等待gradle自动导入</p><p><img src="https://i.loli.net/2020/04/04/WKCFrN3MavV6ncg.png" alt="img"></p><p> 可以看到已经导入完成，开始玩耍。。。</p><p>如果遇到依赖下载慢的情况 在build.gradle文件repositories加入：           </p><p>maven{ url’<a href="http://maven.aliyun.com/nexus/content/groups/public/&#39;}" target="_blank" rel="noopener">http://maven.aliyun.com/nexus/content/groups/public/&#39;}</a></p><p>使用阿里云的maven仓库</p><p>mavenLocal()可以让项目先检查本地的仓库，有的话不用下载。</p>]]></content>
    
    <summary type="html">
    
      Gradle 构件工具
    
    </summary>
    
    
      <category term="工具" scheme="https://hoo334.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://hoo334.github.io/tags/Java/"/>
    
      <category term="Gradle" scheme="https://hoo334.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>JVM 运行时数据区</title>
    <link href="https://hoo334.github.io/2020/04/04/JVM%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <id>https://hoo334.github.io/2020/04/04/JVM%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</id>
    <published>2020-04-04T06:39:13.000Z</published>
    <updated>2020-04-04T10:20:58.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h1><p><img src="https://i.loli.net/2020/03/24/ML2CpVz6XdqoJkl.png" alt=""></p><p> <img src="https://i.loli.net/2020/03/24/VfYt7yh4pav9ure.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      JVM学习
    
    </summary>
    
    
      <category term="JVM" scheme="https://hoo334.github.io/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Git上传本地项目</title>
    <link href="https://hoo334.github.io/2020/04/04/Git%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/"/>
    <id>https://hoo334.github.io/2020/04/04/Git%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-04-04T06:39:13.000Z</published>
    <updated>2020-04-04T10:17:09.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git上传本地项目"><a href="#Git上传本地项目" class="headerlink" title="Git上传本地项目"></a>Git上传本地项目</h1><p><strong>如何将本地项目push到GitHub上？</strong></p><p>GitHub新建一个 repostory 找到URL 例如：<a href="https://github.com/hoo334/test.git" target="_blank" rel="noopener">https://github.com/hoo334/test.git</a></p><p>找到项目文件夹 右键git bash here</p><p><strong>git init</strong></p><p>*<em>git add . *</em></p><p><strong>git commit -m “提交信息”</strong></p><p><strong>git remote add origin URL</strong></p><p><strong>git push -u origin master</strong></p><p><strong>提交更新到Github</strong></p><p><strong>git status （可选 查看更改文件）</strong></p><p><strong>git add 你想要提交更改的文件 或者git add .</strong></p><p><strong>git commit -m “提交信息”</strong></p><p><strong>git push  origin master</strong></p><p><strong>如果操作失误就直接删掉目录内的.git整个文件夹 重新git init。</strong></p>]]></content>
    
    <summary type="html">
    
      Git
    
    </summary>
    
    
      <category term="工具" scheme="https://hoo334.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://hoo334.github.io/tags/Java/"/>
    
      <category term="Git" scheme="https://hoo334.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
