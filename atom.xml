<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2020-08-08T02:47:23.094Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>恢复二叉搜索树</title>
    <link href="https://hoo334.github.io/2020/08/08/%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/08/%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-08-08T01:46:58.000Z</published>
    <updated>2020-08-08T02:47:23.094Z</updated>
    
    <content type="html"><![CDATA[<h4 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">99. 恢复二叉搜索树</a></h4><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  &#x2F;</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">输出: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  3</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><ul><li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li><li>你能想出一个只使用常数空间的解决方案吗？</li></ul><p><strong>方法一：显式中序遍历</strong></p><p>我们知道 BST 的中序遍历是有序的，我们可以使用一个数组存储中序遍历的结点。在交换了两个结点之后的数组，如果我们将其画成折线图，我们会发现存在一段或两段 “下降” 的折线。下面看几个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">交换两个结点后的中序遍历序列:</span><br><span class="line">[1, 3, 2, 4], 存在一段下降的折线[3, 2]，我们交换 “3” 和 “2” 即可</span><br><span class="line">[1, 5, 3 ,4 ,2 ,6], 存在两段下降的折线[5, 3] 和[4, 2]，我们交换左边折线的结点“5” 和右边折线的结点 “2” 即可。</span><br><span class="line">总结：我们只需要找到一个下降折线的左边结点和一个下降折线的右边结点，而不管折线有一根和两根折线。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//存储中序遍历得到的结点</span></span><br><span class="line">        inOrder(root, nodes);</span><br><span class="line">        <span class="keyword">int</span> n = nodes.size(); </span><br><span class="line"><span class="comment">//寻找“下降”折线的左侧结点</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes.get(i).val &gt; nodes.get(i + <span class="number">1</span>).val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//寻找“下降”折线的右侧结点</span></span><br><span class="line">        <span class="keyword">for</span>(; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes.get(j).val &lt; nodes.get(j - <span class="number">1</span>).val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//交换结点的值</span></span><br><span class="line">        TreeNode n1 = nodes.get(i);</span><br><span class="line">        TreeNode n2 = nodes.get(j);</span><br><span class="line">        <span class="keyword">int</span> temp = n1.val;</span><br><span class="line">        n1.val = n2.val;</span><br><span class="line">        n2.val = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inOrder(root.left, nodes);</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        inOrder(root.right, nodes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度O(n)，时间复杂度O(n)。</p><p><strong>方法二：隐式中序遍历</strong></p><p>在方法一中，我们使用了一个数组来保存中序遍历的结点，我们可以在中序遍历的过程中找到两个交换的结点，从而避免了存储中序遍历的结点。</p><p>我们使用 pre 来指向前一个遍历的结点，pre.val &gt; root.val 代表这是一段下降的折线，那我们可以先保存折线左侧的结点，然后再保存折线右侧的结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode x = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode y = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode pre = <span class="keyword">new</span> TreeNode(Integer.MIN_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="comment">//交换结点的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = x.val;</span><br><span class="line">        x.val = y.val;</span><br><span class="line">        y.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="comment">//第一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span> &amp;&amp; pre.val &gt; root.val)&#123;</span><br><span class="line">            x = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个结点不为空才保存第二个结点</span></span><br><span class="line">        <span class="keyword">if</span>(x != <span class="keyword">null</span> &amp;&amp; pre.val &gt; root.val)&#123;</span><br><span class="line">            y = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新前一个遍历的结点 pre</span></span><br><span class="line">        pre = root;</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度O(h)，h 为二叉树的高度。时间复杂度O(n)。</p><p><strong>方法三：Morris 中序遍历</strong></p><p>Morris 非递归中序遍历空间复杂度可以降为O(1)。</p><p>Morris 遍历算法步骤如下（假设当前遍历到的结点为 x ）：</p><ol><li>如果 x 无左孩子，则访问 x 的右孩子， 即 x = x.right。</li><li>如果 x 有左孩子，则找到 x 左子树上的最右结点（即左子树中序遍历的最后一个结点，x 在中序遍历的前驱结点），记为 predecessor。根据 predecessor的右孩子是否为空，进行如下操作：<ul><li>如果 predecessor的右孩子为空，将其右孩子指向 x ，然后访问 x 的左孩子，即 x = x.left。</li><li>如果 predecessor的右孩子不为空，则此时其右孩子指向 x ，说明我们已经遍历完 x 的左子树，我们将 predecessor的右孩子置空，然后访问 x 的右孩子，即 x = x.right。</li></ul></li></ol><p>重复上述操作，直至访问完整棵树。</p><p>整个过程我们只多做一步：将当前结点左子树中的最右边的结点指向它，这样在左子树遍历完成后，我们可以通过这个指针回到 x，且能通过这个知道我们已经遍历完成了左子树，省去了栈的空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode x = <span class="keyword">null</span>, y = <span class="keyword">null</span>, pred = <span class="keyword">null</span>, predecessor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//寻找 predecessor 结点(root 结点中序遍历前一个结点)</span></span><br><span class="line">                predecessor = root.left;</span><br><span class="line">                <span class="keyword">while</span>(predecessor.right != <span class="keyword">null</span> &amp;&amp; predecessor.right != root)&#123;</span><br><span class="line">                    predecessor = predecessor.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span>(predecessor.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    predecessor.right = root;</span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左子树已经访问完了，我们需要断开连接</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(pred != <span class="keyword">null</span> &amp;&amp; root.val &lt; pred.val)&#123;</span><br><span class="line">                        y = root;</span><br><span class="line">                        <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">                            x = pred;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//更新前一个遍历的结点 pred</span></span><br><span class="line">                    pred = root;</span><br><span class="line">                    <span class="comment">//断开连接</span></span><br><span class="line">                    predecessor.right = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//继续遍历右子树</span></span><br><span class="line">                    root = root.right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有左孩子，直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(pred != <span class="keyword">null</span> &amp;&amp; root.val &lt; pred.val)&#123;</span><br><span class="line">                    y = root;</span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        x = pred;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pred = root;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换 x 和 y 的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = x.val;</span><br><span class="line">        x.val = y.val;</span><br><span class="line">        y.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p><p>参见<a href="https://leetcode-cn.com/problems/recover-binary-search-tree/solution/san-chong-jie-fa-xiang-xi-tu-jie-99-hui-fu-er-cha-/" target="_blank" rel="noopener">王尼玛的幻灯片</a>更好地理解算法过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;99-恢复二叉搜索树&quot;&gt;&lt;a href=&quot;#99-恢复二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;99. 恢复二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/recover-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;99. 恢复二叉搜索树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;二叉搜索树中的两个节点被错误地交换。&lt;/p&gt;
&lt;p&gt;请在不改变其结构的情况下，恢复这棵树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>相同的树</title>
    <link href="https://hoo334.github.io/2020/08/07/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/07/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</id>
    <published>2020-08-07T02:28:13.000Z</published>
    <updated>2020-08-07T02:36:27.862Z</updated>
    
    <content type="html"><![CDATA[<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></h4><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>方法一：DFS</strong></p><p>对于两棵树 root1，root2，如果 root1 和 root2 都为空，则返回 true；如果 root1 和 root2 中有一个为空，另一个不为空，则返回false。如果都不为空且它们的值相等，则递归判断左右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(min(m, n))，m，n为两棵树的节点数。空间复杂度O(min(m, n))。</p><p><strong>方法二：BFS</strong></p><p>我们使用两个队列来存储二叉树的层次遍历。判断这个队列中的结点值是否相同即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q1.offer(p);</span><br><span class="line">        q2.offer(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q1.isEmpty() &amp;&amp; !q2.isEmpty())&#123;</span><br><span class="line">            TreeNode n1 = q1.poll(), n2 = q2.poll();</span><br><span class="line">            <span class="keyword">if</span>(n1.val != n2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( (n1.left == <span class="keyword">null</span> ^ n2.left == <span class="keyword">null</span>) || (n1.right == <span class="keyword">null</span> ^ n2.right == <span class="keyword">null</span>) )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(n1.left != <span class="keyword">null</span>) q1.offer(n1.left);</span><br><span class="line">            <span class="keyword">if</span>(n1.right != <span class="keyword">null</span>) q1.offer(n1.right);</span><br><span class="line">            <span class="keyword">if</span>(n2.left != <span class="keyword">null</span>) q2.offer(n2.left);</span><br><span class="line">            <span class="keyword">if</span>(n2.right != <span class="keyword">null</span>) q2.offer(n2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(min(m, n))，m，n为两棵树的节点数。空间复杂度O(min(m, n))。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;100-相同的树&quot;&gt;&lt;a href=&quot;#100-相同的树&quot; class=&quot;headerlink&quot; title=&quot;100. 相同的树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/same-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;100. 相同的树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定两个二叉树，编写一个函数来检验它们是否相同。&lt;/p&gt;
&lt;p&gt;如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>打家劫舍III</title>
    <link href="https://hoo334.github.io/2020/08/05/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/"/>
    <id>https://hoo334.github.io/2020/08/05/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/</id>
    <published>2020-08-05T01:38:57.000Z</published>
    <updated>2020-08-05T02:12:42.647Z</updated>
    
    <content type="html"><![CDATA[<h4 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></h4><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line"></span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 4 + 5 &#x3D; 9.</span><br></pre></td></tr></table></figure><p>很显然，对于每个房子，我们有偷和不偷两种状态，我们取的是这两种状态偷盗的金额的最大值。</p><p>我们用 <code>f(o)</code>表示选择结点 o 的情况下，o 结点的子树上被选择的结点的最大权值和；<code>g(o)</code>表示不选择结点 o 的情况下，o 结点的子树上被选择的结点的最大权值和；l 和 r 代表 o 的左右孩子。</p><ul><li>当 o 被选中时，l 和 r 都不能选中，<code>f(o) = f(l) + f(r)</code>;</li><li>当 o 不被选中时，l 和 r 都能被选中或<strong>不被选择</strong>，<code>g(o) = max(f(l), g(l)) + max(f(r), g(r))</code>;</li></ul><p>第二种情况：二叉树[4,1,null,2,null,3] 的偷盗最大金额为 7 ，选中 4 之后，不能选择子节点 1 ， 对于子节点 1 ，可以有选择 2 和 不选择 2 两种选择，选择 2 得到最后金额 6 ，不选择 2 得到最大金额 7 。即对于一个未选择的根节点，继续不选择子节点有可能会有更好的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; f = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 存储不选择结点的金额</span></span><br><span class="line">    Map&lt;TreeNode, Integer&gt; g = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//存储选择结点的金额</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">//返回选择根节点和不选择根节点的最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(f.getOrDefault(root, <span class="number">0</span>), g.getOrDefault(root, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line"><span class="comment">//选择根节点</span></span><br><span class="line">        f.put(root, root.val + g.getOrDefault(root.left, <span class="number">0</span>) + g.getOrDefault(root.right, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//不选择根节点</span></span><br><span class="line">        g.put(root, Math.max(f.getOrDefault(root.left, <span class="number">0</span>), g.getOrDefault(root.left, <span class="number">0</span>)) + </span><br><span class="line">            Math.max(f.getOrDefault(root.right, <span class="number">0</span>), g.getOrDefault(root.right, <span class="number">0</span>)) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，对二叉树做了一次后序遍历。</p><p>空间复杂度O(n)，栈空间O(n)，哈希表O(n)。</p><p>我们还可以对空间复杂度进行优化，可以看出，对于 <code>f(o)</code>或<code>g(o)</code>，它们的取值只与<code>f(l)</code>、<code>f(r)</code>、<code>g(l)</code>、<code>g(r)</code>有关，我们在递归返回时返回一个数组，这样就可以不适用哈希表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] rootStatus = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(rootStatus[<span class="number">0</span>], rootStatus[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dfs(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//l[0] 代表选择结点 l得到的金额，l[1] 代表不选择结点 l 得到的金额。</span></span><br><span class="line">        <span class="keyword">int</span>[] l = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] r = dfs(root.right);</span><br><span class="line">        <span class="keyword">int</span> selected = root.val + l[<span class="number">1</span>] + r[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> notSelected = Math.max(l[<span class="number">0</span>], l[<span class="number">1</span>]) + Math.max(r[<span class="number">0</span>], r[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;selected, notSelected&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，对二叉树做了一次后序遍历。</p><p>空间复杂度O(n)，栈空间O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;337-打家劫舍-III&quot;&gt;&lt;a href=&quot;#337-打家劫舍-III&quot; class=&quot;headerlink&quot; title=&quot;337. 打家劫舍 III&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;337. 打家劫舍 III&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。&lt;/p&gt;
&lt;p&gt;计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>课程表</title>
    <link href="https://hoo334.github.io/2020/08/04/%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <id>https://hoo334.github.io/2020/08/04/%E8%AF%BE%E7%A8%8B%E8%A1%A8/</id>
    <published>2020-08-04T02:07:41.000Z</published>
    <updated>2020-08-04T03:00:25.042Z</updated>
    
    <content type="html"><![CDATA[<h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></h4><p>你这个学期必须选修 <code>numCourse</code> 门课程，记为 <code>0</code> 到 <code>numCourse-1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：<code>[0,1]</code></p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><a id="more"></a><p> <strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li>输入的先决条件是由 <strong>边缘列表</strong> 表示的图形，而不是 邻接矩阵 。详情请参见<a href="http://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">图的表示法</a>。</li><li>你可以假定输入的先决条件中没有重复的边。</li><li><code>1 &lt;= numCourses &lt;= 10^5</code></li></ol><p>此题可以看作判断一个有向图是否存在环，如果图中存在环，则不存在拓扑排序。如果图中不存在环，则可能存在不止一种拓扑排序。</p><p>不存在拓扑排序：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200804101354711.png" alt="image-20200804101354711"></p><p>存在拓扑排序：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200804101551878.png" alt="image-20200804101551878"></p><p>上图中存在拓扑排序中的一种为：[0, 2, 1, 3, 5, 6, 4]。</p><p>求拓扑序列方法：不断取下<strong>「入度」为零</strong>的结点直到图中没有结点或没有入度为零的结点，按取下结点的顺序就得到了拓扑排序。</p><p>边缘列表就是存储图的每一条边， <code>[[1,0]]</code>代表存在一条结点 0 到结点 1 的边。</p><p><strong>方法一：BFS</strong></p><p>我们首先统计每个结点的出边信息和入度信息，首先将入度为零的结点加入队列，取下一个结点，并将该结点所指向的结点入度减一，同时将入度减为零的结点加入队列，不断重复这个步骤直到队列为空，取下结点的顺序就是拓扑排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;<span class="comment">//edges[i] 为结点 i 所指向的结点数组</span></span><br><span class="line">    <span class="keyword">int</span>[] indeg;<span class="comment">//indeg[i]为结点 i 的入度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            <span class="comment">//存在 edge[1] 到 edge[0] 的边，把edge[0] 加入到 edge[1]</span></span><br><span class="line">            edges.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//edge[0] 入度加一</span></span><br><span class="line">            ++indeg[edge[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//queue 存储入度为 0 的结点</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indeg[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//visited 记录已经取下的结点个数</span></span><br><span class="line">        <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="comment">//取下一个入度为 0 的结点</span></span><br><span class="line">            <span class="keyword">int</span> u = queue.poll();</span><br><span class="line">            <span class="comment">//将该结点所指向的结点的入度减一</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v : edges.get(u))&#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">//将入度为 0 的结点加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(indeg[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能取下所有结点则存在拓扑排序</span></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(n+m)，其中 n 为课程数，m 为先修课程的要求数。空间复杂度 O(n+m)。</p><p><strong>方法二：DFS</strong></p><p>我们也可以使用深度优先搜索来找到拓扑排序，我们使用一个栈来存储拓扑排序。对于任意一个结点，我们首先访问该结点，继续访问该结点指向的结点，一直递归地进行这个操作，直到当前访问的结点出度为 0 ，就开始递归返回，在返回的过程中将结点加入栈中。对所有未搜索过的结点进行深度优先搜索，最后得到的栈中，从栈顶到栈底就是拓扑排序。</p><p>对于图中的任意结点有三个状态：</p><ul><li>未搜索，还没有搜索到这个结点；</li><li>搜索中，已经搜索过这个结点，还未回溯到该结点，此时这个结点还没有入栈；</li><li>已完成，已经搜索过这个结点，已经将该结点入栈。</li></ul><p>每一轮深度优先搜索开始时，我们选择一个未搜索过的结点。</p><p>算法流程：</p><ul><li><p>将当前搜索的结点 u 标记为搜索中，遍历该结点所指向的每一个结点 v</p><ul><li>如果 v 为 未搜索 ，那么开始搜索 v，等待回溯到 u；</li><li>如果 v 为搜索中，那么图中存在一个环，不存在拓扑序列；</li><li>如果 v 为已完成，v 已经在栈中，u 还不在栈中，满足栈中 u 在 v 的上方，不用操作。</li></ul></li><li><p>当 u 所指向的所有结点都为 已完成 时，将 u 放入栈中，将其标为 已完成。</p></li></ul><p>由于我们不需要拓扑序列，只用判断它是否存在，我们只用一个布尔值来代替栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//visited[i] 为结点 i 的状态，0 代表未搜索，1 代表搜索中，2 代表已完成</span></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            edges.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//拓扑序列存在时搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++)&#123;</span><br><span class="line">            <span class="comment">//不断选取未搜索的结点进行 DFS</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将当前结点 u 状态改为 搜索中</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//选取 u 所指向的结点进行 DFS</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : edges.get(u))&#123;</span><br><span class="line">            <span class="comment">//u 指向的结点 v 未搜索过，递归地搜索</span></span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="comment">//搜索过程中出现环，返回</span></span><br><span class="line">                <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visited[v] == <span class="number">1</span>)&#123;<span class="comment">//存在环，将 valid 设为false，返回</span></span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将结点 u 设为已完成状态</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(n+m)，其中 n 为课程数，m 为先修课程的要求数。空间复杂度 O(n+m)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;207-课程表&quot;&gt;&lt;a href=&quot;#207-课程表&quot; class=&quot;headerlink&quot; title=&quot;207. 课程表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/course-schedule/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;207. 课程表&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;你这个学期必须选修 &lt;code&gt;numCourse&lt;/code&gt; 门课程，记为 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;numCourse-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：&lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://hoo334.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>字符串相加</title>
    <link href="https://hoo334.github.io/2020/08/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"/>
    <id>https://hoo334.github.io/2020/08/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</id>
    <published>2020-08-03T01:29:14.000Z</published>
    <updated>2020-08-03T01:33:57.938Z</updated>
    
    <content type="html"><![CDATA[<h4 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></h4><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p><a id="more"></a><p><strong>注意：</strong></p><ol><li><code>num1</code> 和<code>num2</code> 的长度都小于 5100.</li><li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code>.</li><li><code>num1</code> 和<code>num2</code> 都不包含任何前导零。</li><li><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</strong></li></ol><p>使用两个指针从字符串尾部开始依次相加，同时维护进位位。使用 StringBuffer 存储，最后再将结果翻转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num = x + y + carry;</span><br><span class="line">            carry = num / <span class="number">10</span>;</span><br><span class="line">            sb.append(num % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(max(len1, len2))，len1 和 len2 为两个字符串的长度。</p><p>空间复杂度O(1)，除了存储答案的空间，只使用了O(1)的空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;415-字符串相加&quot;&gt;&lt;a href=&quot;#415-字符串相加&quot; class=&quot;headerlink&quot; title=&quot;415. 字符串相加&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;415. 字符串相加&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定两个字符串形式的非负整数 &lt;code&gt;num1&lt;/code&gt; 和&lt;code&gt;num2&lt;/code&gt; ，计算它们的和。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第200场周赛</title>
    <link href="https://hoo334.github.io/2020/08/02/Leetcode%E7%AC%AC200%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <id>https://hoo334.github.io/2020/08/02/Leetcode%E7%AC%AC200%E5%9C%BA%E5%91%A8%E8%B5%9B/</id>
    <published>2020-08-02T04:38:40.000Z</published>
    <updated>2020-08-02T06:44:35.198Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>第一次参加周赛，AC 两道暴力题，重在参与，哈哈哈。</p><a id="more"></a><h4 id="5475-统计好三元组-Easy"><a href="#5475-统计好三元组-Easy" class="headerlink" title="5475. 统计好三元组(Easy)"></a><a href="https://leetcode-cn.com/problems/count-good-triplets/" target="_blank" rel="noopener">5475. 统计好三元组(Easy)</a></h4><p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。</p><p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p><ul><li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li><li><code>|arr[i] - arr[j]| &lt;= a</code></li><li><code>|arr[j] - arr[k]| &lt;= b</code></li><li><code>|arr[i] - arr[k]| &lt;= c</code></li></ul><p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。</p><p>返回 <strong>好三元组的数量</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [3,0,1,1,9,7], a &#x3D; 7, b &#x3D; 2, c &#x3D; 3</span><br><span class="line">输出：4</span><br><span class="line">解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,1,2,2,3], a &#x3D; 0, b &#x3D; 0, c &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在满足所有条件的三元组。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>3 &lt;= arr.length &lt;= 100</code></li><li><code>0 &lt;= arr[i] &lt;= 1000</code></li><li><code>0 &lt;= a, b, c &lt;= 1000</code></li></ul><p>我们直接使用暴力法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Math.abs(arr[i] - arr[j]) &lt;= a &amp;&amp; Math.abs(arr[j] - arr[k]) &lt;= b &amp;&amp; Math.abs(arr[i] - arr[k]) &lt;= c)&#123;</span><br><span class="line">                        ++ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^3)，空间复杂度O(1)。</p><h4 id="5476-找出数组游戏的赢家-Medium"><a href="#5476-找出数组游戏的赢家-Medium" class="headerlink" title="5476. 找出数组游戏的赢家(Medium)"></a><a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/" target="_blank" rel="noopener">5476. 找出数组游戏的赢家(Medium)</a></h4><p>给你一个由 <strong>不同</strong> 整数组成的整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p><p>每回合游戏都在数组的前两个元素（即 <code>arr[0]</code> 和 <code>arr[1]</code> ）之间进行。比较 <code>arr[0]</code> 与 <code>arr[1]</code> 的大小，较大的整数将会取得这一回合的胜利并保留在位置 <code>0</code> ，较小的整数移至数组的末尾。当一个整数赢得 <code>k</code> 个连续回合时，游戏结束，该整数就是比赛的 <strong>赢家</strong> 。</p><p>返回赢得比赛的整数。</p><p>题目数据 <strong>保证</strong> 游戏存在赢家。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [2,1,3,5,4,6,7], k &#x3D; 2</span><br><span class="line">输出：5</span><br><span class="line">解释：一起看一下本场游戏每回合的情况(下图)：</span><br><span class="line">因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/q-example.png" alt="q-example"></p><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 10</span><br><span class="line">输出：3</span><br><span class="line">解释：3 将会在前 10 个回合中连续获胜。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,9,8,2,3,7,6,4,5], k &#x3D; 7</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,11,22,33,44,55,66,77,88,99], k &#x3D; 1000000000</span><br><span class="line">输出：99</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>2 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^6</code></li><li><code>arr</code> 所含的整数 <strong>各不相同</strong> 。</li><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><p><strong>方法一：链表</strong></p><p>需要频繁在数组头部和尾部进行增删，我首先想到链表。我们使用链表来模拟这个游戏规则。当 k 大于数组的长度时，我们直接返回数组中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// k 大于数组长度，直接返回数组中的最大值</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; arr.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x : arr)&#123;</span><br><span class="line">                ans = Math.max(ans, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数组转换为链表</span></span><br><span class="line">        List&lt;Integer&gt; arrList = Arrays.stream(arr).boxed().collect(Collectors.toList());</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(arrList);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//模拟游戏</span></span><br><span class="line">        <span class="keyword">while</span>(count &lt; k)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = list.get(<span class="number">0</span>), second = list.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(first &gt; second)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">                list.addLast(second);</span><br><span class="line">                list.remove(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = <span class="number">1</span>;<span class="comment">//删除第一个结点时，count 初始化为 1</span></span><br><span class="line">                list.addLast(first);</span><br><span class="line">                list.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链表中第一个元素为结果</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，n 为数组的长度。空间复杂度O(n)，n 为数组的长度。</p><p><strong>方法二：滑动窗口</strong></p><p>如果可以修改数组，我们可以只用一次遍历得到答案。我们每次比较两个数，两者中较小的数绝对不可能成为结果，我们将其修改为较大的值，窗口向后移动，再次比较，同时记录获胜的次数，如果次数等于 k 直接返回。   </p><p>思路来自<a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/solution/shuang-bai-by-huth/" target="_blank" rel="noopener">Huth</a>。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802131627474.png" alt="image-20200802131627474"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>, n = arr.length;</span><br><span class="line">        <span class="keyword">while</span>(t &lt; k &amp;&amp; i &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">                arr[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">                t++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，n 为数组的长度。空间复杂度O(1)。</p><h4 id="5477-排布二进制网格的最少交换次数-Medium"><a href="#5477-排布二进制网格的最少交换次数-Medium" class="headerlink" title="5477. 排布二进制网格的最少交换次数(Medium)"></a><a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/" target="_blank" rel="noopener">5477. 排布二进制网格的最少交换次数(Medium)</a></h4><p>给你一个 <code>n x n</code> 的二进制网格 <code>grid</code>，每一次操作中，你可以选择网格的 <strong>相邻两行</strong> 进行交换。</p><p>一个符合要求的网格需要满足主对角线以上的格子全部都是 <strong>0</strong> 。</p><p>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 <strong>-1</strong> 。</p><p>主对角线指的是从 <code>(1, 1)</code> 到 <code>(n, n)</code> 的这些格子。</p><p> <strong>示例 1：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802132108822.png" alt="image-20200802132108822"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [[0,0,1],[1,1,0],[1,0,0]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802132126421.png" alt="image-20200802132126421"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：所有行都是一样的，交换相邻行无法使网格符合要求。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802132246790.png" alt="image-20200802132246790"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,0,0],[1,1,0],[1,1,1]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>grid[i][j]</code> 要么是 <code>0</code> 要么是 <code>1</code> 。</li></ul><p>自己的想法：首先求出每行右侧连续的 0 的个数，使用冒泡排序，将最大值放最上面，将最小值放下面，这不是最佳答案。。。就没想出来。</p><p>贪心思路：</p><p>从第一行开始，如果该行的后缀 0 满足要求，那么直接跳过进入下一行（因为需要的后缀 0  个数都是从大到小的顺序，所以不必担心前一行使用后一行的后缀 0 个数）。</p><p>如果该行的后缀 0 个数不满足条件，那么就往下遍历找到<strong>最先（贪心，这是最小次数）</strong>满足条件的行，一行一行交换上来，记录交换的次数</p><p>如果找不到满足条件的后缀 0 ，那么返回 - 1。</p><p>贪心思路来自<a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/solution/c-tan-xin-hou-zhui-0-by-spacex-1/" target="_blank" rel="noopener">spaceX</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length;</span><br><span class="line">        <span class="keyword">int</span>[] zero = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">//统计每一行的后缀 0 个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            zero[i] = count;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//记录交换的次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从第一行开始判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(zero[i] &gt;= n - i - <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//条件满足</span></span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//条件不满足</span></span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="comment">//尝试找满足条件的后缀 0 个数</span></span><br><span class="line">                <span class="keyword">for</span>(; j &lt; n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(zero[j] &gt;= n - i - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//未找到</span></span><br><span class="line">                <span class="keyword">if</span>(j == n) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//将找到的后缀 0 个数一直交换上来</span></span><br><span class="line">                <span class="keyword">for</span>(; j &gt; i; j--)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = zero[j];</span><br><span class="line">                    zero[j] = zero[j - <span class="number">1</span>];</span><br><span class="line">                    zero[j - <span class="number">1</span>] = temp;</span><br><span class="line">                    <span class="comment">//增加交换次数</span></span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，n 为数组的长度。空间复杂度O(n)。</p><h4 id="5478-最大得分-Hard"><a href="#5478-最大得分-Hard" class="headerlink" title="5478. 最大得分(Hard)"></a><a href="https://leetcode-cn.com/problems/get-the-maximum-score/" target="_blank" rel="noopener">5478. 最大得分(Hard)</a></h4><p>你有两个 <strong>有序</strong> 且数组内元素互不相同的数组 <code>nums1</code> 和 <code>nums2</code> 。</p><p>一条 <strong>合法路径</strong> 定义如下：</p><ul><li>选择数组 nums1 或者 nums2 开始遍历（从下标 0 处开始）。</li><li>从左到右遍历当前数组。</li><li>如果你遇到了 <code>nums1</code> 和 <code>nums2</code> 中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。</li></ul><p>得分定义为合法路径中不同数字的和。</p><p>请你返回所有可能合法路径中的最大得分。</p><p>由于答案可能很大，请你将它对 10^9 + 7 取余后返回。</p><p> <strong>示例 1：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802140803920.png" alt="image-20200802140803920"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [2,4,5,8,10], nums2 &#x3D; [4,6,8,9]</span><br><span class="line">输出：30</span><br><span class="line">解释：合法路径包括：</span><br><span class="line">[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],（从 nums1 开始遍历）</span><br><span class="line">[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]  （从 nums2 开始遍历）</span><br><span class="line">最大得分为上图中的绿色路径 [2,4,6,8,10] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,3,5,7,9], nums2 &#x3D; [3,5,100]</span><br><span class="line">输出：109</span><br><span class="line">解释：最大得分由路径 [1,3,5,100] 得到。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2,3,4,5], nums2 &#x3D; [6,7,8,9,10]</span><br><span class="line">输出：40</span><br><span class="line">解释：nums1 和 nums2 之间无相同数字。</span><br><span class="line">最大得分由路径 [6,7,8,9,10] 得到。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,4,5,8,9,11,19], nums2 &#x3D; [2,3,4,11,12]</span><br><span class="line">输出：61</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length &lt;= 10^5</code></li><li><code>1 &lt;= nums2.length &lt;= 10^5</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^7</code></li><li><code>nums1</code> 和 <code>nums2</code> 都是严格递增的数组。</li></ul><p>自己的想法：可以把两个数组看成一个数，从两个根节点开始求路径的最大长度。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802144100427.png" alt="image-20200802144100427"></p><p>尝试构建这个二叉树，花费的时间太多，正确的方法应该是使用两个指针来模拟这个过程。</p><p>别人的思路：</p><p>相交的点将两个数组分成(k + 1)段，取每一段的较大值计入结果，使用双指针实现。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802143441663.png" alt="image-20200802143441663"></p><p>思路来自<a href="https://leetcode-cn.com/problems/get-the-maximum-score/solution/cshuang-zhi-zhen-fen-duan-tong-ji-zui-da-he-xiang-/" target="_blank" rel="noopener">LeonDeng</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//nums1 和 nums2 当前计算的段的大小</span></span><br><span class="line">        <span class="keyword">long</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//指针</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="comment">//有相同的点，当前段结束</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</span><br><span class="line">                res += (Math.max(sum1, sum2) + nums1[i]);</span><br><span class="line">                <span class="comment">//重置段长</span></span><br><span class="line">                sum1 = <span class="number">0</span>;</span><br><span class="line">                sum2 = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                <span class="comment">//必须先将较小值的指针向后移，先将较大的后移可能会错过相同点</span></span><br><span class="line">                sum1 += nums1[i++];<span class="comment">//将长度添加到段长内</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum2 += nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//增加剩下的段长</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length)&#123;</span><br><span class="line">            sum1 += nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length)&#123;</span><br><span class="line">            sum2 += nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//取两个段长最长加入到结果</span></span><br><span class="line">        res += Math.max(sum1, sum2);</span><br><span class="line">        <span class="comment">//结果取余</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(res % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(max(m,n))，m 和 n 为两个数组的长度。空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;第一次参加周赛，AC 两道暴力题，重在参与，哈哈哈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="https://hoo334.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="双指针" scheme="https://hoo334.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="滑动窗口" scheme="https://hoo334.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
      <category term="贪心" scheme="https://hoo334.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>二叉树展开为链表</title>
    <link href="https://hoo334.github.io/2020/08/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <id>https://hoo334.github.io/2020/08/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</id>
    <published>2020-08-02T01:14:56.000Z</published>
    <updated>2020-08-02T01:54:08.946Z</updated>
    
    <content type="html"><![CDATA[<h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></h4><p>给定一个二叉树，<a href="https://baike.baidu.com/item/原地算法/8010757" target="_blank" rel="noopener">原地</a>将它展开为一个单链表。</p> <a id="more"></a><p>例如，给定二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure><p>将其展开为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure><p><strong>方法一：前序遍历</strong></p><p>将二叉树展开为单链表后，我们发现链表中元素的顺序和二叉树的先序遍历结果相同， 在二叉树先序遍历时，我们使用一个数组存储遍历到的结点，最后将数组中相邻元素连接起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        preorderTraversal(root, list);</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)&#123;</span><br><span class="line">            TreeNode prev = list.get(i - <span class="number">1</span>);</span><br><span class="line">            TreeNode cur = list.get(i);</span><br><span class="line">            <span class="comment">//左结点置空</span></span><br><span class="line">            prev.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//右结点连接下一个结点</span></span><br><span class="line">            prev.right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">            preorderTraversal(root.left, list);</span><br><span class="line">            preorderTraversal(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，每个结点访问两次。空间复杂度O(n)，数组中存储 n 个结点。</p><p><strong>方法二：递归</strong></p><p>我们知道前序遍历的顺序为“根 - 左 - 右”，我们反过来先将右子树变为链表，再将左子数变为链表，再将左子树链表的末尾连接上右子树链表的头部，最后将根节点右结点连接到左子树链表头部，将根节点左结点置空。</p><p>我们使用一个全局变量 last 来保存已经生成的链表的头部，从链表尾部到头部，递归地生成链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode last = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先将右子树转换为链表</span></span><br><span class="line">        flatten(root.right);</span><br><span class="line">        <span class="comment">//再将左子树转换为链表(尾部已经连接上了右子树的头部)</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        <span class="comment">//根节点右子树指向链表头部</span></span><br><span class="line">        root.right = last;</span><br><span class="line">        <span class="comment">//根节点左子树置空</span></span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//更新链表头部</span></span><br><span class="line">        last = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)。</p><p><strong>方法三：寻找前驱结点</strong></p><p>我们可以发现前序遍历中，左子树的最右结点下一个结点就为右结点，我们可以将右子树作为左子树前序遍历最后一个结点的右子树，这样就可以保持前序遍历不变。然后再将左子树变成右子树，左子树置空。我们对二叉树中所有结点做这样一个操作，就可以将二叉树变成链表。</p><p>以示例为例</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802095151550.png" alt="image-20200802095151550"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802095239234.png" alt="image-20200802095239234"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="comment">//对链表中的每个结点进行变换操作</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前结点有左子树，需要变换</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//得到左子树的最右结点</span></span><br><span class="line">                TreeNode leftLast = cur.left;</span><br><span class="line">                <span class="keyword">while</span>(leftLast.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    leftLast = leftLast.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将右子树连接到最右结点</span></span><br><span class="line">                leftLast.right = cur.right;</span><br><span class="line">                <span class="comment">//右子树变为左子树</span></span><br><span class="line">                cur.right = cur.left;</span><br><span class="line">                <span class="comment">//左子树置空</span></span><br><span class="line">                cur.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续转换链表中下一个结点</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;114-二叉树展开为链表&quot;&gt;&lt;a href=&quot;#114-二叉树展开为链表&quot; class=&quot;headerlink&quot; title=&quot;114. 二叉树展开为链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;114. 二叉树展开为链表&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二叉树，&lt;a href=&quot;https://baike.baidu.com/item/原地算法/8010757&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原地&lt;/a&gt;将它展开为一个单链表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>最小区间</title>
    <link href="https://hoo334.github.io/2020/08/01/%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/"/>
    <id>https://hoo334.github.io/2020/08/01/%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/</id>
    <published>2020-08-01T11:57:50.000Z</published>
    <updated>2020-08-01T12:22:28.605Z</updated>
    
    <content type="html"><![CDATA[<h4 id="632-最小区间"><a href="#632-最小区间" class="headerlink" title="632. 最小区间"></a><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener">632. 最小区间</a></h4><p>你有 <code>k</code> 个升序排列的整数数组。找到一个<strong>最小</strong>区间，使得 <code>k</code> 个列表中的每个列表至少有一个数包含在其中。</p><p>我们定义如果 <code>b-a &lt; d-c</code> 或者在 <code>b-a == d-c</code> 时 <code>a &lt; c</code>，则区间 [a,b] 比 [c,d] 小。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</span><br><span class="line">输出: [20,24]</span><br><span class="line">解释: </span><br><span class="line">列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。</span><br><span class="line">列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。</span><br><span class="line">列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>给定的列表可能包含重复元素，所以在这里升序表示 &gt;= 。</li><li>1 &lt;= <code>k</code> &lt;= 3500</li><li>-105 &lt;= <code>元素的值</code> &lt;= 105</li></ol><p><strong>方法一：堆</strong></p><p>给定 k 个列表，需要找到最小区间，使得每个列表都至少有一个数在该区间中。该问题可以转化为：从 k 个列表中各取一个数，使得这 k 个数中的最大值与最小值的差最小。</p><p>假设这 k 个数中的最小值是第 i 个列表中的 x，对于 任意 <code>j≠i</code>，设第 j 个列表中被选为 k 个数之一的数是 y，为了找到最小区间，y 应该取第 j 个列表中大于等于 x 的最小的数。</p><p>使用最小堆维护 k 个指针指向的元素中的最小值，同时维护堆中元素的最大值。初始时，k个指针都指向下标 0 ，最大元素即为所有列表中下标为 0 位置的元素中的最大值。每次从堆中取出最小值（<strong>尝试将最小值扩大来获得更小的区间</strong>），根据最大值和最小值计算区间，如果当前区间小于最小区间，则更新最小区间，然后将对应列表的指针右移，将新元素加入堆中，并更新堆中元素的最大值。</p><p>如果一个列表遍历到末尾，则堆中不会再有该列表的元素，退出循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> rangeLeft = <span class="number">0</span>, rangeRight = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minRange = rangeRight - rangeLeft;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="comment">//存储每个列表的指针</span></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="comment">//小根堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer index1, Integer index2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums.get(index1).get(next[index1]) - nums.get(index2).get(next[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//将每个列表第一个元素指针加入最小堆，并维护这些指针指向的元素的最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            priorityQueue.offer(i);</span><br><span class="line">            max = Math.max(max, nums.get(i).get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//从堆中取出最小值的指针</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = priorityQueue.poll();</span><br><span class="line">            <span class="comment">//根据最大值和最小值计算当前区间</span></span><br><span class="line">            <span class="keyword">int</span> curRange = max - nums.get(minIndex).get(next[minIndex]);</span><br><span class="line">            <span class="comment">//如果当前区间小于最小区间</span></span><br><span class="line">            <span class="keyword">if</span>(curRange &lt; minRange)&#123;</span><br><span class="line">                minRange = curRange;</span><br><span class="line">                rangeLeft = nums.get(minIndex).get(next[minIndex]);</span><br><span class="line">                rangeRight = max;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指针右移</span></span><br><span class="line">            next[minIndex]++;</span><br><span class="line">            <span class="comment">//如果某个列表的指针遍历到末尾，堆中不会有该列表的元素退出循环</span></span><br><span class="line">            <span class="keyword">if</span>(next[minIndex] == nums.get(minIndex).size())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将新元素加入堆中</span></span><br><span class="line">            priorityQueue.offer(minIndex);</span><br><span class="line">            <span class="comment">//更新堆中的最大值</span></span><br><span class="line">            max = Math.max(max, nums.get(minIndex).get(next[minIndex]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;rangeLeft, rangeRight&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n k log k)，n 是所有列表的平均长度，k是列表数量。所有指针移动次数为 nk，操作堆的时间复杂度为O(logk)。</p><p>空间复杂度O(k)，堆中维护 k 个元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;632-最小区间&quot;&gt;&lt;a href=&quot;#632-最小区间&quot; class=&quot;headerlink&quot; title=&quot;632. 最小区间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;632. 最小区间&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;你有 &lt;code&gt;k&lt;/code&gt; 个升序排列的整数数组。找到一个&lt;strong&gt;最小&lt;/strong&gt;区间，使得 &lt;code&gt;k&lt;/code&gt; 个列表中的每个列表至少有一个数包含在其中。&lt;/p&gt;
&lt;p&gt;我们定义如果 &lt;code&gt;b-a &amp;lt; d-c&lt;/code&gt; 或者在 &lt;code&gt;b-a == d-c&lt;/code&gt; 时 &lt;code&gt;a &amp;lt; c&lt;/code&gt;，则区间 [a,b] 比 [c,d] 小。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="堆" scheme="https://hoo334.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>魔术索引</title>
    <link href="https://hoo334.github.io/2020/07/31/%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/"/>
    <id>https://hoo334.github.io/2020/07/31/%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/</id>
    <published>2020-07-31T01:33:39.000Z</published>
    <updated>2020-07-31T01:49:31.684Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题-08-03-魔术索引"><a href="#面试题-08-03-魔术索引" class="headerlink" title="面试题 08.03. 魔术索引"></a><a href="https://leetcode-cn.com/problems/magic-index-lcci/" target="_blank" rel="noopener">面试题 08.03. 魔术索引</a></h4><p>魔术索引。 在数组<code>A[0...n-1]</code>中，有所谓的魔术索引，满足条件<code>A[i] = i</code>。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。</p><a id="more"></a><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0, 2, 3, 4, 5]</span><br><span class="line">输出：0</span><br><span class="line">说明: 0下标的元素为0</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1, 1, 1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li>nums长度在[1, 1000000]之间</li></ol><p>我们直接遍历一次数组即可求出最小的索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p><p>但给的是有序数组，我们可以进行一点优化。</p><p>以示例二为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">元素：1  1  1</span><br><span class="line">下标：0  1  2</span><br><span class="line">     ^</span><br><span class="line">     i</span><br></pre></td></tr></table></figure><p>当 i = 0 时，我们有 nums[0] &gt; 0，i 不是最小索引。由于数组递增，nums[0] 之后的元素都大于等于 nums[0]，下标小于 nums[0] 的元素中不存在最小索引，否则数组就不满足递增关系。</p><p>当我们遍历到第 i 个元素时，如果<code>nums[i] &gt; i</code>，由于数组的递增关系，<code>[0, nums[i])</code>范围内的元素不可能为最小索引，直接令<code>i = nums[i]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[flag] == flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> flag;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[flag] &gt; flag)&#123;</span><br><span class="line">                flag = nums[flag]; <span class="comment">//去掉不需要比较的元素</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度最坏O(n)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;面试题-08-03-魔术索引&quot;&gt;&lt;a href=&quot;#面试题-08-03-魔术索引&quot; class=&quot;headerlink&quot; title=&quot;面试题 08.03. 魔术索引&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/magic-index-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题 08.03. 魔术索引&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;魔术索引。 在数组&lt;code&gt;A[0...n-1]&lt;/code&gt;中，有所谓的魔术索引，满足条件&lt;code&gt;A[i] = i&lt;/code&gt;。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>整数拆分</title>
    <link href="https://hoo334.github.io/2020/07/30/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/"/>
    <id>https://hoo334.github.io/2020/07/30/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</id>
    <published>2020-07-30T07:32:56.000Z</published>
    <updated>2020-07-30T07:53:41.198Z</updated>
    
    <content type="html"><![CDATA[<h4 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">343. 整数拆分</a></h4><p>给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 你可以假设 <em>n</em> 不小于 2 且不大于 58。</p><p><strong>方法一：动态规划</strong></p><p>对于任意正整数 n，我们至少可以将其拆分为两个正整数的和。令 k 是拆分出来的第一个正整数，剩下的部分是 n - k，n - k 可以选择「不拆分」和「继续拆分」，是否拆分取决于这两个选择哪一个的最大乘积最大。</p><p>创建 dp 数组，<code>dp[i]</code> 表示将正整数 i 拆分为至少两个正整数的和之后，这些正整数的最大乘积。0 和 1 都不能进行拆分 所以 <code>dp[0] = dp[1] = 0</code>。</p><p>当 <code>i &gt;= 2</code> 时，假设对正整数 i 拆分出的第一个正整数是 j (1 &lt;= j &lt; i)，有以下两种选择：</p><ul><li>i - j 不继续拆分，此时的乘积是 j * (i - j)</li><li>i - j 继续拆分，此时的乘积是 j * dp[i - j]</li></ul><p>我们取这两者的最大值，得到状态转移方程：<br>$$<br>dp[i] = \max_{1\leq j &lt;i}{j \times max((i - j), dp[i - j])}<br>$$<br>最终结果为 <code>dp[n]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                x = Math.max(x, j * Math.max(dp[i - j], i - j));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(n)。</p><p><strong>方法二：数学</strong></p><p>将 n 拆分成最多的 3 和 2，但是不能出现 1。</p><p>例如当 n = 10 时，最多的 3 的拆分方法为 3331，但是由于 1 对结果没有贡献，将最后的 31 改成 2*2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;=<span class="number">3</span> )<span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, x);</span><br><span class="line">        <span class="comment">//如果最后的余数为 1 ，代表存在 3*1这种情况，要改为 2*2</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, x-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line"><span class="comment">//余数为 2 </span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,x)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;343-整数拆分&quot;&gt;&lt;a href=&quot;#343-整数拆分&quot; class=&quot;headerlink&quot; title=&quot;343. 整数拆分&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/integer-break/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;343. 整数拆分&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个正整数 &lt;em&gt;n&lt;/em&gt;，将其拆分为&lt;strong&gt;至少&lt;/strong&gt;两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数学" scheme="https://hoo334.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>平方数之和</title>
    <link href="https://hoo334.github.io/2020/07/29/%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://hoo334.github.io/2020/07/29/%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-07-29T02:51:24.000Z</published>
    <updated>2020-07-29T03:12:20.632Z</updated>
    
    <content type="html"><![CDATA[<h4 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633. 平方数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/" target="_blank" rel="noopener">633. 平方数之和</a></h4><p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 a^2 + b^2 = c。</p><a id="more"></a><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释: 1 * 1 + 2 * 2 &#x3D; 5</span><br></pre></td></tr></table></figure><p> <strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p>我们直接使用暴力法，这里使用了一点技巧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>; i * i &lt;= c; i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> b = Math.sqrt(c - i * i);</span><br><span class="line">            <span class="comment">//如果 b 为一个数的平方，代表找到</span></span><br><span class="line">            <span class="keyword">if</span>(b == (<span class="keyword">int</span>)b)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(√c)，空间复杂度O(1)。</p><p>最近做 DP 都快 PTSD 了，看到这题居然第一时间想到 DP，人傻了！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;633-平方数之和&quot;&gt;&lt;a href=&quot;#633-平方数之和&quot; class=&quot;headerlink&quot; title=&quot;633. 平方数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-square-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;633. 平方数之和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个非负整数 &lt;code&gt;c&lt;/code&gt; ，你要判断是否存在两个整数 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;，使得 a^2 + b^2 = c。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="数学" scheme="https://hoo334.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>在圆内随机生成点</title>
    <link href="https://hoo334.github.io/2020/07/28/%E5%9C%A8%E5%9C%86%E5%86%85%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%82%B9/"/>
    <id>https://hoo334.github.io/2020/07/28/%E5%9C%A8%E5%9C%86%E5%86%85%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%82%B9/</id>
    <published>2020-07-28T01:31:12.000Z</published>
    <updated>2020-07-28T02:18:28.892Z</updated>
    
    <content type="html"><![CDATA[<h4 id="478-在圆内随机生成点"><a href="#478-在圆内随机生成点" class="headerlink" title="478. 在圆内随机生成点"></a><a href="https://leetcode-cn.com/problems/generate-random-point-in-a-circle/" target="_blank" rel="noopener">478. 在圆内随机生成点</a></h4><p>给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 <code>randPoint</code> 。</p><p>说明:</p><ol><li>输入值和输出值都将是<a href="https://baike.baidu.com/item/浮点数/6162520" target="_blank" rel="noopener">浮点数</a>。</li><li>圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。</li><li>圆周上的点也认为是在圆中。</li><li><code>randPoint</code> 返回一个包含随机点的x坐标和y坐标的大小为2的数组。</li></ol><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[1,0,0],[],[],[]]</span><br><span class="line">输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[10,5,-7.5],[],[],[]]</span><br><span class="line">输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]</span><br></pre></td></tr></table></figure><p><strong>输入语法说明：</strong></p><p>输入是两个列表：调用成员函数名和调用的参数。<code>Solution</code> 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。<code>randPoint</code> 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。</p><p><strong>方法一：拒绝采样</strong></p><p>在矩形中随机生成一个点的方法：随机选取一个 0 ~ 1的浮点数，乘以矩形的边长。使用该方法生成随机点的横纵坐标。我们可以得到第一种在圆内生成随机点的方法，即在这个圆外画一个外接矩形，在矩形内生成随机点，拒绝掉那些落在圆外的点，得到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> xc, yc, rad;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center)</span> </span>&#123;</span><br><span class="line">        xc = x_center;</span><br><span class="line">        yc = y_center;</span><br><span class="line">        rad = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] randPoint() &#123;</span><br><span class="line">        <span class="comment">//获得坐标原点的坐标(矩形的一个角的坐标)</span></span><br><span class="line">        <span class="keyword">double</span> x0 = xc - rad;</span><br><span class="line">        <span class="keyword">double</span> y0 = yc - rad;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//在矩形中生成随机点(xr, yr)</span></span><br><span class="line">            <span class="keyword">double</span> xr = x0 + Math.random() * rad * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> yr = y0 + Math.random() * rad * <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//拒绝掉不在圆内的随机点</span></span><br><span class="line">            <span class="keyword">if</span>(Math.sqrt(Math.pow(xr - xc, <span class="number">2</span>) + Math.pow(yr - yc, <span class="number">2</span>)) &lt; rad)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;xr, yr&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment"> * double[] param_1 = obj.randPoint();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>期望时间复杂度O(1)，最坏的情况是一直被拒绝，时间复杂度为O(n)。</p><p>空间复杂度为O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;478-在圆内随机生成点&quot;&gt;&lt;a href=&quot;#478-在圆内随机生成点&quot; class=&quot;headerlink&quot; title=&quot;478. 在圆内随机生成点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/generate-random-point-in-a-circle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;478. 在圆内随机生成点&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 &lt;code&gt;randPoint&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入值和输出值都将是&lt;a href=&quot;https://baike.baidu.com/item/浮点数/6162520&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浮点数&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。&lt;/li&gt;
&lt;li&gt;圆周上的点也认为是在圆中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;randPoint&lt;/code&gt; 返回一个包含随机点的x坐标和y坐标的大小为2的数组。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="数学" scheme="https://hoo334.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的最大深度</title>
    <link href="https://hoo334.github.io/2020/07/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>https://hoo334.github.io/2020/07/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2020-07-28T01:22:07.000Z</published>
    <updated>2020-07-28T01:30:44.066Z</updated>
    
    <content type="html"><![CDATA[<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h4><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><a id="more"></a><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p><strong>方法一：递归</strong></p><p>当前树的最大深度为左右子树的最大深度加一，左右子树又以同样的方式进行计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根节点为空，返回 0</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//只有根节点，返回 1</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//返回左右子树最大深度加一</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，树中的每个结点被访问一次。</p><p>空间复杂度O(h)，h 为树的高度。</p><p><strong>方法二：层次遍历</strong></p><p>我们可以使用层次遍历来计算二叉树的深度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//队列中保存下一层的结点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//获得当前层数结点的个数</span></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="comment">//将当前层每一个结点的子节点入队</span></span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(t.right);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//当前层结点数减一</span></span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//二叉树层数加一</span></span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度最坏O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;104-二叉树的最大深度&quot;&gt;&lt;a href=&quot;#104-二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;104. 二叉树的最大深度&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;104. 二叉树的最大深度&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;
&lt;p&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 叶子节点是指没有子节点的节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>矩阵中的最长递增路径</title>
    <link href="https://hoo334.github.io/2020/07/26/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/"/>
    <id>https://hoo334.github.io/2020/07/26/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/</id>
    <published>2020-07-26T04:36:57.000Z</published>
    <updated>2020-07-26T04:55:52.608Z</updated>
    
    <content type="html"><![CDATA[<h4 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h4><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><p>将矩阵看成一个有向图，每个元素对应图中一个结点，如果两个相邻元素的值不相等，则存在一条从较小值到较大值的有向边，问题转化为在有向图中寻找最长路径。</p><p>从一个结点开始进行深度优先搜索，可以得到从该结点开始的最长递增路径，对矩阵中每个结点进行深度优先搜索后可得到最长递增路径的长度。</p><p>朴素深度优先搜索的问题是进行了大量的重复计算，同一个结点会被访问多次，每次都重新计算，由于同一个元素的最长递增路径是不变的，我们可以使用矩阵 memo 来存储已经计算过的结果。</p><p>使用记忆化深度优先搜索，当访问到一个元素<code>(i, j)</code>时，如果<code>memo[i][j] != 0</code>，说明该元素的结果已经计算过，直接返回结果；否则需要计算结果，并将其存入 memo 中。</p><p>我们维护一个最大值 max，当遍历完矩阵中所有的元素时即可得到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方向向量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> rows, cols;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rows = matrix.length;</span><br><span class="line">        cols = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对矩阵中每个元素进行 dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)&#123;</span><br><span class="line">                ans = Math.max(ans, dfs(matrix, i, j, memo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] memo)</span></span>&#123;</span><br><span class="line">        <span class="comment">//该结点已经计算过</span></span><br><span class="line">        <span class="keyword">if</span>(memo[row][col] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[row][col];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//递增路径长度为 1 </span></span><br><span class="line">        ++memo[row][col];</span><br><span class="line">        <span class="comment">//尝试从不同方向进行深搜</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> newRow = row + dir[<span class="number">0</span>], newCol = col + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//当前结点的值要小于相邻结点的值</span></span><br><span class="line">            <span class="keyword">if</span>(newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newCol &gt;= <span class="number">0</span> &amp;&amp; newCol &lt; cols &amp;&amp; matrix[newRow][newCol] &gt; matrix[row][col])&#123;</span><br><span class="line">                <span class="comment">//更新当前结点的最大递增路径</span></span><br><span class="line">                memo[row][col] = Math.max(memo[row][col], dfs(matrix, newRow, newCol, memo) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，其中 m 和 n 是矩阵的行数和列数。深度优先搜索的时间复杂度为O(V + E),其中 V 是结点书，E 是边数。在矩阵中 O(V) = O(mn)，O(E) 近似为 O(4mn)。</p><p>空间复杂度O(mn)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;329-矩阵中的最长递增路径&quot;&gt;&lt;a href=&quot;#329-矩阵中的最长递增路径&quot; class=&quot;headerlink&quot; title=&quot;329. 矩阵中的最长递增路径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;329. 矩阵中的最长递增路径&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数矩阵，找出最长递增路径的长度。&lt;/p&gt;
&lt;p&gt;对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>分割数组的最大值</title>
    <link href="https://hoo334.github.io/2020/07/25/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://hoo334.github.io/2020/07/25/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2020-07-25T01:53:39.000Z</published>
    <updated>2020-07-25T03:05:07.462Z</updated>
    
    <content type="html"><![CDATA[<h4 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></h4><p>给定一个非负整数数组和一个整数 <em>m</em>，你需要将这个数组分成 <em>m</em> 个非空的连续子数组。设计一个算法使得这 <em>m</em> 个子数组各自和的最大值最小。</p><a id="more"></a><p><strong>注意:</strong><br>数组长度 <em>n</em> 满足以下条件:</p><ul><li>1 ≤ <em>n</em> ≤ 1000</li><li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums &#x3D; [7,2,5,10,8]</span><br><span class="line">m &#x3D; 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure><p><strong>方法一：暴力（超时）</strong></p><p>我们要将 nums[0 … n - 1] 分为 m 个非空的子数组，我们可以先将 nums 数组分为 [0 … i)，[i … n  -1]两个数组(1 &lt; i &lt;= n - 1)，再计算 nums[i … n - 1] 分成 m - 1个子数组各自和的最大值最小，可以看出这是一个递归操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//利用前缀和数组进行优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            count[i] = count[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// num 数组最多分成 n 个子数组</span></span><br><span class="line">        <span class="keyword">return</span> split(count, m &gt; n ? n : m - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span>[] count, <span class="keyword">int</span> m, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否还需要切分，否则返回[start, end]范围内的元素之和</span></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> count[end + <span class="number">1</span>] - count[start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//枚举每一个切分位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end &amp;&amp; m &gt; <span class="number">0</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//递归地计算[i, end]分割为 m - 1个子数组的最大值的最小值</span></span><br><span class="line">            <span class="keyword">int</span> right = split(count, m - <span class="number">1</span>, i, end);</span><br><span class="line">            <span class="comment">//维护最小值</span></span><br><span class="line">            min = Math.min(min, Math.max(count[i] - count[start], right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^m)，空间复杂度O(n)。爆炸！！！</p><p><strong>方法二：动态规划</strong></p><p>令<code>f[i][j]</code>表示将数组的前 i 个数分割为 j 段所能得到的最大连续子数组和的最小值。我们枚举第 j 段的具体范围，我们可以枚举 k，其中前 k 个数被分割为 j - 1 段，而第 k + 1到第 i 个数为第 j 段。此时，这 j 段子数组中和的最大值就等于 <code>f[k][j - 1]</code>和<code>sub(k + 1, i)</code>中的较大值，其中<code>sub(i, j)</code>表示数组 nums 中下标落在区间[i, j]内的数的和。得到状态转移方程：<br>$$<br>f[i, j] = \min^{i-1}_{k=0}{max(f[k][j - 1],sub(k + 1, i))}<br>$$<br>i 个数最多只能分成 i 段，因此 i &gt;= j 是合法状态，对于不合法的状态(j &gt; i)，由于我们求的是最小值，我们将其初始化为一个很大的值，当我们尝试从不合法的状态转移，得到的结果将是一个很大的数。</p><p>我们还需要初始化<code>f[0][0] = 0</code>，最后的结果为 <code>f[n][m]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//将 dp 数组全部设为最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//生成前缀和数组</span></span><br><span class="line">        <span class="keyword">int</span>[] sub = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sub[i + <span class="number">1</span>] = sub[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//初始状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从前往后依次计算 dp 数组的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//j &lt;= i</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Math.min(i, m); j++)&#123;</span><br><span class="line">                <span class="comment">//枚举最后一个子数组的切割点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k][j - <span class="number">1</span>], sub[i] - sub[k]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(m*n^2)，n 为数组的长度，m 为非空连续子数组的个数。</p><p>空间复杂度O(n * m)。</p><p><strong>方法三：二分查找</strong></p><p>本题中，我们注意到：当我们选定一个值 x，我们可以线性地验证是否存在一种分割方案，满足其最大分割子数组和不超过 x。策略如下：</p><blockquote><p>贪心地模拟分割的过程，从前到后遍历数组，用 sum 表示当前分割子数组的和，cnt 表示已经分割出的子数组的数量(包括当前子数组)，那么每当 sum 加上当前值超过了 x，我们就把当前取的值作为<strong>新的一段</strong>分割子数组的开头，并将分割出的子数组的数量 cnt 加一。遍历结束后验证是否 cnt 不超过 m。</p></blockquote><p>我们可以使用二分查找来解决。二分的上界为数组 nums 中所有元素的和，下界为 nums 中所有元素的最大值。通过二分查找，我们可以得到最小的最大分割子数组和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 初始化二分查找上下界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(left &lt; nums[i])&#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(nums, mid, m))&#123;</span><br><span class="line">                right = mid; <span class="comment">//存在最大分割子数组的和小于 x，将 x 缩小</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//不存在最大分割子数组的和小于 x，将 x 增大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//检查是否存在最大分割子数组的和 小于 x</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// sum 值大于 x，将当前值作为新的分割子数组的开头</span></span><br><span class="line">            <span class="keyword">if</span>(sum + nums[i] &gt; x)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n * log(sum - maxn))，sum 表示数组 nums 中所有元素的和，maxn表示数组所有元素的最大值，每次二分查找时，需要对数组进行一次遍历。</p><p>空间复杂度O(1)。妙啊！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;410-分割数组的最大值&quot;&gt;&lt;a href=&quot;#410-分割数组的最大值&quot; class=&quot;headerlink&quot; title=&quot;410. 分割数组的最大值&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/split-array-largest-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;410. 分割数组的最大值&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个非负整数数组和一个整数 &lt;em&gt;m&lt;/em&gt;，你需要将这个数组分成 &lt;em&gt;m&lt;/em&gt; 个非空的连续子数组。设计一个算法使得这 &lt;em&gt;m&lt;/em&gt; 个子数组各自和的最大值最小。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="贪心" scheme="https://hoo334.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>除数博弈</title>
    <link href="https://hoo334.github.io/2020/07/24/%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/"/>
    <id>https://hoo334.github.io/2020/07/24/%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/</id>
    <published>2020-07-24T02:28:39.000Z</published>
    <updated>2020-07-24T02:52:20.471Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1025-除数博弈"><a href="#1025-除数博弈" class="headerlink" title="1025. 除数博弈"></a><a href="https://leetcode-cn.com/problems/divisor-game/" target="_blank" rel="noopener">1025. 除数博弈</a></h4><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p><p>最初，黑板上有一个数字 <code>N</code> 。在每个玩家的回合，玩家需要执行以下操作：</p><ul><li>选出任一 <code>x</code>，满足 <code>0 &lt; x &lt; N</code> 且 <code>N % x == 0</code> 。</li><li>用 <code>N - x</code> 替换黑板上的数字 <code>N</code> 。</li></ul><p>如果玩家无法执行这些操作，就会输掉游戏。</p><p>只有在爱丽丝在游戏中取得胜利时才返回 <code>True</code>，否则返回 <code>false</code>。假设两个玩家都以最佳状态参与游戏。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li><code>1 &lt;= N &lt;= 1000</code></li></ol><p>我们尝试写几项：</p><ul><li><p>N = 1，区间(0, 1)中没有整数是 n 的因数，所以 Alice 败。</p></li><li><p>N = 2，Alice 选择 1，N 变为 1，Bob 不能继续操作，Alice 胜。</p></li><li><p>N = 3，Alice 选择 1，N 变为 2，根据 N = 2的结论，Bob 胜，Alice 败。</p></li><li><p>N = 4，Alice 可选择 1 或 2，当 Alice 选择 2 时 根据 N = 2的结论 ，Alice 败，Alice 选择 1 时，根据 N = 3 的结论，Alice 胜。</p></li><li><p>N = 5 ，Alice 选择 1 ，根据 N = 4 的结论，Alice 败。 </p></li></ul><p>我们定义 <code>f[i]</code> 表示当数字为 i 时，先手处于必胜态还是必败态，true 代表先手胜，false 代表先手败。当 N = i 时，Alice 在 <code>(0, i)</code>中选择一个因数 j ，使得<code>i % j == 0</code>，且 <code>f[i - j] = false</code>（Bob先手必败），那么 Alice 就可获胜。否则 Alice 败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[N + <span class="number">2</span>];</span><br><span class="line">        f[<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">        f[<span class="number">2</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i % j == <span class="number">0</span>) &amp;&amp; !f[i - j])&#123;</span><br><span class="line">                    f[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(n)。</p><p>看到前面几项的规律，我们猜测 N 为 奇数时 Alice（先手）必败，N 为偶数时，Alice 必胜。</p><p>证明：</p><ol><li>N = 1 和 N = 2 时结论成立。</li><li>N &gt; 2 时，假设 N &lt;= k 时该结论成立，则 N = k + 1 时：<ul><li>如果 k 为偶数，则 k + 1 为奇数，x 是 k + 1 的因数，只能为奇数，奇数减去奇数得到偶数，且 k + 1 - x &lt;= k，轮到 Bob 时都是偶数，根据假设，N &lt;= k时，偶数先手必胜，则 Bob 必胜，Alice 必败。</li><li>如果 k 为奇数，则 k + 1 为偶数，x 是 k + 1的因数，x 可为奇数和偶数，若 Alice 减去一个奇数，k + 1 - x 一定是个奇数，根据假设 Bob 必败，Alice 必胜。当 x 为偶数时，Alice 必败。故 Alice 选择 x 为奇数。</li></ul></li></ol><p>综上，猜想正确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (N &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1025-除数博弈&quot;&gt;&lt;a href=&quot;#1025-除数博弈&quot; class=&quot;headerlink&quot; title=&quot;1025. 除数博弈&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/divisor-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1025. 除数博弈&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。&lt;/p&gt;
&lt;p&gt;最初，黑板上有一个数字 &lt;code&gt;N&lt;/code&gt; 。在每个玩家的回合，玩家需要执行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选出任一 &lt;code&gt;x&lt;/code&gt;，满足 &lt;code&gt;0 &amp;lt; x &amp;lt; N&lt;/code&gt; 且 &lt;code&gt;N % x == 0&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;N - x&lt;/code&gt; 替换黑板上的数字 &lt;code&gt;N&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果玩家无法执行这些操作，就会输掉游戏。&lt;/p&gt;
&lt;p&gt;只有在爱丽丝在游戏中取得胜利时才返回 &lt;code&gt;True&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。假设两个玩家都以最佳状态参与游戏。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="数学" scheme="https://hoo334.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>最小路径和</title>
    <link href="https://hoo334.github.io/2020/07/23/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://hoo334.github.io/2020/07/23/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2020-07-23T01:46:59.000Z</published>
    <updated>2020-07-23T01:58:14.540Z</updated>
    
    <content type="html"><![CDATA[<h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h4><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p>我们创建二维 dp 数组，<code>dp[i][j]</code>表示从左上角出发到<code>(i, j)</code>位置的最小路径和。<code>dp[0][0]=grid[0][0]</code>。对于其他元素有以下方程：</p><ul><li>当 i = 0，j &gt; 0 时，<code>dp[0][j] = dp[0][j - 1] + grid[0][j]</code>；</li><li>当 j = 0，i &gt; 0 时，<code>dp[i][0] =  dp[i - 1][0] + grid[i][0]</code>；</li><li>当 j &gt; 0，i &gt; 0 时，<code>dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])</code>。</li></ul><p><code>dp[m - 1][n - 1]</code>即为从左上角到右下角的路径和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] cost = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"></span><br><span class="line">        cost[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;row; ++i)&#123;</span><br><span class="line">            cost[i][<span class="number">0</span>] = cost[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;col; ++i)&#123;</span><br><span class="line">            cost[<span class="number">0</span>][i] = cost[<span class="number">0</span>][i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;col; j++)&#123;</span><br><span class="line">                cost[i][j] = Math.min(cost[i-<span class="number">1</span>][j],cost[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。</p><p>我们可以使用滚动数组来优化空间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] cost = <span class="keyword">new</span> <span class="keyword">int</span>[col];</span><br><span class="line"></span><br><span class="line">        cost[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;col; ++i)&#123;</span><br><span class="line">            cost[i] = cost[i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left = j &gt; <span class="number">0</span> ? cost[j - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">                cost[j] = Math.min(cost[j],left)+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cost[col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;64-最小路径和&quot;&gt;&lt;a href=&quot;#64-最小路径和&quot; class=&quot;headerlink&quot; title=&quot;64. 最小路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-path-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;64. 最小路径和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个包含非负整数的 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;每次只能向下或者向右移动一步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>寻找旋转排序数组中的最小值II</title>
    <link href="https://hoo334.github.io/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/"/>
    <id>https://hoo334.github.io/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/</id>
    <published>2020-07-22T03:06:19.000Z</published>
    <updated>2020-07-22T06:28:16.842Z</updated>
    
    <content type="html"><![CDATA[<h4 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a> 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li></ul><p>我们得到的旋转数组类似于下图，由两段单调递增的序列构成，右边序列的最大值小于等于左边序列的最小值。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200722142620638.png" alt="image-20200722142620638"></p><p>在二分查找过程中，我们有以下几种情况：</p><ol><li><p>左值 &lt; 中值，中值 &lt; 右值，最小值在左边，[中，右]范围内的值不可能为最小值，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">右</span><br><span class="line">中</span><br><span class="line">左</span><br></pre></td></tr></table></figure></li><li><p>左值 &lt; 中值，中值 &gt; 右值，最小值在右边，[左，中]范围内的值不可能为最小值，可以收缩左边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中</span><br><span class="line">左</span><br><span class="line">右</span><br></pre></td></tr></table></figure></li><li><p>左值 &gt; 中值，中值 &lt; 右值，最小值在左边界，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左</span><br><span class="line">右</span><br><span class="line">中</span><br></pre></td></tr></table></figure></li><li><p>中值 = 右值，最小值在左边界，右值重复(中值有可能不重复，例如 [3, 1, 1]，分别为左中右，收缩右边界变为 [3, 1])，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">左</span><br><span class="line">中   右</span><br></pre></td></tr></table></figure></li></ol><p>情况 1，3是一类，情况 2 是一类，情况 4 是一类：</p><ul><li>如果中值 &lt; 右值，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</li><li>如果中值 &gt; 右值，[左，中]范围内的值不可能为最小值，可以收缩左边界。</li><li>如果中值 = 右值，右值重复，可以收缩右边界。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>; <span class="comment">//左闭右闭区间，用右开区间不方便判断右值</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;<span class="comment">// left == right 结束</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[r])&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>; <span class="comment">//中值 &gt; 右值，中值不可能为最小值，左边界跳过mid</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])&#123;</span><br><span class="line">                r = mid;<span class="comment">//中值 &lt; 右值，中值可能为最小值，右边界只能取到 mid</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == nums[r])&#123;</span><br><span class="line">                --r;<span class="comment">//中值 = 右值，右值重复，右边界左移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平均时间复杂度O(log n)，当数组中数字全部相等时，最坏时间复杂度O(n)。</p><p>空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;154-寻找旋转排序数组中的最小值-II&quot;&gt;&lt;a href=&quot;#154-寻找旋转排序数组中的最小值-II&quot; class=&quot;headerlink&quot; title=&quot;154. 寻找旋转排序数组中的最小值 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;154. 寻找旋转排序数组中的最小值 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。&lt;/p&gt;
&lt;p&gt;请找出其中最小的元素。&lt;/p&gt;
&lt;p&gt;注意数组中可能存在重复的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>寻找旋转排列数组中的最小值</title>
    <link href="https://hoo334.github.io/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>https://hoo334.github.io/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</id>
    <published>2020-07-22T02:05:01.000Z</published>
    <updated>2020-07-22T06:27:13.437Z</updated>
    
    <content type="html"><![CDATA[<h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>使用二分查找，需要始终保持目标值在搜索范围内，并不断缩小左右边界。</p><p>我们得到的旋转数组类似于下图，为两段单调递增的序列构成，且右边序列最大值小于左边序列最小值。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200722142442327.png" alt="image-20200722142442327"></p><p>在二分查找过程中，我们有以下几种情况：</p><ol><li><p>左值 &lt; 中值，中值 &lt; 右值，最小值在左边，[中，右]范围内的值不可能为最小值，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">右</span><br><span class="line">中</span><br><span class="line">左</span><br></pre></td></tr></table></figure></li><li><p>左值 &lt; 中值，中值 &gt; 右值，最小值在右边，[左，中]范围内的值不可能为最小值，可以收缩左边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中</span><br><span class="line">左</span><br><span class="line">右</span><br></pre></td></tr></table></figure></li><li><p>左值 &gt; 中值，中值 &lt; 右值，最小值在左边界，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左</span><br><span class="line">右</span><br><span class="line">中</span><br></pre></td></tr></table></figure></li></ol><p>情况 1，3 是一类，情况 2 是另一类：</p><ul><li>如果中值 &lt; 右值，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</li><li>如果中值 &gt; 右值，[左，中]范围内的值不可能为最小值，可以收缩左边界。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>; <span class="comment">//左闭右闭区间，用右开区间不方便判断右值</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;<span class="comment">// left == right 结束</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[r])&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>; <span class="comment">//中值 &gt; 右值，中值不可能为最小值，左边界跳过mid</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])&#123;</span><br><span class="line">                r = mid;<span class="comment">//中值 &lt; 右值，中值可能为最小值，右边界只能取到 mid</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(log n)，空间复杂度O(1)。</p><p>参考：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;153-寻找旋转排序数组中的最小值&quot;&gt;&lt;a href=&quot;#153-寻找旋转排序数组中的最小值&quot; class=&quot;headerlink&quot; title=&quot;153. 寻找旋转排序数组中的最小值&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;153. 寻找旋转排序数组中的最小值&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。&lt;/p&gt;
&lt;p&gt;请找出其中最小的元素。&lt;/p&gt;
&lt;p&gt;你可以假设数组中不存在重复元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树II</title>
    <link href="https://hoo334.github.io/2020/07/21/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/"/>
    <id>https://hoo334.github.io/2020/07/21/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/</id>
    <published>2020-07-21T02:32:28.000Z</published>
    <updated>2020-07-21T03:50:13.902Z</updated>
    
    <content type="html"><![CDATA[<h4 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. 不同的二叉搜索树 II</a></h4><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p> <a id="more"></a><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 8</code></li></ul><p>我们枚举根结点的值为 i ，根据 BST 的性质，我们可以知道左子树的结点值集合为 [1 … i - 1]，右子树的结点值集合为 [i + 1 … n]。我们可以使用递归来建立子树。</p><p>我们定义 <code>generateTrees(start, end)</code>函数表示当前值的集合为 [start, end]，返回序列 [start, end]生成的所有可行的 BST。我们在 [start, end] 中枚举根结点 i ，将序列分为 [start, i - 1] 和 [i + 1, end] 递归地调用 generateTrees 函数。我们获得了所有的可行的右子树，最后一步，我们从左右子树集合中任选两课拼接到根结点上。</p><p>当 start &gt; end 时递归，BST 为空，返回空结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            allTrees.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> allTrees;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//枚举根结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">//得到左子树结点</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//得到右子树结点</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line"><span class="comment">//从左右子树结点集合中拿出两个结点连接到根结点</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left : leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right : rightTrees)&#123;</span><br><span class="line">                    TreeNode curTree = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    curTree.left = left;</span><br><span class="line">                    curTree.right = right;</span><br><span class="line">                    allTrees.add(curTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的结果存储了许多 BST 的根结点，我们以 n = 5， i = 3 为例来解释：</p><p>以  3 为根结点，左子树结点集合 为指向 1、2 的两个结点，右子树结点为指向 4、5 的两个结点，左右各取一个结点，新建一个根结点，生成 4 棵以 3 为根结点的 BST。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200721114003250.png" alt="image-20200721114003250"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;95-不同的二叉搜索树-II&quot;&gt;&lt;a href=&quot;#95-不同的二叉搜索树-II&quot; class=&quot;headerlink&quot; title=&quot;95. 不同的二叉搜索树 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-binary-search-trees-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;95. 不同的二叉搜索树 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，生成所有由 1 … &lt;em&gt;n&lt;/em&gt; 为节点所组成的 &lt;strong&gt;二叉搜索树&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
</feed>
