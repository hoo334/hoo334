<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2020-09-11T04:50:29.049Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组合总和III</title>
    <link href="https://hoo334.github.io/2020/09/11/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/"/>
    <id>https://hoo334.github.io/2020/09/11/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/</id>
    <published>2020-09-11T04:38:58.000Z</published>
    <updated>2020-09-11T04:50:29.049Z</updated>
    
    <content type="html"><![CDATA[<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a></h4><p>找出所有相加之和为 <strong><em>n</em></strong> 的 <strong>k</strong> 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure><p>需要注意的是，不能包含重复的数字，不能包含重复的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> n 剩余的数字之和</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> k 剩余的数字个数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> min 当前能选取的最小数字</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> path 递归路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> min, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 和为 0 且 剩余数字个数为 0 将当前路径加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//从最小值开始递归</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = min; k &gt; <span class="number">0</span> &amp;&amp; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; n)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            <span class="comment">//下一次选择只能选择比自己大的数字</span></span><br><span class="line">            dfs(n - i, k - <span class="number">1</span>, i + <span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;216-组合总和-III&quot;&gt;&lt;a href=&quot;#216-组合总和-III&quot; class=&quot;headerlink&quot; title=&quot;216. 组合总和 III&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;216. 组合总和 III&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;找出所有相加之和为 &lt;strong&gt;&lt;em&gt;n&lt;/em&gt;&lt;/strong&gt; 的 &lt;strong&gt;k&lt;/strong&gt; 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>组合总和II</title>
    <link href="https://hoo334.github.io/2020/09/10/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/"/>
    <id>https://hoo334.github.io/2020/09/10/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/</id>
    <published>2020-09-10T02:15:43.000Z</published>
    <updated>2020-09-10T02:42:55.155Z</updated>
    
    <content type="html"><![CDATA[<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></h4><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>此题与第 39 题差不多，只是条件限制有些不同。我们首先写出允许重复的初始程序，然后再添加限制条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="number">0</span>, target, candidates, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, ArrayDeque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = start; index &lt; candidates.length; index++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cur = candidates[index];</span><br><span class="line">            <span class="keyword">if</span>(target - cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path.addLast(cur);</span><br><span class="line">            dfs(index + <span class="number">1</span>, target - cur, candidates, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>candidates = [1, 2, 2, 2, 5]</code>，<code>target = 5</code> 时运行得到的结果为<code>[[1,2,2],[1,2,2],[1,2,2],[5]]</code>，<code>[1, 2, 2]</code>这个结果重复了三次。</p><p>想到可以在递归的时候限制，遇到重复的元素就跳过，我们写出如下版本（错误示例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, ArrayDeque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">         ans.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> index = start; index &lt; candidates.length; index++)&#123;</span><br><span class="line">         <span class="keyword">int</span> cur = candidates[index];</span><br><span class="line">         <span class="keyword">if</span>(target - cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//跳过重复的元素            </span></span><br><span class="line"><span class="keyword">if</span>(index &gt; <span class="number">0</span> &amp;&amp; candidates[index] == candidates[index - <span class="number">1</span>])&#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         path.addLast(cur);</span><br><span class="line">         dfs(index + <span class="number">1</span>, target - cur, candidates, path);</span><br><span class="line">         path.removeLast();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再次运行上述示例，我们得到结果<code>[[5]]</code>，<code>[1, 2, 2]</code>被剪掉了。当 index = 2 时，发现 index - 1 的值与它的值相同，则剪掉了这一分支，但我们需要保留这条分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1    index &#x3D; 0      第 1 层</span><br><span class="line">   &#x2F;</span><br><span class="line">  2      index &#x3D; 1      第 2 层</span><br><span class="line"> &#x2F;</span><br><span class="line">2        index &#x3D; 2      第 3 层</span><br></pre></td></tr></table></figure><p>对于下图中的递归路径，我们需要保留左边的分支，删除右边的分支，使每层都可以保留一个与上一层相同的元素，同时在每一层中，只能有一个相同的元素。这样就保留了最左侧的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F;     \</span><br><span class="line">2       2</span><br></pre></td></tr></table></figure><p>具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, ArrayDeque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">         ans.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> index = start; index &lt; candidates.length; index++)&#123;</span><br><span class="line">         <span class="keyword">int</span> cur = candidates[index];</span><br><span class="line">         <span class="keyword">if</span>(target - cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//跳过重复的元素，当 index == start 时不剪枝，保留最左侧的分支            </span></span><br><span class="line"><span class="keyword">if</span>(index &gt; start &amp;&amp; candidates[index] == candidates[index - <span class="number">1</span>])&#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         path.addLast(cur);</span><br><span class="line">         dfs(index + <span class="number">1</span>, target - cur, candidates, path);</span><br><span class="line">         path.removeLast();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/" target="_blank" rel="noopener">weiwei哥的题解</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;40-组合总和-II&quot;&gt;&lt;a href=&quot;#40-组合总和-II&quot; class=&quot;headerlink&quot; title=&quot;40. 组合总和 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;40. 组合总和 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt; 的组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的每个数字在每个组合中只能使用一次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>组合总和</title>
    <link href="https://hoo334.github.io/2020/09/09/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>https://hoo334.github.io/2020/09/09/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</id>
    <published>2020-09-09T01:08:46.000Z</published>
    <updated>2020-09-09T03:17:30.924Z</updated>
    
    <content type="html"><![CDATA[<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></h4><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的数字可以无限制重复被选取。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>1 &lt;= candidates[i] &lt;= 200</code></li><li><code>candidate</code> 中的每个元素都是独一无二的。</li><li><code>1 &lt;= target &lt;= 500</code></li></ul><p>由于 candidates 是无序的，只能暴力搜索全部的解。考虑剪枝，先将 candidates 数组排序，在搜索的过程中如果得到的当前总和大于 target ，那么后面的元素总和都不用尝试（由于数组递增，它们的总和比大于当前总和）。</p><p>数字可以被重复选取代表下一次递归时，还可以取当前选取的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//排序是剪枝的基础</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="number">0</span>, target, candidates, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, ArrayDeque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = candidates.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; start + i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = candidates[start + i];</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(target - cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                path.addLast(cur);</span><br><span class="line">                <span class="comment">//只能使用当前元素及其右侧的值，避免重复解</span></span><br><span class="line">                dfs(start + i, target - cur, candidates, path);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;39-组合总和&quot;&gt;&lt;a href=&quot;#39-组合总和&quot; class=&quot;headerlink&quot; title=&quot;39. 组合总和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;39. 组合总和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个&lt;strong&gt;无重复元素&lt;/strong&gt;的数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt; 的组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的数字可以无限制重复被选取。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>组合</title>
    <link href="https://hoo334.github.io/2020/09/08/%E7%BB%84%E5%90%88/"/>
    <id>https://hoo334.github.io/2020/09/08/%E7%BB%84%E5%90%88/</id>
    <published>2020-09-08T03:21:14.000Z</published>
    <updated>2020-09-08T03:32:21.466Z</updated>
    
    <content type="html"><![CDATA[<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></h4><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>以 n = 4， k = 2为例，我们可以发现如下递归结构：</p><ol><li>如果组合里面有 <code>1</code> ，那么需要在<code>[2, 3, 4]</code>里再找 1 个数；</li><li>如果组合里有 <code>2</code> ，那么需要在<code>[3, 4]</code>里再找 1 个数。这里不能再包含 1 ，因为[1, 2] 这个组合已经在第一种情况中包含。</li></ol><p>我们可以写出如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在[start, end] 选取 k 个数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> k, List&lt;Integer&gt; cur)</span></span>&#123;</span><br><span class="line"><span class="comment">// k == 0 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//对每一个数进行枚举</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; start + i &lt;= end; i++)&#123;</span><br><span class="line">            cur.add(start + i);</span><br><span class="line">            <span class="comment">//继续在[start + i + 1, end] 范围内选取 k - 1 个数</span></span><br><span class="line">            dfs(start + i + <span class="number">1</span>, end, k - <span class="number">1</span>, cur);</span><br><span class="line">            <span class="comment">//删除当前选取的数，重新循环</span></span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们注意到，使用ArrayList 进行删除效率很低，将其改为 ArrayDeque。在进行循环的时候，我们选取的退出条件为<code>start + i &lt;= end</code>，其实还可以缩小一点，当<code>[start + i, end]</code> 中的元素小于 k 个时，我们可以直接退出，将该条件修改为<code>start + i &lt;= end - k + 1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> k, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当[start + i, end]范围内数字个数小于 k 个时退出循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; start + i &lt;= end - k + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            path.addLast(start + i);</span><br><span class="line">            dfs(start + i + <span class="number">1</span>, end, k - <span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;77-组合&quot;&gt;&lt;a href=&quot;#77-组合&quot; class=&quot;headerlink&quot; title=&quot;77. 组合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combinations/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;77. 组合&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定两个整数 &lt;em&gt;n&lt;/em&gt; 和 &lt;em&gt;k&lt;/em&gt;，返回 1 … &lt;em&gt;n&lt;/em&gt; 中所有可能的 &lt;em&gt;k&lt;/em&gt; 个数的组合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>表示数值的字符串</title>
    <link href="https://hoo334.github.io/2020/09/02/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/09/02/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-09-02T01:31:05.000Z</published>
    <updated>2020-09-02T02:16:18.770Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 20. 表示数值的字符串</a></h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p><a id="more"></a><p>确定有限状态自动机是一类计算模型。它包含一系列状态，这些状态中：</p><ul><li>有一个特殊状态，被称为<em>初始状态</em>。</li><li>还有一系列状态被称为<em>接受状态</em>，他们组成了一个特殊的集合。其中一个状态可能既是<em>初始状态</em>，也是<em>接受状态</em>。</li></ul><p>起初这个自动机处于初始状态，然后，它顺序地读取字符串中地每一个字符，并根据当前状态和读入的字符，按照某个事先约定好地转移规则，从当前状态转移到下一个状态，当状态转移完成后，它继续读取下一个字符。当字符串读完后，如果这个自动机处于某个接受状态，则判断该字符串被接受；否则判定该字符串被拒绝。</p><p>如果在输入的过程中某一步转移失败了，判断字符串被拒绝。</p><p>用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：</p><ol><li>起始的空格</li><li>符号位</li><li>整数部分</li><li>左侧有整数的小数点</li><li>左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）</li><li>小数部分</li><li>字符 e</li><li>指数部分的符号位</li><li>指数部分的整数部分</li><li>末尾的空格</li></ol><p>将状态之间的转移规则画成图。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200902095846914.png" alt="image-20200902095846914"></p><p>我们需要处理转移失败的情况。为了处理这种情况，我们创建一个特殊的拒绝状态，一旦自动机转移到这个特殊状态，我们可以立即判定该字符串不被接受。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储每个点的起始状态和接受状态</span></span><br><span class="line">        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = <span class="keyword">new</span> HashMap&lt;State, Map&lt;CharType, State&gt;&gt;();</span><br><span class="line">        Map&lt;CharType, State&gt; initialMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_INITIAL);</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);</span><br><span class="line">            put(CharType.CHAR_SIGN, State.STATE_INT_SIGN);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INITIAL, initialMap);</span><br><span class="line">        Map&lt;CharType, State&gt; intSignMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INT_SIGN, intSignMap);</span><br><span class="line">        Map&lt;CharType, State&gt; integerMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INTEGER, integerMap);</span><br><span class="line">        Map&lt;CharType, State&gt; pointMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_POINT, pointMap);</span><br><span class="line">        Map&lt;CharType, State&gt; pointWithoutIntMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);</span><br><span class="line">        Map&lt;CharType, State&gt; fractionMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_FRACTION, fractionMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">            put(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP, expMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expSignMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP_SIGN, expSignMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expNumberMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);</span><br><span class="line">        Map&lt;CharType, State&gt; endMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_END, endMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        State state = State.STATE_INITIAL;</span><br><span class="line"><span class="comment">//从开始状态开始转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            CharType type = toCharType(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (!transfer.get(state).containsKey(type)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = transfer.get(state).get(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后字符除了 初始状态、整数前面的符号，左边没有数字的小数点，指数 e 和指数 e 的负号不被接受，其他状态全部接受</span></span><br><span class="line">        <span class="keyword">return</span> state == State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharType <span class="title">toCharType</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_NUMBER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'e'</span> || ch == <span class="string">'E'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_EXP;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_POINT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'+'</span> || ch == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_SIGN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_SPACE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_ILLEGAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> State &#123;</span><br><span class="line">        STATE_INITIAL,</span><br><span class="line">        STATE_INT_SIGN,</span><br><span class="line">        STATE_INTEGER,</span><br><span class="line">        STATE_POINT,</span><br><span class="line">        STATE_POINT_WITHOUT_INT,</span><br><span class="line">        STATE_FRACTION,</span><br><span class="line">        STATE_EXP,</span><br><span class="line">        STATE_EXP_SIGN,</span><br><span class="line">        STATE_EXP_NUMBER,</span><br><span class="line">        STATE_END,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> CharType &#123;</span><br><span class="line">        CHAR_NUMBER,</span><br><span class="line">        CHAR_EXP,</span><br><span class="line">        CHAR_POINT,</span><br><span class="line">        CHAR_SIGN,</span><br><span class="line">        CHAR_SPACE,</span><br><span class="line">        CHAR_ILLEGAL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(N)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;剑指-Offer-20-表示数值的字符串&quot;&gt;&lt;a href=&quot;#剑指-Offer-20-表示数值的字符串&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 20. 表示数值的字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 20. 表示数值的字符串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="自动机" scheme="https://hoo334.github.io/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>预测赢家</title>
    <link href="https://hoo334.github.io/2020/09/01/%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/"/>
    <id>https://hoo334.github.io/2020/09/01/%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/</id>
    <published>2020-09-01T01:47:35.000Z</published>
    <updated>2020-09-01T02:56:58.194Z</updated>
    
    <content type="html"><![CDATA[<h4 id="486-预测赢家"><a href="#486-预测赢家" class="headerlink" title="486. 预测赢家"></a><a href="https://leetcode-cn.com/problems/predict-the-winner/" target="_blank" rel="noopener">486. 预测赢家</a></h4><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：[1, 5, 2]</span><br><span class="line">输出：False</span><br><span class="line">解释：一开始，玩家1可以从1和2中进行选择。</span><br><span class="line">如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。</span><br><span class="line">所以，玩家 1 的最终分数为 1 + 2 &#x3D; 3，而玩家 2 为 5 。</span><br><span class="line">因此，玩家 1 永远不会成为赢家，返回 False 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1, 5, 233, 7]</span><br><span class="line">输出：True</span><br><span class="line">解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。</span><br><span class="line">     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>1 &lt;= 给定的数组长度 &lt;= 20.</li><li>数组里所有分数都为非负数且不会大于 10000000 。</li><li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li></ul><p><strong>方法一：递归</strong></p><p>为了判断哪个玩家可以获胜，我们计算一个总分，为先手和后手得分之差。当数组中所有数字被拿取时，如果总分大于等于 0，则先手获胜，反之则后手获胜。</p><p>每次可以从数组头和数组尾拿取一个数字，然后轮到另一个玩家在剩下的部分选取数字。计算总分时，需要记录当前玩家是先手还是后手，判断当前玩家的 得分应该记为正还是负。当数组中剩下的数字多于一个时，当前玩家会选择最优的方案，使自己的分数最大化，因此对两种方案分别计算当前玩家可以得到的分数，其中的最大值为当前玩家最多可以得到的分数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//turn 为 1 代表先手，为 -1 代表后手</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">total</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> turn)</span></span>&#123;</span><br><span class="line">        <span class="comment">//数组中只剩一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[start] * turn;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//当前玩家选择数组头的元素</span></span><br><span class="line">        <span class="keyword">int</span> scoreStart = total(nums, start + <span class="number">1</span>, end, -turn) + nums[start] * turn;</span><br><span class="line">        <span class="comment">//当前玩家选择数组尾的元素</span></span><br><span class="line">        <span class="keyword">int</span> scoreEnd = total(nums, start, end - <span class="number">1</span>, -turn) + nums[end] * turn;</span><br><span class="line"><span class="comment">//当为先手时，选择分数最大的；当为后手时，选择分数最小的</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(scoreStart * turn, scoreEnd * turn) * turn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200901102235086.png" alt="image-20200901102235086"></p><p>时间复杂度O(2^n)，n 是数组的长度。</p><p>空间复杂度O(n)，n 是数组的长度。</p><p><strong>方法二：动态规划</strong></p><p>定义二维数组 dp，其行数和列数都等于数组的长度，<code>dp[i][j]</code> 表示当前数组剩下的部分为下标 i  到下标 j时，当前玩家与另一个玩家的分数只差的最大值，注意当前玩家不一定是先手。</p><p>只有当 i &lt;= j 时才有意义，当 i = j 时，只剩一个数字，当前玩家只能拿取这个数字，因此对于所有 <code>0 &lt;= i &lt; nums.length</code>，都有<code>dp[i][i] = nums[i]</code>。</p><p>当 <code>i &lt; j</code> 时，当前玩家可以选择 nums[i] 或 nums[j]，然后轮到另一个玩家在数组剩下的部分选取数字。在两种方案中，当前玩家会选择最优的方案，使自己的分数最大化。得到转台方程：<br>$$<br>dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])<br>$$<br><code>nums[i] - dp[i + 1][j]</code>代表选择数组头的元素减去另一个玩家的分数之差，<code>nums[j] - dp[i][j - 1]</code>代表选择数组尾的元素减去另一个玩家的分数之差。</p><p>最后判断 <code>dp[0][nums.length - 1]</code>的值，如果大于等于 0 则先手得分大于后手得分，先手赢，反之则后手赢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">                dp[i][j] = Math.max(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][length - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，n 是数组的长度。</p><p>空间复杂度O(n^2)，n 是数组的长度。</p><p>我们可以对空间复杂度进行优化.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">                dp[j] = Math.max(nums[i] - dp[j], nums[j] - dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，n 是数组的长度。</p><p>空间复杂度O(n)，n 是数组的长度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;486-预测赢家&quot;&gt;&lt;a href=&quot;#486-预测赢家&quot; class=&quot;headerlink&quot; title=&quot;486. 预测赢家&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/predict-the-winner/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;486. 预测赢家&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。&lt;/p&gt;
&lt;p&gt;给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>钥匙和房间</title>
    <link href="https://hoo334.github.io/2020/08/31/%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/"/>
    <id>https://hoo334.github.io/2020/08/31/%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/</id>
    <published>2020-08-31T01:06:39.000Z</published>
    <updated>2020-08-31T01:27:48.444Z</updated>
    
    <content type="html"><![CDATA[<h4 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a><a href="https://leetcode-cn.com/problems/keys-and-rooms/" target="_blank" rel="noopener">841. 钥匙和房间</a></h4><p>有 <code>N</code> 个房间，开始时你位于 <code>0</code> 号房间。每个房间有不同的号码：<code>0，1，2，...，N-1</code>，并且房间里可能有一些钥匙能使你进入下一个房间。</p><p>在形式上，对于每个房间 <code>i</code> 都有一个钥匙列表 <code>rooms[i]</code>，每个钥匙 <code>rooms[i][j]</code> 由 <code>[0,1，...，N-1]</code> 中的一个整数表示，其中 <code>N = rooms.length</code>。 钥匙 <code>rooms[i][j] = v</code> 可以打开编号为 <code>v</code> 的房间。</p><p>最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。</p><p>你可以自由地在房间之间来回走动。</p><p>如果能进入每个房间返回 <code>true</code>，否则返回 <code>false</code>。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1],[2],[3],[]]</span><br><span class="line">输出: true</span><br><span class="line">解释:  </span><br><span class="line">我们从 0 号房间开始，拿到钥匙 1。</span><br><span class="line">之后我们去 1 号房间，拿到钥匙 2。</span><br><span class="line">然后我们去 2 号房间，拿到钥匙 3。</span><br><span class="line">最后我们去了 3 号房间。</span><br><span class="line">由于我们能够进入每个房间，我们返回 true。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,3],[3,0,1],[2],[0]]</span><br><span class="line">输出：false</span><br><span class="line">解释：我们不能进入 2 号房间。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= rooms.length &lt;= 1000</code></li><li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li><li>所有房间中的钥匙数量总计不超过 <code>3000</code>。</li></ol><p>当 x 号房间中有 y 号房间的钥匙时，我们就可以从 x 号房间去住 y 号房间。如果我们将这 n 个房间看成有向图中的 n 个节点，那么上述关系就可以看作是图中的 x 号点到 y 号点的一条有向边。</p><p>这样，问题就变成给定一张有向图，询问从 0 号结点出发能否到达所有的结点。</p><p><strong>方法一：DFS</strong></p><p>使用 visited 数组来标记已访问过的结点，最后判断是否存在没有访问过的结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = rooms.size();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">        <span class="comment">//从 0 号结点开始 DFS</span></span><br><span class="line">        dfs(rooms, visited, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//判断是否存在未访问的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[index])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[index] = <span class="keyword">true</span>;</span><br><span class="line">        List&lt;Integer&gt; room = rooms.get(index);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; room.size(); i++)&#123;</span><br><span class="line">            dfs(rooms, visited, room.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n + m)，其中 n 是房间的数量，m 是所有房间中钥匙数量的总数。</p><p>空间复杂度O(n)，其中 n 是房间的数量。</p><p><strong>方法二：BFS</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = rooms.size();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        queue.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//从 0 号结点开始 BFS</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> index = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(!visited[index])&#123;</span><br><span class="line">                visited[index] = <span class="keyword">true</span>;</span><br><span class="line">                List&lt;Integer&gt; room = rooms.get(index);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; room.size(); i++)&#123;</span><br><span class="line">                    queue.offer(room.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//判断是否存在未访问的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n + m)，其中 n 是房间的数量，m 是所有房间中钥匙数量的总数。</p><p>空间复杂度O(n)，其中 n 是房间的数量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;841-钥匙和房间&quot;&gt;&lt;a href=&quot;#841-钥匙和房间&quot; class=&quot;headerlink&quot; title=&quot;841. 钥匙和房间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/keys-and-rooms/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;841. 钥匙和房间&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;有 &lt;code&gt;N&lt;/code&gt; 个房间，开始时你位于 &lt;code&gt;0&lt;/code&gt; 号房间。每个房间有不同的号码：&lt;code&gt;0，1，2，...，N-1&lt;/code&gt;，并且房间里可能有一些钥匙能使你进入下一个房间。&lt;/p&gt;
&lt;p&gt;在形式上，对于每个房间 &lt;code&gt;i&lt;/code&gt; 都有一个钥匙列表 &lt;code&gt;rooms[i]&lt;/code&gt;，每个钥匙 &lt;code&gt;rooms[i][j]&lt;/code&gt; 由 &lt;code&gt;[0,1，...，N-1]&lt;/code&gt; 中的一个整数表示，其中 &lt;code&gt;N = rooms.length&lt;/code&gt;。 钥匙 &lt;code&gt;rooms[i][j] = v&lt;/code&gt; 可以打开编号为 &lt;code&gt;v&lt;/code&gt; 的房间。&lt;/p&gt;
&lt;p&gt;最初，除 &lt;code&gt;0&lt;/code&gt; 号房间外的其余所有房间都被锁住。&lt;/p&gt;
&lt;p&gt;你可以自由地在房间之间来回走动。&lt;/p&gt;
&lt;p&gt;如果能进入每个房间返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>初探nginx</title>
    <link href="https://hoo334.github.io/2020/08/26/%E5%88%9D%E6%8E%A2nginx/"/>
    <id>https://hoo334.github.io/2020/08/26/%E5%88%9D%E6%8E%A2nginx/</id>
    <published>2020-08-26T01:11:13.000Z</published>
    <updated>2020-08-30T04:38:34.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nginx-简介"><a href="#nginx-简介" class="headerlink" title="nginx 简介"></a>nginx 简介</h3><h4 id="nginx概述"><a href="#nginx概述" class="headerlink" title="nginx概述"></a>nginx概述</h4><p>nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。</p><a id="more"></a><h4 id="nginx-作为服务器"><a href="#nginx-作为服务器" class="headerlink" title="nginx 作为服务器"></a>nginx 作为服务器</h4><p>nginx作为负载均衡服务：nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务，也可以支持作为 HTTP<a href="https://baike.baidu.com/item/代理服务" target="_blank" rel="noopener">代理服务</a>对外进行服务。nginx采用C进行编写，不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多。</p><p>处理静态文件，索引文件以及自动索引;打开文件描述符缓冲。</p><p>无缓存的反向代理加速，简单的负载均衡和容错。</p><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。</p><p>客户端  –&gt;  代理服务器 –&gt; Internet</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826093023122.png" alt="image-20200826093023122"></p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只<br>需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返<br>回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器<br>地址，隐藏了真实服务器 IP 地址。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826093104775.png" alt="image-20200826093104775"></p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>并发请求过大时，单个服务器不足以支撑，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826093307366.png" alt="image-20200826093307366"></p><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速<br>度。降低原来单个服务器的压力。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826093345623.png" alt="image-20200826093345623"></p><h3 id="CentOS-下安装-nginx"><a href="#CentOS-下安装-nginx" class="headerlink" title="CentOS 下安装 nginx"></a>CentOS 下安装 nginx</h3><h4 id="安装nginx所需依赖"><a href="#安装nginx所需依赖" class="headerlink" title="安装nginx所需依赖"></a>安装nginx所需依赖</h4><p>首先检查是否已经安装依赖，能显示出版本号则可跳过该步骤。</p><blockquote><p>rpm -qa | grep pcre</p><p>rpm -qa | grep zlib</p><p>rpm -qa | grep gcc</p><p>rpm -qa | grep zlib</p></blockquote><h5 id="安装-pcre"><a href="#安装-pcre" class="headerlink" title="安装 pcre"></a>安装 pcre</h5><p>下载压缩包</p><blockquote><p>wget <a href="http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz" target="_blank" rel="noopener">http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</a></p></blockquote><p>找到压缩包所在位置，解压</p><blockquote><p>tar -xvf pcre-8.37.tar.gz</p></blockquote><p>进入目录 pcre-8.37，配置并安装</p><blockquote><p>./configure</p><p>make &amp;&amp; make install</p></blockquote><h5 id="安装-openssl-、zlib-等依赖"><a href="#安装-openssl-、zlib-等依赖" class="headerlink" title="安装 openssl 、zlib 等依赖"></a>安装 openssl 、zlib 等依赖</h5><blockquote><p>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</p></blockquote><h5 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h5><p>进入<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">官网</a>，选择 nginx-1.18.0，下载。找到压缩包位置，解压。</p><blockquote><p>tar -xvf nginx-1.18.0.tar.gz</p></blockquote><p>进入 nginx-1.18.0 目录</p><blockquote><p>cd nginx-1.18.0</p></blockquote><p>配置并安装</p><blockquote><p>./configure</p><p>make &amp;&amp; make install</p></blockquote><h5 id="防火墙配置（也可以直接关闭防火墙，不推荐这么做）"><a href="#防火墙配置（也可以直接关闭防火墙，不推荐这么做）" class="headerlink" title="防火墙配置（也可以直接关闭防火墙，不推荐这么做）"></a>防火墙配置（也可以直接关闭防火墙，不推荐这么做）</h5><p>查看开放的端口</p><blockquote><p>firewall-cmd –list-all</p></blockquote><p>设置开放的端口(开放80端口)</p><blockquote><p>firewall-cmd –add-service=http –permanent<br>sudo firewall-cmd –add-port=80/tcp –permanent</p></blockquote><p>重启防火墙</p><blockquote><p>firewall-cmd –reload</p></blockquote><h3 id="nginx-常用命令及配置文件说明"><a href="#nginx-常用命令及配置文件说明" class="headerlink" title="nginx 常用命令及配置文件说明"></a>nginx 常用命令及配置文件说明</h3><h4 id="nginx-常用命令"><a href="#nginx-常用命令" class="headerlink" title="nginx 常用命令"></a>nginx 常用命令</h4><p>首先进入sbin目录：</p><blockquote><p>cd /usr/local/nginx/sbin</p></blockquote><p>启动</p><blockquote><p>./nginx</p></blockquote><p>关闭</p><blockquote><p>./nginx -s stop</p></blockquote><p>重新加载</p><blockquote><p>./nginx -s reload</p></blockquote><h4 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx.conf 配置文件"></a>nginx.conf 配置文件</h4><p>配置文件在 /usr/local/nginx/conf 目录下。</p><p>文件中许多都是注释掉的部分，将其精简得到如下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="nginx-conf-文件三部分"><a href="#nginx-conf-文件三部分" class="headerlink" title="nginx.conf 文件三部分"></a>nginx.conf 文件三部分</h5><h6 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h6><p>从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配<br>置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以<br>及配置文件的引入等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br></pre></td></tr></table></figure><p>这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。</p><h6 id="events-块"><a href="#events-块" class="headerlink" title="events 块"></a>events 块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>events 块涉及的指令主要影响 nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process<br>下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word<br>process 可以同时支持的最大连接数等。<br>上述例子就表示每个 work process 支持的最大连接数为 1024。这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p><h6 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。<br>需要注意的是：http 块也可以包括 http 全局块、server 块。</p><ol><li><p>http 全局块</p><p>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p></li><li><p>server 块</p><p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。<br>每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</p><ul><li><p>全局 server 块</p><p>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。</p></li><li><p>location 块</p><p>一个 server 块可以配置多个 location 块。<br>这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称<br>（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓<br>存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p></li></ul></li></ol><h3 id="反向代理实例1"><a href="#反向代理实例1" class="headerlink" title="反向代理实例1"></a>反向代理实例1</h3><p>实现效果：使用 nginx 反向代理，访问 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 直接跳转到 tomcat主页面。</p><p>首先在服务器安装 tomcat进入<a href="https://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">官网</a>下载linux版本。</p><p>解压</p><blockquote><p>tar -xvf apache-tomcat-7.0.70.tar.gz</p></blockquote><p>启动 tomcat</p><blockquote><p>cd apache-tomcat-7.0.70/bin</p><p>./startup.sh</p></blockquote><p>没有错误的话，在服务器访问 localhost:8080 可以看到 tomcat 主界面。</p><p>同时我们需要开启服务器的 8080 端口，便于客户机访问。</p><blockquote><p>firewall-cmd –add-port=8080/tcp –permanent<br>firewall-cmd –reload</p></blockquote><p>在windows 浏览器中输入192.168.1.200:8080（192.168.1.200为服务器 IP）也可以访问到 tomcat 主界面。</p><p>在 windows hosts 文件中添加域名映射：</p><blockquote><p>192.168.1.200   <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a></p></blockquote><p>访问 <a href="http://www.123.com:8080也可以访问到">www.123.com:8080也可以访问到</a> tomcat 主界面。</p><p>修改 nginx 配置文件实现反向代理</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826105658235.png" alt="image-20200826105658235"></p><p>启动 nginx 服务器，访问 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 即可看到 tomcat 主界面。</p><h3 id="反向代理实例2"><a href="#反向代理实例2" class="headerlink" title="反向代理实例2"></a>反向代理实例2</h3><p>实现效果：使用 nginx 实现反向代理，根据访问路径的不同跳转到不同端口的服务中。</p><p>nginx 监听端口为 9001，</p><p>访问 192.168.1.200:9001/edu/    跳转到 localhost:8080</p><p>访问 192.168.1.200:9001/vod/    跳转到 localhost:8081</p><p>我们需要两台 tomcat，直接解压 tomcat 压缩包到两个文件夹。8080 端口的 tomcat 不需要配置，8081 端口的 tomcat 需要更改端口：</p><p>进入 tomcat 解压文件夹，进入 conf 文件夹，找到 server.xml</p><p>更改如下端口号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server port&#x3D;&quot;8015&quot; shutdown&#x3D;&quot;SHUTDOWN&quot;&gt;  &#x2F;&#x2F; 将默认 8005 改为 8015</span><br><span class="line">&lt;Connector port&#x3D;&quot;8081&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; &#x2F;&#x2F; 将默认 8080 改为 8081</span><br><span class="line">&lt;Connector port&#x3D;&quot;8019&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt; &#x2F;&#x2F;将默认 8009 改为 8019</span><br></pre></td></tr></table></figure><p>进入bin目录，启动两台tomcat</p><blockquote><p>./startup.sh</p></blockquote><p>可在虚拟机中访问 localhost:8080 和 localhost:8081 看到 tomcat 主页面。开放防火墙 8080 和 8081 端口后，可在 windows 中访问 192.168.1.200:8080 和 192.168.1.200:8081 都能看到 tomcat 主页面。</p><p>接下来我们将两个静态资源分别放入 tomcat 的 webapps 文件夹中。</p><p>我们新建两个 html 文件，8080端口的tomcat 中有一个文件夹 edu，文件夹内一个名为a.html，文件内容为<code>&lt;h1&gt;8080&lt;h1&gt;</code>，8081端口的tomcat 中有一个文件夹 vod，文件夹内一个名为a.html，文件内容为<code>&lt;h1&gt;8081&lt;h1&gt;</code>。</p><p>windows 访问192.168.1.200:8080/edu/a.html 和 192.168.1.200:8081/vod/a.html 可分别看见 8080 和 8081 字样。</p><p>再来继续配置 nginx，打开 nginx.conf，更改如下内容。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826203446684.png" alt="image-20200826203446684"></p><p>启动 nginx，我们在 windows 环境下 访问 192.168.1.200:9001/edu/a.html 和 192.168.1.200:9001/vod/a.html 即可看到 8080 和 8081 字样。</p><h3 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>实现效果：浏览器中输入 192.168.1.200/edu/a.html，可以看到 8080 和 8081 字样不停变换。</p><p>我们新建两个 html 文件，8080端口的tomcat 中有一个文件夹 edu，文件夹内一个名为a.html，文件内容为<code>&lt;h1&gt;8080&lt;h1&gt;</code>，8081端口的tomcat 中同样有一个文件夹 edu，文件夹内一个名为a.html，文件内容为<code>&lt;h1&gt;8081&lt;h1&gt;</code>。</p><p>windows 访问192.168.1.200:8080/edu/a.html 和 192.168.1.200:8081/edu/a.html 可分别看见 8080 和 8081 字样。</p><p>我们在 nginx 配置文件中进行修改：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826204159859.png" alt="image-20200826204159859"></p><p>启动 nginx，windows 访问 192.168.1.200/edu/a.html，不停刷新，即可看到 8080 和 8081交替出现（如果不交替出现，可能是浏览器缓存，换 edge 试试）。</p><p>负载均衡的集中方式：</p><ol><li><p>轮询（默认）</p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</p></li><li><p>weight</p><p>weight 表示权重，默认为1，权重越高，服务器分配到的客户端越多。指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826204626473.png" alt="image-20200826204626473"></p></li><li><p>ip_hash</p><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826204640931.png" alt="image-20200826204640931"></p></li><li><p>fair</p><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826204708191.png" alt="image-20200826204708191"></p></li></ol><h3 id="动静分离-1"><a href="#动静分离-1" class="headerlink" title="动静分离"></a>动静分离</h3><p>nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和<br>静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 nginx<br>处理静态页面，Tomcat 处理动态页面。</p><p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；<br>另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。<br>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使<br>浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资<br>源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，<br>所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，<br>不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送<br>一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码<br>304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p><p>在 linux 系统中准备静态资源：</p><blockquote><p>cd /</p><p>mkdir data</p><p>cd data</p><p>mkdir www</p><p>mkdir image</p></blockquote><p>在 www 文件夹下放一个 html 文件（名为 a.html），在image 文件夹下放一张图片（1.jpg）。</p><p>配置 nginx 实现文件与 web 请求路径的映射。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826205334410.png" alt="image-20200826205334410"></p><p>在 windows 访问 192.168.1.200/image/1.jpg即可看到图片，访问 192.168.1.200/www/a.html即可看到页面信息。访问 192.168.1.200/image/ ，你会看到目录下的文件信息，这就是 <code>autoindex on</code> 的作用。</p><h3 id="高可用集群（主从模式）"><a href="#高可用集群（主从模式）" class="headerlink" title="高可用集群（主从模式）"></a>高可用集群（主从模式）</h3><p>一般 nginx 都是以集群来工作，增加可用性，我们要实现一主一备 nginx，当主 nginx 挂了，备份nginx 可以继续工作。</p><p>我们需要在两台 linux 虚拟机，分别安装 nginx。</p><p>我们还需要在两台虚拟机中安装 keepalived：</p><blockquote><p>yum install keepalived –y</p></blockquote><p>在/etc 文件夹下，修改主nginx 虚拟机的 keepalived.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.1.200</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">    script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;   # 检测 nginx 是否活着的脚本</span><br><span class="line"></span><br><span class="line">    interval 2        #（检测脚本执行的间隔）</span><br><span class="line"></span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER     # 备份服务器上将 MASTER 改为 BACKUP</span><br><span class="line">    interface ens33  # 网卡</span><br><span class="line">    virtual_router_id 51  # 主、备机的 virtual_router_id 必须相同</span><br><span class="line">    priority 100    # 主、备机取不同的优先级，主机值较大，备份机值较小</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.17.50  #  VRRP H 虚拟地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改备份 nginx 虚拟机的 keepalived.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.1.200</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">    script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;</span><br><span class="line"></span><br><span class="line">    interval 2</span><br><span class="line"></span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.17.50</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在两台虚拟机的 /usr/local/src 添加检测脚本 nginx_check.sh ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">A&#x3D;&#96;ps -C nginx –no-header |wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ &#96;ps -C nginx --no-header |wc -l&#96; -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>把两台服务器上的 nginx 和 keepalived 启动</p><blockquote><p>nginx sbin 目录下启动 nginx    ./nginx</p><p>启动keepalived  systemctl start keepalived.service</p></blockquote><p>在 windows 浏览器访问 192.168.17.50，即可看见 nginx 主界面，我们将主 nginx 关闭，再次访问，依然能看见 nginx 主界面，说明备份 nginx 工作正常。</p><h3 id="nginx-原理"><a href="#nginx-原理" class="headerlink" title="nginx 原理"></a>nginx 原理</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826211511134.png" alt="image-20200826211511134"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826211523072.png" alt="image-20200826211523072"></p><p>master -  workers  的机制的好处<br>首先，对于每个 worker 进程来说，由于采用多个相互独立的进程，单一的 worker 进程出问题了，不会影响到 nginx 的全部服务，只是该 worker 上的全部请求失败。</p><p><strong>需要设置多少个 worker</strong><br>Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进<br>程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话<br>下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu<br>数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。</p><p><strong>设置 worker  数量</strong></p><p>worker_processes 4  </p><p>#work 绑定 cpu(4 work 绑定 4cpu)。<br>worker_cpu_affinity 0001 0010 0100 1000  </p><p>#work 绑定 cpu (4 work 绑定 8 cpu 中的 4 个) 。<br>worker_cpu_affinity 0000001 00000010 00000100 00001000</p><p>连接数 worker_connection 表示每个 worker 进程所能建立连接的最大值。一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： worker_connections * worker_processes /2，而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections * worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;nginx-简介&quot;&gt;&lt;a href=&quot;#nginx-简介&quot; class=&quot;headerlink&quot; title=&quot;nginx 简介&quot;&gt;&lt;/a&gt;nginx 简介&lt;/h3&gt;&lt;h4 id=&quot;nginx概述&quot;&gt;&lt;a href=&quot;#nginx概述&quot; class=&quot;headerlink&quot; title=&quot;nginx概述&quot;&gt;&lt;/a&gt;nginx概述&lt;/h4&gt;&lt;p&gt;nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://hoo334.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="https://hoo334.github.io/2020/08/26/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>https://hoo334.github.io/2020/08/26/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</id>
    <published>2020-08-26T00:52:15.000Z</published>
    <updated>2020-08-26T01:05:10.627Z</updated>
    
    <content type="html"><![CDATA[<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h4><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><a id="more"></a><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826085317695.png" alt="image-20200826085317695"></p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><p><strong>方法一：回溯</strong></p><p>首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。</p><p>回溯过程中维护一个字符串，表示已有的字母排列。该字符串初始为空，每次取电话号码的一位数字，从哈希表中获取该数字对应的所有字母，将其中一个字母插入到已有字母的后面，然后继续处理电话号码的后一位数字，直到处理完所有数字，得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, String&gt; numMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        numMap.put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">        numMap.put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">        numMap.put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        numMap.put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        numMap.put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">        numMap.put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        numMap.put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        numMap.put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line"></span><br><span class="line">        backtrack(combinations, numMap, digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuffer());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; numMap, String digits, <span class="keyword">int</span> index, StringBuffer combination)</span></span>&#123;</span><br><span class="line">        <span class="comment">//是否遍历完 digits 中所有数字</span></span><br><span class="line">        <span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//获取数字对应的所有字符</span></span><br><span class="line">            <span class="keyword">char</span> c = digits.charAt(index);</span><br><span class="line">            String letters = numMap.get(c);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length(); i++)&#123;</span><br><span class="line">                <span class="comment">//取一个字母，并继续处理后一位数字</span></span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, numMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                <span class="comment">//删除当前字母，并进行下一个循环</span></span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(3^m * 4^ n)，m 为对应三个字母的数字个数，n 为对应四个字母的数字个数。</p><p>空间复杂度O(m + n)，m 为对应三个字母的数字个数，n 为对应四个字母的数字个数。除返回值外，空间复杂度取决于哈希表及递归调用层数，递归调用层数最多为 m + n。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;17-电话号码的字母组合&quot;&gt;&lt;a href=&quot;#17-电话号码的字母组合&quot; class=&quot;headerlink&quot; title=&quot;17. 电话号码的字母组合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;17. 电话号码的字母组合&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个仅包含数字 &lt;code&gt;2-9&lt;/code&gt; 的字符串，返回所有它能表示的字母组合。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="回溯" scheme="https://hoo334.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>递增子序列</title>
    <link href="https://hoo334.github.io/2020/08/25/%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://hoo334.github.io/2020/08/25/%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-08-25T01:20:53.000Z</published>
    <updated>2020-08-25T02:02:10.504Z</updated>
    
    <content type="html"><![CDATA[<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode-cn.com/problems/increasing-subsequences/" target="_blank" rel="noopener">491. 递增子序列</a></h4><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 6, 7, 7]</span><br><span class="line">输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ol><p>我们可以枚举出所有的子序列，然后判断当前的子序列是否是非严格递增的。对于数组中的每个数来说都有<strong>选中</strong>和<strong>不选中</strong>两种状态。长度为 n 的序列选择子序列一共有 2 ^ n 种情况。我们可以使用递归的方法实现二进制枚举，然后判断是否合法，我们可以得到这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">        <span class="comment">// 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span></span><br><span class="line">        <span class="keyword">if</span> (isValid() &amp;&amp; notVisited()) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果选择当前元素</span></span><br><span class="line">    temp.add(nums[cur]);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">    temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果不选择当前元素</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个临时数组 temp 保存当前选出的子序列，用 cur 来表示当前位置的下标，在 执行<code>dfs(cur, nums)</code>之前，[0, cur - 1]区间内的所有元素都被考虑过，[cur, n]区间内的元素还未被考虑。我们考虑 cur 位置选或者不选，如果选择当前元素，将当前元素加入 temp，然后递归下一个位置，在递归结束后，把 temp 的最后一个元素删除进行回溯；如果不选择当前元素，直接递归下一个位置。</p><p>我们可以对选择和不选择做一些简单的限定，就可以让枚举出来的序列都是合法且不重复：</p><ul><li><p>只有当前的元素大于等于上一个选择的元素时才能选择这个元素，这样枚举出来的所有元素都是合法的。</p></li><li><p>如何保证没有重复呢？我们给不选择做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。如果有两个相同的元素，我们有四种情况:</p><ol><li>选前者，选后者</li><li>选前者，不选后者</li><li>不选前者，选后者</li><li>不选前者，不选后者</li></ol><p>其中第二种和第三种情况是等价的，这样限制后，舍弃了第二种，保留了第三种。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, Integer.MIN_VALUE, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历到末尾</span></span><br><span class="line">        <span class="keyword">if</span>(cur == nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//当前元素大于等于前一个选择的元素</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cur] &gt;= last)&#123;</span><br><span class="line">            temp.add(nums[cur]);</span><br><span class="line">            dfs(cur + <span class="number">1</span>, nums[cur], nums);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//当前元素不等于前一个选择的元素才考虑不选择当前元素，去重</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cur] != last)&#123;</span><br><span class="line">            dfs(cur + <span class="number">1</span>, last, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n * 2 ^ n)，枚举子序列O(2 ^ n)，保存答案O(n)。</p><p>空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;491-递增子序列&quot;&gt;&lt;a href=&quot;#491-递增子序列&quot; class=&quot;headerlink&quot; title=&quot;491. 递增子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/increasing-subsequences/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;491. 递增子序列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>重复的子字符串</title>
    <link href="https://hoo334.github.io/2020/08/24/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/08/24/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-08-24T01:27:03.000Z</published>
    <updated>2020-08-24T01:42:25.713Z</updated>
    
    <content type="html"><![CDATA[<h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></h4><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line"></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure><p><strong>方法一：枚举</strong></p><p>如果一个长度为 n 的字符串可以由它的一个长度为 n‘ 的子串 s’ 重复多次构成，那么：</p><ul><li>n 一定是 n‘ 的倍数；</li><li>s’ 一定是 s 的前缀；</li><li>对于任意的 <code>i∈[n&#39;, n)</code>，有 <code>s[i] = s[i - n&#39;]</code>。</li></ul><p>我们枚举子串的长度 n’ ，同时判断 s[i] 和 s[i - n’] 是否相等。子串的长度 n’ 属于 [1, n / 2]，长度为 n 的字符串至少要由两个重复子串构成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//字符串长度不能整除子串的长度，continue</span></span><br><span class="line">            <span class="keyword">if</span>(n % i != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//判断子串s[0 ... i - 1] 是否为重复的子串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) != s.charAt(j - i))&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;459-重复的子字符串&quot;&gt;&lt;a href=&quot;#459-重复的子字符串&quot; class=&quot;headerlink&quot; title=&quot;459. 重复的子字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/repeated-substring-pattern/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;459. 重复的子字符串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>汉明距离</title>
    <link href="https://hoo334.github.io/2020/08/23/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    <id>https://hoo334.github.io/2020/08/23/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</id>
    <published>2020-08-23T01:23:21.000Z</published>
    <updated>2020-08-23T01:33:43.579Z</updated>
    
    <content type="html"><![CDATA[<h4 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">461. 汉明距离</a></h4><p>两个整数之间的<a href="https://baike.baidu.com/item/汉明距离" target="_blank" rel="noopener">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p><a id="more"></a><p><strong>注意：</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure><p>我们知道异或操作：不同得 1 ，相同得 0。我们对 x 和 y 做一次异或操作，得到的数的二进制位中的 1 的个数就是 x 和 y 的汉明距离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; 1, y &#x3D; 4</span><br><span class="line">1       (0 0 0 1)</span><br><span class="line">4       (0 1 0 0)</span><br><span class="line">1 xor 4 (0 1 0 1)  &quot;1&quot; 的个数为 2，即汉明距离为 2</span><br></pre></td></tr></table></figure><p><strong>方法一：位移</strong></p><p>我们要求一个数字二进制位中 “1” 的个数，可以不断将数字右移，统计最后一位为 1 的个数，直到数字为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = x ^ y, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p><p><strong>方法二：布赖恩·克尼根算法</strong></p><p>「Brian Kernighan 算法」，用于清除二进制串中最右边的 1。</p><p>我们每次对 n 和 n - 1进行按位与操作后，n 中最右边的 1 会被抹去变为 0 。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823091337544.png" alt="image-20200823091337544"></p><p>我们不断地将数字的最右边的 “1” 变为 0 ，同时统计 1 的个数，直到数字为 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = x ^ y, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != <span class="number">0</span>)&#123;</span><br><span class="line">            m = m &amp; (m - <span class="number">1</span>);</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;461-汉明距离&quot;&gt;&lt;a href=&quot;#461-汉明距离&quot; class=&quot;headerlink&quot; title=&quot;461. 汉明距离&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/hamming-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;461. 汉明距离&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;两个整数之间的&lt;a href=&quot;https://baike.baidu.com/item/汉明距离&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汉明距离&lt;/a&gt;指的是这两个数字对应二进制位不同的位置的数目。&lt;/p&gt;
&lt;p&gt;给出两个整数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt;，计算它们之间的汉明距离。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="位运算" scheme="https://hoo334.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>数字范围按位与</title>
    <link href="https://hoo334.github.io/2020/08/23/%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/"/>
    <id>https://hoo334.github.io/2020/08/23/%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/</id>
    <published>2020-08-23T01:02:09.000Z</published>
    <updated>2020-08-23T01:39:08.518Z</updated>
    
    <content type="html"><![CDATA[<h4 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">201. 数字范围按位与</a></h4><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p><a id="more"></a><p><strong>示例 1:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [5,7]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>我们首先想到将[m, n] 范围内的运算全部做一次与运算，然而超时。我们将 [9, 12] 的二进制字符画成图：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823090713328.png" alt="image-20200823090713328"></p><p>我们可以发现，对所有数字执行按位与运算的结果是对应二进制字符串的公共前缀再用零补上后面的剩余位。进一步的说，这些字符串的公共前缀就等于 9 和 12 两个数字的二进制字符串的公共前缀。</p><p><strong>方法一：位移</strong></p><p>我们可以将两个数字不断右移，同时记录位移的次数，直到它们相等，得到了公共前缀，我们再将公共前缀左移相应的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到公共前缀</span></span><br><span class="line">        <span class="keyword">while</span>(m != n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            ++shift;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左移相应的次数</span></span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; shift;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p><p><strong>方法二：Brian Kernighan 算法</strong></p><p>「Brian Kernighan 算法」，用于清除二进制串中最右边的 1。</p><p>我们每次对 n 和 n - 1进行按位与操作后，n 中最右边的 1 会被抹去变为 0 。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823091337544.png" alt="image-20200823091337544"></p><p>对于此题，我们将一直清除 n 最右边的 1 ，直到  n &lt;= m，此时 n 就是公共前缀。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823092218184.png" alt="image-20200823092218184"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; n)&#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;201-数字范围按位与&quot;&gt;&lt;a href=&quot;#201-数字范围按位与&quot; class=&quot;headerlink&quot; title=&quot;201. 数字范围按位与&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;201. 数字范围按位与&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定范围 [m, n]，其中 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="位运算" scheme="https://hoo334.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>24点游戏</title>
    <link href="https://hoo334.github.io/2020/08/22/24%E7%82%B9%E6%B8%B8%E6%88%8F/"/>
    <id>https://hoo334.github.io/2020/08/22/24%E7%82%B9%E6%B8%B8%E6%88%8F/</id>
    <published>2020-08-22T01:37:40.000Z</published>
    <updated>2020-08-22T01:58:34.610Z</updated>
    
    <content type="html"><![CDATA[<h4 id="679-24-点游戏"><a href="#679-24-点游戏" class="headerlink" title="679. 24 点游戏"></a><a href="https://leetcode-cn.com/problems/24-game/" target="_blank" rel="noopener">679. 24 点游戏</a></h4><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 <code>*</code>，<code>/</code>，<code>+</code>，<code>-</code>，<code>(</code>，<code>)</code> 的运算得到 24。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 1, 8, 7]</span><br><span class="line">输出: True</span><br><span class="line">解释: (8-4) * (7-1) &#x3D; 24</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 1, 2]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>除法运算符 <code>/</code> 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。</li><li>每个运算符对两个数进行运算。特别是我们不能用 <code>-</code> 作为一元运算符。例如，<code>[1, 1, 1, 1]</code> 作为输入时，表达式 <code>-1 - 1 - 1 - 1</code> 是不允许的。</li><li>你不能将数字连接在一起。例如，输入为 <code>[1, 2, 1, 2]</code> 时，不能写成 12 + 12 。</li></ol><p>一共有 4 个数和 3 个运算操作，因此可能性并不多。</p><p>首先从 4 个数字中有序取出两个数字共 4 * 3 = 12 种选法，再选择 4 种运算中的一种，将运算的结果取代选出的两个数字。</p><p>在剩下的 3 个数字中有序取出两个数字共 3 * 2 = 6 种选法，再选择 4 种运算中的一种，将运算的结果取代选出的两个数字。</p><p>最后剩下两个数字，有两种不同的顺序，并选择 4 种运算之一。</p><p>总共有 12 * 4 * 6 * 4 * 2 * 4 = 9216 种可能。</p><p>我们直接使用暴力方法来求解，用一个列表存储全部数字，每次从列表中选出 2 个数字，再选择 1 种运算操作，用计算的结果取代选出的 2 个数字。重复以上步骤，直到最后剩下一个数字，判断它是否等于 24 即可。</p><p>注意到除法运算为实数除法，结果为浮点数，因此在列表中应该全部存储浮点数。两个浮点数差值小于 1e-6 时可认为它们相等。同时，在进行除法运算时，除数不能为 0 ，遇到这种情况我们可以直接排除。</p><p>加法和乘法都满足交换律，对于选出的 2 个数字不需要考虑不同的顺序，在第二次运算时直接跳过。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> TARGET = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> EPSILON = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ADD = <span class="number">0</span>, MULTIPLY = <span class="number">1</span>, SUBTRACT = <span class="number">2</span>, DIVIDE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgePoint24</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将所有数字转为 double 并存进list</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            list.add((<span class="keyword">double</span>) num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(List&lt;Double&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列表中只剩一个数字，判断它是否等于 24</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(list.get(<span class="number">0</span>) - TARGET) &lt; EPSILON;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="comment">// 有序选出 i，j 位置的两个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)&#123;</span><br><span class="line">                <span class="comment">//选出同一个数</span></span><br><span class="line">                <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;Double&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//保存除 i，j 位置的元素</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k != i &amp;&amp; k != j)&#123;</span><br><span class="line">                        list2.add(list.get(k));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//选出一种运算</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                    <span class="comment">//如果是加或乘运算，且这是第二次选中 i 和 j</span></span><br><span class="line">                    <span class="keyword">if</span>(k &lt; <span class="number">2</span> &amp;&amp; i &gt; j)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//计算结果</span></span><br><span class="line">                    <span class="keyword">if</span>(k == ADD)&#123;</span><br><span class="line">                        list2.add(list.get(i) + list.get(j));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == MULTIPLY)&#123;</span><br><span class="line">                        list2.add(list.get(i) * list.get(j));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == SUBTRACT)&#123;</span><br><span class="line">                        list2.add(list.get(i) - list.get(j));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == DIVIDE)&#123;</span><br><span class="line">                        <span class="comment">//跳过除数为 0 的情况</span></span><br><span class="line">                        <span class="keyword">if</span>(Math.abs(list.get(j)) &lt; EPSILON)&#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            list2.add(list.get(i) / list.get(j));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//继续选出两个数字并计算，如果得到结果，返回 true</span></span><br><span class="line">                    <span class="keyword">if</span>(solve(list2))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">// list 不能得到 24点，删除加入的元素，并尝试下一种运算</span></span><br><span class="line">                    list2.remove(list2.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;679-24-点游戏&quot;&gt;&lt;a href=&quot;#679-24-点游戏&quot; class=&quot;headerlink&quot; title=&quot;679. 24 点游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/24-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;679. 24 点游戏&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 &lt;code&gt;*&lt;/code&gt;，&lt;code&gt;/&lt;/code&gt;，&lt;code&gt;+&lt;/code&gt;，&lt;code&gt;-&lt;/code&gt;，&lt;code&gt;(&lt;/code&gt;，&lt;code&gt;)&lt;/code&gt; 的运算得到 24。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数学" scheme="https://hoo334.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的最小深度</title>
    <link href="https://hoo334.github.io/2020/08/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <id>https://hoo334.github.io/2020/08/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</id>
    <published>2020-08-21T01:34:22.000Z</published>
    <updated>2020-08-21T01:50:12.976Z</updated>
    
    <content type="html"><![CDATA[<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h4><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><a id="more"></a><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最小深度  2.</p><p>看到这么简单的题，一顿操作，立马就写出了如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试发现 [2,9]这个用例不对，我们得到的结果为 1，实际结果为 2。原因在于我们统计了空结点到根节点的深度。</p><p>对于每个结点，当只有一个子树时，直接返回子树的最小深度加一；当有两颗子树时，返回左右子树之中的最小深度加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="keyword">null</span> &amp;&amp; root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(h)，h 为树的高度，当二叉树退化为链表时，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;111-二叉树的最小深度&quot;&gt;&lt;a href=&quot;#111-二叉树的最小深度&quot; class=&quot;headerlink&quot; title=&quot;111. 二叉树的最小深度&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;111. 二叉树的最小深度&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二叉树，找出其最小深度。&lt;/p&gt;
&lt;p&gt;最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>扫雷游戏</title>
    <link href="https://hoo334.github.io/2020/08/20/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/"/>
    <id>https://hoo334.github.io/2020/08/20/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</id>
    <published>2020-08-20T04:01:59.000Z</published>
    <updated>2020-08-20T04:12:29.682Z</updated>
    
    <content type="html"><![CDATA[<h4 id="529-扫雷游戏"><a href="#529-扫雷游戏" class="headerlink" title="529. 扫雷游戏"></a><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">529. 扫雷游戏</a></h4><p>让我们一起来玩扫雷游戏！</p><p>给定一个代表游戏板的二维字符矩阵。 <strong>‘M’</strong> 代表一个<strong>未挖出的</strong>地雷，<strong>‘E’</strong> 代表一个<strong>未挖出的</strong>空方块，<strong>‘B’</strong> 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong>已挖出的</strong>空白方块，<strong>数字</strong>（’1’ 到 ‘8’）表示有多少地雷与这块<strong>已挖出的</strong>方块相邻，<strong>‘X’</strong> 则表示一个<strong>已挖出的</strong>地雷。</p><p>现在给出在所有<strong>未挖出的</strong>方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><ol><li><p>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 <strong>‘X’</strong>。</p></li><li><p>如果一个<strong>没有相邻地雷</strong>的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的<strong>未挖出</strong>方块都应该被递归地揭露。</p></li><li><p>如果一个<strong>至少与一个地雷相邻</strong>的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。</p></li><li><p>如果在此次点击中，若无更多方块可被揭露，则返回面板。</p><a id="more"></a></li></ol><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">解释:</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">解释:</span><br></pre></td></tr></table></figure><p> <strong>注意：</strong></p><ol><li>输入矩阵的宽和高的范围为 [1,50]。</li><li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li><li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li><li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li></ol><p>对于我们点击的每一个方块，有两种情况：</p><ul><li>当前点击的方块是未挖出的地雷，将其值改为 X；</li><li>当前点击的是为未挖出的空方块，我们需要统计它周围相邻的方块里地雷的数量cnt（即M 的数量）。如果 cnt 为 0 ，则将其改为 B，且递归地处理周围<strong>八个</strong>未挖出地方块，如果 cnt 不为 0 ，将其改为数字即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = click[<span class="number">0</span>], y = click[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//判断当前方块是否为地雷</span></span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == <span class="string">'M'</span>)&#123;</span><br><span class="line">            board[x][y] = <span class="string">'X'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(board, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计当前空方块周围地雷数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[tx][ty] == <span class="string">'M'</span>)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//地雷数大于零，直接修改当前方块为地雷数</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            board[x][y] = (<span class="keyword">char</span>) (cnt + <span class="string">'0'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//周围没有地雷，递归地对周围八个方块进行搜索</span></span><br><span class="line">            board[x][y] = <span class="string">'B'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">                <span class="comment">//碰到边界或者不是未挖出的方块时返回</span></span><br><span class="line">                <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length || board[tx][ty] != <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dfs(board, tx, ty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)，m 和 n 为面板的长宽。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;529-扫雷游戏&quot;&gt;&lt;a href=&quot;#529-扫雷游戏&quot; class=&quot;headerlink&quot; title=&quot;529. 扫雷游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minesweeper/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;529. 扫雷游戏&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;让我们一起来玩扫雷游戏！&lt;/p&gt;
&lt;p&gt;给定一个代表游戏板的二维字符矩阵。 &lt;strong&gt;‘M’&lt;/strong&gt; 代表一个&lt;strong&gt;未挖出的&lt;/strong&gt;地雷，&lt;strong&gt;‘E’&lt;/strong&gt; 代表一个&lt;strong&gt;未挖出的&lt;/strong&gt;空方块，&lt;strong&gt;‘B’&lt;/strong&gt; 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的&lt;strong&gt;已挖出的&lt;/strong&gt;空白方块，&lt;strong&gt;数字&lt;/strong&gt;（’1’ 到 ‘8’）表示有多少地雷与这块&lt;strong&gt;已挖出的&lt;/strong&gt;方块相邻，&lt;strong&gt;‘X’&lt;/strong&gt; 则表示一个&lt;strong&gt;已挖出的&lt;/strong&gt;地雷。&lt;/p&gt;
&lt;p&gt;现在给出在所有&lt;strong&gt;未挖出的&lt;/strong&gt;方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 &lt;strong&gt;‘X’&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个&lt;strong&gt;没有相邻地雷&lt;/strong&gt;的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的&lt;strong&gt;未挖出&lt;/strong&gt;方块都应该被递归地揭露。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个&lt;strong&gt;至少与一个地雷相邻&lt;/strong&gt;的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果在此次点击中，若无更多方块可被揭露，则返回面板。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>回文子串</title>
    <link href="https://hoo334.github.io/2020/08/19/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/08/19/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2020-08-19T02:18:27.000Z</published>
    <updated>2020-08-19T02:45:23.029Z</updated>
    
    <content type="html"><![CDATA[<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></h4><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>输入的字符串长度不会超过 1000 。</li></ul><p>我们枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同时就拓展，否则就停止拓展。</p><p>当回文长度为奇数时，回文中心就是一个字符；当回文长度为偶数时，回文中心为两个字符。一个长度为 n 的字符串，可能的回文中心有 2n - 1 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; n; index++)&#123;</span><br><span class="line">            <span class="comment">//回文长度为奇数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index, k = index; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//回文长度为偶数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index, k = index + <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将回文长度为奇数和偶数的两种情况合在一起，我们令 <code>0 &lt;= index &lt; 2n - 1</code>，回文中心<code>(j, k)</code>，其中<code>j = index / 2, k = j + (index mod 2)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">2</span> * n - <span class="number">1</span>; index++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index / <span class="number">2</span>, k = index / <span class="number">2</span> + index % <span class="number">2</span>; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;647-回文子串&quot;&gt;&lt;a href=&quot;#647-回文子串&quot; class=&quot;headerlink&quot; title=&quot;647. 回文子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/palindromic-substrings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;647. 回文子串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。&lt;/p&gt;
&lt;p&gt;具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>有序列表转换二叉搜索树</title>
    <link href="https://hoo334.github.io/2020/08/18/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/18/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-08-18T01:46:47.000Z</published>
    <updated>2020-08-21T01:54:41.678Z</updated>
    
    <content type="html"><![CDATA[<h4 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a></h4><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><p>我们需要构造出平衡的二叉树，每次让左右子树的结点个数接近，我们可以找出链表元素的中位数作为根节点的值。链表中小于根节点的元素个数与大于根节点的元素个数要么相等，要么相差 1。我们递归地对左右子树进行构造。</p><p>设当前链表左端点为 left， 右端点为 right，具体范围为<code>[left, right)</code>，左闭右开区间。定义左闭右开区间的好处是，可以方便表示初始列表<code>[head, null)</code>，如果使用左闭右闭区间，则第一次需要遍历到链表末尾来获取 right 的值。在找出链表中位数结点 mid后，我们可以使用<code>[left, mid)</code>和<code>[mid.next, right)</code>来分别表示左右子树对应的列表。</p><p>使用快慢指针法来得到链表的中位数结点，fast 指针每次移动两次，slow 指针每次移动一次，当 fast 到达边界（fast == right 或 fast.next == right，right 的前驱结点为链表的最后一个结点）时停止，此时 slow 指向的元素就是链表的中位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//左闭右开区间 [left, right)</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//得到中间结点</span></span><br><span class="line">        ListNode mid = getMid(left, right);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(mid.val);</span><br><span class="line">        <span class="comment">//递归构造左右子树</span></span><br><span class="line">        root.left = buildTree(left, mid);</span><br><span class="line">        root.right =  buildTree(mid.next, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getMid</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        ListNode slow = left;</span><br><span class="line">        ListNode fast = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != right &amp;&amp; fast.next != right)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n logn)，空间复杂度O(log n)。 n 是链表的长度。</p><p>寻找链表的中位数是一个比较耗时的操作，在二叉搜索树的构建过程是一个中序遍历，遍历结果就是链表，我们可以使用一个指针 ptr 来指向下一个需要建立的链表结点，在构建二叉搜索树的同时不断将 ptr 向后移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode ptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ptr = head;</span><br><span class="line">        <span class="keyword">int</span> length = getLength(head);</span><br><span class="line"><span class="comment">//左闭右闭区间 [left, right]</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//得到链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//计算 mid 位置</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        <span class="comment">//先构建左子树</span></span><br><span class="line">        root.left = buildTree(left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//左子树构建完时，ptr 指向根节点</span></span><br><span class="line">        root.val = ptr.val;</span><br><span class="line">        ptr = ptr.next;</span><br><span class="line">        <span class="comment">//构建右子树</span></span><br><span class="line">        root.right = buildTree(mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(log n)。n 为链表的长度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;109-有序链表转换二叉搜索树&quot;&gt;&lt;a href=&quot;#109-有序链表转换二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;109. 有序链表转换二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;109. 有序链表转换二叉搜索树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="https://hoo334.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程实战</title>
    <link href="https://hoo334.github.io/2020/08/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    <id>https://hoo334.github.io/2020/08/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</id>
    <published>2020-08-17T04:48:00.000Z</published>
    <updated>2020-08-27T01:03:34.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>线程的优势：</p><ul><li>发挥多处理器强大的能力</li><li>建模的简单性（为模型中的每种类型的任务都分配一个专门的线程）</li><li>异步事件的简化处理</li><li>响应更灵敏的用户界面</li></ul><a id="more"></a><h4 id="线程带来的风险"><a href="#线程带来的风险" class="headerlink" title="线程带来的风险"></a>线程带来的风险</h4><h5 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h5><p>线程安全性可能是非常复杂的，在没有充分同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至会产生奇怪的结果。</p><h5 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h5><p>安全性的定义是”永远不发生糟糕的事情”，而活跃性关注于另一个目标“某件正确的事情最终会发生“。<strong>当某个操作无法继续执行下去时，就会发生活跃性问题。</strong>活跃性问题的形式之一就是无意中造成的无限循环。</p><h5 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h5><p>在设计良好的并发应用程序中，线程能提高程序的性能。但无论如何，线程会带来一定的运行时开销。在多线程程序中，当线程调度器挂起一个活跃线程并转而运行另一个线程时，就会频繁出现上下文切换操作，这会带来极大的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1-1 非线程安全的数值序列生成器</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 返回一个独一无二的值</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeSequence sequence = <span class="keyword">new</span> UnsafeSequence();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.print(sequence.getNext() + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有充分同步的情况下，生成的序列号可能相同（也可能全部不相同，但是多运行几次一定可以看到相同的序列号）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一次运行结果：</span><br><span class="line">0321054678</span><br></pre></td></tr></table></figure><p>我们将 getNext 修改为一个同步方法（添加 synchronized），就可修复上面的错误，每次都可以得到唯一的序列号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1-2 线程安全的数值序列生成器</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextValue++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sequence sequence = <span class="keyword">new</span> Sequence();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.print(sequence.getNext() + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>从非正式意义上来说，对象的状态是指存储在状态变量（例如实例和静态域）中的数据。<code>共享</code>意味着变量可以由多个线程同时访问，而<code>可变</code>意味着变量的值可以在生命周期内变化。</p><p>当多个线程访问某个状态变量并且其中有一个线程执行写入操作，必须采用<code>同步</code>机制来协同这些线程对变量的访问。Java 中的主要同步机制是关键字 <code>synchronized</code> ，它提供了一种独占的加锁方式，但“同步”这个术语还包括 volatile 类型的变量，显式锁（Explicit Lock） 以及原子变量。</p><blockquote><p>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误，有三种方式可以修复这个问题：</p><ol><li>不在线程中共享该状态变量</li><li>将该状态变量设置为不可变的变量</li><li>在访问状态变量时使用同步</li></ol></blockquote><p>在编写并发程序时，一种正常的编程方法就是：首先使代码正确运行，然后提高代码的速度。</p><h4 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h4><p>在线程安全性的定义中最核心的概念就是正确性，正确性的含义是，<strong>某个类的行为与其规范完全一致</strong>。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件（Post condition）来描述对象操作的结果。当多线程访问某个类时，这个类始终都能表现出正确的行为，那么这个类就是线程安全的。</p><blockquote><p>在线程安全的类中封装了必要的同步机制，因此客户端无需进一步采取同步措施。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span></span>&#123;<span class="comment">//Response 和Request 类定义一样</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//构造、setter、getter 省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-1 一个无状态的 Servlet</span></span><br><span class="line"><span class="comment">* 线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdderServlet</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = request.getValue();</span><br><span class="line">        System.out.println(<span class="string">"Init Value: "</span> + value);</span><br><span class="line">        value += <span class="number">6</span>;</span><br><span class="line">        System.out.println(<span class="string">"Modified Value: "</span> + value);</span><br><span class="line">        request.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与大多数 Servlet 相同，AdderServlet 是无状态的：它既不包含任何域，也不包含对任何其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。由于线程访问无状态对象的行为并不会影响其他线程中操作的正确性，因此无状态对象是线程安全的。</p><blockquote><p>无状态对象一定是线程安全的</p></blockquote><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>当我们在无状态对象中增加一个状态时，会出现什么情况？我们在 Servlet 中增加一个 long 类型的域，用它来统计请求的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2-2 在没有同步的情况下统计已请求数量的 Servlet</span></span><br><span class="line"><span class="comment"> * 非线程安全</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAdderServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = request.getValue();</span><br><span class="line">        System.out.println(<span class="string">"Init Value: "</span> + value);</span><br><span class="line">        value += <span class="number">6</span>;</span><br><span class="line">        System.out.println(<span class="string">"Modified Value: "</span> + value);</span><br><span class="line">        response.setValue(value);</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Request req = <span class="keyword">new</span> Request(<span class="number">11</span>);</span><br><span class="line">        Response resp = <span class="keyword">new</span> Response();</span><br><span class="line">        UnsafeAdderServlet servlet = <span class="keyword">new</span> UnsafeAdderServlet();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                servlet.service(req,resp);</span><br><span class="line">                System.out.println(servlet.getCount());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们调用 service 方法 200,000 次，最后的 count 也应该是 200,000 ，一次的运行结果却是 199,999。在并发量高的时候，count 值出现了偏差，这是因为自增操作包含三个独立的操作：读取 - 修改 - 写入，结果状态依赖于前面的状态。如果两个线程在没有同步的情况下对 count 变量进行自增操作，可能会带来偏差。以 count 初值为 9 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread 1:     read(9)  --&gt;  modify(9 + 1 &#x3D; 10)  --&gt;  wirteback(10)</span><br><span class="line">Thread 2:                     read(9)  --&gt;  modify(9 + 1 &#x3D; 10)  --&gt;  wirteback(10)</span><br></pre></td></tr></table></figure><p>最终 count 的值为 10，而正确的值为 11 ，这产生了偏差。在并发编程中，这种<strong>由不正确的时序而出现的不正确的结果是一种非常重要的情况</strong>，它有一个正式的名字：<strong>竞态条件</strong>。</p><p>当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作。</p><p>使用“先检查后执行”的一种常见情况就是延迟初始化。延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-3 延迟初始化中的竞态条件</span></span><br><span class="line"><span class="comment">* 非线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitRace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ExpensiveObject instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExpensiveObject <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ExpensiveObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LazyInitRace lazyInitRace = <span class="keyword">new</span> LazyInitRace();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(lazyInitRace.getInstance());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpensiveObject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExpensiveObject</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//假设创建对象时间为 200 ms，增加错误几率</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">concurrencyinpractice.chap2.ExpensiveObject@674827d5</span><br><span class="line">concurrencyinpractice.chap2.ExpensiveObject@674827d5</span><br><span class="line">concurrencyinpractice.chap2.ExpensiveObject@22673956</span><br></pre></td></tr></table></figure><p>字符@后面的十六进制数就是对象的哈希码值，在对同一个对象多次调用 hashcode 方法时，哈希码值应该不会改变，结果中出现了两个不同的哈希码值说明我们调用三次 getInstance 方法时，instance 被初始化了两次，这不是我们想要的结果。</p><p>为了保证线程安全性，“先检查后操作” 和 “读取 - 修改 - 写入” 操作必须是原子的，我们称这类操作为复合操作。可以使用锁来保证复合操作以原子方式执行，这里我们使用原子变量来修复 UnsafeAdderServlet 的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-4 使用 AtomicLong 类型的变量来统计已处理请求的数量</span></span><br><span class="line"><span class="comment">* 线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeAdderServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong count = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = request.getValue();</span><br><span class="line">        System.out.println(<span class="string">"Init Value: "</span> + value);</span><br><span class="line">        value += <span class="number">6</span>;</span><br><span class="line">        System.out.println(<span class="string">"Modified Value: "</span> + value);</span><br><span class="line">        response.setValue(value);</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Request req = <span class="keyword">new</span> Request(<span class="number">11</span>);</span><br><span class="line">        Response resp = <span class="keyword">new</span> Response();</span><br><span class="line">        SafeAdderServlet servlet = <span class="keyword">new</span> SafeAdderServlet();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                servlet.service(req,resp);</span><br><span class="line">                System.out.println(servlet.getCount());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序，我们看到最后的count 值为 500,000 与请求的次数相同。通过使用 AtomicLong 来代替 long 类型的计数器，能够确保所有对计数器状态的访问都是原子的。</p><p>当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍是线程安全的。</p><blockquote><p>在实际情况中，应尽可能地使用现有的线程安全对象（例如 AtomicLong）来管理类的状态。</p></blockquote><p>我们希望提升 Servlet 的性能，将最近计算的结果缓存起来，当两个相同的请求数值到来时，可以直接使用上一次的计算结果，而无须重新计算。</p><p>我们通过 AtomicReference 来管理最近执行的数值和结果，它能保证线程安全性吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-5 在没有足够原子性保证的情况下对最近计算结果进行缓存</span></span><br><span class="line"><span class="comment">* 非线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCachingAdderServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Integer&gt; lastNumber = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Integer&gt; lastResult = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">if</span>(request.equals(lastNumber.get()))&#123;</span><br><span class="line">            response.setValue(lastResult.get());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            response.setValue(request.getValue() + <span class="number">6</span>);</span><br><span class="line">            lastNumber.set(request.getValue());</span><br><span class="line">            Thread.sleep(<span class="number">3</span>);</span><br><span class="line">            lastResult.set(response.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"lastNumber: "</span> + lastNumber + <span class="string">"\t lastResult: "</span> + lastResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeCachingAdderServlet servlet = <span class="keyword">new</span> UnsafeCachingAdderServlet();</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    servlet.service(<span class="keyword">new</span> Request((<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>)), response);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">部分运行结果：</span><br><span class="line">lastNumber: 18 lastResult: null</span><br><span class="line">lastNumber: 33 lastResult: 27</span><br><span class="line">lastNumber: 42 lastResult: 83</span><br></pre></td></tr></table></figure><p>这部分结果中，只有第二行是我们期待的结果，其他两行的 result != number + 6。代码中的两组操作（见注释）每一个操作由两个原子操作组成，但这两个原子操作直接串行，不加以同步，这组操作仍是非线程安全的，因为在这两个原子操作中可能有其他线程修改了 AtomicReference 指向的值，这破坏了不变性条件。</p><blockquote><p>要保持状态的一致性，就要在单个原子操作中更新所有相关的状态变量。</p></blockquote><h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><p>Java 提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以 synchronized 来修饰的方法就是一种横跨整个方法体的同步代码块，该同步代码块的锁就是方法调用所在的对象。<strong>静态的 synchronized 方法以 Class 对象作为锁</strong>。</p><p>每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）。<strong>线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁</strong>。</p><p>在程序 2-6 中使用  synchronized 修饰 service 方法，在同一时刻只能有一个线程可以使用 service 方法，服务的响应性非常低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-6 能正确地缓存最新的计算结果，但并发性非常糟糕（不要这么做）</span></span><br><span class="line"><span class="comment">* 线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedAdderServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer lastNumber;</span><br><span class="line">    <span class="keyword">private</span> Integer lastResult;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span></span>&#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">if</span>(request.equals(lastNumber))&#123;</span><br><span class="line">            response.setValue(lastNumber);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            lastNumber = request.getValue();</span><br><span class="line">            response.setValue(request.getValue() + <span class="number">6</span>);</span><br><span class="line">            lastResult = response.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"lastNumber: "</span> + lastNumber + <span class="string">"\t lastResult: "</span> + lastResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedAdderServlet servlet = <span class="keyword">new</span> SynchronizedAdderServlet();</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                servlet.service(<span class="keyword">new</span> Request((<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>)), response);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”而不是“调用”。重入的一种实现方法是，<strong>为每个锁关联一个获取计数值和一个所有者线程</strong>，当计数值为 0 时，这个锁未被任何线程持有。当线程请求一个未被持有的锁时，JVM 将记下锁的持有者，并将计数值置为 1 ，如果同一个线程再次获取这个数，计数值将会递增。</p><p>程序 2-7 中，子类改写了父类的 synchronized 方法，然后调用父类中的方法如果没有可重入的锁，那么这段代码将产生死锁。由于 Widget 和 LoggingWidget 中的 doSomething 方法都是 synchronized 方法，因此每个 doSomething 方法在执行前都会获取 Widget 上的锁。如果内置锁是不可重入的，那么调用 super.doSomething 时无法获得 Widget 上的锁，这个锁已经被持有，线程将永远停顿下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-7 如果内置锁是不可重入的，这段代码会发生死锁</span></span><br><span class="line"><span class="comment">* 线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Widget::doSomething()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LoggingWidget::doSomething()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LoggingWidget widget = <span class="keyword">new</span> LoggingWidget();</span><br><span class="line">        widget.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h4><p>由于锁能使其保护的代码路径以穿行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。只要始终遵循这些协议，就能保证状态的一致性。</p><p>访问共享状态的复合操作都必须是原子操作以避免产生竞态条件。如果复合操作在执行过程中持有一个锁，那么会使复合操作成为原子操作。然而，仅仅将复合操作封装到同步代码块中是不够的。<strong>如果使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁</strong>。一种常见的错误认为：只有在写入共享变量时才需要同步，然而并非如此。（见3.1节）</p><blockquote><p>对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。</p></blockquote><p>一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。在许多线程安全类中都使用了这种模式，例如 Vector 和其他同步集合类。</p><blockquote><p>每个共享和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁在保护变量。</p></blockquote><p>只有被多个线程同时访问的可变数据才需要通过锁来保护。</p><blockquote><p>对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要同一个锁来保护。</p></blockquote><h4 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h4><p>在 UnsafeCachingAdderServlet 中，我们引入了缓存来提升性能，在缓存中需要使用共享状态，因此需要通过同步来维护状态的完整性。然而，如果使用 SynchronizedAdderServlet 中的同步方式，那么代码的执行性能将会十分糟糕。它通过 Servlet 对象的内置锁来保护每一个状态变量，这种简单且粗粒度的方法能保证线程安全性，但读出的代价很高。由于 service 是一个 synchronized 方法，因此每次只有一个线程可以执行，这背离了Servlet 框架的初衷，即 Servlet 需要能同时处理多个请求，这在负载过高的情况下将给用户带来糟糕的体验。</p><p>程序2-8中将 Servlet 的代码修改为两个独立的代码块，第一个代码块执行“先检查后执行”序列，另一个代码块负责对缓存更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-8 缓存最近计算的数值积计算结果的Servlet</span></span><br><span class="line"><span class="comment">* 线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedAdderServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer lastNumber;</span><br><span class="line">    <span class="keyword">private</span> Integer lastResult;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> hits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> cacheHits;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getHits</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">getCacheHitRatio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)cacheHits / (<span class="keyword">double</span>)hits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不要把从 request 提取数值等耗时操作放在同步代码块中</span></span><br><span class="line">        <span class="keyword">int</span> num = request.getValue();</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否命中缓存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            ++hits;</span><br><span class="line">            <span class="keyword">if</span>(lastNumber != <span class="keyword">null</span> &amp;&amp; num == lastNumber)&#123;</span><br><span class="line">                ++cacheHits;</span><br><span class="line">                result = lastResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有命中缓存就更新缓存的值</span></span><br><span class="line">        <span class="keyword">if</span>(result == Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="comment">//计算结果</span></span><br><span class="line">            result = request.getValue() + <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;<span class="comment">//更新缓存</span></span><br><span class="line">                lastNumber = request.getValue();</span><br><span class="line">                lastResult = result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setValue(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CachedAdderServlet servlet = <span class="keyword">new</span> CachedAdderServlet();</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                servlet.service(<span class="keyword">new</span> Request((<span class="keyword">int</span>)(Math.random() * <span class="number">4</span>)), response);</span><br><span class="line">                System.out.println(<span class="string">"Cache Hit Ratio: "</span> + servlet.getCacheHitRatio());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通常，在简单性与性能之间存在相互制约的因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能破坏安全性）。</p></blockquote><p>当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论执行计算密集的操作，还是执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性问题。</p><blockquote><p>当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络 I/O 或控制台 I/O ），一定不要持有锁。</p></blockquote><h3 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h3><p>要编写正确的并发程序，关键问题在于：在访问共享的可变状态时需要进行正确的管理。我们已经知道同步代码块和同步方法可以确保以原子的方式执行操作，但一种常见的误解是，认为关键字 synchronized 只能用于实现原子性。同步还有一个重要的方面：<strong>内存可见性（Memory Visibility）</strong>。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。有多个读线程和写线程同时对一个变量进行操作，读线程可能读到的是过期的数据，我们无法确保读线程能<strong>适时</strong>地看到其他线程写入的值，有时甚至是不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步。</p><p>程序 3-1 中说明了当多个线程在没有同步的情况下共享数据时出现的错误。在代码中，主线程和读线程都将访问共享变量 ready 和 number。主线程启动读线程，然后将 numer 设为 42，并将 ready 设为 true。读线程一直循环知道发现 ready 的值变为 true 然后输出number。虽然看起来可能会输出 42（运行了好多次，都是 42。。），但事实上很可能输出 0 ，或者根本无法终止。这是因为在代码中没有使用足够的同步机制，因此无法保证主线程写入的 ready值和 number 值对于读线程来说是可见的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-1 在没有同步的情况下共享变量</span></span><br><span class="line"><span class="comment">* 非线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!ready)&#123;</span><br><span class="line">                <span class="comment">//暂停当前正在执行的线程对象（及放弃当前拥有的cpu资源）,并执行其他线程</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NoVisibility 可能会输出 0 ，因为读线程看到了 ready 的值，但没有看到 number 的值，这种现象称为重排序（Reordering）。</p><blockquote><p>在没有同步的情况下，编译器、处理器以及运行时都可能对操作的执行顺序进行意向不到的调整。只要有数据在多个线程之间共享，就使用正确的同步。</p></blockquote><p>NoVisibility 展示了在缺乏同步的程序中可能产生错误结果的一种情况：失效数据。当读线程查看 ready 变量时，可能会得到一个已经失效的值。更糟糕的是，可能获得一个变量的最新值而获得另一个变量的失效值。失效数据还可能导致一些令人困惑的故障，例如意料之外的异常、被破坏的数据结构、不精确的计算以及无限循环等。</p><p>程序 3-2 中的 MutableInteger 不是线程安全的，get  和 set 都是在没有同步的情况下访问 value的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-2 非线程安全的可变整数类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序 3-3 SynchronizedInteger 通过对 get  和 set 方法进行同步，可以使之成为一个线程安全的类。仅对 set 方法进行同步是不够的，调用 get 的线程仍然会看见失效值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-3 线程安全的可变整数类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性。</p><p>最低安全性适用于绝大多数变量，但有一个例外：非 volatile 类型的 64 位数值变量（double 和 long）。Java 内存模型要求，变量的读取和写入操作必须是原子操作，但对于非 volatile 类型的 long 和 double 变量，JVM 允许将64 位的读写操作分为两个 32 位的操作。当读取到一个新值的高 32 位 和 旧值的低 32 位组合的 64 位数时，就出现了错误。</p><blockquote><p>在多线程程序中使用共享且可变的 long 和 double 等类型的变量也是不安全的，除非用 volatile 来声明它们，或者用锁保护起来。</p></blockquote><p>内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。当后一个线程执行由锁保护的同步代码块时，可以看到前一个线程之前在同一个同步代码块中的所有操作结果。</p><blockquote><p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p></blockquote><p>Java 语言提供了一种稍弱的同步机制，即 <strong>volatile 变量，用来确保将变量的更新操作通知到其他线程。</strong>当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。<strong>volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</strong></p><p>在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 synchronized 关键字更轻量级的同步机制。从内存可见性的角度来看，写入 volatile 变量相当于退出同步代码块，而读取 volatile 变量相当于进入同步代码块。</p><blockquote><p>仅当 volatile 变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用 volatile 变量。</p></blockquote><p>程序 3-4 给出了 volatile 变量的一种典型用法：检查某个状态标记以判断是否退出循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-4 数绵羊</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> asleep;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">while</span>(!asleep)</span><br><span class="line">        countSomeSheep();</span><br></pre></td></tr></table></figure><p>volatile 的语义不足以保证递增操作的原子性（count），除非你能确保只有一个线程对变量执行写操作。（如果存在两个线程对变量进行写操作，需要一种机制来保持这两个线程之间的互斥关系，但 volatile 只能保证可见性，不能保证原子性）</p><blockquote><p>加锁机制既可以确保可见性又可以保证原子性，volatile 变量只能保证可见性。</p></blockquote><p>当且仅当满足以下所有条件时，才应该使用 volatile 变量：</p><ul><li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值</li><li>该变量不会与其他状态变量一起纳入不变性条件中</li><li>在访问变量时不需要加锁</li></ul><h4 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h4><p>“发布（Publish）”一个对象指，使对象能够在当前作用域之外的代码中使用。“逸出（Escape）”指，当某个不应该发布的对象被发布。</p><p>发布对象最简单的方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象。如 3-5 所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-5 发布一个对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knownSecrets;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    knownSecrets = <span class="keyword">new</span> HashSet&lt;Secret&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发布某个对象时，可能会间接地发布其他对象。如果将一个 Secret 对象添加到集合 knownSecrets 中，那么同样会发布这个对象，因为任何代码都能遍历这个集合，获得Secret 对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-6 使内部的可变状态逸出（不要这么做）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">        <span class="string">"AK"</span>, <span class="string">"AL"</span> ...</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String[] getStates()&#123;<span class="keyword">return</span> states; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，任何调用者都能修改 states 数组的内容，数组states已经逸出了它所在的作用域。</p><p>当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。</p><p>最后一种发布对象或其内部状态的机制就是发布一个内部类的实例。3-7 中，当 ThisEscape 发布 EventListener 时，也隐含地发布了 ThisEscape 实例本身，因为在这个内部类实例中包含了对 ThisEscape 实例地隐含引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-7 隐式地使 this 引用逸出（不要这么做）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span></span>&#123;</span><br><span class="line">        source.registerListener(<span class="keyword">new</span> EventListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>&#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ThisEscape 中给出了逸出地一个特殊示例，即 this 引用在构造函数中逸出。当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。在构造过程中使 this 引用逸出的一个常见错误是：在构造函数中启动一个线程。如果想在构造函数中注册一个时间监听器或启动线程，可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-8 使用工厂方法来防止 this 引用在构造过程中逸出</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">        listener = <span class="keyword">new</span> EventListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>&#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span></span>&#123;</span><br><span class="line">        SafeListener safe = <span class="keyword">new</span> SafeListener();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果尽在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（Thread Confinement）。</p><p>栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-9 基本类型的局部变量与引用变量的线程封闭性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span> </span>&#123;</span><br><span class="line">        SortedSet&lt;Animal&gt; animals;</span><br><span class="line">        <span class="keyword">int</span> numPairs = <span class="number">0</span>;</span><br><span class="line">        Animal candidate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// animals 被封闭在方法中，不要使它们逸出</span></span><br><span class="line">        animals = <span class="keyword">new</span> TreeSet&lt;Animal&gt;(<span class="keyword">new</span> SpeciesGenderComparator());</span><br><span class="line">        animals.addAll(candidates);</span><br><span class="line">        <span class="keyword">for</span> (Animal a : animals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidate == <span class="keyword">null</span> || !candidate.isPotentialMate(a))</span><br><span class="line">                candidate = a;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ark.load(<span class="keyword">new</span> AnimalPair(candidate, a));</span><br><span class="line">                ++numPairs;</span><br><span class="line">                candidate = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numPairs;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果发布了对 animals 的引用，那么线程封闭性将被破坏，并导致对象 animals 的逸出。</p><p>维持线程封闭性的一种更规范方法是使用 ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。 </p><p>例如，在单线程程序中可能维持一个全局的数据库连接，并在程序启动时初始化这个连接，由于 JDBC 连接对象不一定是线程安全的。通过将 JDBC 的连接保存到 ThreadLocal 对象中，每个线程都会拥有属于自己的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-10 使用 ThreadLocal 来维持线程封闭性</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHandler= <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Connection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当第一次调用 get 方法时，initialValue 将会被调用</span></span><br><span class="line">        <span class="keyword">return</span> connectionHandler.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用这项技术。</p><p>ThreadLocal 变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。</p><h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><p>满足同步需求的另一种方法是使用不可变对象（Immutable Object）。如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性是不可变对象的固有属性，它们的不变性条件是由构造函数创建的，只要它们的状态不改变，那么这些不变性条件就能得以维持。</p><blockquote><p>不可变对象一定是线程安全的。</p></blockquote><p>当满足以下条件时，对象才是不可变的：</p><ul><li>对象创建以后其状态不能改变</li><li>对象的所有域都是 final 类型</li><li>对象是正确创建的（在创建对象期间 this 引用没有逸出）</li></ul><p>在不可变对象的内部仍可以使用可变对象来管理它们的状态，如程序 3-11 所示，但是其中的 Set 对象在构造完成之后无法对其进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-11 在可变对象基础上构建的不可变类</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stooges.add(<span class="string">"Moe"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Larry"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Curly"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStoogeNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; stooges = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">        stooges.add(<span class="string">"Moe"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Larry"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Curly"</span>);</span><br><span class="line">        <span class="keyword">return</span> stooges.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键字 final 可以视为 C++ 中 const 机制的一种受限版本，用于构造不可变对象。final 类型的域是不能修改的（但如果 final 域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。final 域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。</p><blockquote><p>正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为 final 域”也是一个良好的编程习惯。</p></blockquote><p>我们看一个因式分解 Servlet，它包含两个原子操作：更新缓存的结果，以及判断缓存中的数值是否等于请求的数值。每当需要对一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据。例如 3-12 的 OneValueCache。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-12 对数值及其因数分解结果进行缓存的不可变容器类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        <span class="comment">//如果没有调用 copyOf 函数，那么 OneValue 就是不可变的</span></span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于在访问和更新多个相关变量时出现的竞争条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。</p><p>程序 3-13 中的 VolatileCachedFactorizer 使用了 OneValueCache 来保存缓存的数值及其因数。当一个线程将 volatile 类型的 cache 设置为引用一个新的 OneValueCache 时，其他线程就会立即看到最新缓存的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-13 使用指向不可变容器对象的 volatile 类型引用以缓存最新的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            <span class="comment">//更新缓存</span></span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encodeIntoResponse</span><span class="params">(ServletResponse resp, BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BigInteger <span class="title">extractFromRequest</span><span class="params">(ServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(<span class="string">"7"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger[] factor(BigInteger i) &#123;</span><br><span class="line">        <span class="comment">// Doesn't really factor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger[]&#123;i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h4><p>在某些情况下我们希望在多个线程间共享对象，此时必须确保安全地进行共享。如果像程序 3-14 那样将对象引用保存到公有域中，那么还不足以安全地发布这个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-14 在没有足够同步的情况下发布对象（不要这么做）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuffIntoPublic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Holder holder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于存在可见性问题，其他线程看到的 Holder 对象将处于不一致的状态，即使该对象的构造函数中已经正确地构造了不变性条件。这种不正确地发布将<strong>导致其他线程看到尚未创建完成的对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-15 由于未被正确发布，因此这个类可能出现故障</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSanity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n != n)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"This statement is false."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于没有使用同步来确保 Holder 对象对其他线程可见，因此将 Holder 称为“未被正确发布”。除了发布对象的线程外，其他线程可以看到的 Holder 域是一个失效值，因此将看到一个空引用或之前的旧值。</p><blockquote><p>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。</p></blockquote><p>在没有额外同步地情况下，也可以安全地访问 final 类型的域。然而，如果 final 类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态是仍然需要同步。</p><p>要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：</p><ul><li>在静态初始化函数中初始化一个对象引用。</li><li>将对象的引用保存到 volatile 类型的域或者 AtomicReference 对象中。</li><li>将对象的引用保存到某个正确构造对象的 final 类型域中。</li><li>将对象的引用保存到一个由锁保护的域中。</li></ul><p>如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象叫做“事实不可变对象（Effectively Immutable Object）”。</p><blockquote><p>在没有额外同步的情况下，任何线程都可以安全得使用被安全发布得事实不可变对象。</p></blockquote><p>如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态得可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保继续修改操作的可见性。</p><p>对象的发布需求取决于它的可变性：</p><ul><li>不可变对象可以通过任意机制来发布</li><li>事实不可变对象必须通过安全方式发布</li><li>可变对象必须通过安全方式发布，并且必须是线程安全的或者由某个锁保护起来</li></ul><p>在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：</p><ol><li><strong>线程封闭</strong>。线程封闭的对象只能由一个而线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。</li><li><strong>只读共享</strong>。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。</li><li><strong>线程安全共享</strong>。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步同步。</li><li><strong>保护对象</strong>。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li></ol><h3 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;线程的优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发挥多处理器强大的能力&lt;/li&gt;
&lt;li&gt;建模的简单性（为模型中的每种类型的任务都分配一个专门的线程）&lt;/li&gt;
&lt;li&gt;异步事件的简化处理&lt;/li&gt;
&lt;li&gt;响应更灵敏的用户界面&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://hoo334.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="https://hoo334.github.io/2020/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-08-17T01:39:30.000Z</published>
    <updated>2020-08-17T01:49:06.285Z</updated>
    
    <content type="html"><![CDATA[<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p></blockquote><a id="more"></a><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回 <code>true</code> 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>返回 <code>false</code> 。</p><p>一颗树是平衡二叉树，当且仅当所有子树都是二叉平衡树，我们可以使用递归的方式来判断二叉树是否为平衡二叉树。</p><p>我们使用 height 函数来求树的最大高度，如果左右子树的高度不超过 1 ，再分别递归地遍历左右子节点，并判断左右子树是否为平衡二叉树。这是一个自顶向下的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(length(root.left) - length(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(length(root.left), length(root.right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，最坏情况下，二叉树为链表，遍历所有结点时间复杂度O(n)，计算高度时间复杂度为O(n)。</p><p>空间复杂度O(n)。</p><p>我们可以递归地判断当前结点的左右子树是否平衡，再判断以当前结点为根的树是否平衡，如果平衡，返回其高度（不小于 0 ），否则返回 - 1，代表不是平衡二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftLength = length(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightLength = length(root.right);</span><br><span class="line">        <span class="keyword">if</span>(leftLength == -<span class="number">1</span> || rightLength == -<span class="number">1</span> || Math.abs(leftLength - rightLength) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftLength, rightLength) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;110-平衡二叉树&quot;&gt;&lt;a href=&quot;#110-平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;110. 平衡二叉树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/balanced-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;110. 平衡二叉树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过1。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
