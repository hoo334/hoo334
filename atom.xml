<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2020-09-15T01:08:50.920Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解数独</title>
    <link href="https://hoo334.github.io/2020/09/15/%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
    <id>https://hoo334.github.io/2020/09/15/%E8%A7%A3%E6%95%B0%E7%8B%AC/</id>
    <published>2020-09-15T00:52:11.000Z</published>
    <updated>2020-09-15T01:08:50.920Z</updated>
    
    <content type="html"><![CDATA[<h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></h4><p>编写一个程序，通过已填充的空格来解决数独问题。</p><p>一个数独的解法需<strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li></ol><a id="more"></a><p>空白格用 <code>&#39;.&#39;</code> 表示。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200915085345737.png" alt="image-20200915085345737"></p><p>一个数独。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200915085359798.png" alt="image-20200915085359798"></p><p>答案被标成红色。</p><p><strong>Note:</strong></p><ul><li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li><li>你可以假设给定的数独只有唯一解。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><p>由于每个数字只能在同一行、同一列和同一个九宫格中只会出现一次，我们使用三个数组来标记该数字是否出现，如果出现则直接退出递归。同时使用一个数组保存剩余的空位，对每个空位尝试放入 1- 9的数字，如果将所有空位都使用完，没有出现错误则发现了一种解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] line = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] column = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][][] block = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="keyword">int</span>[]&gt; spaces = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">//保存空位</span></span><br><span class="line">                    spaces.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//标记已存在的数字</span></span><br><span class="line">                    <span class="keyword">int</span> digit = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//从第一个空位开始递归</span></span><br><span class="line">        dfs(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将所有空位用完，找到了一组解</span></span><br><span class="line">        <span class="keyword">if</span>(pos == spaces.size())&#123;</span><br><span class="line">            valid = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//获取一个空位</span></span><br><span class="line">        <span class="keyword">int</span>[] space = spaces.get(pos);</span><br><span class="line">        <span class="keyword">int</span> i = space[<span class="number">0</span>], j = space[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//尝试将该空位中放入 1-9 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> digit = <span class="number">0</span>; digit &lt; <span class="number">9</span> &amp;&amp; !valid; ++digit)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit])&#123;</span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="keyword">true</span>;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>) (digit + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">                dfs(board, pos + <span class="number">1</span>);</span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;37-解数独&quot;&gt;&lt;a href=&quot;#37-解数独&quot; class=&quot;headerlink&quot; title=&quot;37. 解数独&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sudoku-solver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;37. 解数独&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;编写一个程序，通过已填充的空格来解决数独问题。&lt;/p&gt;
&lt;p&gt;一个数独的解法需&lt;strong&gt;遵循如下规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一个以粗实线分隔的 &lt;code&gt;3x3&lt;/code&gt; 宫内只能出现一次。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>JPA中@Transactional怎么用？</title>
    <link href="https://hoo334.github.io/2020/09/11/@Transactional%E5%88%B0%E5%BA%95%E6%9C%89%E5%95%A5%E7%94%A8/"/>
    <id>https://hoo334.github.io/2020/09/11/@Transactional%E5%88%B0%E5%BA%95%E6%9C%89%E5%95%A5%E7%94%A8/</id>
    <published>2020-09-11T12:59:08.000Z</published>
    <updated>2020-09-15T00:44:24.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先新建一个 SpringBoot 项目，修改 pom.xml，增加以下内容：</p><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mysql --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后新建配置文件 application.yml，我们需要在本地有个 test 数据库。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/test?useSSL=true&amp;characterEncoding=utf-8&amp;serverTimezone=Hongkong</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">org.hibernate.dialect.MySQL5InnoDBDialect</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>新建实体类 User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"usr"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建启动类 DemoMain：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>  <span class="comment">//开启事务管理</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoMain<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，打开Navicat，可以看到 test 数据库中有一张 usr 表。</p><p>在Navicat 中插入两个User：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into usr(money) values(10000);</span><br><span class="line">insert into usr(money) values(0);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200911211455133.png" alt="image-20200911211455133"></p><p>到这里，一切准备就绪。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>新建 UserRepository ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Modifying;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Query;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"update usr set money = money - 1 where id = ?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(Long userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"update usr set money = money + 1 where id = ?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Long userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub()</code>方法使用户 1 账户减少一块钱，<code>add()</code>方法使用户 2 账户增加一块钱。</p><p>实现 UserService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Transactional //重点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户 1 向用户 2 转一千块（每次一块）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            userRepository.sub(<span class="number">1L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户 2 每次收到 1 块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            userRepository.add(<span class="number">2L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>transfer()</code>方法模拟，用户 1 向用户 2 转账 1000 次，每次 1000 块，但是用户 2 需要等待用户 1 的所有转出都完成才开始转入。</p><p>新建 UserController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/transfer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">transfer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.transfer();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"done"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>现在启动DemoMain，访问 <a href="http://localhost:8080/transfer" target="_blank" rel="noopener">http://localhost:8080/transfer</a> ，然后<strong>立即</strong>关闭这个程序。</p><p>现在我们来看 usr 表</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200911212851901.png" alt="image-20200911212851901"></p><p> 发现它们账户总和资金并不是 10000 ，这是非常危险的，转账丢钱了！查看控制栏我们也能看到 Hibernate 执行的 sql 信息。</p><p>我们再试一次，先启动 DemoMain，访问 <a href="http://localhost:8080/transfer" target="_blank" rel="noopener">http://localhost:8080/transfer</a> ，然后<strong>立即</strong>关闭 MySQL（模拟一次数据库故障），然后再启动 MySQL。</p><p>再看 usr 表</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200911213334624.png" alt="image-20200911213334624"></p><p>钱又变少了！！</p><p>看到这里，你可能已经猜到了 <code>@Transactional</code>注解是用来干啥的，它就是用来保证转账的金额总和不变。</p><p>现在我们将<code>transfer()</code>方法上的<code>@Transactional</code>恢复，然后将两个账户恢复至初始状态（账户 1 中 10000块，账户 2 中 0 块，PS：这两句 SQL 会写吧。。）</p><p>我们再尝试一次服务故障，发现控制栏中依然有 Hibernate 执行的 sql 信息，打开 usr 表，账户 1 中依然有 10000块，账户 1 的所有转账都失败了！</p><p>再试一次数据库故障，账户 1 中依然有 10000 块，转账依然失败。</p><p>这种情况是符合我们的预期，宁可失败，也不能少钱。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常来说，repository 实例的 CRUD 方法是事务的，如果自己定义 SQL，需要在除 SELECT 语句的方法（INSERT、UPDATE 等）上加上<code>@Transactional</code>（保证事务性）和<code>@Modifying</code>。</p><p>另一种方法就是在 service 的方法上添加<code>@Transactional</code>注解，现在 repository 上的<code>@Transactional</code>注解被忽略，永远使用的是最外层的 @Transactional 注解。注意：必须要在启动类上添加 <code>@EnableTransactionManagement</code>开启事务管理。</p><p>如果这个事务在中途失败了，Spring 会将该事务回滚。</p><p><strong>由于个人水平有限，如有错误和不足请轻喷</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;首先新建一个 SpringBoot 项目，修改 pom.xml，增加以下内容：&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://hoo334.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://hoo334.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>组合总和III</title>
    <link href="https://hoo334.github.io/2020/09/11/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/"/>
    <id>https://hoo334.github.io/2020/09/11/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/</id>
    <published>2020-09-11T04:38:58.000Z</published>
    <updated>2020-09-11T04:50:29.049Z</updated>
    
    <content type="html"><![CDATA[<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a></h4><p>找出所有相加之和为 <strong><em>n</em></strong> 的 <strong>k</strong> 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure><p>需要注意的是，不能包含重复的数字，不能包含重复的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> n 剩余的数字之和</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> k 剩余的数字个数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> min 当前能选取的最小数字</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> path 递归路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> min, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 和为 0 且 剩余数字个数为 0 将当前路径加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//从最小值开始递归</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = min; k &gt; <span class="number">0</span> &amp;&amp; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; n)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            <span class="comment">//下一次选择只能选择比自己大的数字</span></span><br><span class="line">            dfs(n - i, k - <span class="number">1</span>, i + <span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;216-组合总和-III&quot;&gt;&lt;a href=&quot;#216-组合总和-III&quot; class=&quot;headerlink&quot; title=&quot;216. 组合总和 III&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;216. 组合总和 III&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;找出所有相加之和为 &lt;strong&gt;&lt;em&gt;n&lt;/em&gt;&lt;/strong&gt; 的 &lt;strong&gt;k&lt;/strong&gt; 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>组合总和II</title>
    <link href="https://hoo334.github.io/2020/09/10/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/"/>
    <id>https://hoo334.github.io/2020/09/10/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/</id>
    <published>2020-09-10T02:15:43.000Z</published>
    <updated>2020-09-10T02:42:55.155Z</updated>
    
    <content type="html"><![CDATA[<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></h4><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>此题与第 39 题差不多，只是条件限制有些不同。我们首先写出允许重复的初始程序，然后再添加限制条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="number">0</span>, target, candidates, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, ArrayDeque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = start; index &lt; candidates.length; index++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cur = candidates[index];</span><br><span class="line">            <span class="keyword">if</span>(target - cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path.addLast(cur);</span><br><span class="line">            dfs(index + <span class="number">1</span>, target - cur, candidates, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>candidates = [1, 2, 2, 2, 5]</code>，<code>target = 5</code> 时运行得到的结果为<code>[[1,2,2],[1,2,2],[1,2,2],[5]]</code>，<code>[1, 2, 2]</code>这个结果重复了三次。</p><p>想到可以在递归的时候限制，遇到重复的元素就跳过，我们写出如下版本（错误示例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, ArrayDeque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">         ans.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> index = start; index &lt; candidates.length; index++)&#123;</span><br><span class="line">         <span class="keyword">int</span> cur = candidates[index];</span><br><span class="line">         <span class="keyword">if</span>(target - cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//跳过重复的元素            </span></span><br><span class="line"><span class="keyword">if</span>(index &gt; <span class="number">0</span> &amp;&amp; candidates[index] == candidates[index - <span class="number">1</span>])&#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         path.addLast(cur);</span><br><span class="line">         dfs(index + <span class="number">1</span>, target - cur, candidates, path);</span><br><span class="line">         path.removeLast();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再次运行上述示例，我们得到结果<code>[[5]]</code>，<code>[1, 2, 2]</code>被剪掉了。当 index = 2 时，发现 index - 1 的值与它的值相同，则剪掉了这一分支，但我们需要保留这条分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1    index &#x3D; 0      第 1 层</span><br><span class="line">   &#x2F;</span><br><span class="line">  2      index &#x3D; 1      第 2 层</span><br><span class="line"> &#x2F;</span><br><span class="line">2        index &#x3D; 2      第 3 层</span><br></pre></td></tr></table></figure><p>对于下图中的递归路径，我们需要保留左边的分支，删除右边的分支，使每层都可以保留一个与上一层相同的元素，同时在每一层中，只能有一个相同的元素。这样就保留了最左侧的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F;     \</span><br><span class="line">2       2</span><br></pre></td></tr></table></figure><p>具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, ArrayDeque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">         ans.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> index = start; index &lt; candidates.length; index++)&#123;</span><br><span class="line">         <span class="keyword">int</span> cur = candidates[index];</span><br><span class="line">         <span class="keyword">if</span>(target - cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//跳过重复的元素，当 index == start 时不剪枝，保留最左侧的分支            </span></span><br><span class="line"><span class="keyword">if</span>(index &gt; start &amp;&amp; candidates[index] == candidates[index - <span class="number">1</span>])&#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         path.addLast(cur);</span><br><span class="line">         dfs(index + <span class="number">1</span>, target - cur, candidates, path);</span><br><span class="line">         path.removeLast();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/" target="_blank" rel="noopener">weiwei哥的题解</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;40-组合总和-II&quot;&gt;&lt;a href=&quot;#40-组合总和-II&quot; class=&quot;headerlink&quot; title=&quot;40. 组合总和 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;40. 组合总和 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt; 的组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的每个数字在每个组合中只能使用一次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>组合总和</title>
    <link href="https://hoo334.github.io/2020/09/09/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>https://hoo334.github.io/2020/09/09/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</id>
    <published>2020-09-09T01:08:46.000Z</published>
    <updated>2020-09-09T03:17:30.924Z</updated>
    
    <content type="html"><![CDATA[<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></h4><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的数字可以无限制重复被选取。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>1 &lt;= candidates[i] &lt;= 200</code></li><li><code>candidate</code> 中的每个元素都是独一无二的。</li><li><code>1 &lt;= target &lt;= 500</code></li></ul><p>由于 candidates 是无序的，只能暴力搜索全部的解。考虑剪枝，先将 candidates 数组排序，在搜索的过程中如果得到的当前总和大于 target ，那么后面的元素总和都不用尝试（由于数组递增，它们的总和比大于当前总和）。</p><p>数字可以被重复选取代表下一次递归时，还可以取当前选取的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//排序是剪枝的基础</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="number">0</span>, target, candidates, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, ArrayDeque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = candidates.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; start + i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = candidates[start + i];</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(target - cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                path.addLast(cur);</span><br><span class="line">                <span class="comment">//只能使用当前元素及其右侧的值，避免重复解</span></span><br><span class="line">                dfs(start + i, target - cur, candidates, path);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;39-组合总和&quot;&gt;&lt;a href=&quot;#39-组合总和&quot; class=&quot;headerlink&quot; title=&quot;39. 组合总和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;39. 组合总和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个&lt;strong&gt;无重复元素&lt;/strong&gt;的数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt; 的组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的数字可以无限制重复被选取。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>组合</title>
    <link href="https://hoo334.github.io/2020/09/08/%E7%BB%84%E5%90%88/"/>
    <id>https://hoo334.github.io/2020/09/08/%E7%BB%84%E5%90%88/</id>
    <published>2020-09-08T03:21:14.000Z</published>
    <updated>2020-09-08T03:32:21.466Z</updated>
    
    <content type="html"><![CDATA[<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></h4><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>以 n = 4， k = 2为例，我们可以发现如下递归结构：</p><ol><li>如果组合里面有 <code>1</code> ，那么需要在<code>[2, 3, 4]</code>里再找 1 个数；</li><li>如果组合里有 <code>2</code> ，那么需要在<code>[3, 4]</code>里再找 1 个数。这里不能再包含 1 ，因为[1, 2] 这个组合已经在第一种情况中包含。</li></ol><p>我们可以写出如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在[start, end] 选取 k 个数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> k, List&lt;Integer&gt; cur)</span></span>&#123;</span><br><span class="line"><span class="comment">// k == 0 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//对每一个数进行枚举</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; start + i &lt;= end; i++)&#123;</span><br><span class="line">            cur.add(start + i);</span><br><span class="line">            <span class="comment">//继续在[start + i + 1, end] 范围内选取 k - 1 个数</span></span><br><span class="line">            dfs(start + i + <span class="number">1</span>, end, k - <span class="number">1</span>, cur);</span><br><span class="line">            <span class="comment">//删除当前选取的数，重新循环</span></span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们注意到，使用ArrayList 进行删除效率很低，将其改为 ArrayDeque。在进行循环的时候，我们选取的退出条件为<code>start + i &lt;= end</code>，其实还可以缩小一点，当<code>[start + i, end]</code> 中的元素小于 k 个时，我们可以直接退出，将该条件修改为<code>start + i &lt;= end - k + 1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> k, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当[start + i, end]范围内数字个数小于 k 个时退出循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; start + i &lt;= end - k + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            path.addLast(start + i);</span><br><span class="line">            dfs(start + i + <span class="number">1</span>, end, k - <span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;77-组合&quot;&gt;&lt;a href=&quot;#77-组合&quot; class=&quot;headerlink&quot; title=&quot;77. 组合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combinations/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;77. 组合&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定两个整数 &lt;em&gt;n&lt;/em&gt; 和 &lt;em&gt;k&lt;/em&gt;，返回 1 … &lt;em&gt;n&lt;/em&gt; 中所有可能的 &lt;em&gt;k&lt;/em&gt; 个数的组合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>表示数值的字符串</title>
    <link href="https://hoo334.github.io/2020/09/02/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/09/02/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-09-02T01:31:05.000Z</published>
    <updated>2020-09-02T02:16:18.770Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 20. 表示数值的字符串</a></h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p><a id="more"></a><p>确定有限状态自动机是一类计算模型。它包含一系列状态，这些状态中：</p><ul><li>有一个特殊状态，被称为<em>初始状态</em>。</li><li>还有一系列状态被称为<em>接受状态</em>，他们组成了一个特殊的集合。其中一个状态可能既是<em>初始状态</em>，也是<em>接受状态</em>。</li></ul><p>起初这个自动机处于初始状态，然后，它顺序地读取字符串中地每一个字符，并根据当前状态和读入的字符，按照某个事先约定好地转移规则，从当前状态转移到下一个状态，当状态转移完成后，它继续读取下一个字符。当字符串读完后，如果这个自动机处于某个接受状态，则判断该字符串被接受；否则判定该字符串被拒绝。</p><p>如果在输入的过程中某一步转移失败了，判断字符串被拒绝。</p><p>用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：</p><ol><li>起始的空格</li><li>符号位</li><li>整数部分</li><li>左侧有整数的小数点</li><li>左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）</li><li>小数部分</li><li>字符 e</li><li>指数部分的符号位</li><li>指数部分的整数部分</li><li>末尾的空格</li></ol><p>将状态之间的转移规则画成图。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200902095846914.png" alt="image-20200902095846914"></p><p>我们需要处理转移失败的情况。为了处理这种情况，我们创建一个特殊的拒绝状态，一旦自动机转移到这个特殊状态，我们可以立即判定该字符串不被接受。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储每个点的起始状态和接受状态</span></span><br><span class="line">        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = <span class="keyword">new</span> HashMap&lt;State, Map&lt;CharType, State&gt;&gt;();</span><br><span class="line">        Map&lt;CharType, State&gt; initialMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_INITIAL);</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);</span><br><span class="line">            put(CharType.CHAR_SIGN, State.STATE_INT_SIGN);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INITIAL, initialMap);</span><br><span class="line">        Map&lt;CharType, State&gt; intSignMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INT_SIGN, intSignMap);</span><br><span class="line">        Map&lt;CharType, State&gt; integerMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INTEGER, integerMap);</span><br><span class="line">        Map&lt;CharType, State&gt; pointMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_POINT, pointMap);</span><br><span class="line">        Map&lt;CharType, State&gt; pointWithoutIntMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);</span><br><span class="line">        Map&lt;CharType, State&gt; fractionMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_FRACTION, fractionMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">            put(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP, expMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expSignMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP_SIGN, expSignMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expNumberMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);</span><br><span class="line">        Map&lt;CharType, State&gt; endMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_END, endMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        State state = State.STATE_INITIAL;</span><br><span class="line"><span class="comment">//从开始状态开始转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            CharType type = toCharType(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (!transfer.get(state).containsKey(type)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = transfer.get(state).get(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后字符除了 初始状态、整数前面的符号，左边没有数字的小数点，指数 e 和指数 e 的负号不被接受，其他状态全部接受</span></span><br><span class="line">        <span class="keyword">return</span> state == State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharType <span class="title">toCharType</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_NUMBER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'e'</span> || ch == <span class="string">'E'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_EXP;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_POINT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'+'</span> || ch == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_SIGN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_SPACE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_ILLEGAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> State &#123;</span><br><span class="line">        STATE_INITIAL,</span><br><span class="line">        STATE_INT_SIGN,</span><br><span class="line">        STATE_INTEGER,</span><br><span class="line">        STATE_POINT,</span><br><span class="line">        STATE_POINT_WITHOUT_INT,</span><br><span class="line">        STATE_FRACTION,</span><br><span class="line">        STATE_EXP,</span><br><span class="line">        STATE_EXP_SIGN,</span><br><span class="line">        STATE_EXP_NUMBER,</span><br><span class="line">        STATE_END,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> CharType &#123;</span><br><span class="line">        CHAR_NUMBER,</span><br><span class="line">        CHAR_EXP,</span><br><span class="line">        CHAR_POINT,</span><br><span class="line">        CHAR_SIGN,</span><br><span class="line">        CHAR_SPACE,</span><br><span class="line">        CHAR_ILLEGAL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(N)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;剑指-Offer-20-表示数值的字符串&quot;&gt;&lt;a href=&quot;#剑指-Offer-20-表示数值的字符串&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 20. 表示数值的字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 20. 表示数值的字符串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="自动机" scheme="https://hoo334.github.io/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>预测赢家</title>
    <link href="https://hoo334.github.io/2020/09/01/%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/"/>
    <id>https://hoo334.github.io/2020/09/01/%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/</id>
    <published>2020-09-01T01:47:35.000Z</published>
    <updated>2020-09-01T02:56:58.194Z</updated>
    
    <content type="html"><![CDATA[<h4 id="486-预测赢家"><a href="#486-预测赢家" class="headerlink" title="486. 预测赢家"></a><a href="https://leetcode-cn.com/problems/predict-the-winner/" target="_blank" rel="noopener">486. 预测赢家</a></h4><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：[1, 5, 2]</span><br><span class="line">输出：False</span><br><span class="line">解释：一开始，玩家1可以从1和2中进行选择。</span><br><span class="line">如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。</span><br><span class="line">所以，玩家 1 的最终分数为 1 + 2 &#x3D; 3，而玩家 2 为 5 。</span><br><span class="line">因此，玩家 1 永远不会成为赢家，返回 False 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1, 5, 233, 7]</span><br><span class="line">输出：True</span><br><span class="line">解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。</span><br><span class="line">     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>1 &lt;= 给定的数组长度 &lt;= 20.</li><li>数组里所有分数都为非负数且不会大于 10000000 。</li><li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li></ul><p><strong>方法一：递归</strong></p><p>为了判断哪个玩家可以获胜，我们计算一个总分，为先手和后手得分之差。当数组中所有数字被拿取时，如果总分大于等于 0，则先手获胜，反之则后手获胜。</p><p>每次可以从数组头和数组尾拿取一个数字，然后轮到另一个玩家在剩下的部分选取数字。计算总分时，需要记录当前玩家是先手还是后手，判断当前玩家的 得分应该记为正还是负。当数组中剩下的数字多于一个时，当前玩家会选择最优的方案，使自己的分数最大化，因此对两种方案分别计算当前玩家可以得到的分数，其中的最大值为当前玩家最多可以得到的分数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//turn 为 1 代表先手，为 -1 代表后手</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">total</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> turn)</span></span>&#123;</span><br><span class="line">        <span class="comment">//数组中只剩一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[start] * turn;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//当前玩家选择数组头的元素</span></span><br><span class="line">        <span class="keyword">int</span> scoreStart = total(nums, start + <span class="number">1</span>, end, -turn) + nums[start] * turn;</span><br><span class="line">        <span class="comment">//当前玩家选择数组尾的元素</span></span><br><span class="line">        <span class="keyword">int</span> scoreEnd = total(nums, start, end - <span class="number">1</span>, -turn) + nums[end] * turn;</span><br><span class="line"><span class="comment">//当为先手时，选择分数最大的；当为后手时，选择分数最小的</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(scoreStart * turn, scoreEnd * turn) * turn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200901102235086.png" alt="image-20200901102235086"></p><p>时间复杂度O(2^n)，n 是数组的长度。</p><p>空间复杂度O(n)，n 是数组的长度。</p><p><strong>方法二：动态规划</strong></p><p>定义二维数组 dp，其行数和列数都等于数组的长度，<code>dp[i][j]</code> 表示当前数组剩下的部分为下标 i  到下标 j时，当前玩家与另一个玩家的分数只差的最大值，注意当前玩家不一定是先手。</p><p>只有当 i &lt;= j 时才有意义，当 i = j 时，只剩一个数字，当前玩家只能拿取这个数字，因此对于所有 <code>0 &lt;= i &lt; nums.length</code>，都有<code>dp[i][i] = nums[i]</code>。</p><p>当 <code>i &lt; j</code> 时，当前玩家可以选择 nums[i] 或 nums[j]，然后轮到另一个玩家在数组剩下的部分选取数字。在两种方案中，当前玩家会选择最优的方案，使自己的分数最大化。得到转台方程：<br>$$<br>dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])<br>$$<br><code>nums[i] - dp[i + 1][j]</code>代表选择数组头的元素减去另一个玩家的分数之差，<code>nums[j] - dp[i][j - 1]</code>代表选择数组尾的元素减去另一个玩家的分数之差。</p><p>最后判断 <code>dp[0][nums.length - 1]</code>的值，如果大于等于 0 则先手得分大于后手得分，先手赢，反之则后手赢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">                dp[i][j] = Math.max(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][length - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，n 是数组的长度。</p><p>空间复杂度O(n^2)，n 是数组的长度。</p><p>我们可以对空间复杂度进行优化.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">                dp[j] = Math.max(nums[i] - dp[j], nums[j] - dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，n 是数组的长度。</p><p>空间复杂度O(n)，n 是数组的长度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;486-预测赢家&quot;&gt;&lt;a href=&quot;#486-预测赢家&quot; class=&quot;headerlink&quot; title=&quot;486. 预测赢家&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/predict-the-winner/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;486. 预测赢家&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。&lt;/p&gt;
&lt;p&gt;给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>钥匙和房间</title>
    <link href="https://hoo334.github.io/2020/08/31/%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/"/>
    <id>https://hoo334.github.io/2020/08/31/%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/</id>
    <published>2020-08-31T01:06:39.000Z</published>
    <updated>2020-08-31T01:27:48.444Z</updated>
    
    <content type="html"><![CDATA[<h4 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a><a href="https://leetcode-cn.com/problems/keys-and-rooms/" target="_blank" rel="noopener">841. 钥匙和房间</a></h4><p>有 <code>N</code> 个房间，开始时你位于 <code>0</code> 号房间。每个房间有不同的号码：<code>0，1，2，...，N-1</code>，并且房间里可能有一些钥匙能使你进入下一个房间。</p><p>在形式上，对于每个房间 <code>i</code> 都有一个钥匙列表 <code>rooms[i]</code>，每个钥匙 <code>rooms[i][j]</code> 由 <code>[0,1，...，N-1]</code> 中的一个整数表示，其中 <code>N = rooms.length</code>。 钥匙 <code>rooms[i][j] = v</code> 可以打开编号为 <code>v</code> 的房间。</p><p>最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。</p><p>你可以自由地在房间之间来回走动。</p><p>如果能进入每个房间返回 <code>true</code>，否则返回 <code>false</code>。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1],[2],[3],[]]</span><br><span class="line">输出: true</span><br><span class="line">解释:  </span><br><span class="line">我们从 0 号房间开始，拿到钥匙 1。</span><br><span class="line">之后我们去 1 号房间，拿到钥匙 2。</span><br><span class="line">然后我们去 2 号房间，拿到钥匙 3。</span><br><span class="line">最后我们去了 3 号房间。</span><br><span class="line">由于我们能够进入每个房间，我们返回 true。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,3],[3,0,1],[2],[0]]</span><br><span class="line">输出：false</span><br><span class="line">解释：我们不能进入 2 号房间。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= rooms.length &lt;= 1000</code></li><li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li><li>所有房间中的钥匙数量总计不超过 <code>3000</code>。</li></ol><p>当 x 号房间中有 y 号房间的钥匙时，我们就可以从 x 号房间去住 y 号房间。如果我们将这 n 个房间看成有向图中的 n 个节点，那么上述关系就可以看作是图中的 x 号点到 y 号点的一条有向边。</p><p>这样，问题就变成给定一张有向图，询问从 0 号结点出发能否到达所有的结点。</p><p><strong>方法一：DFS</strong></p><p>使用 visited 数组来标记已访问过的结点，最后判断是否存在没有访问过的结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = rooms.size();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">        <span class="comment">//从 0 号结点开始 DFS</span></span><br><span class="line">        dfs(rooms, visited, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//判断是否存在未访问的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[index])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[index] = <span class="keyword">true</span>;</span><br><span class="line">        List&lt;Integer&gt; room = rooms.get(index);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; room.size(); i++)&#123;</span><br><span class="line">            dfs(rooms, visited, room.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n + m)，其中 n 是房间的数量，m 是所有房间中钥匙数量的总数。</p><p>空间复杂度O(n)，其中 n 是房间的数量。</p><p><strong>方法二：BFS</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = rooms.size();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        queue.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//从 0 号结点开始 BFS</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> index = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(!visited[index])&#123;</span><br><span class="line">                visited[index] = <span class="keyword">true</span>;</span><br><span class="line">                List&lt;Integer&gt; room = rooms.get(index);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; room.size(); i++)&#123;</span><br><span class="line">                    queue.offer(room.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//判断是否存在未访问的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n + m)，其中 n 是房间的数量，m 是所有房间中钥匙数量的总数。</p><p>空间复杂度O(n)，其中 n 是房间的数量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;841-钥匙和房间&quot;&gt;&lt;a href=&quot;#841-钥匙和房间&quot; class=&quot;headerlink&quot; title=&quot;841. 钥匙和房间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/keys-and-rooms/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;841. 钥匙和房间&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;有 &lt;code&gt;N&lt;/code&gt; 个房间，开始时你位于 &lt;code&gt;0&lt;/code&gt; 号房间。每个房间有不同的号码：&lt;code&gt;0，1，2，...，N-1&lt;/code&gt;，并且房间里可能有一些钥匙能使你进入下一个房间。&lt;/p&gt;
&lt;p&gt;在形式上，对于每个房间 &lt;code&gt;i&lt;/code&gt; 都有一个钥匙列表 &lt;code&gt;rooms[i]&lt;/code&gt;，每个钥匙 &lt;code&gt;rooms[i][j]&lt;/code&gt; 由 &lt;code&gt;[0,1，...，N-1]&lt;/code&gt; 中的一个整数表示，其中 &lt;code&gt;N = rooms.length&lt;/code&gt;。 钥匙 &lt;code&gt;rooms[i][j] = v&lt;/code&gt; 可以打开编号为 &lt;code&gt;v&lt;/code&gt; 的房间。&lt;/p&gt;
&lt;p&gt;最初，除 &lt;code&gt;0&lt;/code&gt; 号房间外的其余所有房间都被锁住。&lt;/p&gt;
&lt;p&gt;你可以自由地在房间之间来回走动。&lt;/p&gt;
&lt;p&gt;如果能进入每个房间返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>初探nginx</title>
    <link href="https://hoo334.github.io/2020/08/26/%E5%88%9D%E6%8E%A2nginx/"/>
    <id>https://hoo334.github.io/2020/08/26/%E5%88%9D%E6%8E%A2nginx/</id>
    <published>2020-08-26T01:11:13.000Z</published>
    <updated>2020-08-30T04:38:34.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nginx-简介"><a href="#nginx-简介" class="headerlink" title="nginx 简介"></a>nginx 简介</h3><h4 id="nginx概述"><a href="#nginx概述" class="headerlink" title="nginx概述"></a>nginx概述</h4><p>nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。</p><a id="more"></a><h4 id="nginx-作为服务器"><a href="#nginx-作为服务器" class="headerlink" title="nginx 作为服务器"></a>nginx 作为服务器</h4><p>nginx作为负载均衡服务：nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务，也可以支持作为 HTTP<a href="https://baike.baidu.com/item/代理服务" target="_blank" rel="noopener">代理服务</a>对外进行服务。nginx采用C进行编写，不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多。</p><p>处理静态文件，索引文件以及自动索引;打开文件描述符缓冲。</p><p>无缓存的反向代理加速，简单的负载均衡和容错。</p><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。</p><p>客户端  –&gt;  代理服务器 –&gt; Internet</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826093023122.png" alt="image-20200826093023122"></p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只<br>需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返<br>回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器<br>地址，隐藏了真实服务器 IP 地址。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826093104775.png" alt="image-20200826093104775"></p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>并发请求过大时，单个服务器不足以支撑，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826093307366.png" alt="image-20200826093307366"></p><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速<br>度。降低原来单个服务器的压力。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826093345623.png" alt="image-20200826093345623"></p><h3 id="CentOS-下安装-nginx"><a href="#CentOS-下安装-nginx" class="headerlink" title="CentOS 下安装 nginx"></a>CentOS 下安装 nginx</h3><h4 id="安装nginx所需依赖"><a href="#安装nginx所需依赖" class="headerlink" title="安装nginx所需依赖"></a>安装nginx所需依赖</h4><p>首先检查是否已经安装依赖，能显示出版本号则可跳过该步骤。</p><blockquote><p>rpm -qa | grep pcre</p><p>rpm -qa | grep zlib</p><p>rpm -qa | grep gcc</p><p>rpm -qa | grep zlib</p></blockquote><h5 id="安装-pcre"><a href="#安装-pcre" class="headerlink" title="安装 pcre"></a>安装 pcre</h5><p>下载压缩包</p><blockquote><p>wget <a href="http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz" target="_blank" rel="noopener">http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</a></p></blockquote><p>找到压缩包所在位置，解压</p><blockquote><p>tar -xvf pcre-8.37.tar.gz</p></blockquote><p>进入目录 pcre-8.37，配置并安装</p><blockquote><p>./configure</p><p>make &amp;&amp; make install</p></blockquote><h5 id="安装-openssl-、zlib-等依赖"><a href="#安装-openssl-、zlib-等依赖" class="headerlink" title="安装 openssl 、zlib 等依赖"></a>安装 openssl 、zlib 等依赖</h5><blockquote><p>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</p></blockquote><h5 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h5><p>进入<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">官网</a>，选择 nginx-1.18.0，下载。找到压缩包位置，解压。</p><blockquote><p>tar -xvf nginx-1.18.0.tar.gz</p></blockquote><p>进入 nginx-1.18.0 目录</p><blockquote><p>cd nginx-1.18.0</p></blockquote><p>配置并安装</p><blockquote><p>./configure</p><p>make &amp;&amp; make install</p></blockquote><h5 id="防火墙配置（也可以直接关闭防火墙，不推荐这么做）"><a href="#防火墙配置（也可以直接关闭防火墙，不推荐这么做）" class="headerlink" title="防火墙配置（也可以直接关闭防火墙，不推荐这么做）"></a>防火墙配置（也可以直接关闭防火墙，不推荐这么做）</h5><p>查看开放的端口</p><blockquote><p>firewall-cmd –list-all</p></blockquote><p>设置开放的端口(开放80端口)</p><blockquote><p>firewall-cmd –add-service=http –permanent<br>sudo firewall-cmd –add-port=80/tcp –permanent</p></blockquote><p>重启防火墙</p><blockquote><p>firewall-cmd –reload</p></blockquote><h3 id="nginx-常用命令及配置文件说明"><a href="#nginx-常用命令及配置文件说明" class="headerlink" title="nginx 常用命令及配置文件说明"></a>nginx 常用命令及配置文件说明</h3><h4 id="nginx-常用命令"><a href="#nginx-常用命令" class="headerlink" title="nginx 常用命令"></a>nginx 常用命令</h4><p>首先进入sbin目录：</p><blockquote><p>cd /usr/local/nginx/sbin</p></blockquote><p>启动</p><blockquote><p>./nginx</p></blockquote><p>关闭</p><blockquote><p>./nginx -s stop</p></blockquote><p>重新加载</p><blockquote><p>./nginx -s reload</p></blockquote><h4 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx.conf 配置文件"></a>nginx.conf 配置文件</h4><p>配置文件在 /usr/local/nginx/conf 目录下。</p><p>文件中许多都是注释掉的部分，将其精简得到如下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="nginx-conf-文件三部分"><a href="#nginx-conf-文件三部分" class="headerlink" title="nginx.conf 文件三部分"></a>nginx.conf 文件三部分</h5><h6 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h6><p>从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配<br>置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以<br>及配置文件的引入等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br></pre></td></tr></table></figure><p>这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。</p><h6 id="events-块"><a href="#events-块" class="headerlink" title="events 块"></a>events 块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>events 块涉及的指令主要影响 nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process<br>下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word<br>process 可以同时支持的最大连接数等。<br>上述例子就表示每个 work process 支持的最大连接数为 1024。这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p><h6 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。<br>需要注意的是：http 块也可以包括 http 全局块、server 块。</p><ol><li><p>http 全局块</p><p>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p></li><li><p>server 块</p><p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。<br>每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</p><ul><li><p>全局 server 块</p><p>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。</p></li><li><p>location 块</p><p>一个 server 块可以配置多个 location 块。<br>这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称<br>（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓<br>存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p></li></ul></li></ol><h3 id="反向代理实例1"><a href="#反向代理实例1" class="headerlink" title="反向代理实例1"></a>反向代理实例1</h3><p>实现效果：使用 nginx 反向代理，访问 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 直接跳转到 tomcat主页面。</p><p>首先在服务器安装 tomcat进入<a href="https://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">官网</a>下载linux版本。</p><p>解压</p><blockquote><p>tar -xvf apache-tomcat-7.0.70.tar.gz</p></blockquote><p>启动 tomcat</p><blockquote><p>cd apache-tomcat-7.0.70/bin</p><p>./startup.sh</p></blockquote><p>没有错误的话，在服务器访问 localhost:8080 可以看到 tomcat 主界面。</p><p>同时我们需要开启服务器的 8080 端口，便于客户机访问。</p><blockquote><p>firewall-cmd –add-port=8080/tcp –permanent<br>firewall-cmd –reload</p></blockquote><p>在windows 浏览器中输入192.168.1.200:8080（192.168.1.200为服务器 IP）也可以访问到 tomcat 主界面。</p><p>在 windows hosts 文件中添加域名映射：</p><blockquote><p>192.168.1.200   <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a></p></blockquote><p>访问 <a href="http://www.123.com:8080也可以访问到">www.123.com:8080也可以访问到</a> tomcat 主界面。</p><p>修改 nginx 配置文件实现反向代理</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826105658235.png" alt="image-20200826105658235"></p><p>启动 nginx 服务器，访问 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 即可看到 tomcat 主界面。</p><h3 id="反向代理实例2"><a href="#反向代理实例2" class="headerlink" title="反向代理实例2"></a>反向代理实例2</h3><p>实现效果：使用 nginx 实现反向代理，根据访问路径的不同跳转到不同端口的服务中。</p><p>nginx 监听端口为 9001，</p><p>访问 192.168.1.200:9001/edu/    跳转到 localhost:8080</p><p>访问 192.168.1.200:9001/vod/    跳转到 localhost:8081</p><p>我们需要两台 tomcat，直接解压 tomcat 压缩包到两个文件夹。8080 端口的 tomcat 不需要配置，8081 端口的 tomcat 需要更改端口：</p><p>进入 tomcat 解压文件夹，进入 conf 文件夹，找到 server.xml</p><p>更改如下端口号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server port&#x3D;&quot;8015&quot; shutdown&#x3D;&quot;SHUTDOWN&quot;&gt;  &#x2F;&#x2F; 将默认 8005 改为 8015</span><br><span class="line">&lt;Connector port&#x3D;&quot;8081&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; &#x2F;&#x2F; 将默认 8080 改为 8081</span><br><span class="line">&lt;Connector port&#x3D;&quot;8019&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt; &#x2F;&#x2F;将默认 8009 改为 8019</span><br></pre></td></tr></table></figure><p>进入bin目录，启动两台tomcat</p><blockquote><p>./startup.sh</p></blockquote><p>可在虚拟机中访问 localhost:8080 和 localhost:8081 看到 tomcat 主页面。开放防火墙 8080 和 8081 端口后，可在 windows 中访问 192.168.1.200:8080 和 192.168.1.200:8081 都能看到 tomcat 主页面。</p><p>接下来我们将两个静态资源分别放入 tomcat 的 webapps 文件夹中。</p><p>我们新建两个 html 文件，8080端口的tomcat 中有一个文件夹 edu，文件夹内一个名为a.html，文件内容为<code>&lt;h1&gt;8080&lt;h1&gt;</code>，8081端口的tomcat 中有一个文件夹 vod，文件夹内一个名为a.html，文件内容为<code>&lt;h1&gt;8081&lt;h1&gt;</code>。</p><p>windows 访问192.168.1.200:8080/edu/a.html 和 192.168.1.200:8081/vod/a.html 可分别看见 8080 和 8081 字样。</p><p>再来继续配置 nginx，打开 nginx.conf，更改如下内容。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826203446684.png" alt="image-20200826203446684"></p><p>启动 nginx，我们在 windows 环境下 访问 192.168.1.200:9001/edu/a.html 和 192.168.1.200:9001/vod/a.html 即可看到 8080 和 8081 字样。</p><h3 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>实现效果：浏览器中输入 192.168.1.200/edu/a.html，可以看到 8080 和 8081 字样不停变换。</p><p>我们新建两个 html 文件，8080端口的tomcat 中有一个文件夹 edu，文件夹内一个名为a.html，文件内容为<code>&lt;h1&gt;8080&lt;h1&gt;</code>，8081端口的tomcat 中同样有一个文件夹 edu，文件夹内一个名为a.html，文件内容为<code>&lt;h1&gt;8081&lt;h1&gt;</code>。</p><p>windows 访问192.168.1.200:8080/edu/a.html 和 192.168.1.200:8081/edu/a.html 可分别看见 8080 和 8081 字样。</p><p>我们在 nginx 配置文件中进行修改：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826204159859.png" alt="image-20200826204159859"></p><p>启动 nginx，windows 访问 192.168.1.200/edu/a.html，不停刷新，即可看到 8080 和 8081交替出现（如果不交替出现，可能是浏览器缓存，换 edge 试试）。</p><p>负载均衡的集中方式：</p><ol><li><p>轮询（默认）</p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</p></li><li><p>weight</p><p>weight 表示权重，默认为1，权重越高，服务器分配到的客户端越多。指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826204626473.png" alt="image-20200826204626473"></p></li><li><p>ip_hash</p><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826204640931.png" alt="image-20200826204640931"></p></li><li><p>fair</p><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826204708191.png" alt="image-20200826204708191"></p></li></ol><h3 id="动静分离-1"><a href="#动静分离-1" class="headerlink" title="动静分离"></a>动静分离</h3><p>nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和<br>静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 nginx<br>处理静态页面，Tomcat 处理动态页面。</p><p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；<br>另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。<br>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使<br>浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资<br>源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，<br>所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，<br>不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送<br>一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码<br>304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p><p>在 linux 系统中准备静态资源：</p><blockquote><p>cd /</p><p>mkdir data</p><p>cd data</p><p>mkdir www</p><p>mkdir image</p></blockquote><p>在 www 文件夹下放一个 html 文件（名为 a.html），在image 文件夹下放一张图片（1.jpg）。</p><p>配置 nginx 实现文件与 web 请求路径的映射。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826205334410.png" alt="image-20200826205334410"></p><p>在 windows 访问 192.168.1.200/image/1.jpg即可看到图片，访问 192.168.1.200/www/a.html即可看到页面信息。访问 192.168.1.200/image/ ，你会看到目录下的文件信息，这就是 <code>autoindex on</code> 的作用。</p><h3 id="高可用集群（主从模式）"><a href="#高可用集群（主从模式）" class="headerlink" title="高可用集群（主从模式）"></a>高可用集群（主从模式）</h3><p>一般 nginx 都是以集群来工作，增加可用性，我们要实现一主一备 nginx，当主 nginx 挂了，备份nginx 可以继续工作。</p><p>我们需要在两台 linux 虚拟机，分别安装 nginx。</p><p>我们还需要在两台虚拟机中安装 keepalived：</p><blockquote><p>yum install keepalived –y</p></blockquote><p>在/etc 文件夹下，修改主nginx 虚拟机的 keepalived.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.1.200</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">    script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;   # 检测 nginx 是否活着的脚本</span><br><span class="line"></span><br><span class="line">    interval 2        #（检测脚本执行的间隔）</span><br><span class="line"></span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER     # 备份服务器上将 MASTER 改为 BACKUP</span><br><span class="line">    interface ens33  # 网卡</span><br><span class="line">    virtual_router_id 51  # 主、备机的 virtual_router_id 必须相同</span><br><span class="line">    priority 100    # 主、备机取不同的优先级，主机值较大，备份机值较小</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.17.50  #  VRRP H 虚拟地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改备份 nginx 虚拟机的 keepalived.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.1.200</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">    script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;</span><br><span class="line"></span><br><span class="line">    interval 2</span><br><span class="line"></span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.17.50</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在两台虚拟机的 /usr/local/src 添加检测脚本 nginx_check.sh ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">A&#x3D;&#96;ps -C nginx –no-header |wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ &#96;ps -C nginx --no-header |wc -l&#96; -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>把两台服务器上的 nginx 和 keepalived 启动</p><blockquote><p>nginx sbin 目录下启动 nginx    ./nginx</p><p>启动keepalived  systemctl start keepalived.service</p></blockquote><p>在 windows 浏览器访问 192.168.17.50，即可看见 nginx 主界面，我们将主 nginx 关闭，再次访问，依然能看见 nginx 主界面，说明备份 nginx 工作正常。</p><h3 id="nginx-原理"><a href="#nginx-原理" class="headerlink" title="nginx 原理"></a>nginx 原理</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826211511134.png" alt="image-20200826211511134"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826211523072.png" alt="image-20200826211523072"></p><p>master -  workers  的机制的好处<br>首先，对于每个 worker 进程来说，由于采用多个相互独立的进程，单一的 worker 进程出问题了，不会影响到 nginx 的全部服务，只是该 worker 上的全部请求失败。</p><p><strong>需要设置多少个 worker</strong><br>Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进<br>程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话<br>下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu<br>数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。</p><p><strong>设置 worker  数量</strong></p><p>worker_processes 4  </p><p>#work 绑定 cpu(4 work 绑定 4cpu)。<br>worker_cpu_affinity 0001 0010 0100 1000  </p><p>#work 绑定 cpu (4 work 绑定 8 cpu 中的 4 个) 。<br>worker_cpu_affinity 0000001 00000010 00000100 00001000</p><p>连接数 worker_connection 表示每个 worker 进程所能建立连接的最大值。一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： worker_connections * worker_processes /2，而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections * worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;nginx-简介&quot;&gt;&lt;a href=&quot;#nginx-简介&quot; class=&quot;headerlink&quot; title=&quot;nginx 简介&quot;&gt;&lt;/a&gt;nginx 简介&lt;/h3&gt;&lt;h4 id=&quot;nginx概述&quot;&gt;&lt;a href=&quot;#nginx概述&quot; class=&quot;headerlink&quot; title=&quot;nginx概述&quot;&gt;&lt;/a&gt;nginx概述&lt;/h4&gt;&lt;p&gt;nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://hoo334.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="https://hoo334.github.io/2020/08/26/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>https://hoo334.github.io/2020/08/26/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</id>
    <published>2020-08-26T00:52:15.000Z</published>
    <updated>2020-08-26T01:05:10.627Z</updated>
    
    <content type="html"><![CDATA[<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h4><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><a id="more"></a><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826085317695.png" alt="image-20200826085317695"></p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><p><strong>方法一：回溯</strong></p><p>首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。</p><p>回溯过程中维护一个字符串，表示已有的字母排列。该字符串初始为空，每次取电话号码的一位数字，从哈希表中获取该数字对应的所有字母，将其中一个字母插入到已有字母的后面，然后继续处理电话号码的后一位数字，直到处理完所有数字，得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, String&gt; numMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        numMap.put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">        numMap.put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">        numMap.put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        numMap.put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        numMap.put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">        numMap.put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        numMap.put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        numMap.put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line"></span><br><span class="line">        backtrack(combinations, numMap, digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuffer());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; numMap, String digits, <span class="keyword">int</span> index, StringBuffer combination)</span></span>&#123;</span><br><span class="line">        <span class="comment">//是否遍历完 digits 中所有数字</span></span><br><span class="line">        <span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//获取数字对应的所有字符</span></span><br><span class="line">            <span class="keyword">char</span> c = digits.charAt(index);</span><br><span class="line">            String letters = numMap.get(c);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length(); i++)&#123;</span><br><span class="line">                <span class="comment">//取一个字母，并继续处理后一位数字</span></span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, numMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                <span class="comment">//删除当前字母，并进行下一个循环</span></span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(3^m * 4^ n)，m 为对应三个字母的数字个数，n 为对应四个字母的数字个数。</p><p>空间复杂度O(m + n)，m 为对应三个字母的数字个数，n 为对应四个字母的数字个数。除返回值外，空间复杂度取决于哈希表及递归调用层数，递归调用层数最多为 m + n。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;17-电话号码的字母组合&quot;&gt;&lt;a href=&quot;#17-电话号码的字母组合&quot; class=&quot;headerlink&quot; title=&quot;17. 电话号码的字母组合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;17. 电话号码的字母组合&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个仅包含数字 &lt;code&gt;2-9&lt;/code&gt; 的字符串，返回所有它能表示的字母组合。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="回溯" scheme="https://hoo334.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>递增子序列</title>
    <link href="https://hoo334.github.io/2020/08/25/%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://hoo334.github.io/2020/08/25/%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-08-25T01:20:53.000Z</published>
    <updated>2020-08-25T02:02:10.504Z</updated>
    
    <content type="html"><![CDATA[<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode-cn.com/problems/increasing-subsequences/" target="_blank" rel="noopener">491. 递增子序列</a></h4><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 6, 7, 7]</span><br><span class="line">输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ol><p>我们可以枚举出所有的子序列，然后判断当前的子序列是否是非严格递增的。对于数组中的每个数来说都有<strong>选中</strong>和<strong>不选中</strong>两种状态。长度为 n 的序列选择子序列一共有 2 ^ n 种情况。我们可以使用递归的方法实现二进制枚举，然后判断是否合法，我们可以得到这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">        <span class="comment">// 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span></span><br><span class="line">        <span class="keyword">if</span> (isValid() &amp;&amp; notVisited()) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果选择当前元素</span></span><br><span class="line">    temp.add(nums[cur]);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">    temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果不选择当前元素</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个临时数组 temp 保存当前选出的子序列，用 cur 来表示当前位置的下标，在 执行<code>dfs(cur, nums)</code>之前，[0, cur - 1]区间内的所有元素都被考虑过，[cur, n]区间内的元素还未被考虑。我们考虑 cur 位置选或者不选，如果选择当前元素，将当前元素加入 temp，然后递归下一个位置，在递归结束后，把 temp 的最后一个元素删除进行回溯；如果不选择当前元素，直接递归下一个位置。</p><p>我们可以对选择和不选择做一些简单的限定，就可以让枚举出来的序列都是合法且不重复：</p><ul><li><p>只有当前的元素大于等于上一个选择的元素时才能选择这个元素，这样枚举出来的所有元素都是合法的。</p></li><li><p>如何保证没有重复呢？我们给不选择做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。如果有两个相同的元素，我们有四种情况:</p><ol><li>选前者，选后者</li><li>选前者，不选后者</li><li>不选前者，选后者</li><li>不选前者，不选后者</li></ol><p>其中第二种和第三种情况是等价的，这样限制后，舍弃了第二种，保留了第三种。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, Integer.MIN_VALUE, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历到末尾</span></span><br><span class="line">        <span class="keyword">if</span>(cur == nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//当前元素大于等于前一个选择的元素</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cur] &gt;= last)&#123;</span><br><span class="line">            temp.add(nums[cur]);</span><br><span class="line">            dfs(cur + <span class="number">1</span>, nums[cur], nums);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//当前元素不等于前一个选择的元素才考虑不选择当前元素，去重</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cur] != last)&#123;</span><br><span class="line">            dfs(cur + <span class="number">1</span>, last, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n * 2 ^ n)，枚举子序列O(2 ^ n)，保存答案O(n)。</p><p>空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;491-递增子序列&quot;&gt;&lt;a href=&quot;#491-递增子序列&quot; class=&quot;headerlink&quot; title=&quot;491. 递增子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/increasing-subsequences/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;491. 递增子序列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>重复的子字符串</title>
    <link href="https://hoo334.github.io/2020/08/24/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/08/24/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-08-24T01:27:03.000Z</published>
    <updated>2020-08-24T01:42:25.713Z</updated>
    
    <content type="html"><![CDATA[<h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></h4><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line"></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure><p><strong>方法一：枚举</strong></p><p>如果一个长度为 n 的字符串可以由它的一个长度为 n‘ 的子串 s’ 重复多次构成，那么：</p><ul><li>n 一定是 n‘ 的倍数；</li><li>s’ 一定是 s 的前缀；</li><li>对于任意的 <code>i∈[n&#39;, n)</code>，有 <code>s[i] = s[i - n&#39;]</code>。</li></ul><p>我们枚举子串的长度 n’ ，同时判断 s[i] 和 s[i - n’] 是否相等。子串的长度 n’ 属于 [1, n / 2]，长度为 n 的字符串至少要由两个重复子串构成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//字符串长度不能整除子串的长度，continue</span></span><br><span class="line">            <span class="keyword">if</span>(n % i != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//判断子串s[0 ... i - 1] 是否为重复的子串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) != s.charAt(j - i))&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;459-重复的子字符串&quot;&gt;&lt;a href=&quot;#459-重复的子字符串&quot; class=&quot;headerlink&quot; title=&quot;459. 重复的子字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/repeated-substring-pattern/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;459. 重复的子字符串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>汉明距离</title>
    <link href="https://hoo334.github.io/2020/08/23/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    <id>https://hoo334.github.io/2020/08/23/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</id>
    <published>2020-08-23T01:23:21.000Z</published>
    <updated>2020-08-23T01:33:43.579Z</updated>
    
    <content type="html"><![CDATA[<h4 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">461. 汉明距离</a></h4><p>两个整数之间的<a href="https://baike.baidu.com/item/汉明距离" target="_blank" rel="noopener">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p><a id="more"></a><p><strong>注意：</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure><p>我们知道异或操作：不同得 1 ，相同得 0。我们对 x 和 y 做一次异或操作，得到的数的二进制位中的 1 的个数就是 x 和 y 的汉明距离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; 1, y &#x3D; 4</span><br><span class="line">1       (0 0 0 1)</span><br><span class="line">4       (0 1 0 0)</span><br><span class="line">1 xor 4 (0 1 0 1)  &quot;1&quot; 的个数为 2，即汉明距离为 2</span><br></pre></td></tr></table></figure><p><strong>方法一：位移</strong></p><p>我们要求一个数字二进制位中 “1” 的个数，可以不断将数字右移，统计最后一位为 1 的个数，直到数字为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = x ^ y, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p><p><strong>方法二：布赖恩·克尼根算法</strong></p><p>「Brian Kernighan 算法」，用于清除二进制串中最右边的 1。</p><p>我们每次对 n 和 n - 1进行按位与操作后，n 中最右边的 1 会被抹去变为 0 。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823091337544.png" alt="image-20200823091337544"></p><p>我们不断地将数字的最右边的 “1” 变为 0 ，同时统计 1 的个数，直到数字为 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = x ^ y, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != <span class="number">0</span>)&#123;</span><br><span class="line">            m = m &amp; (m - <span class="number">1</span>);</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;461-汉明距离&quot;&gt;&lt;a href=&quot;#461-汉明距离&quot; class=&quot;headerlink&quot; title=&quot;461. 汉明距离&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/hamming-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;461. 汉明距离&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;两个整数之间的&lt;a href=&quot;https://baike.baidu.com/item/汉明距离&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汉明距离&lt;/a&gt;指的是这两个数字对应二进制位不同的位置的数目。&lt;/p&gt;
&lt;p&gt;给出两个整数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt;，计算它们之间的汉明距离。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="位运算" scheme="https://hoo334.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>数字范围按位与</title>
    <link href="https://hoo334.github.io/2020/08/23/%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/"/>
    <id>https://hoo334.github.io/2020/08/23/%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/</id>
    <published>2020-08-23T01:02:09.000Z</published>
    <updated>2020-08-23T01:39:08.518Z</updated>
    
    <content type="html"><![CDATA[<h4 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">201. 数字范围按位与</a></h4><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p><a id="more"></a><p><strong>示例 1:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [5,7]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>我们首先想到将[m, n] 范围内的运算全部做一次与运算，然而超时。我们将 [9, 12] 的二进制字符画成图：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823090713328.png" alt="image-20200823090713328"></p><p>我们可以发现，对所有数字执行按位与运算的结果是对应二进制字符串的公共前缀再用零补上后面的剩余位。进一步的说，这些字符串的公共前缀就等于 9 和 12 两个数字的二进制字符串的公共前缀。</p><p><strong>方法一：位移</strong></p><p>我们可以将两个数字不断右移，同时记录位移的次数，直到它们相等，得到了公共前缀，我们再将公共前缀左移相应的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到公共前缀</span></span><br><span class="line">        <span class="keyword">while</span>(m != n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            ++shift;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左移相应的次数</span></span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; shift;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p><p><strong>方法二：Brian Kernighan 算法</strong></p><p>「Brian Kernighan 算法」，用于清除二进制串中最右边的 1。</p><p>我们每次对 n 和 n - 1进行按位与操作后，n 中最右边的 1 会被抹去变为 0 。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823091337544.png" alt="image-20200823091337544"></p><p>对于此题，我们将一直清除 n 最右边的 1 ，直到  n &lt;= m，此时 n 就是公共前缀。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823092218184.png" alt="image-20200823092218184"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; n)&#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;201-数字范围按位与&quot;&gt;&lt;a href=&quot;#201-数字范围按位与&quot; class=&quot;headerlink&quot; title=&quot;201. 数字范围按位与&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;201. 数字范围按位与&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定范围 [m, n]，其中 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="位运算" scheme="https://hoo334.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>24点游戏</title>
    <link href="https://hoo334.github.io/2020/08/22/24%E7%82%B9%E6%B8%B8%E6%88%8F/"/>
    <id>https://hoo334.github.io/2020/08/22/24%E7%82%B9%E6%B8%B8%E6%88%8F/</id>
    <published>2020-08-22T01:37:40.000Z</published>
    <updated>2020-08-22T01:58:34.610Z</updated>
    
    <content type="html"><![CDATA[<h4 id="679-24-点游戏"><a href="#679-24-点游戏" class="headerlink" title="679. 24 点游戏"></a><a href="https://leetcode-cn.com/problems/24-game/" target="_blank" rel="noopener">679. 24 点游戏</a></h4><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 <code>*</code>，<code>/</code>，<code>+</code>，<code>-</code>，<code>(</code>，<code>)</code> 的运算得到 24。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 1, 8, 7]</span><br><span class="line">输出: True</span><br><span class="line">解释: (8-4) * (7-1) &#x3D; 24</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 1, 2]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>除法运算符 <code>/</code> 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。</li><li>每个运算符对两个数进行运算。特别是我们不能用 <code>-</code> 作为一元运算符。例如，<code>[1, 1, 1, 1]</code> 作为输入时，表达式 <code>-1 - 1 - 1 - 1</code> 是不允许的。</li><li>你不能将数字连接在一起。例如，输入为 <code>[1, 2, 1, 2]</code> 时，不能写成 12 + 12 。</li></ol><p>一共有 4 个数和 3 个运算操作，因此可能性并不多。</p><p>首先从 4 个数字中有序取出两个数字共 4 * 3 = 12 种选法，再选择 4 种运算中的一种，将运算的结果取代选出的两个数字。</p><p>在剩下的 3 个数字中有序取出两个数字共 3 * 2 = 6 种选法，再选择 4 种运算中的一种，将运算的结果取代选出的两个数字。</p><p>最后剩下两个数字，有两种不同的顺序，并选择 4 种运算之一。</p><p>总共有 12 * 4 * 6 * 4 * 2 * 4 = 9216 种可能。</p><p>我们直接使用暴力方法来求解，用一个列表存储全部数字，每次从列表中选出 2 个数字，再选择 1 种运算操作，用计算的结果取代选出的 2 个数字。重复以上步骤，直到最后剩下一个数字，判断它是否等于 24 即可。</p><p>注意到除法运算为实数除法，结果为浮点数，因此在列表中应该全部存储浮点数。两个浮点数差值小于 1e-6 时可认为它们相等。同时，在进行除法运算时，除数不能为 0 ，遇到这种情况我们可以直接排除。</p><p>加法和乘法都满足交换律，对于选出的 2 个数字不需要考虑不同的顺序，在第二次运算时直接跳过。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> TARGET = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> EPSILON = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ADD = <span class="number">0</span>, MULTIPLY = <span class="number">1</span>, SUBTRACT = <span class="number">2</span>, DIVIDE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgePoint24</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将所有数字转为 double 并存进list</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            list.add((<span class="keyword">double</span>) num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(List&lt;Double&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列表中只剩一个数字，判断它是否等于 24</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(list.get(<span class="number">0</span>) - TARGET) &lt; EPSILON;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="comment">// 有序选出 i，j 位置的两个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)&#123;</span><br><span class="line">                <span class="comment">//选出同一个数</span></span><br><span class="line">                <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;Double&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//保存除 i，j 位置的元素</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k != i &amp;&amp; k != j)&#123;</span><br><span class="line">                        list2.add(list.get(k));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//选出一种运算</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                    <span class="comment">//如果是加或乘运算，且这是第二次选中 i 和 j</span></span><br><span class="line">                    <span class="keyword">if</span>(k &lt; <span class="number">2</span> &amp;&amp; i &gt; j)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//计算结果</span></span><br><span class="line">                    <span class="keyword">if</span>(k == ADD)&#123;</span><br><span class="line">                        list2.add(list.get(i) + list.get(j));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == MULTIPLY)&#123;</span><br><span class="line">                        list2.add(list.get(i) * list.get(j));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == SUBTRACT)&#123;</span><br><span class="line">                        list2.add(list.get(i) - list.get(j));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == DIVIDE)&#123;</span><br><span class="line">                        <span class="comment">//跳过除数为 0 的情况</span></span><br><span class="line">                        <span class="keyword">if</span>(Math.abs(list.get(j)) &lt; EPSILON)&#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            list2.add(list.get(i) / list.get(j));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//继续选出两个数字并计算，如果得到结果，返回 true</span></span><br><span class="line">                    <span class="keyword">if</span>(solve(list2))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">// list 不能得到 24点，删除加入的元素，并尝试下一种运算</span></span><br><span class="line">                    list2.remove(list2.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;679-24-点游戏&quot;&gt;&lt;a href=&quot;#679-24-点游戏&quot; class=&quot;headerlink&quot; title=&quot;679. 24 点游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/24-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;679. 24 点游戏&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 &lt;code&gt;*&lt;/code&gt;，&lt;code&gt;/&lt;/code&gt;，&lt;code&gt;+&lt;/code&gt;，&lt;code&gt;-&lt;/code&gt;，&lt;code&gt;(&lt;/code&gt;，&lt;code&gt;)&lt;/code&gt; 的运算得到 24。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数学" scheme="https://hoo334.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的最小深度</title>
    <link href="https://hoo334.github.io/2020/08/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <id>https://hoo334.github.io/2020/08/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</id>
    <published>2020-08-21T01:34:22.000Z</published>
    <updated>2020-08-21T01:50:12.976Z</updated>
    
    <content type="html"><![CDATA[<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h4><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><a id="more"></a><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最小深度  2.</p><p>看到这么简单的题，一顿操作，立马就写出了如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试发现 [2,9]这个用例不对，我们得到的结果为 1，实际结果为 2。原因在于我们统计了空结点到根节点的深度。</p><p>对于每个结点，当只有一个子树时，直接返回子树的最小深度加一；当有两颗子树时，返回左右子树之中的最小深度加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="keyword">null</span> &amp;&amp; root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(h)，h 为树的高度，当二叉树退化为链表时，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;111-二叉树的最小深度&quot;&gt;&lt;a href=&quot;#111-二叉树的最小深度&quot; class=&quot;headerlink&quot; title=&quot;111. 二叉树的最小深度&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;111. 二叉树的最小深度&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二叉树，找出其最小深度。&lt;/p&gt;
&lt;p&gt;最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>扫雷游戏</title>
    <link href="https://hoo334.github.io/2020/08/20/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/"/>
    <id>https://hoo334.github.io/2020/08/20/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</id>
    <published>2020-08-20T04:01:59.000Z</published>
    <updated>2020-08-20T04:12:29.682Z</updated>
    
    <content type="html"><![CDATA[<h4 id="529-扫雷游戏"><a href="#529-扫雷游戏" class="headerlink" title="529. 扫雷游戏"></a><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">529. 扫雷游戏</a></h4><p>让我们一起来玩扫雷游戏！</p><p>给定一个代表游戏板的二维字符矩阵。 <strong>‘M’</strong> 代表一个<strong>未挖出的</strong>地雷，<strong>‘E’</strong> 代表一个<strong>未挖出的</strong>空方块，<strong>‘B’</strong> 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong>已挖出的</strong>空白方块，<strong>数字</strong>（’1’ 到 ‘8’）表示有多少地雷与这块<strong>已挖出的</strong>方块相邻，<strong>‘X’</strong> 则表示一个<strong>已挖出的</strong>地雷。</p><p>现在给出在所有<strong>未挖出的</strong>方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><ol><li><p>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 <strong>‘X’</strong>。</p></li><li><p>如果一个<strong>没有相邻地雷</strong>的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的<strong>未挖出</strong>方块都应该被递归地揭露。</p></li><li><p>如果一个<strong>至少与一个地雷相邻</strong>的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。</p></li><li><p>如果在此次点击中，若无更多方块可被揭露，则返回面板。</p><a id="more"></a></li></ol><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">解释:</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">解释:</span><br></pre></td></tr></table></figure><p> <strong>注意：</strong></p><ol><li>输入矩阵的宽和高的范围为 [1,50]。</li><li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li><li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li><li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li></ol><p>对于我们点击的每一个方块，有两种情况：</p><ul><li>当前点击的方块是未挖出的地雷，将其值改为 X；</li><li>当前点击的是为未挖出的空方块，我们需要统计它周围相邻的方块里地雷的数量cnt（即M 的数量）。如果 cnt 为 0 ，则将其改为 B，且递归地处理周围<strong>八个</strong>未挖出地方块，如果 cnt 不为 0 ，将其改为数字即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = click[<span class="number">0</span>], y = click[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//判断当前方块是否为地雷</span></span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == <span class="string">'M'</span>)&#123;</span><br><span class="line">            board[x][y] = <span class="string">'X'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(board, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计当前空方块周围地雷数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[tx][ty] == <span class="string">'M'</span>)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//地雷数大于零，直接修改当前方块为地雷数</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            board[x][y] = (<span class="keyword">char</span>) (cnt + <span class="string">'0'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//周围没有地雷，递归地对周围八个方块进行搜索</span></span><br><span class="line">            board[x][y] = <span class="string">'B'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">                <span class="comment">//碰到边界或者不是未挖出的方块时返回</span></span><br><span class="line">                <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length || board[tx][ty] != <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dfs(board, tx, ty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)，m 和 n 为面板的长宽。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;529-扫雷游戏&quot;&gt;&lt;a href=&quot;#529-扫雷游戏&quot; class=&quot;headerlink&quot; title=&quot;529. 扫雷游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minesweeper/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;529. 扫雷游戏&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;让我们一起来玩扫雷游戏！&lt;/p&gt;
&lt;p&gt;给定一个代表游戏板的二维字符矩阵。 &lt;strong&gt;‘M’&lt;/strong&gt; 代表一个&lt;strong&gt;未挖出的&lt;/strong&gt;地雷，&lt;strong&gt;‘E’&lt;/strong&gt; 代表一个&lt;strong&gt;未挖出的&lt;/strong&gt;空方块，&lt;strong&gt;‘B’&lt;/strong&gt; 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的&lt;strong&gt;已挖出的&lt;/strong&gt;空白方块，&lt;strong&gt;数字&lt;/strong&gt;（’1’ 到 ‘8’）表示有多少地雷与这块&lt;strong&gt;已挖出的&lt;/strong&gt;方块相邻，&lt;strong&gt;‘X’&lt;/strong&gt; 则表示一个&lt;strong&gt;已挖出的&lt;/strong&gt;地雷。&lt;/p&gt;
&lt;p&gt;现在给出在所有&lt;strong&gt;未挖出的&lt;/strong&gt;方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 &lt;strong&gt;‘X’&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个&lt;strong&gt;没有相邻地雷&lt;/strong&gt;的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的&lt;strong&gt;未挖出&lt;/strong&gt;方块都应该被递归地揭露。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个&lt;strong&gt;至少与一个地雷相邻&lt;/strong&gt;的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果在此次点击中，若无更多方块可被揭露，则返回面板。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>回文子串</title>
    <link href="https://hoo334.github.io/2020/08/19/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/08/19/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2020-08-19T02:18:27.000Z</published>
    <updated>2020-08-19T02:45:23.029Z</updated>
    
    <content type="html"><![CDATA[<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></h4><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>输入的字符串长度不会超过 1000 。</li></ul><p>我们枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同时就拓展，否则就停止拓展。</p><p>当回文长度为奇数时，回文中心就是一个字符；当回文长度为偶数时，回文中心为两个字符。一个长度为 n 的字符串，可能的回文中心有 2n - 1 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; n; index++)&#123;</span><br><span class="line">            <span class="comment">//回文长度为奇数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index, k = index; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//回文长度为偶数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index, k = index + <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将回文长度为奇数和偶数的两种情况合在一起，我们令 <code>0 &lt;= index &lt; 2n - 1</code>，回文中心<code>(j, k)</code>，其中<code>j = index / 2, k = j + (index mod 2)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">2</span> * n - <span class="number">1</span>; index++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index / <span class="number">2</span>, k = index / <span class="number">2</span> + index % <span class="number">2</span>; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;647-回文子串&quot;&gt;&lt;a href=&quot;#647-回文子串&quot; class=&quot;headerlink&quot; title=&quot;647. 回文子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/palindromic-substrings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;647. 回文子串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。&lt;/p&gt;
&lt;p&gt;具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>有序列表转换二叉搜索树</title>
    <link href="https://hoo334.github.io/2020/08/18/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/18/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-08-18T01:46:47.000Z</published>
    <updated>2020-08-21T01:54:41.678Z</updated>
    
    <content type="html"><![CDATA[<h4 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a></h4><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><p>我们需要构造出平衡的二叉树，每次让左右子树的结点个数接近，我们可以找出链表元素的中位数作为根节点的值。链表中小于根节点的元素个数与大于根节点的元素个数要么相等，要么相差 1。我们递归地对左右子树进行构造。</p><p>设当前链表左端点为 left， 右端点为 right，具体范围为<code>[left, right)</code>，左闭右开区间。定义左闭右开区间的好处是，可以方便表示初始列表<code>[head, null)</code>，如果使用左闭右闭区间，则第一次需要遍历到链表末尾来获取 right 的值。在找出链表中位数结点 mid后，我们可以使用<code>[left, mid)</code>和<code>[mid.next, right)</code>来分别表示左右子树对应的列表。</p><p>使用快慢指针法来得到链表的中位数结点，fast 指针每次移动两次，slow 指针每次移动一次，当 fast 到达边界（fast == right 或 fast.next == right，right 的前驱结点为链表的最后一个结点）时停止，此时 slow 指向的元素就是链表的中位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//左闭右开区间 [left, right)</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//得到中间结点</span></span><br><span class="line">        ListNode mid = getMid(left, right);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(mid.val);</span><br><span class="line">        <span class="comment">//递归构造左右子树</span></span><br><span class="line">        root.left = buildTree(left, mid);</span><br><span class="line">        root.right =  buildTree(mid.next, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getMid</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        ListNode slow = left;</span><br><span class="line">        ListNode fast = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != right &amp;&amp; fast.next != right)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n logn)，空间复杂度O(log n)。 n 是链表的长度。</p><p>寻找链表的中位数是一个比较耗时的操作，在二叉搜索树的构建过程是一个中序遍历，遍历结果就是链表，我们可以使用一个指针 ptr 来指向下一个需要建立的链表结点，在构建二叉搜索树的同时不断将 ptr 向后移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode ptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ptr = head;</span><br><span class="line">        <span class="keyword">int</span> length = getLength(head);</span><br><span class="line"><span class="comment">//左闭右闭区间 [left, right]</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//得到链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//计算 mid 位置</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        <span class="comment">//先构建左子树</span></span><br><span class="line">        root.left = buildTree(left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//左子树构建完时，ptr 指向根节点</span></span><br><span class="line">        root.val = ptr.val;</span><br><span class="line">        ptr = ptr.next;</span><br><span class="line">        <span class="comment">//构建右子树</span></span><br><span class="line">        root.right = buildTree(mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(log n)。n 为链表的长度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;109-有序链表转换二叉搜索树&quot;&gt;&lt;a href=&quot;#109-有序链表转换二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;109. 有序链表转换二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;109. 有序链表转换二叉搜索树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="https://hoo334.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
</feed>
