<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2020-08-24T01:42:25.713Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重复的子字符串</title>
    <link href="https://hoo334.github.io/2020/08/24/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/08/24/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-08-24T01:27:03.000Z</published>
    <updated>2020-08-24T01:42:25.713Z</updated>
    
    <content type="html"><![CDATA[<h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></h4><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line"></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure><p><strong>方法一：枚举</strong></p><p>如果一个长度为 n 的字符串可以由它的一个长度为 n‘ 的子串 s’ 重复多次构成，那么：</p><ul><li>n 一定是 n‘ 的倍数；</li><li>s’ 一定是 s 的前缀；</li><li>对于任意的 <code>i∈[n&#39;, n)</code>，有 <code>s[i] = s[i - n&#39;]</code>。</li></ul><p>我们枚举子串的长度 n’ ，同时判断 s[i] 和 s[i - n’] 是否相等。子串的长度 n’ 属于 [1, n / 2]，长度为 n 的字符串至少要由两个重复子串构成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//字符串长度不能整除子串的长度，continue</span></span><br><span class="line">            <span class="keyword">if</span>(n % i != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//判断子串s[0 ... i - 1] 是否为重复的子串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) != s.charAt(j - i))&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;459-重复的子字符串&quot;&gt;&lt;a href=&quot;#459-重复的子字符串&quot; class=&quot;headerlink&quot; title=&quot;459. 重复的子字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/repeated-substring-pattern/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;459. 重复的子字符串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>汉明距离</title>
    <link href="https://hoo334.github.io/2020/08/23/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    <id>https://hoo334.github.io/2020/08/23/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</id>
    <published>2020-08-23T01:23:21.000Z</published>
    <updated>2020-08-23T01:33:43.579Z</updated>
    
    <content type="html"><![CDATA[<h4 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">461. 汉明距离</a></h4><p>两个整数之间的<a href="https://baike.baidu.com/item/汉明距离" target="_blank" rel="noopener">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p><a id="more"></a><p><strong>注意：</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure><p>我们知道异或操作：不同得 1 ，相同得 0。我们对 x 和 y 做一次异或操作，得到的数的二进制位中的 1 的个数就是 x 和 y 的汉明距离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; 1, y &#x3D; 4</span><br><span class="line">1       (0 0 0 1)</span><br><span class="line">4       (0 1 0 0)</span><br><span class="line">1 xor 4 (0 1 0 1)  &quot;1&quot; 的个数为 2，即汉明距离为 2</span><br></pre></td></tr></table></figure><p><strong>方法一：位移</strong></p><p>我们要求一个数字二进制位中 “1” 的个数，可以不断将数字右移，统计最后一位为 1 的个数，直到数字为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = x ^ y, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p><p><strong>方法二：布赖恩·克尼根算法</strong></p><p>「Brian Kernighan 算法」，用于清除二进制串中最右边的 1。</p><p>我们每次对 n 和 n - 1进行按位与操作后，n 中最右边的 1 会被抹去变为 0 。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823091337544.png" alt="image-20200823091337544"></p><p>我们不断地将数字的最右边的 “1” 变为 0 ，同时统计 1 的个数，直到数字为 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = x ^ y, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != <span class="number">0</span>)&#123;</span><br><span class="line">            m = m &amp; (m - <span class="number">1</span>);</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;461-汉明距离&quot;&gt;&lt;a href=&quot;#461-汉明距离&quot; class=&quot;headerlink&quot; title=&quot;461. 汉明距离&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/hamming-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;461. 汉明距离&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;两个整数之间的&lt;a href=&quot;https://baike.baidu.com/item/汉明距离&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汉明距离&lt;/a&gt;指的是这两个数字对应二进制位不同的位置的数目。&lt;/p&gt;
&lt;p&gt;给出两个整数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt;，计算它们之间的汉明距离。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="位运算" scheme="https://hoo334.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>数字范围按位与</title>
    <link href="https://hoo334.github.io/2020/08/23/%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/"/>
    <id>https://hoo334.github.io/2020/08/23/%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/</id>
    <published>2020-08-23T01:02:09.000Z</published>
    <updated>2020-08-23T01:39:08.518Z</updated>
    
    <content type="html"><![CDATA[<h4 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">201. 数字范围按位与</a></h4><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p><a id="more"></a><p><strong>示例 1:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [5,7]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>我们首先想到将[m, n] 范围内的运算全部做一次与运算，然而超时。我们将 [9, 12] 的二进制字符画成图：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823090713328.png" alt="image-20200823090713328"></p><p>我们可以发现，对所有数字执行按位与运算的结果是对应二进制字符串的公共前缀再用零补上后面的剩余位。进一步的说，这些字符串的公共前缀就等于 9 和 12 两个数字的二进制字符串的公共前缀。</p><p><strong>方法一：位移</strong></p><p>我们可以将两个数字不断右移，同时记录位移的次数，直到它们相等，得到了公共前缀，我们再将公共前缀左移相应的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到公共前缀</span></span><br><span class="line">        <span class="keyword">while</span>(m != n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            ++shift;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左移相应的次数</span></span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; shift;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p><p><strong>方法二：Brian Kernighan 算法</strong></p><p>「Brian Kernighan 算法」，用于清除二进制串中最右边的 1。</p><p>我们每次对 n 和 n - 1进行按位与操作后，n 中最右边的 1 会被抹去变为 0 。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823091337544.png" alt="image-20200823091337544"></p><p>对于此题，我们将一直清除 n 最右边的 1 ，直到  n &lt;= m，此时 n 就是公共前缀。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823092218184.png" alt="image-20200823092218184"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; n)&#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;201-数字范围按位与&quot;&gt;&lt;a href=&quot;#201-数字范围按位与&quot; class=&quot;headerlink&quot; title=&quot;201. 数字范围按位与&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;201. 数字范围按位与&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定范围 [m, n]，其中 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="位运算" scheme="https://hoo334.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>24点游戏</title>
    <link href="https://hoo334.github.io/2020/08/22/24%E7%82%B9%E6%B8%B8%E6%88%8F/"/>
    <id>https://hoo334.github.io/2020/08/22/24%E7%82%B9%E6%B8%B8%E6%88%8F/</id>
    <published>2020-08-22T01:37:40.000Z</published>
    <updated>2020-08-22T01:58:34.610Z</updated>
    
    <content type="html"><![CDATA[<h4 id="679-24-点游戏"><a href="#679-24-点游戏" class="headerlink" title="679. 24 点游戏"></a><a href="https://leetcode-cn.com/problems/24-game/" target="_blank" rel="noopener">679. 24 点游戏</a></h4><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 <code>*</code>，<code>/</code>，<code>+</code>，<code>-</code>，<code>(</code>，<code>)</code> 的运算得到 24。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 1, 8, 7]</span><br><span class="line">输出: True</span><br><span class="line">解释: (8-4) * (7-1) &#x3D; 24</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 1, 2]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>除法运算符 <code>/</code> 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。</li><li>每个运算符对两个数进行运算。特别是我们不能用 <code>-</code> 作为一元运算符。例如，<code>[1, 1, 1, 1]</code> 作为输入时，表达式 <code>-1 - 1 - 1 - 1</code> 是不允许的。</li><li>你不能将数字连接在一起。例如，输入为 <code>[1, 2, 1, 2]</code> 时，不能写成 12 + 12 。</li></ol><p>一共有 4 个数和 3 个运算操作，因此可能性并不多。</p><p>首先从 4 个数字中有序取出两个数字共 4 * 3 = 12 种选法，再选择 4 种运算中的一种，将运算的结果取代选出的两个数字。</p><p>在剩下的 3 个数字中有序取出两个数字共 3 * 2 = 6 种选法，再选择 4 种运算中的一种，将运算的结果取代选出的两个数字。</p><p>最后剩下两个数字，有两种不同的顺序，并选择 4 种运算之一。</p><p>总共有 12 * 4 * 6 * 4 * 2 * 4 = 9216 种可能。</p><p>我们直接使用暴力方法来求解，用一个列表存储全部数字，每次从列表中选出 2 个数字，再选择 1 种运算操作，用计算的结果取代选出的 2 个数字。重复以上步骤，直到最后剩下一个数字，判断它是否等于 24 即可。</p><p>注意到除法运算为实数除法，结果为浮点数，因此在列表中应该全部存储浮点数。两个浮点数差值小于 1e-6 时可认为它们相等。同时，在进行除法运算时，除数不能为 0 ，遇到这种情况我们可以直接排除。</p><p>加法和乘法都满足交换律，对于选出的 2 个数字不需要考虑不同的顺序，在第二次运算时直接跳过。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> TARGET = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> EPSILON = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ADD = <span class="number">0</span>, MULTIPLY = <span class="number">1</span>, SUBTRACT = <span class="number">2</span>, DIVIDE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgePoint24</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将所有数字转为 double 并存进list</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            list.add((<span class="keyword">double</span>) num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(List&lt;Double&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列表中只剩一个数字，判断它是否等于 24</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(list.get(<span class="number">0</span>) - TARGET) &lt; EPSILON;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="comment">// 有序选出 i，j 位置的两个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)&#123;</span><br><span class="line">                <span class="comment">//选出同一个数</span></span><br><span class="line">                <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;Double&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//保存除 i，j 位置的元素</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k != i &amp;&amp; k != j)&#123;</span><br><span class="line">                        list2.add(list.get(k));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//选出一种运算</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                    <span class="comment">//如果是加或乘运算，且这是第二次选中 i 和 j</span></span><br><span class="line">                    <span class="keyword">if</span>(k &lt; <span class="number">2</span> &amp;&amp; i &gt; j)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//计算结果</span></span><br><span class="line">                    <span class="keyword">if</span>(k == ADD)&#123;</span><br><span class="line">                        list2.add(list.get(i) + list.get(j));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == MULTIPLY)&#123;</span><br><span class="line">                        list2.add(list.get(i) * list.get(j));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == SUBTRACT)&#123;</span><br><span class="line">                        list2.add(list.get(i) - list.get(j));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == DIVIDE)&#123;</span><br><span class="line">                        <span class="comment">//跳过除数为 0 的情况</span></span><br><span class="line">                        <span class="keyword">if</span>(Math.abs(list.get(j)) &lt; EPSILON)&#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            list2.add(list.get(i) / list.get(j));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//继续选出两个数字并计算，如果得到结果，返回 true</span></span><br><span class="line">                    <span class="keyword">if</span>(solve(list2))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">// list 不能得到 24点，删除加入的元素，并尝试下一种运算</span></span><br><span class="line">                    list2.remove(list2.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;679-24-点游戏&quot;&gt;&lt;a href=&quot;#679-24-点游戏&quot; class=&quot;headerlink&quot; title=&quot;679. 24 点游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/24-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;679. 24 点游戏&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 &lt;code&gt;*&lt;/code&gt;，&lt;code&gt;/&lt;/code&gt;，&lt;code&gt;+&lt;/code&gt;，&lt;code&gt;-&lt;/code&gt;，&lt;code&gt;(&lt;/code&gt;，&lt;code&gt;)&lt;/code&gt; 的运算得到 24。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="数学" scheme="https://hoo334.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的最小深度</title>
    <link href="https://hoo334.github.io/2020/08/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <id>https://hoo334.github.io/2020/08/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</id>
    <published>2020-08-21T01:34:22.000Z</published>
    <updated>2020-08-21T01:50:12.976Z</updated>
    
    <content type="html"><![CDATA[<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h4><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><a id="more"></a><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最小深度  2.</p><p>看到这么简单的题，一顿操作，立马就写出了如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试发现 [2,9]这个用例不对，我们得到的结果为 1，实际结果为 2。原因在于我们统计了空结点到根节点的深度。</p><p>对于每个结点，当只有一个子树时，直接返回子树的最小深度加一；当有两颗子树时，返回左右子树之中的最小深度加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="keyword">null</span> &amp;&amp; root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(h)，h 为树的高度，当二叉树退化为链表时，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;111-二叉树的最小深度&quot;&gt;&lt;a href=&quot;#111-二叉树的最小深度&quot; class=&quot;headerlink&quot; title=&quot;111. 二叉树的最小深度&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;111. 二叉树的最小深度&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二叉树，找出其最小深度。&lt;/p&gt;
&lt;p&gt;最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>扫雷游戏</title>
    <link href="https://hoo334.github.io/2020/08/20/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/"/>
    <id>https://hoo334.github.io/2020/08/20/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</id>
    <published>2020-08-20T04:01:59.000Z</published>
    <updated>2020-08-20T04:12:29.682Z</updated>
    
    <content type="html"><![CDATA[<h4 id="529-扫雷游戏"><a href="#529-扫雷游戏" class="headerlink" title="529. 扫雷游戏"></a><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">529. 扫雷游戏</a></h4><p>让我们一起来玩扫雷游戏！</p><p>给定一个代表游戏板的二维字符矩阵。 <strong>‘M’</strong> 代表一个<strong>未挖出的</strong>地雷，<strong>‘E’</strong> 代表一个<strong>未挖出的</strong>空方块，<strong>‘B’</strong> 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong>已挖出的</strong>空白方块，<strong>数字</strong>（’1’ 到 ‘8’）表示有多少地雷与这块<strong>已挖出的</strong>方块相邻，<strong>‘X’</strong> 则表示一个<strong>已挖出的</strong>地雷。</p><p>现在给出在所有<strong>未挖出的</strong>方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><ol><li><p>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 <strong>‘X’</strong>。</p></li><li><p>如果一个<strong>没有相邻地雷</strong>的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的<strong>未挖出</strong>方块都应该被递归地揭露。</p></li><li><p>如果一个<strong>至少与一个地雷相邻</strong>的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。</p></li><li><p>如果在此次点击中，若无更多方块可被揭露，则返回面板。</p><a id="more"></a></li></ol><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">解释:</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">解释:</span><br></pre></td></tr></table></figure><p> <strong>注意：</strong></p><ol><li>输入矩阵的宽和高的范围为 [1,50]。</li><li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li><li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li><li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li></ol><p>对于我们点击的每一个方块，有两种情况：</p><ul><li>当前点击的方块是未挖出的地雷，将其值改为 X；</li><li>当前点击的是为未挖出的空方块，我们需要统计它周围相邻的方块里地雷的数量cnt（即M 的数量）。如果 cnt 为 0 ，则将其改为 B，且递归地处理周围<strong>八个</strong>未挖出地方块，如果 cnt 不为 0 ，将其改为数字即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = click[<span class="number">0</span>], y = click[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//判断当前方块是否为地雷</span></span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == <span class="string">'M'</span>)&#123;</span><br><span class="line">            board[x][y] = <span class="string">'X'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(board, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计当前空方块周围地雷数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[tx][ty] == <span class="string">'M'</span>)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//地雷数大于零，直接修改当前方块为地雷数</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            board[x][y] = (<span class="keyword">char</span>) (cnt + <span class="string">'0'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//周围没有地雷，递归地对周围八个方块进行搜索</span></span><br><span class="line">            board[x][y] = <span class="string">'B'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">                <span class="comment">//碰到边界或者不是未挖出的方块时返回</span></span><br><span class="line">                <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length || board[tx][ty] != <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dfs(board, tx, ty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)，m 和 n 为面板的长宽。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;529-扫雷游戏&quot;&gt;&lt;a href=&quot;#529-扫雷游戏&quot; class=&quot;headerlink&quot; title=&quot;529. 扫雷游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minesweeper/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;529. 扫雷游戏&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;让我们一起来玩扫雷游戏！&lt;/p&gt;
&lt;p&gt;给定一个代表游戏板的二维字符矩阵。 &lt;strong&gt;‘M’&lt;/strong&gt; 代表一个&lt;strong&gt;未挖出的&lt;/strong&gt;地雷，&lt;strong&gt;‘E’&lt;/strong&gt; 代表一个&lt;strong&gt;未挖出的&lt;/strong&gt;空方块，&lt;strong&gt;‘B’&lt;/strong&gt; 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的&lt;strong&gt;已挖出的&lt;/strong&gt;空白方块，&lt;strong&gt;数字&lt;/strong&gt;（’1’ 到 ‘8’）表示有多少地雷与这块&lt;strong&gt;已挖出的&lt;/strong&gt;方块相邻，&lt;strong&gt;‘X’&lt;/strong&gt; 则表示一个&lt;strong&gt;已挖出的&lt;/strong&gt;地雷。&lt;/p&gt;
&lt;p&gt;现在给出在所有&lt;strong&gt;未挖出的&lt;/strong&gt;方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 &lt;strong&gt;‘X’&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个&lt;strong&gt;没有相邻地雷&lt;/strong&gt;的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的&lt;strong&gt;未挖出&lt;/strong&gt;方块都应该被递归地揭露。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个&lt;strong&gt;至少与一个地雷相邻&lt;/strong&gt;的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果在此次点击中，若无更多方块可被揭露，则返回面板。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>回文子串</title>
    <link href="https://hoo334.github.io/2020/08/19/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/08/19/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2020-08-19T02:18:27.000Z</published>
    <updated>2020-08-19T02:45:23.029Z</updated>
    
    <content type="html"><![CDATA[<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></h4><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>输入的字符串长度不会超过 1000 。</li></ul><p>我们枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同时就拓展，否则就停止拓展。</p><p>当回文长度为奇数时，回文中心就是一个字符；当回文长度为偶数时，回文中心为两个字符。一个长度为 n 的字符串，可能的回文中心有 2n - 1 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; n; index++)&#123;</span><br><span class="line">            <span class="comment">//回文长度为奇数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index, k = index; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//回文长度为偶数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index, k = index + <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将回文长度为奇数和偶数的两种情况合在一起，我们令 <code>0 &lt;= index &lt; 2n - 1</code>，回文中心<code>(j, k)</code>，其中<code>j = index / 2, k = j + (index mod 2)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">2</span> * n - <span class="number">1</span>; index++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index / <span class="number">2</span>, k = index / <span class="number">2</span> + index % <span class="number">2</span>; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;647-回文子串&quot;&gt;&lt;a href=&quot;#647-回文子串&quot; class=&quot;headerlink&quot; title=&quot;647. 回文子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/palindromic-substrings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;647. 回文子串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。&lt;/p&gt;
&lt;p&gt;具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>有序列表转换二叉搜索树</title>
    <link href="https://hoo334.github.io/2020/08/18/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/18/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-08-18T01:46:47.000Z</published>
    <updated>2020-08-21T01:54:41.678Z</updated>
    
    <content type="html"><![CDATA[<h4 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a></h4><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><p>我们需要构造出平衡的二叉树，每次让左右子树的结点个数接近，我们可以找出链表元素的中位数作为根节点的值。链表中小于根节点的元素个数与大于根节点的元素个数要么相等，要么相差 1。我们递归地对左右子树进行构造。</p><p>设当前链表左端点为 left， 右端点为 right，具体范围为<code>[left, right)</code>，左闭右开区间。定义左闭右开区间的好处是，可以方便表示初始列表<code>[head, null)</code>，如果使用左闭右闭区间，则第一次需要遍历到链表末尾来获取 right 的值。在找出链表中位数结点 mid后，我们可以使用<code>[left, mid)</code>和<code>[mid.next, right)</code>来分别表示左右子树对应的列表。</p><p>使用快慢指针法来得到链表的中位数结点，fast 指针每次移动两次，slow 指针每次移动一次，当 fast 到达边界（fast == right 或 fast.next == right，right 的前驱结点为链表的最后一个结点）时停止，此时 slow 指向的元素就是链表的中位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//左闭右开区间 [left, right)</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//得到中间结点</span></span><br><span class="line">        ListNode mid = getMid(left, right);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(mid.val);</span><br><span class="line">        <span class="comment">//递归构造左右子树</span></span><br><span class="line">        root.left = buildTree(left, mid);</span><br><span class="line">        root.right =  buildTree(mid.next, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getMid</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        ListNode slow = left;</span><br><span class="line">        ListNode fast = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != right &amp;&amp; fast.next != right)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n logn)，空间复杂度O(log n)。 n 是链表的长度。</p><p>寻找链表的中位数是一个比较耗时的操作，在二叉搜索树的构建过程是一个中序遍历，遍历结果就是链表，我们可以使用一个指针 ptr 来指向下一个需要建立的链表结点，在构建二叉搜索树的同时不断将 ptr 向后移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode ptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ptr = head;</span><br><span class="line">        <span class="keyword">int</span> length = getLength(head);</span><br><span class="line"><span class="comment">//左闭右闭区间 [left, right]</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//得到链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//计算 mid 位置</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        <span class="comment">//先构建左子树</span></span><br><span class="line">        root.left = buildTree(left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//左子树构建完时，ptr 指向根节点</span></span><br><span class="line">        root.val = ptr.val;</span><br><span class="line">        ptr = ptr.next;</span><br><span class="line">        <span class="comment">//构建右子树</span></span><br><span class="line">        root.right = buildTree(mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(log n)。n 为链表的长度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;109-有序链表转换二叉搜索树&quot;&gt;&lt;a href=&quot;#109-有序链表转换二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;109. 有序链表转换二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;109. 有序链表转换二叉搜索树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="https://hoo334.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="https://hoo334.github.io/2020/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-08-17T01:39:30.000Z</published>
    <updated>2020-08-17T01:49:06.285Z</updated>
    
    <content type="html"><![CDATA[<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p></blockquote><a id="more"></a><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回 <code>true</code> 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>返回 <code>false</code> 。</p><p>一颗树是平衡二叉树，当且仅当所有子树都是二叉平衡树，我们可以使用递归的方式来判断二叉树是否为平衡二叉树。</p><p>我们使用 height 函数来求树的最大高度，如果左右子树的高度不超过 1 ，再分别递归地遍历左右子节点，并判断左右子树是否为平衡二叉树。这是一个自顶向下的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(length(root.left) - length(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(length(root.left), length(root.right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，最坏情况下，二叉树为链表，遍历所有结点时间复杂度O(n)，计算高度时间复杂度为O(n)。</p><p>空间复杂度O(n)。</p><p>我们可以递归地判断当前结点的左右子树是否平衡，再判断以当前结点为根的树是否平衡，如果平衡，返回其高度（不小于 0 ），否则返回 - 1，代表不是平衡二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftLength = length(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightLength = length(root.right);</span><br><span class="line">        <span class="keyword">if</span>(leftLength == -<span class="number">1</span> || rightLength == -<span class="number">1</span> || Math.abs(leftLength - rightLength) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftLength, rightLength) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;110-平衡二叉树&quot;&gt;&lt;a href=&quot;#110-平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;110. 平衡二叉树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/balanced-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;110. 平衡二叉树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过1。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>图像渲染</title>
    <link href="https://hoo334.github.io/2020/08/16/%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/"/>
    <id>https://hoo334.github.io/2020/08/16/%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/</id>
    <published>2020-08-16T01:39:32.000Z</published>
    <updated>2020-08-16T01:46:30.340Z</updated>
    
    <content type="html"><![CDATA[<h4 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733. 图像渲染"></a><a href="https://leetcode-cn.com/problems/flood-fill/" target="_blank" rel="noopener">733. 图像渲染</a></h4><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p><p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p><p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>最后返回经过上色渲染后的图像。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">输出: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">解析: </span><br><span class="line">在图像的正中间，(坐标(sr,sc)&#x3D;(1,1)),</span><br><span class="line">在路径上所有符合条件的像素点的颜色都被更改成2。</span><br><span class="line">注意，右下角的像素没有更改为2，</span><br><span class="line">因为它不是在上下左右四个方向上与初始点相连的像素点。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>image</code> 和 <code>image[0]</code> 的长度在范围 <code>[1, 50]</code> 内。</li><li>给出的初始点将满足 <code>0 &lt;= sr &lt; image.length</code> 和 <code>0 &lt;= sc &lt; image[0].length</code>。</li><li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code>内。</li></ul><p><strong>方法一：DFS</strong></p><p>我们从起点开始进行深度优先搜索，每搜索到一个方格时，如果它的颜色与初始位置的方格颜色相同，我们就将其颜色改为新的颜色，并继续搜索。</p><p><strong>注意</strong>：在初始颜色和新颜色相同的情况下会造成死循环，仔细思考，这种情况不需要任何改变，直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        m = image.length;</span><br><span class="line">        n = image[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] != newColor)&#123;</span><br><span class="line">            fill(image, image[sr][sc], newColor, sr, sc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> originColor, <span class="keyword">int</span> newColor, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || image[x][y] != originColor)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        image[x][y] = newColor;</span><br><span class="line">        fill(image, originColor, newColor, x + <span class="number">1</span>, y);</span><br><span class="line">        fill(image, originColor, newColor, x - <span class="number">1</span>, y);</span><br><span class="line">        fill(image, originColor, newColor, x, y + <span class="number">1</span>);</span><br><span class="line">        fill(image, originColor, newColor, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。m 和 n 为图像的长宽。</p><p><strong>方法二：BFS</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">int</span> originColor = image[sr][sc];</span><br><span class="line">        <span class="keyword">if</span>(originColor == newColor)&#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = image.length, n = image[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr, sc&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] point = queue.poll();</span><br><span class="line">            image[point[<span class="number">0</span>]][point[<span class="number">1</span>]] = newColor;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> mx = point[<span class="number">0</span>] + dx[i];</span><br><span class="line">                <span class="keyword">int</span> my = point[<span class="number">1</span>] + dy[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(mx &gt;= <span class="number">0</span> &amp;&amp; mx &lt; m &amp;&amp; my &gt;= <span class="number">0</span> &amp;&amp; my &lt; n &amp;&amp; image[mx][my] == originColor)&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;mx, my&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。m 和 n 为图像的长宽。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;733-图像渲染&quot;&gt;&lt;a href=&quot;#733-图像渲染&quot; class=&quot;headerlink&quot; title=&quot;733. 图像渲染&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/flood-fill/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;733. 图像渲染&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。&lt;/p&gt;
&lt;p&gt;给你一个坐标 &lt;code&gt;(sr, sc)&lt;/code&gt; 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 &lt;code&gt;newColor&lt;/code&gt;，让你重新上色这幅图像。&lt;/p&gt;
&lt;p&gt;为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。&lt;/p&gt;
&lt;p&gt;最后返回经过上色渲染后的图像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://hoo334.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>有效的括号</title>
    <link href="https://hoo334.github.io/2020/08/14/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://hoo334.github.io/2020/08/14/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2020-08-14T01:33:14.000Z</published>
    <updated>2020-08-14T01:36:43.005Z</updated>
    
    <content type="html"><![CDATA[<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h4><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><a id="more"></a><p>使用栈的经典题目，我们将所有的左括号入栈，当遇到右括号时，如果栈为空或者栈顶元素不能与当前括号匹配，返回false。遍历到最后，如果栈为空则 返回 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.size() == <span class="number">0</span> || stack.pop() != <span class="string">'('</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.size() == <span class="number">0</span> || stack.pop() != <span class="string">'['</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.size() == <span class="number">0</span> || stack.pop() != <span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;20-有效的括号&quot;&gt;&lt;a href=&quot;#20-有效的括号&quot; class=&quot;headerlink&quot; title=&quot;20. 有效的括号&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;20. 有效的括号&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;{&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;}&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;[&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;]&amp;#39;&lt;/code&gt; 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意空字符串可被认为是有效字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>字符串相乘</title>
    <link href="https://hoo334.github.io/2020/08/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <id>https://hoo334.github.io/2020/08/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</id>
    <published>2020-08-13T02:11:21.000Z</published>
    <updated>2020-08-13T02:25:13.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">43. 字符串相乘</a></h4><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><code>num1</code> 和 <code>num2</code> 的长度小于110。</li><li><code>num1</code> 和 <code>num2</code> 只包含数字 <code>0-9</code>。</li><li><code>num1</code> 和 <code>num2</code> 均不以零开头，除非是数字 0 本身。</li><li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li></ol><p>我们可以模拟竖式计算来得到最后的结果。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200813101253597.png" alt="image-20200813101253597"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用 num1 的每一位乘 num2</span></span><br><span class="line">        <span class="keyword">int</span> len1 = num1.length(), len2 = num2.length();</span><br><span class="line">        String ans = <span class="string">"0"</span>;</span><br><span class="line">        <span class="comment">//从 num1 的最后一位开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//添加尾部的 0 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len1 - <span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">                sb.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算乘积</span></span><br><span class="line">            <span class="keyword">int</span> x = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> y = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> num = x * y + carry;</span><br><span class="line">                sb.append(num % <span class="number">10</span>);</span><br><span class="line">                carry = num / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果最后有进位，就将结果加入</span></span><br><span class="line">            <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">                sb.append(carry % <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//结果相加</span></span><br><span class="line">            ans = addStrings(ans, sb.reverse().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//字符串相加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num = x + y + carry;</span><br><span class="line">            carry = num / <span class="number">10</span>;</span><br><span class="line">            sb.append(num % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(m + n)。</p><p>我们可以优化竖式计算，num1 位数为 m，num2 位数为 n，num1 * num2 的最大总位数为 m * n。num1[i] * num2[j] 的结果为 tmp（可能为一位或者两位数），第一位位于 res[i + j]，第二位位于 res[i + j + 1]。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200813102303621.png" alt="image-20200813102303621"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> y = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> num = x * y + res[i + j + <span class="number">1</span>];</span><br><span class="line">                res[i + j + <span class="number">1</span>] = num % <span class="number">10</span>;</span><br><span class="line">                res[i + j] += num / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//第一位如果为 0，去掉第一位的 0</span></span><br><span class="line">            ans.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(m + n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;43-字符串相乘&quot;&gt;&lt;a href=&quot;#43-字符串相乘&quot; class=&quot;headerlink&quot; title=&quot;43. 字符串相乘&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/multiply-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;43. 字符串相乘&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定两个以字符串形式表示的非负整数 &lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt;，返回 &lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt; 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>克隆图</title>
    <link href="https://hoo334.github.io/2020/08/12/%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
    <id>https://hoo334.github.io/2020/08/12/%E5%85%8B%E9%9A%86%E5%9B%BE/</id>
    <published>2020-08-12T01:27:37.000Z</published>
    <updated>2020-08-12T01:49:45.646Z</updated>
    
    <content type="html"><![CDATA[<h4 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></h4><p>给你无向 <strong><a href="https://baike.baidu.com/item/连通图/6460995?fr=aladdin" target="_blank" rel="noopener">连通</a></strong> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank" rel="noopener"><strong>深拷贝</strong></a>（克隆）。</p><a id="more"></a><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p> <strong>示例 1：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812092919759.png" alt="image-20200812092919759"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812092941156.png" alt="image-20200812092941156"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812092954884.png" alt="image-20200812092954884"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[2],[1]]</span><br><span class="line">输出：[[2],[1]]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li>节点数不超过 100 。</li><li>每个节点值 <code>Node.val</code> 都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li><li>无向图是一个<a href="https://baike.baidu.com/item/简单图/1680528?fr=aladdin" target="_blank" rel="noopener">简单图</a>，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em> 的邻居。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ol><p><strong>方法一：DFS</strong></p><p>算法：</p><ol><li><p>使用一个哈希表存储所有已被访问和克隆得结点。哈希表中的 key 是原始图中的结点，value 是克隆图中对应结点。</p></li><li><p>从给定结点开始遍历图。如果某个结点已经被访问过，则返回其克隆图中的对应结点。</p><p>给定无向边 A - B，如果不对访问过的结点做标记，那么会陷入死循环中。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812093915504.png" alt="image-20200812093915504"></p></li><li><p>如果当前访问结点不在哈希表中，则创建它的克隆结点存储在哈希表中。在进入递归之前，必须先将克隆结点保存在哈希表中。如果不保证这种顺序，可能会导致死循环。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812094048633.png" alt="image-20200812094048633"></p></li><li><p>递归调用每个结点的邻接点。每一次调用返回其对应邻接点的克隆结点，最终返回这些克隆邻接点的列表，将其放入对应克隆结点的邻接表中。这样就可以克隆给定的结点和其邻接点。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果该结点已经访问过，直接从哈希表中取出对应的克隆结点返回</span></span><br><span class="line">        <span class="keyword">if</span>(visited.containsKey(node))&#123;</span><br><span class="line">            <span class="keyword">return</span> visited.get(node);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//克隆结点，注意到为了深拷贝，我们不会克隆它的邻接列表</span></span><br><span class="line">        Node cloneNode = <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="comment">//存储克隆结点</span></span><br><span class="line">        visited.put(node, cloneNode);</span><br><span class="line"><span class="comment">//遍历该结点的邻居，并更新克隆结点的邻居列表</span></span><br><span class="line">        <span class="keyword">for</span>(Node n : node.neighbors)&#123;</span><br><span class="line">            cloneNode.neighbors.add(cloneGraph(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)，其中 n 表示结点数量。</p><p><strong>方法二：BFS</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将给定的结点加入列表</span></span><br><span class="line">        queue.add(node);</span><br><span class="line">        <span class="comment">//克隆第一个结点并存储到哈希表</span></span><br><span class="line">        visited.put(node, <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//取出队列的头结点</span></span><br><span class="line">            Node n = queue.remove();</span><br><span class="line">            <span class="comment">//遍历该结点的邻居</span></span><br><span class="line">            <span class="keyword">for</span>(Node t : n.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited.containsKey(t))&#123;</span><br><span class="line">                    <span class="comment">//如果没有访问过，就克隆并存储在哈希表中</span></span><br><span class="line">                    visited.put(t, <span class="keyword">new</span> Node(t.val, <span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">                    <span class="comment">//将邻居结点加入队列中</span></span><br><span class="line">                    queue.add(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新当前结点的邻居列表</span></span><br><span class="line">                visited.get(n).neighbors.add(visited.get(t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.get(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)，其中 n 表示结点数量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;133-克隆图&quot;&gt;&lt;a href=&quot;#133-克隆图&quot; class=&quot;headerlink&quot; title=&quot;133. 克隆图&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/clone-graph/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;133. 克隆图&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你无向 &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/连通图/6460995?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;连通&lt;/a&gt;&lt;/strong&gt; 图中一个节点的引用，请你返回该图的 &lt;a href=&quot;https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;&lt;/a&gt;（克隆）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://hoo334.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>被围绕的区域</title>
    <link href="https://hoo334.github.io/2020/08/11/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
    <id>https://hoo334.github.io/2020/08/11/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</id>
    <published>2020-08-11T02:13:36.000Z</published>
    <updated>2020-08-11T02:30:16.102Z</updated>
    
    <content type="html"><![CDATA[<h4 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></h4><p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p><p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p>运行你的函数后，矩阵变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p><strong>解释:</strong></p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 <code>&#39;O&#39;</code> 都不会被填充为 <code>&#39;X&#39;</code>。 任何不在边界上，或不与边界上的 <code>&#39;O&#39;</code> 相连的 <code>&#39;O&#39;</code> 最终都会被填充为 <code>&#39;X&#39;</code>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p><p>自己的想法：从每一个字母<code>O</code>（不在边界上）开始DFS，遇到四个 X 返回，在返回过程中将 O 修改为 X；如果碰到边界，直接返回。</p><p>发现返回的条件太复杂，不会实现。</p><p>下面是官方题解：</p><p>给定矩阵中有三种元素：</p><ul><li>字母X</li><li>被字母 X 包围的字母 O</li><li>没有被字母 X 包围的字母 O</li></ul><p>要判断字母 O 是否被字母 X 包围比较困难，注意到：<strong>任何边界上的 <code>O</code> 都不会被填充为<code>X</code></strong>。我们可以想到，所有不被 X 包围的 O 都与边界上的 O 相连。我们利用这个性质判断 O 是否被 X 包围：</p><ul><li>对于每个边界上的 O，我们以它为起点，标记所有与之相连或间接相连的字母 O</li><li>遍历这个矩阵，对于每个字母：<ul><li>如果该字母被标记过，则表示它没有被字母X包围，将其恢复为 O</li><li>如果该字母没有被标记，则表示它被字母 X 包围，将其改为 X</li></ul></li></ul><p><strong>方法一：DFS</strong></p><p>使用深度优先搜索实现标记，我们将标记过的字母 O 改为 字母A。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        m = board.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">//标记与边界相连的字母 O</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//标记与边界相连的字母 O</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, m - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//处理每一个字母</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'A'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || board[x][y] != <span class="string">'O'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//标记与边界相连的字母 O</span></span><br><span class="line">        board[x][y] = <span class="string">'A'</span>;</span><br><span class="line">        dfs(board, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x - <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x, y + <span class="number">1</span>);</span><br><span class="line">        dfs(board, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。m，n为矩阵的长宽。</p><p><strong>方法二：BFS</strong></p><p>我们使用广度优先搜索来实现标记，同样，将标记过的字母 O 改为 字母A。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">//将边界上的字母 O 坐标加入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">'O'</span>) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span>(board[i][n - <span class="number">1</span>] == <span class="string">'O'</span>) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, n - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">'O'</span>) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, i&#125;);</span><br><span class="line">            <span class="keyword">if</span>(board[m - <span class="number">1</span>][i] == <span class="string">'O'</span>)queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;m - <span class="number">1</span>, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//将边界上的字母 O 坐标加入队列</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//从队列中取出一个字母 O，对其标记</span></span><br><span class="line">            <span class="keyword">int</span>[] t = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = t[<span class="number">0</span>], y = t[<span class="number">1</span>];</span><br><span class="line">            board[x][y] = <span class="string">'A'</span>;</span><br><span class="line"><span class="comment">//将当前字母 O 相连的字母 O 坐标加入队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n || board[nx][ny] != <span class="string">'O'</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//处理每一个字母</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'A'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。m，n为矩阵的长宽。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;130-被围绕的区域&quot;&gt;&lt;a href=&quot;#130-被围绕的区域&quot; class=&quot;headerlink&quot; title=&quot;130. 被围绕的区域&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/surrounded-regions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;130. 被围绕的区域&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二维的矩阵，包含 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt;（&lt;strong&gt;字母 O&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;找到所有被 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 围绕的区域，并将这些区域里所有的 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt; 用 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 填充。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://hoo334.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>和为K的子数组</title>
    <link href="https://hoo334.github.io/2020/08/10/%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://hoo334.github.io/2020/08/10/%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2020-08-10T07:17:39.000Z</published>
    <updated>2020-08-10T07:41:16.687Z</updated>
    
    <content type="html"><![CDATA[<h4 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></h4><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p><a id="more"></a><p><strong>示例 1 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure><p><strong>说明 :</strong></p><ol><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li></ol><p><strong>方法一：暴力</strong></p><p>考虑以 i 结尾和为 k 的连续子数组个数，我们需要统计符合条件的下标 j 的个数，其中 <code>0 &lt;= j &lt;= i</code>，且<code>[j...i]</code>这个子数组的和恰好为 k。我们可以枚举 j 的值，然后再使用 O(n)的时间复杂度来求和，那样就达到O(n^3) 时间复杂度。如果我们知道<code>[j, i]</code>子数组的和，就能在O(1)时间求出<code>[j - 1, i]</code>子数组的和，因此我们初始时令 j = i，在循环中使 j 变小，同时维护一个数组和 sum。我们就能在O(1)时间内得到子数组<code>[j...i]</code>的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum == k)&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(1)。</p><p><strong>方法二：前缀和+哈希表优化</strong></p><p>我们定义 pre[i] 为 [0 … i] 内所有数的和，则有：<br>$$<br>pre[i] = pre[i - 1] + nums[i]<br>$$<br>那么 [j … i]子数组为 k ，这个条件可以转化为：<br>$$<br>pre[i] - pre[j - 1] == k<br>$$<br>简单移项得到：<br>$$<br>pre[j - 1] == pre[i] - k<br>$$<br>我们考虑 以 i 结尾的和为 k 的连续子数组时，只要统计有多少个前缀和为 pre[i] - k 的 pre[j] 即可。我们建立哈希表 map，使用和为键，出现的次数为相应的值，记录pre[i] 出现的次数，从左至右边更新 map，同时维护一个前缀和变量 pre，这样在计算 pre[i]时直接使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始值，和为 0 的子数组个数为 1</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="comment">//计算 pre[i]</span></span><br><span class="line">            pre += nums[i];</span><br><span class="line">            <span class="comment">//找到和为 pre[i] - k 子数组个数 </span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(pre - k))&#123;</span><br><span class="line">                count += map.get(pre - k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新 pre[i] 和的个数</span></span><br><span class="line">            map.put(pre, map.getOrDefault(pre, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;560-和为K的子数组&quot;&gt;&lt;a href=&quot;#560-和为K的子数组&quot; class=&quot;headerlink&quot; title=&quot;560. 和为K的子数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/subarray-sum-equals-k/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;560. 和为K的子数组&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数数组和一个整数 &lt;strong&gt;k，&lt;/strong&gt;你需要找到该数组中和为 &lt;strong&gt;k&lt;/strong&gt; 的连续的子数组的个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第201场周赛</title>
    <link href="https://hoo334.github.io/2020/08/10/Leetcode%E7%AC%AC201%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <id>https://hoo334.github.io/2020/08/10/Leetcode%E7%AC%AC201%E5%9C%BA%E5%91%A8%E8%B5%9B/</id>
    <published>2020-08-10T02:23:05.000Z</published>
    <updated>2020-08-10T09:03:13.264Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>第二次参加周赛，又是AC两道暴力题，菜鸡只会暴力/(ㄒoㄒ)/~~。</p><a id="more"></a><h4 id="5483-整理字符串-Easy"><a href="#5483-整理字符串-Easy" class="headerlink" title="5483. 整理字符串(Easy)"></a><a href="https://leetcode-cn.com/problems/make-the-string-great/" target="_blank" rel="noopener">5483. 整理字符串(Easy)</a></h4><p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p><p>一个整理好的字符串中，<strong>两个相邻字符</strong> <code>s[i]</code> 和 <code>s[i + 1]</code> 不会同时满足下述条件：</p><ul><li><code>0 &lt;= i &lt;= s.length - 2</code></li><li><code>s[i]</code> 是小写字符，但 <code>s[i + 1]</code> 是相同的大写字符；<strong>反之亦然</strong> 。</li></ul><p>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 <strong>两个相邻</strong> 字符并删除，直到字符串整理好为止。</p><p>请返回整理好的 <strong>字符串</strong> 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。</p><p><strong>注意：</strong>空字符串也属于整理好的字符串，尽管其中没有任何字符。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leEeetcode&quot;</span><br><span class="line">输出：&quot;leetcode&quot;</span><br><span class="line">解释：无论你第一次选的是 i &#x3D; 1 还是 i &#x3D; 2，都会使 &quot;leEeetcode&quot; 缩减为 &quot;leetcode&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abBAcC&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;s&quot;</span><br><span class="line">输出：&quot;s&quot;</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含小写和大写英文字母</li></ul><p>这题目描述简直离谱，一句话来说就是：不断删除字符串中的 “xX” 或 “Xx”两个字符，x 为某个字母小写，X 为小写字母 x 对应的大写字母。</p><p>我们直接使用 StringBuffer 来进行字符的删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">makeGood</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sb.length() - <span class="number">2</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>( Math.abs(sb.charAt(i) - sb.charAt(i + <span class="number">1</span>)) == <span class="number">32</span> )&#123;</span><br><span class="line">                sb.delete(i, i + <span class="number">2</span>);</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1545-找出第-N-个二进制字符串中的第-K-位-Medium"><a href="#1545-找出第-N-个二进制字符串中的第-K-位-Medium" class="headerlink" title="1545. 找出第 N 个二进制字符串中的第 K 位(Medium)"></a><a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/" target="_blank" rel="noopener">1545. 找出第 N 个二进制字符串中的第 K 位(Medium)</a></h4><p>给你两个正整数 <code>n</code> 和 <code>k</code>，二进制字符串 <code>Sn</code> 的形成规则如下：</p><ul><li><code>S1 = &quot;0&quot;</code></li><li>当 <code>i &gt; 1</code> 时，<code>Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code></li></ul><p>其中 <code>+</code> 表示串联操作，<code>reverse(x)</code> 返回反转 <code>x</code> 后得到的字符串，而 <code>invert(x)</code> 则会翻转 x 中的每一位（0 变为 1，而 1 变为 0）</p><p>例如，符合上述描述的序列的前 4 个字符串依次是：</p><ul><li><code>S1 = &quot;0&quot;</code></li><li><code>S2 = &quot;011&quot;</code></li><li><code>S3 = &quot;0111001&quot;</code></li><li><code>S4 = &quot;011100110110001&quot;</code></li></ul><p>请你返回 <code>Sn</code> 的 <strong>第 <code>k</code> 位字符</strong> ，题目数据保证 <code>k</code> 一定在 <code>Sn</code> 长度范围以内。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：&quot;0&quot;</span><br><span class="line">解释：S3 为 &quot;0111001&quot;，其第 1 位为 &quot;0&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4, k &#x3D; 11</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line">解释：S4 为 &quot;011100110110001&quot;，其第 11 位为 &quot;1&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1, k &#x3D; 1</span><br><span class="line">输出：&quot;0&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 2, k &#x3D; 3</span><br><span class="line">输出：&quot;1&quot;</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= 2n - 1</code></li></ul><p><strong>方法一：暴力</strong></p><p>菜鸡只会暴力。/(ㄒoㄒ)/~~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"0"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            StringBuffer temp = invertAndReverse(sb);</span><br><span class="line">            sb.append(<span class="number">1</span>).append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.charAt(k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuffer <span class="title">invertAndReverse</span><span class="params">(StringBuffer s)</span></span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span>)&#123;</span><br><span class="line">                sb.append(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：数学</strong></p><p>将 n 个字符串从大到小遍历 n - 1 次，计算第 n 个字符串中间位置 midPos，并判断 k 与 midPos 的位置关系：</p><ol><li><p>如果 k &gt; midPos，第 n 个字符串第 k 个数字等于 第 n - 1 个字符串的第 midPos * 2 - k 个数字，并累加当前取反次数。</p></li><li><p>如果 k &lt; midPos，无需处理，直接遍历第 n - 1 个字符串。</p></li><li><p>k == midPos，当前位置为 1，根据取反次数计算返回即可。 </p></li></ol><p>思路来自<a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/solution/zhi-she-ji-jian-dan-de-shu-xue-ji-suan-by-lirunjun/" target="_blank" rel="noopener">___rj</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以 n &#x3D; 3， k &#x3D; 5 来解释第 3 条规则：</span><br><span class="line">s1 &#x3D; 0</span><br><span class="line">s2 &#x3D; 011</span><br><span class="line">s3 &#x3D; 0111001</span><br><span class="line"></span><br><span class="line">所有的下标都是从 1 开始，n &#x3D; 3 时，midPos &#x3D; 2 ^ 2 &#x3D; 4，而 k &#x3D; 5，S3[5] 为 reverse(invert(S2))[5 - 4],为invert(s2)[4 - (5 - 4)],即 invert(s2)[3]。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> invertNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//计算第 n 个字符串的中间位置</span></span><br><span class="line">            <span class="keyword">int</span> midPos = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(k == midPos)&#123;<span class="comment">//等于中间位置，中间位置为 1 变换 invertNum 次得到的数</span></span><br><span class="line">                <span class="keyword">return</span> invertNum % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &gt; midPos)&#123;<span class="comment">//在第 n - 1个字符串中查找</span></span><br><span class="line">                k = <span class="number">2</span> * midPos - k;</span><br><span class="line">                ++invertNum;</span><br><span class="line">            &#125;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结果为 初始值 0 变换 invertNum 次得到</span></span><br><span class="line">        <span class="keyword">return</span> invertNum % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">'0'</span> : <span class="string">'1'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：递归</strong></p><p>和方法二类似，这里用递归实现。</p><p>思路来自<a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/solution/di-gui-shuang-bai-logn-by-233999/" target="_blank" rel="noopener">小名的魔法少爷</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(k == mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &lt; mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n - <span class="number">1</span>, k);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n - <span class="number">1</span>, <span class="number">2</span> * mid - k) == <span class="string">'0'</span> ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1546-和为目标值的最大数目不重叠非空子数组数目-Medium"><a href="#1546-和为目标值的最大数目不重叠非空子数组数目-Medium" class="headerlink" title="1546. 和为目标值的最大数目不重叠非空子数组数目(Medium)"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/" target="_blank" rel="noopener">1546. 和为目标值的最大数目不重叠非空子数组数目(Medium)</a></h4><p>给你一个数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>请你返回 <strong>非空不重叠</strong> 子数组的最大数目，且每个子数组中数字和都为 <code>target</code> 。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：总共有 2 个不重叠子数组 [(1,1),1,(1,1)] ，它们的和为目标值 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,3,5,1,4,2,-9], target &#x3D; 6</span><br><span class="line">输出：2</span><br><span class="line">解释：总共有 3 个子数组和为 6 。</span><br><span class="line">([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,6,6,3,5,4,1,2,8], target &#x3D; 10</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,0,0], target &#x3D; 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>0 &lt;= target &lt;= 10^6</code></li></ul><p>我们使用前缀和 + 哈希表来实现，此题与<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a>类似，使用 pre[i] 来表示[0 … i] 的子数组的和。使用一个 HashSet 存储已经出现过的连续子数组和 pre[i] ，在遍历的过程中判断是否存在和为 sum - target 的值（连续子数组 pre[j - 1]）：</p><ul><li>存在，证明 [j … i]是一个满足条件的结果。此时，需要将 HashSet 和 sum 清空，保证不会用到 [j … i] 的元素 ，同时将 sum 加入 HashSet。</li><li>不存在，继续将 pre[i] 加入 HashSet。</li></ul><p>思路来自<a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/solution/c-qian-zhui-he-tan-xin-shuang-bai-by-scyq/" target="_blank" rel="noopener">scyq</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)&#123;</span><br><span class="line">            sum += x;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(sum - target))&#123;</span><br><span class="line">                set.clear();</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1547-切棍子的最小成本-Hard"><a href="#1547-切棍子的最小成本-Hard" class="headerlink" title="1547. 切棍子的最小成本(Hard)"></a><a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/" target="_blank" rel="noopener">1547. 切棍子的最小成本(Hard)</a></h4><p>有一根长度为 <code>n</code> 个单位的木棍，棍上从 <code>0</code> 到 <code>n</code> 标记了若干位置。例如，长度为 <strong>6</strong> 的棍子可以标记如下：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200810164134879.png" alt="image-20200810164134879"></p><p>给你一个整数数组 <code>cuts</code> ，其中 <code>cuts[i]</code> 表示你需要将棍子切开的位置。</p><p>你可以按顺序完成切割，也可以根据需要更改切割的顺序。</p><p>每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。</p><p>返回切棍子的 <strong>最小总成本</strong> 。</p><p> <strong>示例 1：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200810170104715.png" alt="image-20200810170104715"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200810164337518.png" alt="image-20200810164337518"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 7, cuts &#x3D; [1,3,4,5]</span><br><span class="line">输出：16</span><br><span class="line">解释：按 [1, 3, 4, 5] 的顺序切割的情况如上所示。</span><br><span class="line"></span><br><span class="line">第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 &#x3D; 20 。</span><br><span class="line">而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 &#x3D; 16（如示例图中 7 + 4 + 3 + 2 &#x3D; 16）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 9, cuts &#x3D; [5,6,1,4,2]</span><br><span class="line">输出：22</span><br><span class="line">解释：如果按给定的顺序切割，则总成本为 25 。总成本 &lt;&#x3D; 25 的切割顺序很多，例如，[4，6，5，2，1] 的总成本 &#x3D; 22，是所有可能方案中成本最小的。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 10^6</code></li><li><code>1 &lt;= cuts.length &lt;= min(n - 1, 100)</code></li><li><code>1 &lt;= cuts[i] &lt;= n - 1</code></li><li><code>cuts</code> 数组中的所有整数都 <strong>互不相同</strong></li></ul><p>我们使用动态规划：<code>dp[i][j]</code> 表示切割<code>[i, j]</code>这段木棍所需要的最小成本，那么就在<code>[i, j]</code>之间找一个切割点，使切割成本最小。</p><p>状态转移方程为：<br>$$<br>dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cus[j] - cuts[i])<br>$$<br><code>dp[0][n]</code>为最后结果。我们从较小的木棍长度开始 dp，[i, j] 长度最短为 2 ，否则就没有切割点。</p><p>思路来自<a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/solution/java-qu-jian-dp-by-deena/" target="_blank" rel="noopener">Evelyn</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] cuts)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加头尾</span></span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        list.add(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : cuts)&#123;</span><br><span class="line">            list.add(x);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">int</span> m = list.size();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][m];</span><br><span class="line">        <span class="comment">//[i, j]从最短长度 2 开始 dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; m; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt; m; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">//list.get(j) - list.get(i)为切割[i, j]的成本</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + list.get(j) - list.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;第二次参加周赛，又是AC两道暴力题，菜鸡只会暴力/(ㄒoㄒ)/~~。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>计算二进制子串</title>
    <link href="https://hoo334.github.io/2020/08/10/%E8%AE%A1%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/08/10/%E8%AE%A1%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/</id>
    <published>2020-08-10T02:11:09.000Z</published>
    <updated>2020-08-10T02:20:17.113Z</updated>
    
    <content type="html"><![CDATA[<h4 id="696-计数二进制子串"><a href="#696-计数二进制子串" class="headerlink" title="696. 计数二进制子串"></a><a href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" rel="noopener">696. 计数二进制子串</a></h4><p>给定一个字符串 <code>s</code>，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p><p>重复出现的子串要计算它们出现的次数。</p><a id="more"></a><p><strong>示例 1 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;00110011&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br><span class="line"></span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数。</span><br><span class="line"></span><br><span class="line">另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</span><br></pre></td></tr></table></figure><p><strong>示例 2 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;10101&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>s.length</code> 在1到50,000之间。</li><li><code>s</code> 只包含“0”或“1”字符。</li></ul><p>我们可以将字符串 s 按照 0 和 1 的连续段分组，存在 counts 数组中，例如 s = 00111011，可以得到 counts = {2, 3, 1, 2}。</p><p>counts 数组中两个相邻的数一定为两种不同的字符。假设 counts 数组中相邻的两个数字为 u 和 v，那么可能为 u 个 0 ，v  个 1 或 u 个 1 ，v 个 0，这一对数字对答案的贡献为 min{u, v}。我们遍历所有相邻的数对，计算它们的贡献和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; counts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//生成 counts 数组</span></span><br><span class="line">        <span class="keyword">char</span> cur = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == cur)&#123;</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                counts.add(c);</span><br><span class="line">                cur = s.charAt(i);</span><br><span class="line">                c =  <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counts.add(c);</span><br><span class="line">        <span class="comment">//计算贡献和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.size(); i++)&#123;</span><br><span class="line">            ans += Math.min(counts.get(i), counts.get(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度和空间复杂度都为 O(n)。</p><p>我们可以发现，在对每一个数计算贡献时，我们只用到了前一个值，我们使用 last 来保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>, n = s.length(), last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ptr &lt; n)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(ptr);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(ptr &lt; n &amp;&amp; s.charAt(ptr) == c)&#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans += Math.min(count, last);</span><br><span class="line">            last = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;696-计数二进制子串&quot;&gt;&lt;a href=&quot;#696-计数二进制子串&quot; class=&quot;headerlink&quot; title=&quot;696. 计数二进制子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/count-binary-substrings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;696. 计数二进制子串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt;，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。&lt;/p&gt;
&lt;p&gt;重复出现的子串要计算它们出现的次数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>复原IP地址</title>
    <link href="https://hoo334.github.io/2020/08/09/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <id>https://hoo334.github.io/2020/08/09/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</id>
    <published>2020-08-09T02:09:00.000Z</published>
    <updated>2020-08-10T09:04:07.745Z</updated>
    
    <content type="html"><![CDATA[<h4 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原IP地址</a></h4><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 <code>&#39;.&#39;</code>分隔。</p> <a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;25525511135&quot;</span><br><span class="line">输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><p><strong>方法一：暴力</strong></p><p>我们枚举三个切割点，将每一段转换为数字，如果都满足 0 ~ 255 则保存最后结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuffer ip = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span>; a &lt; <span class="number">4</span>; a++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; b &lt; <span class="number">4</span>; b++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; <span class="number">4</span>; c++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; <span class="number">4</span>; d++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(a + b + c + d == s.length())&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> n1 = Integer.parseInt(s.substring(<span class="number">0</span>, a));</span><br><span class="line">                        <span class="keyword">int</span> n2 = Integer.parseInt(s.substring(a, a + b));</span><br><span class="line">                        <span class="keyword">int</span> n3 = Integer.parseInt(s.substring(a + b, a + b + c));</span><br><span class="line">                        <span class="keyword">int</span> n4 = Integer.parseInt(s.substring(a + b + c));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(n1 &lt;= <span class="number">255</span> &amp;&amp; n2 &lt;= <span class="number">255</span> &amp;&amp; n3 &lt;= <span class="number">255</span> &amp;&amp; n4 &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                            ip.append(n1).append(<span class="string">'.'</span>).append(n2).append(<span class="string">'.'</span>).append(n3).append(<span class="string">'.'</span>).append(n4);</span><br><span class="line">                            <span class="keyword">if</span>(ip.length() == s.length() + <span class="number">3</span>) res.add(ip.toString());</span><br><span class="line">                            ip.delete(<span class="number">0</span>, ip.length());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                         </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：回溯</strong></p><p>我们使用递归函数 <code>dfs(segId, segStart)</code>表示我们正在从 <code>s[segStart]</code>的位置开始，搜索地址中的 segId 段，其中 segId 取值为 {0, 1, 2, 3}。由于 IP 地址每一段范围为 0 ~ 255 ，我们从 s[segStart] 开始，从小到大枚举这一段 IP 地址的结束位置 segEnd。如果满足要求则进行下一段搜索，递归调用 dfs(segId + 1, segEnd + 1)。</p><p>如果某一段中 s[segStart] = ‘0’ ，那么这一段只能为 0。</p><p>在递归搜索中，如果四段 IP 地址已经全部得到且遍历完了整个字符串，那么保存结果；如果还没有找到四段 IP 地址但已经遍历完了整个字符串，结束搜索，提前回溯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEG_COUNT = <span class="number">4</span>;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] segments = <span class="keyword">new</span> <span class="keyword">int</span>[SEG_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        dfs(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> segId, <span class="keyword">int</span> segStart)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到 4 段 ip 地址，并且遍历完了字符串，这就是一种答案</span></span><br><span class="line">        <span class="keyword">if</span>(segId == SEG_COUNT)&#123;</span><br><span class="line">            <span class="keyword">if</span>(segStart == s.length())&#123;</span><br><span class="line">                StringBuffer ip = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SEG_COUNT; i++)&#123;</span><br><span class="line">                    ip.append(segments[i]);</span><br><span class="line">                    <span class="keyword">if</span>(i != SEG_COUNT - <span class="number">1</span>)&#123;</span><br><span class="line">                        ip.append(<span class="string">'.'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(ip.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果还没找到四段 ip 地址就已经遍历完了字符串，那么提前 回溯</span></span><br><span class="line">        <span class="keyword">if</span>(segStart == s.length())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前数字为 0 ，那么这段 IP 只能为 0</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(segStart) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            segments[segId] = <span class="number">0</span>;</span><br><span class="line">            dfs(s, segId + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一般情况</span></span><br><span class="line">        <span class="keyword">int</span> addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> segEnd = segStart; segEnd &lt; s.length(); ++segEnd)&#123;</span><br><span class="line">            addr = addr * <span class="number">10</span> + (s.charAt(segEnd) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(addr &gt; <span class="number">0</span> &amp;&amp; addr &lt;= <span class="number">0xFF</span>)&#123;</span><br><span class="line">                segments[segId] = addr;</span><br><span class="line">                dfs(s, segId + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;93-复原IP地址&quot;&gt;&lt;a href=&quot;#93-复原IP地址&quot; class=&quot;headerlink&quot; title=&quot;93. 复原IP地址&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/restore-ip-addresses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;93. 复原IP地址&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。&lt;/p&gt;
&lt;p&gt;有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt;分隔。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>恢复二叉搜索树</title>
    <link href="https://hoo334.github.io/2020/08/08/%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/08/%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-08-08T01:46:58.000Z</published>
    <updated>2020-08-08T02:47:23.094Z</updated>
    
    <content type="html"><![CDATA[<h4 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">99. 恢复二叉搜索树</a></h4><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  &#x2F;</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">输出: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  3</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><ul><li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li><li>你能想出一个只使用常数空间的解决方案吗？</li></ul><p><strong>方法一：显式中序遍历</strong></p><p>我们知道 BST 的中序遍历是有序的，我们可以使用一个数组存储中序遍历的结点。在交换了两个结点之后的数组，如果我们将其画成折线图，我们会发现存在一段或两段 “下降” 的折线。下面看几个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">交换两个结点后的中序遍历序列:</span><br><span class="line">[1, 3, 2, 4], 存在一段下降的折线[3, 2]，我们交换 “3” 和 “2” 即可</span><br><span class="line">[1, 5, 3 ,4 ,2 ,6], 存在两段下降的折线[5, 3] 和[4, 2]，我们交换左边折线的结点“5” 和右边折线的结点 “2” 即可。</span><br><span class="line">总结：我们只需要找到一个下降折线的左边结点和一个下降折线的右边结点，而不管折线有一根和两根折线。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//存储中序遍历得到的结点</span></span><br><span class="line">        inOrder(root, nodes);</span><br><span class="line">        <span class="keyword">int</span> n = nodes.size(); </span><br><span class="line"><span class="comment">//寻找“下降”折线的左侧结点</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes.get(i).val &gt; nodes.get(i + <span class="number">1</span>).val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//寻找“下降”折线的右侧结点</span></span><br><span class="line">        <span class="keyword">for</span>(; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes.get(j).val &lt; nodes.get(j - <span class="number">1</span>).val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//交换结点的值</span></span><br><span class="line">        TreeNode n1 = nodes.get(i);</span><br><span class="line">        TreeNode n2 = nodes.get(j);</span><br><span class="line">        <span class="keyword">int</span> temp = n1.val;</span><br><span class="line">        n1.val = n2.val;</span><br><span class="line">        n2.val = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inOrder(root.left, nodes);</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        inOrder(root.right, nodes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度O(n)，时间复杂度O(n)。</p><p><strong>方法二：隐式中序遍历</strong></p><p>在方法一中，我们使用了一个数组来保存中序遍历的结点，我们可以在中序遍历的过程中找到两个交换的结点，从而避免了存储中序遍历的结点。</p><p>我们使用 pre 来指向前一个遍历的结点，pre.val &gt; root.val 代表这是一段下降的折线，那我们可以先保存折线左侧的结点，然后再保存折线右侧的结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode x = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode y = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode pre = <span class="keyword">new</span> TreeNode(Integer.MIN_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="comment">//交换结点的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = x.val;</span><br><span class="line">        x.val = y.val;</span><br><span class="line">        y.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="comment">//第一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span> &amp;&amp; pre.val &gt; root.val)&#123;</span><br><span class="line">            x = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个结点不为空才保存第二个结点</span></span><br><span class="line">        <span class="keyword">if</span>(x != <span class="keyword">null</span> &amp;&amp; pre.val &gt; root.val)&#123;</span><br><span class="line">            y = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新前一个遍历的结点 pre</span></span><br><span class="line">        pre = root;</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度O(h)，h 为二叉树的高度。时间复杂度O(n)。</p><p><strong>方法三：Morris 中序遍历</strong></p><p>Morris 非递归中序遍历空间复杂度可以降为O(1)。</p><p>Morris 遍历算法步骤如下（假设当前遍历到的结点为 x ）：</p><ol><li>如果 x 无左孩子，则访问 x 的右孩子， 即 x = x.right。</li><li>如果 x 有左孩子，则找到 x 左子树上的最右结点（即左子树中序遍历的最后一个结点，x 在中序遍历的前驱结点），记为 predecessor。根据 predecessor的右孩子是否为空，进行如下操作：<ul><li>如果 predecessor的右孩子为空，将其右孩子指向 x ，然后访问 x 的左孩子，即 x = x.left。</li><li>如果 predecessor的右孩子不为空，则此时其右孩子指向 x ，说明我们已经遍历完 x 的左子树，我们将 predecessor的右孩子置空，然后访问 x 的右孩子，即 x = x.right。</li></ul></li></ol><p>重复上述操作，直至访问完整棵树。</p><p>整个过程我们只多做一步：将当前结点左子树中的最右边的结点指向它，这样在左子树遍历完成后，我们可以通过这个指针回到 x，且能通过这个知道我们已经遍历完成了左子树，省去了栈的空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode x = <span class="keyword">null</span>, y = <span class="keyword">null</span>, pred = <span class="keyword">null</span>, predecessor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//寻找 predecessor 结点(root 结点中序遍历前一个结点)</span></span><br><span class="line">                predecessor = root.left;</span><br><span class="line">                <span class="keyword">while</span>(predecessor.right != <span class="keyword">null</span> &amp;&amp; predecessor.right != root)&#123;</span><br><span class="line">                    predecessor = predecessor.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span>(predecessor.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    predecessor.right = root;</span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左子树已经访问完了，我们需要断开连接</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(pred != <span class="keyword">null</span> &amp;&amp; root.val &lt; pred.val)&#123;</span><br><span class="line">                        y = root;</span><br><span class="line">                        <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">                            x = pred;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//更新前一个遍历的结点 pred</span></span><br><span class="line">                    pred = root;</span><br><span class="line">                    <span class="comment">//断开连接</span></span><br><span class="line">                    predecessor.right = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//继续遍历右子树</span></span><br><span class="line">                    root = root.right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有左孩子，直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(pred != <span class="keyword">null</span> &amp;&amp; root.val &lt; pred.val)&#123;</span><br><span class="line">                    y = root;</span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        x = pred;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pred = root;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换 x 和 y 的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = x.val;</span><br><span class="line">        x.val = y.val;</span><br><span class="line">        y.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p><p>参见<a href="https://leetcode-cn.com/problems/recover-binary-search-tree/solution/san-chong-jie-fa-xiang-xi-tu-jie-99-hui-fu-er-cha-/" target="_blank" rel="noopener">王尼玛的幻灯片</a>更好地理解算法过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;99-恢复二叉搜索树&quot;&gt;&lt;a href=&quot;#99-恢复二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;99. 恢复二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/recover-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;99. 恢复二叉搜索树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;二叉搜索树中的两个节点被错误地交换。&lt;/p&gt;
&lt;p&gt;请在不改变其结构的情况下，恢复这棵树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>相同的树</title>
    <link href="https://hoo334.github.io/2020/08/07/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/07/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</id>
    <published>2020-08-07T02:28:13.000Z</published>
    <updated>2020-08-07T02:36:27.862Z</updated>
    
    <content type="html"><![CDATA[<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></h4><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>方法一：DFS</strong></p><p>对于两棵树 root1，root2，如果 root1 和 root2 都为空，则返回 true；如果 root1 和 root2 中有一个为空，另一个不为空，则返回false。如果都不为空且它们的值相等，则递归判断左右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(min(m, n))，m，n为两棵树的节点数。空间复杂度O(min(m, n))。</p><p><strong>方法二：BFS</strong></p><p>我们使用两个队列来存储二叉树的层次遍历。判断这个队列中的结点值是否相同即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q1.offer(p);</span><br><span class="line">        q2.offer(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q1.isEmpty() &amp;&amp; !q2.isEmpty())&#123;</span><br><span class="line">            TreeNode n1 = q1.poll(), n2 = q2.poll();</span><br><span class="line">            <span class="keyword">if</span>(n1.val != n2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( (n1.left == <span class="keyword">null</span> ^ n2.left == <span class="keyword">null</span>) || (n1.right == <span class="keyword">null</span> ^ n2.right == <span class="keyword">null</span>) )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(n1.left != <span class="keyword">null</span>) q1.offer(n1.left);</span><br><span class="line">            <span class="keyword">if</span>(n1.right != <span class="keyword">null</span>) q1.offer(n1.right);</span><br><span class="line">            <span class="keyword">if</span>(n2.left != <span class="keyword">null</span>) q2.offer(n2.left);</span><br><span class="line">            <span class="keyword">if</span>(n2.right != <span class="keyword">null</span>) q2.offer(n2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(min(m, n))，m，n为两棵树的节点数。空间复杂度O(min(m, n))。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;100-相同的树&quot;&gt;&lt;a href=&quot;#100-相同的树&quot; class=&quot;headerlink&quot; title=&quot;100. 相同的树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/same-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;100. 相同的树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定两个二叉树，编写一个函数来检验它们是否相同。&lt;/p&gt;
&lt;p&gt;如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
