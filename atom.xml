<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2020-07-26T04:55:52.608Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>矩阵中的最长递增路径</title>
    <link href="https://hoo334.github.io/2020/07/26/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/"/>
    <id>https://hoo334.github.io/2020/07/26/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/</id>
    <published>2020-07-26T04:36:57.000Z</published>
    <updated>2020-07-26T04:55:52.608Z</updated>
    
    <content type="html"><![CDATA[<h4 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h4><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><p>将矩阵看成一个有向图，每个元素对应图中一个结点，如果两个相邻元素的值不相等，则存在一条从较小值到较大值的有向边，问题转化为在有向图中寻找最长路径。</p><p>从一个结点开始进行深度优先搜索，可以得到从该结点开始的最长递增路径，对矩阵中每个结点进行深度优先搜索后可得到最长递增路径的长度。</p><p>朴素深度优先搜索的问题是进行了大量的重复计算，同一个结点会被访问多次，每次都重新计算，由于同一个元素的最长递增路径是不变的，我们可以使用矩阵 memo 来存储已经计算过的结果。</p><p>使用记忆化深度优先搜索，当访问到一个元素<code>(i, j)</code>时，如果<code>memo[i][j] != 0</code>，说明该元素的结果已经计算过，直接返回结果；否则需要计算结果，并将其存入 memo 中。</p><p>我们维护一个最大值 max，当遍历完矩阵中所有的元素时即可得到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方向向量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> rows, cols;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rows = matrix.length;</span><br><span class="line">        cols = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对矩阵中每个元素进行 dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)&#123;</span><br><span class="line">                ans = Math.max(ans, dfs(matrix, i, j, memo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] memo)</span></span>&#123;</span><br><span class="line">        <span class="comment">//该结点已经计算过</span></span><br><span class="line">        <span class="keyword">if</span>(memo[row][col] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[row][col];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//递增路径长度为 1 </span></span><br><span class="line">        ++memo[row][col];</span><br><span class="line">        <span class="comment">//尝试从不同方向进行深搜</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> newRow = row + dir[<span class="number">0</span>], newCol = col + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//当前结点的值要小于相邻结点的值</span></span><br><span class="line">            <span class="keyword">if</span>(newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newCol &gt;= <span class="number">0</span> &amp;&amp; newCol &lt; cols &amp;&amp; matrix[newRow][newCol] &gt; matrix[row][col])&#123;</span><br><span class="line">                <span class="comment">//更新当前结点的最大递增路径</span></span><br><span class="line">                memo[row][col] = Math.max(memo[row][col], dfs(matrix, newRow, newCol, memo) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，其中 m 和 n 是矩阵的行数和列数。深度优先搜索的时间复杂度为O(V + E),其中 V 是结点书，E 是边数。在矩阵中 O(V) = O(mn)，O(E) 近似为 O(4mn)。</p><p>空间复杂度O(mn)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;329-矩阵中的最长递增路径&quot;&gt;&lt;a href=&quot;#329-矩阵中的最长递增路径&quot; class=&quot;headerlink&quot; title=&quot;329. 矩阵中的最长递增路径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;329. 矩阵中的最长递增路径&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数矩阵，找出最长递增路径的长度。&lt;/p&gt;
&lt;p&gt;对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>分割数组的最大值</title>
    <link href="https://hoo334.github.io/2020/07/25/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://hoo334.github.io/2020/07/25/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2020-07-25T01:53:39.000Z</published>
    <updated>2020-07-25T03:05:07.462Z</updated>
    
    <content type="html"><![CDATA[<h4 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></h4><p>给定一个非负整数数组和一个整数 <em>m</em>，你需要将这个数组分成 <em>m</em> 个非空的连续子数组。设计一个算法使得这 <em>m</em> 个子数组各自和的最大值最小。</p><a id="more"></a><p><strong>注意:</strong><br>数组长度 <em>n</em> 满足以下条件:</p><ul><li>1 ≤ <em>n</em> ≤ 1000</li><li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums &#x3D; [7,2,5,10,8]</span><br><span class="line">m &#x3D; 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure><p><strong>方法一：暴力（超时）</strong></p><p>我们要将 nums[0 … n - 1] 分为 m 个非空的子数组，我们可以先将 nums 数组分为 [0 … i)，[i … n  -1]两个数组(1 &lt; i &lt;= n - 1)，再计算 nums[i … n - 1] 分成 m - 1个子数组各自和的最大值最小，可以看出这是一个递归操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//利用前缀和数组进行优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            count[i] = count[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// num 数组最多分成 n 个子数组</span></span><br><span class="line">        <span class="keyword">return</span> split(count, m &gt; n ? n : m - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span>[] count, <span class="keyword">int</span> m, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否还需要切分，否则返回[start, end]范围内的元素之和</span></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> count[end + <span class="number">1</span>] - count[start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//枚举每一个切分位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end &amp;&amp; m &gt; <span class="number">0</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//递归地计算[i, end]分割为 m - 1个子数组的最大值的最小值</span></span><br><span class="line">            <span class="keyword">int</span> right = split(count, m - <span class="number">1</span>, i, end);</span><br><span class="line">            <span class="comment">//维护最小值</span></span><br><span class="line">            min = Math.min(min, Math.max(count[i] - count[start], right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^m)，空间复杂度O(n)。爆炸！！！</p><p><strong>方法二：动态规划</strong></p><p>令<code>f[i][j]</code>表示将数组的前 i 个数分割为 j 段所能得到的最大连续子数组和的最小值。我们枚举第 j 段的具体范围，我们可以枚举 k，其中前 k 个数被分割为 j - 1 段，而第 k + 1到第 i 个数为第 j 段。此时，这 j 段子数组中和的最大值就等于 <code>f[k][j - 1]</code>和<code>sub(k + 1, i)</code>中的较大值，其中<code>sub(i, j)</code>表示数组 nums 中下标落在区间[i, j]内的数的和。得到状态转移方程：<br>$$<br>f[i, j] = \min^{i-1}_{k=0}{max(f[k][j - 1],sub(k + 1, i))}<br>$$<br>i 个数最多只能分成 i 段，因此 i &gt;= j 是合法状态，对于不合法的状态(j &gt; i)，由于我们求的是最小值，我们将其初始化为一个很大的值，当我们尝试从不合法的状态转移，得到的结果将是一个很大的数。</p><p>我们还需要初始化<code>f[0][0] = 0</code>，最后的结果为 <code>f[n][m]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//将 dp 数组全部设为最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//生成前缀和数组</span></span><br><span class="line">        <span class="keyword">int</span>[] sub = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sub[i + <span class="number">1</span>] = sub[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//初始状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从前往后依次计算 dp 数组的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//j &lt;= i</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Math.min(i, m); j++)&#123;</span><br><span class="line">                <span class="comment">//枚举最后一个子数组的切割点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k][j - <span class="number">1</span>], sub[i] - sub[k]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(m*n^2)，n 为数组的长度，m 为非空连续子数组的个数。</p><p>空间复杂度O(n * m)。</p><p><strong>方法三：二分查找</strong></p><p>本题中，我们注意到：当我们选定一个值 x，我们可以线性地验证是否存在一种分割方案，满足其最大分割子数组和不超过 x。策略如下：</p><blockquote><p>贪心地模拟分割的过程，从前到后遍历数组，用 sum 表示当前分割子数组的和，cnt 表示已经分割出的子数组的数量(包括当前子数组)，那么每当 sum 加上当前值超过了 x，我们就把当前取的值作为<strong>新的一段</strong>分割子数组的开头，并将分割出的子数组的数量 cnt 加一。遍历结束后验证是否 cnt 不超过 m。</p></blockquote><p>我们可以使用二分查找来解决。二分的上界为数组 nums 中所有元素的和，下界为 nums 中所有元素的最大值。通过二分查找，我们可以得到最小的最大分割子数组和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 初始化二分查找上下界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(left &lt; nums[i])&#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(nums, mid, m))&#123;</span><br><span class="line">                right = mid; <span class="comment">//存在最大分割子数组的和小于 x，将 x 缩小</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//不存在最大分割子数组的和小于 x，将 x 增大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//检查是否存在最大分割子数组的和 小于 x</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// sum 值大于 x，将当前值作为新的分割子数组的开头</span></span><br><span class="line">            <span class="keyword">if</span>(sum + nums[i] &gt; x)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n * log(sum - maxn))，sum 表示数组 nums 中所有元素的和，maxn表示数组所有元素的最大值，每次二分查找时，需要对数组进行一次遍历。</p><p>空间复杂度O(1)。妙啊！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;410-分割数组的最大值&quot;&gt;&lt;a href=&quot;#410-分割数组的最大值&quot; class=&quot;headerlink&quot; title=&quot;410. 分割数组的最大值&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/split-array-largest-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;410. 分割数组的最大值&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个非负整数数组和一个整数 &lt;em&gt;m&lt;/em&gt;，你需要将这个数组分成 &lt;em&gt;m&lt;/em&gt; 个非空的连续子数组。设计一个算法使得这 &lt;em&gt;m&lt;/em&gt; 个子数组各自和的最大值最小。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="贪心" scheme="https://hoo334.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>除数博弈</title>
    <link href="https://hoo334.github.io/2020/07/24/%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/"/>
    <id>https://hoo334.github.io/2020/07/24/%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/</id>
    <published>2020-07-24T02:28:39.000Z</published>
    <updated>2020-07-24T02:52:20.471Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1025-除数博弈"><a href="#1025-除数博弈" class="headerlink" title="1025. 除数博弈"></a><a href="https://leetcode-cn.com/problems/divisor-game/" target="_blank" rel="noopener">1025. 除数博弈</a></h4><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p><p>最初，黑板上有一个数字 <code>N</code> 。在每个玩家的回合，玩家需要执行以下操作：</p><ul><li>选出任一 <code>x</code>，满足 <code>0 &lt; x &lt; N</code> 且 <code>N % x == 0</code> 。</li><li>用 <code>N - x</code> 替换黑板上的数字 <code>N</code> 。</li></ul><p>如果玩家无法执行这些操作，就会输掉游戏。</p><p>只有在爱丽丝在游戏中取得胜利时才返回 <code>True</code>，否则返回 <code>false</code>。假设两个玩家都以最佳状态参与游戏。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li><code>1 &lt;= N &lt;= 1000</code></li></ol><p>我们尝试写几项：</p><ul><li><p>N = 1，区间(0, 1)中没有整数是 n 的因数，所以 Alice 败。</p></li><li><p>N = 2，Alice 选择 1，N 变为 1，Bob 不能继续操作，Alice 胜。</p></li><li><p>N = 3，Alice 选择 1，N 变为 2，根据 N = 2的结论，Bob 胜，Alice 败。</p></li><li><p>N = 4，Alice 可选择 1 或 2，当 Alice 选择 2 时 根据 N = 2的结论 ，Alice 败，Alice 选择 1 时，根据 N = 3 的结论，Alice 胜。</p></li><li><p>N = 5 ，Alice 选择 1 ，根据 N = 4 的结论，Alice 败。 </p></li></ul><p>我们定义 <code>f[i]</code> 表示当数字为 i 时，先手处于必胜态还是必败态，true 代表先手胜，false 代表先手败。当 N = i 时，Alice 在 <code>(0, i)</code>中选择一个因数 j ，使得<code>i % j == 0</code>，且 <code>f[i - j] = false</code>（Bob先手必败），那么 Alice 就可获胜。否则 Alice 败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[N + <span class="number">2</span>];</span><br><span class="line">        f[<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">        f[<span class="number">2</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i % j == <span class="number">0</span>) &amp;&amp; !f[i - j])&#123;</span><br><span class="line">                    f[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(n)。</p><p>看到前面几项的规律，我们猜测 N 为 奇数时 Alice（先手）必败，N 为偶数时，Alice 必胜。</p><p>证明：</p><ol><li>N = 1 和 N = 2 时结论成立。</li><li>N &gt; 2 时，假设 N &lt;= k 时该结论成立，则 N = k + 1 时：<ul><li>如果 k 为偶数，则 k + 1 为奇数，x 是 k + 1 的因数，只能为奇数，奇数减去奇数得到偶数，且 k + 1 - x &lt;= k，轮到 Bob 时都是偶数，根据假设，N &lt;= k时，偶数先手必胜，则 Bob 必胜，Alice 必败。</li><li>如果 k 为奇数，则 k + 1 为偶数，x 是 k + 1的因数，x 可为奇数和偶数，若 Alice 减去一个奇数，k + 1 - x 一定是个奇数，根据假设 Bob 必败，Alice 必胜。当 x 为偶数时，Alice 必败。故 Alice 选择 x 为奇数。</li></ul></li></ol><p>综上，猜想正确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (N &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1025-除数博弈&quot;&gt;&lt;a href=&quot;#1025-除数博弈&quot; class=&quot;headerlink&quot; title=&quot;1025. 除数博弈&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/divisor-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1025. 除数博弈&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。&lt;/p&gt;
&lt;p&gt;最初，黑板上有一个数字 &lt;code&gt;N&lt;/code&gt; 。在每个玩家的回合，玩家需要执行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选出任一 &lt;code&gt;x&lt;/code&gt;，满足 &lt;code&gt;0 &amp;lt; x &amp;lt; N&lt;/code&gt; 且 &lt;code&gt;N % x == 0&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;N - x&lt;/code&gt; 替换黑板上的数字 &lt;code&gt;N&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果玩家无法执行这些操作，就会输掉游戏。&lt;/p&gt;
&lt;p&gt;只有在爱丽丝在游戏中取得胜利时才返回 &lt;code&gt;True&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。假设两个玩家都以最佳状态参与游戏。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="数学" scheme="https://hoo334.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>最小路径和</title>
    <link href="https://hoo334.github.io/2020/07/23/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://hoo334.github.io/2020/07/23/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2020-07-23T01:46:59.000Z</published>
    <updated>2020-07-23T01:58:14.540Z</updated>
    
    <content type="html"><![CDATA[<h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h4><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p>我们创建二维 dp 数组，<code>dp[i][j]</code>表示从左上角出发到<code>(i, j)</code>位置的最小路径和。<code>dp[0][0]=grid[0][0]</code>。对于其他元素有以下方程：</p><ul><li>当 i = 0，j &gt; 0 时，<code>dp[0][j] = dp[0][j - 1] + grid[0][j]</code>；</li><li>当 j = 0，i &gt; 0 时，<code>dp[i][0] =  dp[i - 1][0] + grid[i][0]</code>；</li><li>当 j &gt; 0，i &gt; 0 时，<code>dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])</code>。</li></ul><p><code>dp[m - 1][n - 1]</code>即为从左上角到右下角的路径和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] cost = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"></span><br><span class="line">        cost[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;row; ++i)&#123;</span><br><span class="line">            cost[i][<span class="number">0</span>] = cost[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;col; ++i)&#123;</span><br><span class="line">            cost[<span class="number">0</span>][i] = cost[<span class="number">0</span>][i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;col; j++)&#123;</span><br><span class="line">                cost[i][j] = Math.min(cost[i-<span class="number">1</span>][j],cost[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。</p><p>我们可以使用滚动数组来优化空间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] cost = <span class="keyword">new</span> <span class="keyword">int</span>[col];</span><br><span class="line"></span><br><span class="line">        cost[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;col; ++i)&#123;</span><br><span class="line">            cost[i] = cost[i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left = j &gt; <span class="number">0</span> ? cost[j - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">                cost[j] = Math.min(cost[j],left)+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cost[col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;64-最小路径和&quot;&gt;&lt;a href=&quot;#64-最小路径和&quot; class=&quot;headerlink&quot; title=&quot;64. 最小路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-path-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;64. 最小路径和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个包含非负整数的 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;每次只能向下或者向右移动一步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>寻找旋转排序数组中的最小值II</title>
    <link href="https://hoo334.github.io/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/"/>
    <id>https://hoo334.github.io/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/</id>
    <published>2020-07-22T03:06:19.000Z</published>
    <updated>2020-07-22T06:28:16.842Z</updated>
    
    <content type="html"><![CDATA[<h4 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a> 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li></ul><p>我们得到的旋转数组类似于下图，由两段单调递增的序列构成，右边序列的最大值小于等于左边序列的最小值。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200722142620638.png" alt="image-20200722142620638"></p><p>在二分查找过程中，我们有以下几种情况：</p><ol><li><p>左值 &lt; 中值，中值 &lt; 右值，最小值在左边，[中，右]范围内的值不可能为最小值，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">右</span><br><span class="line">中</span><br><span class="line">左</span><br></pre></td></tr></table></figure></li><li><p>左值 &lt; 中值，中值 &gt; 右值，最小值在右边，[左，中]范围内的值不可能为最小值，可以收缩左边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中</span><br><span class="line">左</span><br><span class="line">右</span><br></pre></td></tr></table></figure></li><li><p>左值 &gt; 中值，中值 &lt; 右值，最小值在左边界，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左</span><br><span class="line">右</span><br><span class="line">中</span><br></pre></td></tr></table></figure></li><li><p>中值 = 右值，最小值在左边界，右值重复(中值有可能不重复，例如 [3, 1, 1]，分别为左中右，收缩右边界变为 [3, 1])，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">左</span><br><span class="line">中   右</span><br></pre></td></tr></table></figure></li></ol><p>情况 1，3是一类，情况 2 是一类，情况 4 是一类：</p><ul><li>如果中值 &lt; 右值，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</li><li>如果中值 &gt; 右值，[左，中]范围内的值不可能为最小值，可以收缩左边界。</li><li>如果中值 = 右值，右值重复，可以收缩右边界。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>; <span class="comment">//左闭右闭区间，用右开区间不方便判断右值</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;<span class="comment">// left == right 结束</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[r])&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>; <span class="comment">//中值 &gt; 右值，中值不可能为最小值，左边界跳过mid</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])&#123;</span><br><span class="line">                r = mid;<span class="comment">//中值 &lt; 右值，中值可能为最小值，右边界只能取到 mid</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == nums[r])&#123;</span><br><span class="line">                --r;<span class="comment">//中值 = 右值，右值重复，右边界左移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平均时间复杂度O(log n)，当数组中数字全部相等时，最坏时间复杂度O(n)。</p><p>空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;154-寻找旋转排序数组中的最小值-II&quot;&gt;&lt;a href=&quot;#154-寻找旋转排序数组中的最小值-II&quot; class=&quot;headerlink&quot; title=&quot;154. 寻找旋转排序数组中的最小值 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;154. 寻找旋转排序数组中的最小值 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。&lt;/p&gt;
&lt;p&gt;请找出其中最小的元素。&lt;/p&gt;
&lt;p&gt;注意数组中可能存在重复的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>寻找旋转排列数组中的最小值</title>
    <link href="https://hoo334.github.io/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>https://hoo334.github.io/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</id>
    <published>2020-07-22T02:05:01.000Z</published>
    <updated>2020-07-22T06:27:13.437Z</updated>
    
    <content type="html"><![CDATA[<h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>使用二分查找，需要始终保持目标值在搜索范围内，并不断缩小左右边界。</p><p>我们得到的旋转数组类似于下图，为两段单调递增的序列构成，且右边序列最大值小于左边序列最小值。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200722142442327.png" alt="image-20200722142442327"></p><p>在二分查找过程中，我们有以下几种情况：</p><ol><li><p>左值 &lt; 中值，中值 &lt; 右值，最小值在左边，[中，右]范围内的值不可能为最小值，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">右</span><br><span class="line">中</span><br><span class="line">左</span><br></pre></td></tr></table></figure></li><li><p>左值 &lt; 中值，中值 &gt; 右值，最小值在右边，[左，中]范围内的值不可能为最小值，可以收缩左边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中</span><br><span class="line">左</span><br><span class="line">右</span><br></pre></td></tr></table></figure></li><li><p>左值 &gt; 中值，中值 &lt; 右值，最小值在左边界，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左</span><br><span class="line">右</span><br><span class="line">中</span><br></pre></td></tr></table></figure></li></ol><p>情况 1，3 是一类，情况 2 是另一类：</p><ul><li>如果中值 &lt; 右值，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</li><li>如果中值 &gt; 右值，[左，中]范围内的值不可能为最小值，可以收缩左边界。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>; <span class="comment">//左闭右闭区间，用右开区间不方便判断右值</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;<span class="comment">// left == right 结束</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[r])&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>; <span class="comment">//中值 &gt; 右值，中值不可能为最小值，左边界跳过mid</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])&#123;</span><br><span class="line">                r = mid;<span class="comment">//中值 &lt; 右值，中值可能为最小值，右边界只能取到 mid</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(log n)，空间复杂度O(1)。</p><p>参考：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;153-寻找旋转排序数组中的最小值&quot;&gt;&lt;a href=&quot;#153-寻找旋转排序数组中的最小值&quot; class=&quot;headerlink&quot; title=&quot;153. 寻找旋转排序数组中的最小值&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;153. 寻找旋转排序数组中的最小值&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。&lt;/p&gt;
&lt;p&gt;请找出其中最小的元素。&lt;/p&gt;
&lt;p&gt;你可以假设数组中不存在重复元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树II</title>
    <link href="https://hoo334.github.io/2020/07/21/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/"/>
    <id>https://hoo334.github.io/2020/07/21/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/</id>
    <published>2020-07-21T02:32:28.000Z</published>
    <updated>2020-07-21T03:50:13.902Z</updated>
    
    <content type="html"><![CDATA[<h4 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. 不同的二叉搜索树 II</a></h4><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p> <a id="more"></a><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 8</code></li></ul><p>我们枚举根结点的值为 i ，根据 BST 的性质，我们可以知道左子树的结点值集合为 [1 … i - 1]，右子树的结点值集合为 [i + 1 … n]。我们可以使用递归来建立子树。</p><p>我们定义 <code>generateTrees(start, end)</code>函数表示当前值的集合为 [start, end]，返回序列 [start, end]生成的所有可行的 BST。我们在 [start, end] 中枚举根结点 i ，将序列分为 [start, i - 1] 和 [i + 1, end] 递归地调用 generateTrees 函数。我们获得了所有的可行的右子树，最后一步，我们从左右子树集合中任选两课拼接到根结点上。</p><p>当 start &gt; end 时递归，BST 为空，返回空结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            allTrees.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> allTrees;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//枚举根结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">//得到左子树结点</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//得到右子树结点</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line"><span class="comment">//从左右子树结点集合中拿出两个结点连接到根结点</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left : leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right : rightTrees)&#123;</span><br><span class="line">                    TreeNode curTree = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    curTree.left = left;</span><br><span class="line">                    curTree.right = right;</span><br><span class="line">                    allTrees.add(curTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的结果存储了许多 BST 的根结点，我们以 n = 5， i = 3 为例来解释：</p><p>以  3 为根结点，左子树结点集合 为指向 1、2 的两个结点，右子树结点为指向 4、5 的两个结点，左右各取一个结点，新建一个根结点，生成 4 棵以 3 为根结点的 BST。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200721114003250.png" alt="image-20200721114003250"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;95-不同的二叉搜索树-II&quot;&gt;&lt;a href=&quot;#95-不同的二叉搜索树-II&quot; class=&quot;headerlink&quot; title=&quot;95. 不同的二叉搜索树 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-binary-search-trees-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;95. 不同的二叉搜索树 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，生成所有由 1 … &lt;em&gt;n&lt;/em&gt; 为节点所组成的 &lt;strong&gt;二叉搜索树&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>两数之和II-输入有序数组</title>
    <link href="https://hoo334.github.io/2020/07/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://hoo334.github.io/2020/07/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2020-07-20T04:41:41.000Z</published>
    <updated>2020-07-20T04:52:55.070Z</updated>
    
    <content type="html"><![CDATA[<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h4><p>给定一个已按照 <strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><a id="more"></a><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br></pre></td></tr></table></figure><p>初始化两个指针，左指针指向有序数组第一个元素，右指针指向有序数组最后一个元素，计算两个指针指向的元素之和 sum，若 sum &lt; target，则将左指针右移，尝试获得更大的 sum，若 sum &gt; target，则将右指针左移，尝试获得更小的 sum，当左右指针相遇时结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>; i &lt; j; )&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;167-两数之和-II-输入有序数组&quot;&gt;&lt;a href=&quot;#167-两数之和-II-输入有序数组&quot; class=&quot;headerlink&quot; title=&quot;167. 两数之和 II - 输入有序数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;167. 两数之和 II - 输入有序数组&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个已按照 &lt;strong&gt;升序排列&lt;/strong&gt; 的有序数组，找到两个数使得它们相加之和等于目标数。&lt;/p&gt;
&lt;p&gt;函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2&lt;em&gt;。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://hoo334.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>验证栈序列</title>
    <link href="https://hoo334.github.io/2020/07/20/%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/"/>
    <id>https://hoo334.github.io/2020/07/20/%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/</id>
    <published>2020-07-20T04:06:53.000Z</published>
    <updated>2020-07-20T04:47:34.012Z</updated>
    
    <content type="html"><![CDATA[<h4 id="946-验证栈序列"><a href="#946-验证栈序列" class="headerlink" title="946. 验证栈序列"></a><a href="https://leetcode-cn.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">946. 验证栈序列</a></h4><p>给定 <code>pushed</code> 和 <code>popped</code> 两个序列，每个序列中的 <strong>值都不重复</strong>，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code> 。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li><li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li><li><code>pushed</code> 是 <code>popped</code> 的排列。</li></ol><p><strong>方法一：模拟</strong></p><p>我们模拟做题过程中判断是否为出栈序列的方法，将入栈序列中的元素依次入栈，在入栈的过程中，如果栈顶元素与出栈序列的第一个元素相同则将栈顶元素弹出，直到最后栈中元素为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pushed.length, n = popped.length;</span><br><span class="line">        <span class="comment">//入栈序列长度与出栈序列长度不相同</span></span><br><span class="line">        <span class="keyword">if</span>(m != n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//是否出栈完成</span></span><br><span class="line">        <span class="keyword">while</span>(j != n)&#123;</span><br><span class="line">            <span class="comment">//入栈元素与出栈元素不相同，添加元素</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; pushed[i] != popped[j])&#123;</span><br><span class="line">                stack.addLast(pushed[i++]);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//入栈元素与出栈元素相同，先将其入栈，然后再出栈</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; m &amp;&amp; pushed[i] == popped[j])&#123;</span><br><span class="line">                stack.addLast(pushed[i++]);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//栈顶元素与出栈元素相同则出栈</span></span><br><span class="line">            <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peekLast() == popped[j])&#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//无元素入栈，栈顶元素与出栈元素不相同</span></span><br><span class="line">                    <span class="keyword">if</span>(i == m)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">//还有元素入栈，跳出循环，继续进行进栈操作</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p><p><strong>方法二：贪心</strong></p><p>将 pushed 队列中每个数都 push 到栈中，同时检查这个数是不是 popped 序列中下一个要 pop 的值，如果是，就要把它 pop 出来。</p><p>最后，检查是否所有的值都 pop 出来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pushed.length;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : pushed)&#123;</span><br><span class="line">            stack.addLast(x);</span><br><span class="line">            <span class="keyword">while</span>(stack.size() != <span class="number">0</span> &amp;&amp; stack.peekLast() == popped[j])&#123;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;946-验证栈序列&quot;&gt;&lt;a href=&quot;#946-验证栈序列&quot; class=&quot;headerlink&quot; title=&quot;946. 验证栈序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/validate-stack-sequences/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;946. 验证栈序列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定 &lt;code&gt;pushed&lt;/code&gt; 和 &lt;code&gt;popped&lt;/code&gt; 两个序列，每个序列中的 &lt;strong&gt;值都不重复&lt;/strong&gt;，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
      <category term="贪心" scheme="https://hoo334.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>戳气球</title>
    <link href="https://hoo334.github.io/2020/07/19/%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <id>https://hoo334.github.io/2020/07/19/%E6%88%B3%E6%B0%94%E7%90%83/</id>
    <published>2020-07-19T02:59:12.000Z</published>
    <updated>2020-07-19T04:12:49.201Z</updated>
    
    <content type="html"><![CDATA[<h4 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></h4><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。如果你戳破气球 <code>i</code> ，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><a id="more"></a><p><strong>说明:</strong></p><ul><li>你可以假设 <code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins &#x3D;  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   &#x3D; 167</span><br></pre></td></tr></table></figure><p>为了避免讨论边界情况，我们将 nums 数组首尾各加上 一个 数字 1 ，将这个新数组叫做 val。</p><p><strong>方法一：记忆化搜索</strong></p><p>戳气球这个操作会使两个气球从不相邻变为相邻，使得后续操作难以进行，我们倒过来看这些操作，将全过程看作是每次添加一个气球。</p><p>定义方法 solve，令 <code>solve(i, j)</code>表示开区间<code>(i, j)</code>内位置全部填满能够得到的最多硬币数。由于是开区间，因此区间两端的气球编号就是 i 和 j，对应 val[i] 和 val[j]。</p><ul><li>当 <code>i &gt;= j - 1</code> 时，开区间中没有气球，<code>solve(i, j)</code>的值为 0 。</li><li>当<code>i &lt; j - 1</code> 时，我们枚举开区间<code>(i, j)</code>内的全部位置 mid，令 mid 为当前区间第一个添加的气球，此时，区间中只有 三个值 val[i]，val[mid]，val[j]，能得到的硬币数为这三个值的积。mid 将开区间<code>(i, j)</code>分为<code>(i, mid)</code>和<code>(mid, j)</code>两部分，我们递归地计算这两个部分对 <code>solve(i, j)</code>的贡献。</li></ul><p>$$<br>solve(i, j) = \max^{j-1}_{mid=i+1}{val[i]\times val[mid]\times val[j] + solve(i,mid) + solve(mid,j) }\ \  {i &lt; j - 1}<br>$$</p><p>$$<br>solve(i, j)  = 0 \ \  {i \geq j - 1}<br>$$</p><p>为了避免重复计算，我们储存 solve 的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] rec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rec = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">2</span>; i++)&#123;</span><br><span class="line">            Arrays.fill(rec[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rec[left][right] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += solve(left, i) + solve(i, right);</span><br><span class="line">            rec[left][right] = Math.max(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^3)，空间复杂度O(n^2)。</p><p><strong>方法二：动态规划</strong></p><p>我们可以将自顶向下的记忆化搜索变为自底向上的动态规划，令 <code>dp[i][j]</code>表示填满开区间<code>(i, j)</code>能得到的最多硬币数，边界条件为 i &gt;= j - 1，此时<code>dp[i][j] = 0</code>。<br>$$<br>dp[i][j]=\max^{j-1}_{k=i+1}{val[i]\times val[k]\times val[j] + solve(i,k) + solve(k,j) }\ \   {i &lt; j - 1}<br>$$<br>$$<br>dp[i][j]  = 0 \ \  {i \geq j - 1}<br>$$</p><p>最终答案为<code>dp[0][n + 1]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] rec = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从数组尾部开始自底向上动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;<span class="comment">//枚举左边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; j++)&#123;<span class="comment">//枚举右边界</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)&#123;<span class="comment">//枚举开区间(i, j)中的全部位置</span></span><br><span class="line">                    <span class="keyword">int</span> sum = val[i] * val[k] * val[j];</span><br><span class="line">                    sum += rec[i][k] + rec[k][j];</span><br><span class="line">                    rec[i][j] = Math.max(rec[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rec[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^3)，空间复杂度O(n^2)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;312-戳气球&quot;&gt;&lt;a href=&quot;#312-戳气球&quot; class=&quot;headerlink&quot; title=&quot;312. 戳气球&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/burst-balloons/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;312. 戳气球&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;有 &lt;code&gt;n&lt;/code&gt; 个气球，编号为&lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;，每个气球上都标有一个数字，这些数字存在数组 &lt;code&gt;nums&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;现在要求你戳破所有的气球。如果你戳破气球 &lt;code&gt;i&lt;/code&gt; ，就可以获得 &lt;code&gt;nums[left] * nums[i] * nums[right]&lt;/code&gt; 个硬币。 这里的 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 代表和 &lt;code&gt;i&lt;/code&gt; 相邻的两个气球的序号。注意当你戳破了气球 &lt;code&gt;i&lt;/code&gt; 后，气球 &lt;code&gt;left&lt;/code&gt; 和气球 &lt;code&gt;right&lt;/code&gt; 就变成了相邻的气球。&lt;/p&gt;
&lt;p&gt;求所能获得硬币的最大数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>交错字符串</title>
    <link href="https://hoo334.github.io/2020/07/18/%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/07/18/%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-07-18T03:13:56.000Z</published>
    <updated>2020-07-18T03:51:53.671Z</updated>
    
    <content type="html"><![CDATA[<h4 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">97. 交错字符串</a></h4><p>给定三个字符串 <em>s1</em>, <em>s2</em>, <em>s3</em>, 验证 <em>s3</em> 是否是由 <em>s1</em> 和 <em>s2</em> 交错组成的。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>首先我们需要理解「交错」这个概念，s3 由 s1 的部分字符 和 s2 的部分字符交错形成，以示例 1 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;aadbbcbcac&quot; &#x3D; &quot;aa&quot; + &quot;db&quot; + &quot;bc&quot; + &quot;bca&quot; + &quot;c&quot;</span><br><span class="line">s1     s2     s1      s2     s1</span><br></pre></td></tr></table></figure><p>示例2中，s3 中剩下 “accc” ，s1 剩下 “cc” ，s2 剩下”ca”，”cc” 和 “ca” 无法交错形成 “accc”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;aadbbbaccc&quot; &#x3D; &quot;aa&quot; + &quot;dbb&quot; + &quot;b&quot; + ...</span><br><span class="line">s1     s2     s1</span><br></pre></td></tr></table></figure><p>可以将其当作不同路径来理解，下图来自<a href="https://leetcode-cn.com/problems/interleaving-string/solution/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch/" target="_blank" rel="noopener">gousiqi</a></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200718114829025.png" alt="image-20200718114829025"></p><p>首先，s1 和 s2 的长度之和不等于 s3 ，s3 必然不可能为 s1 和 s2 交错形成。我们定义 <code>f(i, j)</code>表示字符串 s1 的前 i 个字符能否与字符串 s2 的前 j 个字符形成字符串 s3 的前 i + j 个字符。如果 s1 的第 i 个字符与 s3 的第 i + j 个字符相等，那么 <code>f(i, j)</code>取决于 s1 的前 i - 1 个字符和 s2 的前 j 个字符能否交错构成 s3 的前 i + j - 1 个字符，表示为<code>f(i - 1, j)</code>。如果 s2 的第 j 个字符与 s3 的第 i + j 个字符相等，那么 <code>f(i, j)</code> 取决于 s1 的前 i 个字符和 s2 的前 j - 1 个字符能否交错构成 s3 的前 i + j - 1个字符，表示为<code>f(i, j - 1)</code>。我们可以得出动态规划方程：<br>$$<br>f(i,j)=[f(i - 1, j)\ and\ s_1[i]=s_3[i+j]]\ or\ [f(i, j - 1)\ and\ s_2[j] = s_3[i+j]]<br>$$<br>边界条件为 <code>f(0, 0) = true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length(), t = s3.length();</span><br><span class="line">        <span class="keyword">if</span>(m + n != t)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p = i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;<span class="comment">//注意字符串的下标与公式的区别</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//两个条件之间是 “或” 的关系</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。</p><p>我们还可以使用滚动数组来优化空间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length(), t = s3.length();</span><br><span class="line">        <span class="keyword">if</span>(m + n != t)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p = i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = dp[j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = dp[j] || dp[j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;97-交错字符串&quot;&gt;&lt;a href=&quot;#97-交错字符串&quot; class=&quot;headerlink&quot; title=&quot;97. 交错字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/interleaving-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;97. 交错字符串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定三个字符串 &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt;, &lt;em&gt;s3&lt;/em&gt;, 验证 &lt;em&gt;s3&lt;/em&gt; 是否是由 &lt;em&gt;s1&lt;/em&gt; 和 &lt;em&gt;s2&lt;/em&gt; 交错组成的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://hoo334.github.io/2020/07/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://hoo334.github.io/2020/07/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2020-07-17T02:02:36.000Z</published>
    <updated>2020-07-17T05:12:40.060Z</updated>
    
    <content type="html"><![CDATA[<p>在有序数组种，常用二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。在二分查找算法的细节主要有两点：「while 循环中的的不等号是否带等号」，「边界的取值问题」。</p><a id="more"></a><h3 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"><span class="keyword">while</span>(...)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">...;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">left = ...;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">right = ...;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mid = left + (right - left) / 2</code> 是为了避免整数溢出，我们剩下的就是要在省略号的地方填上相应的步骤来实现二分查找。</p><h3 id="寻找有序数组"><a href="#寻找有序数组" class="headerlink" title="寻找有序数组"></a>寻找有序数组</h3><p>在有序数组中寻找一个数，如果存在，返回下标，否则返回 -1。</p><p>下面我们看一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> datastructure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 在有序数组中寻找一个整数</span></span><br><span class="line"><span class="comment">    * @param nums，有序数组</span></span><br><span class="line"><span class="comment">    * @param target，需要寻找的目标</span></span><br><span class="line"><span class="comment">    * @return 找到的数值索引，未找到返回 -1</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchNum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>; <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;<span class="comment">//重点：因为左右闭区间，所以当 left == right 时，还有一个值需要判断，需要加上等号</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">//搜索区间变成[mid + 1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">//因为右闭区间,搜索区间为[left, mid - 1]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchNum2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length; <span class="comment">// 搜索区间为 [left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//左闭右开区间，当 left == right 时，区间内已经没有值</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//搜索区间变成[mid + 1, right)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//因为右开区间，搜索区间为[left, mid)，如果为 right = mid - 1，</span></span><br><span class="line">                <span class="comment">//区间为[left, mid - 1)，我们会漏掉 mid - 1位置的值</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">77</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">100</span>&#125;;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            Random random = <span class="keyword">new</span> Random(i*<span class="number">80</span>);</span><br><span class="line">            <span class="keyword">int</span> num = nums[random.nextInt(<span class="number">14</span>)];</span><br><span class="line">            System.out.println(<span class="string">"left &lt;= right: searching "</span> + num + <span class="string">" index: "</span> + binarySearchNum(nums,num));</span><br><span class="line">            System.out.println(<span class="string">"left &lt; right: searching "</span> + num + <span class="string">" index： "</span> + binarySearchNum2(nums,num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 2, 2, 3, 3, 4, 5, 14, 33, 44, 77, 77, 100]</span><br><span class="line">left &lt;&#x3D; right: searching 77 index: 12</span><br><span class="line">left &lt; right: searching 77 index： 11</span><br><span class="line">left &lt;&#x3D; right: searching 3 index: 4</span><br><span class="line">left &lt; right: searching 3 index： 5</span><br><span class="line">left &lt;&#x3D; right: searching 100 index: 13</span><br><span class="line">left &lt; right: searching 100 index： 13</span><br><span class="line">left &lt;&#x3D; right: searching 3 index: 4</span><br><span class="line">left &lt; right: searching 3 index： 5</span><br><span class="line">left &lt;&#x3D; right: searching 1 index: 0</span><br><span class="line">left &lt; right: searching 1 index： 0</span><br></pre></td></tr></table></figure><p><code>num[mid] == target</code> 时，我们已经找到了一个值的下标，直接返回即可。</p><h4 id="关于-left-lt-right-和-left-lt-right"><a href="#关于-left-lt-right-和-left-lt-right" class="headerlink" title="关于 left &lt;= right 和 left &lt; right"></a>关于 left &lt;= right 和 left &lt; right</h4><ul><li><p>当初始化 <code>left = 0, right = nums.length - 1</code> 时，搜索区间为<code>[left, right]</code>，当 <code>left == right</code>时，搜索区间内还有一个值 nums[left] 没有判断，循环条件内使用 left &lt;= right，如果使用 left &lt; right 最后需要加一次判断 nums[left] == target ?</p></li><li><p>当初始化 <code>left = 0, right = nums.length</code> 时，搜索区间为<code>[left, right)</code>，当 <code>left == right</code>时，搜索区间内没有值，循环条件内使用 left &lt; right。</p></li></ul><h4 id="关于left、right-取值问题"><a href="#关于left、right-取值问题" class="headerlink" title="关于left、right 取值问题"></a>关于left、right 取值问题</h4><ul><li><p>当初始化 <code>left = 0, right = nums.length - 1</code> 时，搜索区间为<code>[left, right]</code>，<code>mid = (left + right) / 2</code>，如果<code>nums[mid] &lt; target</code>，那么 target 值在 mid 右侧，left = mid + 1，此时搜索区间为<code>[mid + 1,right]</code>，如果<code>nums[mid] &gt; target</code>，那么 target 值在 mid 左侧，right = mid - 1，此时搜索区间为<code>[left, mid - 1]</code>。</p></li><li><p>当初始化 <code>left = 0, right = nums.length</code> 时，搜索区间为<code>[left, right)</code>，<code>mid = (left + right) / 2</code>，如果<code>nums[mid] &lt; target</code>，那么 target 值在 mid 右侧，left = mid + 1，此时搜索区间为<code>[mid + 1,right)</code>，如果<code>nums[mid] &gt; target</code>，那么 target 值在 mid 左侧，right = mid，此时搜索区间为<code>[left, mid)</code>，如果right =mid - 1，那么搜索区间为<code>[left, mid - 1)</code>，mid -  1 位置的值就不在搜索区间内，这是不对的，会造成错误。</p></li></ul><h3 id="寻找左侧边界"><a href="#寻找左侧边界" class="headerlink" title="寻找左侧边界"></a>寻找左侧边界</h3><p>二分查找数组中从左至右等于 target 的第一个值的下标，没有则返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchLeftBoundNum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length; <span class="comment">// 搜索区间为 [left, right)</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//左闭右开区间，当 left == right 时，区间内已经没有值</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;<span class="comment">//右侧逼近，下一个搜索区间[left, mid)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;<span class="comment">//搜索区间变成[mid + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//因为右开区间，搜索区间为[left, mid)，如果为 right = mid - 1，</span></span><br><span class="line">            <span class="comment">//区间为[left, mid - 1)，我们会漏掉 mid - 1位置的值</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//目前的 nums[left]是从左至右第一个大于等于 target 的值</span></span><br><span class="line">    <span class="keyword">if</span>(left == nums.length)&#123;<span class="comment">//target 大于所有值</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 2, 2, 3, 3, 4, 5, 14, 33, 44, 77, 77, 100]</span><br><span class="line">searching left bound 2 index: 1</span><br><span class="line">searching left bound 77 index: 11</span><br><span class="line">searching left bound 1 index: 0</span><br></pre></td></tr></table></figure><p>在找到 target 时，没有立刻返回，而是缩小搜索区间的右侧，从右侧逼近，达到锁定左侧边界的目的。</p><h3 id="寻找右侧边界"><a href="#寻找右侧边界" class="headerlink" title="寻找右侧边界"></a>寻找右侧边界</h3><p>二分查找数组中从右至左等于 target 的第一个值的下标，没有则返回 -1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static int binarySearchRightBoundNum(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; nums.length; &#x2F;&#x2F; 搜索区间为 [left, right)</span><br><span class="line">    while (left &lt; right) &#123; &#x2F;&#x2F;左闭右开区间，当 left &#x3D;&#x3D; right 时，区间内已经没有值</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;&#x2F;&#x2F;左侧逼近，下一个搜索区间[mid + 1, right)</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;&#x2F;&#x2F;搜索区间变成[mid + 1, right]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;因为右开区间，搜索区间为[left, mid)，如果为 right &#x3D; mid - 1，</span><br><span class="line">            &#x2F;&#x2F;区间为[left, mid - 1)，我们会漏掉 mid - 1位置的值</span><br><span class="line">            right &#x3D; mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 目前的 nums[left] 左边的部分的值都是大于等于 target</span><br><span class="line">    if(left &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F;target 小于所有值</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;返回最后一个等于 target 值的下标</span><br><span class="line">        return nums[left - 1] &#x3D;&#x3D; target ? left - 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 2, 2, 3, 3, 4, 5, 14, 33, 44, 77, 77, 100]</span><br><span class="line">searching right bound 2 index: 3</span><br><span class="line">searching right bound 77 index: 12</span><br><span class="line">searching right bound 1 index: 0</span><br></pre></td></tr></table></figure><p>在找到 target 时，没有立刻返回，而是缩小搜索区间的左侧，从左侧逼近，达到锁定右侧边界的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在有序数组种，常用二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。在二分查找算法的细节主要有两点：「while 循环中的的不等号是否带等号」，「边界的取值问题」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://hoo334.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>搜索插入位置</title>
    <link href="https://hoo334.github.io/2020/07/17/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>https://hoo334.github.io/2020/07/17/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</id>
    <published>2020-07-17T01:54:41.000Z</published>
    <updated>2020-07-17T02:02:50.830Z</updated>
    
    <content type="html"><![CDATA[<h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>看到数组有序，可以想到二分查找，此题查找的是第一个大于等于 target 数值的下标。我们直接使用二分法，利用二分法不断逼近第一个大于等于 target 的下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(log n)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;35-搜索插入位置&quot;&gt;&lt;a href=&quot;#35-搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;35. 搜索插入位置&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-insert-position/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;35. 搜索插入位置&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;你可以假设数组中无重复元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>判断二分图</title>
    <link href="https://hoo334.github.io/2020/07/16/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>https://hoo334.github.io/2020/07/16/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</id>
    <published>2020-07-16T01:41:08.000Z</published>
    <updated>2020-07-16T02:16:17.387Z</updated>
    
    <content type="html"><![CDATA[<h4 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">785. 判断二分图</a></h4><p>给定一个无向图<code>graph</code>，当这个图为二分图时返回<code>true</code>。</p><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p><p><code>graph</code>将会以邻接表方式给出，<code>graph[i]</code>表示图中与节点<code>i</code>相连的所有节点。每个节点都是一个在<code>0</code>到<code>graph.length-1</code>之间的整数。这图中没有自环和平行边： <code>graph[i]</code> 中不存在<code>i</code>，并且<code>graph[i]</code>中没有重复的值。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。</span><br><span class="line">示例 2:</span><br><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>graph</code> 的长度范围为 <code>[1, 100]</code>。</li><li><code>graph[i]</code> 中的元素的范围为 <code>[0, graph.length - 1]</code>。</li><li><code>graph[i]</code> 不会包含 <code>i</code> 或者有重复的值。</li><li>图是无向的: 如果<code>j</code> 在 <code>graph[i]</code>里边, 那么 <code>i</code> 也会在 <code>graph[j]</code>里边。</li></ul><p>对于图中任意两个结点 u 和 v ，如果它们之间有一条边相连，那么 u 和 v 必须属于不同的集合。</p><p>如果给定的无向图连通，那么我们就可以任选一个结点开始，给它染成红色，将其所连的所有结点染成绿色，同一种颜色表示它们在同一个集合里，我们再将绿色结点直接相连的未染色结点染成红色。</p><p>算法流程：</p><ul><li><p>任选一个结点开始，将其染成红色，并从该结点开始对整个无向图进行遍历；</p></li><li><p>在遍历过程中，如果我们通过结点 u 访问到了结点 v （u，v之间有一条边相连），那么会有两种情况：</p><ul><li>如果 v 未染色，将其染成与 u 不同的颜色，并对 v 直接相连的结点进行遍历；</li><li>如果 v 被染色，并且颜色与 u 相同，说明给定的无向图不是二分图，我们直接返回 false；</li></ul></li><li><p>当遍历结束时，说明给定的无向图是二分图，返回 true。</p></li></ul><p>我们可以使用「深度优先搜索」或「广度优先搜索」对无向图进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNCOLORED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        color = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        valid = <span class="keyword">true</span>;</span><br><span class="line">        Arrays.fill(color, UNCOLORED);</span><br><span class="line">        <span class="comment">//DFS</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i] == UNCOLORED)&#123;</span><br><span class="line">                dfs(i, RED, graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> c, <span class="keyword">int</span>[][] graph)</span></span>&#123;</span><br><span class="line">        color[node] = c;</span><br><span class="line">        <span class="comment">//直接相连结点颜色为当前结点颜色相反</span></span><br><span class="line">        <span class="keyword">int</span> cNei = c == RED ? GREEN : RED;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph[node])&#123;</span><br><span class="line">            <span class="comment">//相连结点未被染色</span></span><br><span class="line">            <span class="keyword">if</span>(color[neighbor] == UNCOLORED)&#123;</span><br><span class="line">                dfs(neighbor, cNei, graph);</span><br><span class="line">                <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[neighbor] != cNei)&#123;<span class="comment">//直接相连结点与当前结点颜色相同</span></span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 BFS 实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNCOLORED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        color = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(color, UNCOLORED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i] == UNCOLORED)&#123;</span><br><span class="line">                Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                color[i] = RED;</span><br><span class="line">                <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">                    <span class="keyword">int</span> cNei = color[node] == RED ? GREEN : RED;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph[node])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(color[neighbor] == UNCOLORED)&#123;</span><br><span class="line">                            queue.offer(neighbor);</span><br><span class="line">                            color[neighbor] = cNei;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[neighbor] != cNei)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(N + M)，其中 N 和 M 分别是无向图的点数和边数。</p><p>空间复杂度O(N)，存储结点颜色数组需要 O(N)空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;785-判断二分图&quot;&gt;&lt;a href=&quot;#785-判断二分图&quot; class=&quot;headerlink&quot; title=&quot;785. 判断二分图&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/is-graph-bipartite/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;785. 判断二分图&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个无向图&lt;code&gt;graph&lt;/code&gt;，当这个图为二分图时返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;graph&lt;/code&gt;将会以邻接表方式给出，&lt;code&gt;graph[i]&lt;/code&gt;表示图中与节点&lt;code&gt;i&lt;/code&gt;相连的所有节点。每个节点都是一个在&lt;code&gt;0&lt;/code&gt;到&lt;code&gt;graph.length-1&lt;/code&gt;之间的整数。这图中没有自环和平行边： &lt;code&gt;graph[i]&lt;/code&gt; 中不存在&lt;code&gt;i&lt;/code&gt;，并且&lt;code&gt;graph[i]&lt;/code&gt;中没有重复的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://hoo334.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树</title>
    <link href="https://hoo334.github.io/2020/07/15/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/07/15/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-07-15T01:46:59.000Z</published>
    <updated>2020-07-15T06:29:17.373Z</updated>
    
    <content type="html"><![CDATA[<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h4><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p>给定一个有序序列 1 … n，为了构建出一颗二叉搜索树，我们可以将数字 i 作为树根，将 1 … i - 1作为左子树，将 i + 1 … n 作为右子树。由于根植的不同，我们能保证每颗二叉搜索树是唯一的。</p><p>记<code>f[n]</code> 为整数 1 … n 构成的二叉搜索树种数，得到动态规划方程：<br>$$<br>f[n] = \sum^{n}_{i = 1}{f[i - 1]*f[n - i]}<br>$$<br>边界条件，当序列长度为1（只有根）或为 0（空树）时只有一种情况： f[0] = 1，f[1] = 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;96-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#96-不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;96. 不同的二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-binary-search-trees/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;96. 不同的二叉搜索树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，求以 1 … &lt;em&gt;n&lt;/em&gt; 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>三角形最小路径和</title>
    <link href="https://hoo334.github.io/2020/07/14/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://hoo334.github.io/2020/07/14/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2020-07-14T03:07:48.000Z</published>
    <updated>2020-07-15T02:05:46.938Z</updated>
    
    <content type="html"><![CDATA[<h4 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></h4><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p><strong>相邻的结点</strong> 在这里指的是 <code>下标</code> 与 <code>上一层结点下标</code> 相同或者等于 <code>上一层结点下标 + 1</code> 的两个结点。</p> <a id="more"></a><p>例如，给定三角形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p><p> <strong>说明：</strong></p><p>如果你可以只使用 <em>O</em>(<em>n</em>) 的额外空间（<em>n</em> 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p><p>我们使用 <code>f[i][j]</code>来表示从三角形顶部走到位置<code>(i, j)</code>的最小路径和。这里的 <code>i</code> 和 <code>j</code> 指的是三角形中第<code>i</code>行第<code>j</code>列（从 0 开始编号）的的位置。</p><p>由于每一步只能移动到下一个相邻的结点，要到位置<code>(i, j)</code>，上一步位置就只能在<code>(i - 1, j)</code>或<code>(i - 1, j - 1)</code>中选择。我们在两者之间找一个路径和比较小的来转移，状态方程为：<br>$$<br>f[i][j] = min(f[i -1][j - 1], f[i - 1][j]) + c[i][j]<br>$$<br>其中<code>c[i][j]</code>表示位置<code>(i, j)</code>对应的元素值。</p><p>注意边界条件：</p><ul><li><p>当 j == 0 时，没有左上结点，只能从上一个结点转移过来，状态转移方程为：<br>$$<br>f[i][j] = f[i - 1][j] + c[i][j]<br>$$</p></li><li><p>当 j == i 时，没有上结点，只能从左上结点转移过来，状态转移方程为：</p></li></ul><p>$$<br>f[i][j] = f[i - 1][j - 1] + c[i][j]<br>$$</p><p>最终的答案为 <code>f[n - 1][0]</code> 到 <code>f[n - 1][n - 1]</code> 的最小值，其中  n 是三角形的行数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = triangle.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.get(m - <span class="number">1</span>).size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> up = j != i ? dp[i - <span class="number">1</span>][j] : Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">int</span> upLeft = j - <span class="number">1</span> &gt;= <span class="number">0</span> ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">                dp[i][j] = triangle.get(i).get(j) + Math.min(up, upLeft); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = dp[m - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            min = Math.min(min, dp[m - <span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(n^2)。</p><p>我们可以看到 dp 数组中第 i 行的值只与第 i - 1 行的值有关，我们可以只使用一个一维数组存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = triangle.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.get(m - <span class="number">1</span>).size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>]= triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>, upLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                up = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = up + triangle.get(i).get(j);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">                    dp[j] = upLeft + triangle.get(i).get(j);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = Math.min(up, upLeft) + triangle.get(i).get(j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第 j + 1 个元素的左上元素等于第 j 个元素上方的元素</span></span><br><span class="line">                upLeft = up;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            min = Math.min(min, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;120-三角形最小路径和&quot;&gt;&lt;a href=&quot;#120-三角形最小路径和&quot; class=&quot;headerlink&quot; title=&quot;120. 三角形最小路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/triangle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;120. 三角形最小路径和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相邻的结点&lt;/strong&gt; 在这里指的是 &lt;code&gt;下标&lt;/code&gt; 与 &lt;code&gt;上一层结点下标&lt;/code&gt; 相同或者等于 &lt;code&gt;上一层结点下标 + 1&lt;/code&gt; 的两个结点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>两个数组的交集 II</title>
    <link href="https://hoo334.github.io/2020/07/13/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/"/>
    <id>https://hoo334.github.io/2020/07/13/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/</id>
    <published>2020-07-13T01:38:41.000Z</published>
    <updated>2020-07-13T02:07:46.076Z</updated>
    
    <content type="html"><![CDATA[<h4 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></h4><p>给定两个数组，编写一个函数来计算它们的交集。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出: [2,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong><em>进阶:</em></strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 <em>nums1</em> 的大小比 <em>nums2</em> 小很多，哪种方法更优？</li><li>如果 <em>nums2</em> 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><p><strong>方法一：哈希表</strong></p><p>我们使用哈希表存储每个数字出现的次数。首先遍历第一个数组，统计所有数字及出现的次数。再遍历第二个数组，如果哈希表中存在这个数字，将其出现的次数减一，并将其加入到结果中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ansList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num) &amp;&amp; map.get(num) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ansList.add(num);</span><br><span class="line">                map.put(num, map.get(num) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = ansList.size();</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(m + n)，其中 m 和 n 为两个数组的长度。空间复杂度O(max(m, n))。</p><p><strong>方法二：排序</strong></p><p>如果两个数组是有序的，可以便捷的计算两个数组的交集。首先将两个数组进行排序，然后使用两个指针遍历数组。初始时，两个指针分别指向两个数组的头部，每次比较两个指针指向的两个数组中的数字，如果两个数字相等，将当前数字加入结果中，将两个指针后移；如果两个数字不相等，将较小数字的指针向后移动。当至少一个指针遍历到数组末尾时结束循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] intersection = <span class="keyword">new</span> <span class="keyword">int</span>[Math.min(nums1.length, nums2.length)];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums1.length &amp;&amp; j &lt; nums2.length; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                ++j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    intersection[index++] = nums1[i];</span><br><span class="line">                    ++i;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(intersection, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mlogm + nlogn)，m 和 n 分别是两个数组的长度。</p><p>空间复杂度O(min(m, n))。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;350-两个数组的交集-II&quot;&gt;&lt;a href=&quot;#350-两个数组的交集-II&quot; class=&quot;headerlink&quot; title=&quot;350. 两个数组的交集 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;350. 两个数组的交集 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>地下城游戏</title>
    <link href="https://hoo334.github.io/2020/07/12/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/"/>
    <id>https://hoo334.github.io/2020/07/12/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/</id>
    <published>2020-07-12T03:40:31.000Z</published>
    <updated>2020-07-17T10:03:31.727Z</updated>
    
    <content type="html"><![CDATA[<h4 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">174. 地下城游戏</a></h4><p>一些恶魔抓住了公主（<strong>P</strong>）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（<strong>K</strong>）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为<em>负整数</em>，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 <em>0</em>），要么包含增加骑士健康点数的魔法球（若房间里的值为<em>正整数</em>，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p> <a id="more"></a><p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong></p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 <code>右 -&gt; 右 -&gt; 下 -&gt; 下</code>，则骑士的初始健康点数至少为 <strong>7</strong>。</p><table><thead><tr><th>-2 (K)</th><th>-3</th><th>3</th></tr></thead><tbody><tr><td>-5</td><td>-10</td><td>1</td></tr><tr><td>10</td><td>30</td><td>-5 (P)</td></tr></tbody></table><p> <strong>说明:</strong></p><ul><li>骑士的健康点数没有上限。</li><li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li></ul><p>很容易想到使用动态规划，我们先尝试从左上到右下的顺序进行动态规划，对于每一条路径，我们需要同时记录两个值。第一个是「从出发点到当前点的路径和」，第二个是「从出发点到当前点所需的最小初始值」，这两个值的重要程度相同。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/uTlo1kQfOin2vp3.png" alt="image-20200712115157247"></p><ul><li>绿色路径，「从出发点到当前点的路径和」为 1 ，「从出发点到当前点所需的最小初始值」为 3。</li><li>蓝色路径，「从出发点到当前点的路径和」为 -1 ，「从出发点到当前点所需的最小初始值」为 2。</li></ul><p>我们应该选择绿色路径，因为蓝色路径的路径和太小，需要初始值为 4 才能到达终点 -2，而绿色路径只需要初始值为 3 即可到达终点 -2 。如果我们将终点 -2 换为 0，我们就应该选择蓝色路径，蓝色路径需要初始值为 2 ，绿色路径需要初始值为 3。</p><p>如果从左上到右下进行动态规划，我们无法确定到达(1, 2) 的方案，这样的动态规划是不满足「无后效性」的。</p><p>我们考虑从右下到左上进行动态规划。令<code>dp[i][j]</code>表示从坐标<code>(i, j)</code>到终点所需的最小初始值。当在坐标<code>(i, j)</code>时，如果此时路径和不小于<code>dp[i][j]</code>，我们就能到达终点。这样一来，我们就无需关心路径和，只需关注最小初始值。对于 <code>dp[i][j]</code>，我们只要关心<code>dp[i][j + 1]</code>和<code>dp[i + 1][j]</code>的最小值 <code>minn</code>。记当前格子的值为 <code>dungeon(i, j)</code>，那么在坐标<code>(i, j)</code>的初始值只要达到 <code>minn - dungeon(i, j)</code>即可。同时，初始值还必须大于 1 ，得到状态转移方程：<br>$$<br>dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon(i, j), 1)<br>$$<br>最终答案为 <code>dp[0][0]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length,  n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//dp 边界无效值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//初始条件，最小初始值为 1</span></span><br><span class="line">        dp[m][n - <span class="number">1</span>] = dp[m - <span class="number">1</span>][n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="comment">//找出能到达终点的最小初始值</span></span><br><span class="line">                <span class="keyword">int</span> minn = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//计算 dp[i][j] 的最小初始值</span></span><br><span class="line">                dp[i][j] = Math.max(minn - dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;174-地下城游戏&quot;&gt;&lt;a href=&quot;#174-地下城游戏&quot; class=&quot;headerlink&quot; title=&quot;174. 地下城游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/dungeon-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;174. 地下城游戏&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;一些恶魔抓住了公主（&lt;strong&gt;P&lt;/strong&gt;）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（&lt;strong&gt;K&lt;/strong&gt;）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。&lt;/p&gt;
&lt;p&gt;骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。&lt;/p&gt;
&lt;p&gt;有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为&lt;em&gt;负整数&lt;/em&gt;，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 &lt;em&gt;0&lt;/em&gt;），要么包含增加骑士健康点数的魔法球（若房间里的值为&lt;em&gt;正整数&lt;/em&gt;，则表示骑士将增加健康点数）。&lt;/p&gt;
&lt;p&gt;为了尽快到达公主，骑士决定每次只向右或向下移动一步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>计算右侧小于当前元素的个数</title>
    <link href="https://hoo334.github.io/2020/07/11/%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://hoo334.github.io/2020/07/11/%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2020-07-11T04:02:11.000Z</published>
    <updated>2020-07-11T04:22:54.179Z</updated>
    
    <content type="html"><![CDATA[<h4 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></h4><p>给定一个整数数组 <em>nums<em>，按要求返回一个新数组 *counts</em>。数组 *counts</em> 有该性质： <code>counts[i]</code> 的值是 <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [5,2,6,1]</span><br><span class="line">输出: [2,1,1,0] </span><br><span class="line">解释:</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1).</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1).</span><br><span class="line">6 的右侧有 1 个更小的元素 (1).</span><br><span class="line">1 的右侧有 0 个更小的元素.</span><br></pre></td></tr></table></figure><p>暴力解法（超时）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(1)。</p><p>从暴力解法中可以看出，我们做了许多的重复的统计工作，我们如果从后往前遍历数组，并保存下已经遍历过的数字及它们出现的次数，在下一次遍历时，就不用重复统计。</p><p>使用二叉搜索树也可完成插入并统计的功能，我们从右往左依次遍历数组，并构建二叉树。在插入结点的过程中我们可以统计出右侧小于当前结点元素的个数。</p><p>在一般的二叉树结点上，我们添加了一个 count 变量来统计小于当前结点 val 值的结点个数。。</p><p>递归实现添加结点的算法：</p><ul><li>当走到右结点，统计根结点和根结点左结点的个数，继续插入并统计根结点右侧是否还有比当前结点值小的结点。</li><li>当走到左节点或根结点时，计数器加一，继续插入并统计根结点左侧是否还有比当前结点值小的结点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        Integer[] res = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">        Arrays.fill(res, <span class="number">0</span>);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//反向构造二叉树，统计右边最小数</span></span><br><span class="line">        TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            root = addAndCount(root, <span class="keyword">new</span> TreeNode(nums[i]), res, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">addAndCount</span><span class="params">(TreeNode root, TreeNode node, Integer[] res, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = node;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根结点左边的保存不大于根结点的元素</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt;= node.val)&#123;</span><br><span class="line">            <span class="comment">//不大于根结点值的结点个数加一</span></span><br><span class="line">            root.count++ ;</span><br><span class="line">            <span class="comment">//递归将当前结点插入左子树</span></span><br><span class="line">            root.left = addAndCount(root.left, node, res, i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//统计比当前结点值小的元素个数（根结点 1 + 左节点 root.count）</span></span><br><span class="line">            res[i] += <span class="number">1</span> + root.count;</span><br><span class="line">            <span class="comment">//统计根结点右子树中是否还有比当前结点值小的结点</span></span><br><span class="line">            root.right = addAndCount(root.right, node, res, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.count = <span class="number">0</span>;<span class="comment">//小于 val 值的结点个数</span></span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(nlogn)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;315-计算右侧小于当前元素的个数&quot;&gt;&lt;a href=&quot;#315-计算右侧小于当前元素的个数&quot; class=&quot;headerlink&quot; title=&quot;315. 计算右侧小于当前元素的个数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;315. 计算右侧小于当前元素的个数&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数数组 &lt;em&gt;nums&lt;em&gt;，按要求返回一个新数组 *counts&lt;/em&gt;。数组 *counts&lt;/em&gt; 有该性质： &lt;code&gt;counts[i]&lt;/code&gt; 的值是 &lt;code&gt;nums[i]&lt;/code&gt; 右侧小于 &lt;code&gt;nums[i]&lt;/code&gt; 的元素的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>最佳买卖股票时机含冷冻期</title>
    <link href="https://hoo334.github.io/2020/07/10/%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
    <id>https://hoo334.github.io/2020/07/10/%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</id>
    <published>2020-07-10T03:01:03.000Z</published>
    <updated>2020-07-15T02:40:37.120Z</updated>
    
    <content type="html"><![CDATA[<h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h4><p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><p>将「买入」和「卖出」分开考虑，「买入」为负收益，「卖出」为正收益。我们需要尽可能地降低负收益而提高正收益，我们可以使用动态规划，维护股市中每一天结束后可以获得的「累计最大收益」，并以此进行状态转移，得到最终的答案。</p><p>我们使用 f[i] 表示<strong>第 i 天结束之后</strong>的「累计最大收益」。根据题目描述，我们有三种状态：</p><ol><li><p>有股票 记为 <code>f[i][0]</code>;</p></li><li><p>不在冷冻期，有股票，记为 <code>f[i][1]</code>;</p></li><li><p>不在冷冻期，无股票，记为 <code>f[i][2]</code>;</p></li></ol><p>这里的处于冷冻期指在第 i 天结束之后的状态。也就是说：第 i 天结束之后处于冷冻期，那么第 i + 1 天将无法买入股票。</p><p>状态转移分析：</p><ul><li><p>对于<code>f[i][0]</code>，第 i 天的股票可以是第 i - 1 天已经持有的，对应 <code>f[i - 1][0]</code>；或者是第 i 天买入的，第 i 天能买入股票证明第 i - 1 天没有股票且不能在冷冻期，对应<code>f[i - 1][2]</code>，加上买股票的负收益。因此状态转移方程为：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][2] - prices[i])<br>$$</p></li><li><p>对于<code>f[i][1]</code>，我们在第 i 天结束之后在冷冻期，证明在第 i 天卖出了股票，说明第 i - 1 天必须持有股票，对应的状态为 <code>f[i - 1][0]</code>加上卖出股票的正收益。状态转移方程为：<br>$$<br>f[i][1] = f[i - 1][0] + prices[i]<br>$$</p></li><li><p>对于<code>f[i][2]</code>，我们在第 i 天结束之后不在冷冻期，可能在第 i - 1 天也是没有股票，不在冷冻期的状态转移过来，对应<code>f[i - 1][2]</code>；或者是第 i - 1 天无股票，在冷冻期的状态转移过来，对应<code>f[i - 1][1]</code>。状态转移方程为：<br>$$<br>f[i][2] = max(f[i - 1][2], f[i - 1][1])<br>$$<br>最终的答案为：<br>$$<br>max(f[n - 1][1], f[n - 1][2])<br>$$<br>如果在最后一天手里仍有股票是没有任何意义的。</p><p>我们可以初始化第 0 天的条件：<code>f[0][0]=-prices[0]</code>，<code>&#39;f[0][1]=0</code>，<code>f[0][2]=0</code></p><p>第 0 天有股票的负收益为 -prices[0]，第 0 天无股票的收益为 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)。</p><p>注意到第 i 天的状态只与第 i - 1 天的状态有关，我们可以将空间复杂度优化到常数级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> one = -prices[<span class="number">0</span>], two = <span class="number">0</span>, three = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newOne = Math.max(one, three - prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newTwo = one + prices[i];</span><br><span class="line">            <span class="keyword">int</span> newThree = Math.max(three, two);</span><br><span class="line"></span><br><span class="line">            one = newOne;</span><br><span class="line">            two = newTwo;</span><br><span class="line">            three = newThree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(two, three);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;309-最佳买卖股票时机含冷冻期&quot;&gt;&lt;a href=&quot;#309-最佳买卖股票时机含冷冻期&quot; class=&quot;headerlink&quot; title=&quot;309. 最佳买卖股票时机含冷冻期&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;309. 最佳买卖股票时机含冷冻期&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数数组，其中第 &lt;em&gt;i&lt;/em&gt; 个元素代表了第 &lt;em&gt;i&lt;/em&gt; 天的股票价格 。&lt;/p&gt;
&lt;p&gt;设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/li&gt;
&lt;li&gt;卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
