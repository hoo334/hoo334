<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2020-08-21T01:50:12.976Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树的最小深度</title>
    <link href="https://hoo334.github.io/2020/08/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <id>https://hoo334.github.io/2020/08/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</id>
    <published>2020-08-21T01:34:22.000Z</published>
    <updated>2020-08-21T01:50:12.976Z</updated>
    
    <content type="html"><![CDATA[<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h4><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><a id="more"></a><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最小深度  2.</p><p>看到这么简单的题，一顿操作，立马就写出了如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试发现 [2,9]这个用例不对，我们得到的结果为 1，实际结果为 2。原因在于我们统计了空结点到根节点的深度。</p><p>对于每个结点，当只有一个子树时，直接返回子树的最小深度加一；当有两颗子树时，返回左右子树之中的最小深度加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="keyword">null</span> &amp;&amp; root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(h)，h 为树的高度，当二叉树退化为链表时，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;111-二叉树的最小深度&quot;&gt;&lt;a href=&quot;#111-二叉树的最小深度&quot; class=&quot;headerlink&quot; title=&quot;111. 二叉树的最小深度&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;111. 二叉树的最小深度&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二叉树，找出其最小深度。&lt;/p&gt;
&lt;p&gt;最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>扫雷游戏</title>
    <link href="https://hoo334.github.io/2020/08/20/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/"/>
    <id>https://hoo334.github.io/2020/08/20/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</id>
    <published>2020-08-20T04:01:59.000Z</published>
    <updated>2020-08-20T04:12:29.682Z</updated>
    
    <content type="html"><![CDATA[<h4 id="529-扫雷游戏"><a href="#529-扫雷游戏" class="headerlink" title="529. 扫雷游戏"></a><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">529. 扫雷游戏</a></h4><p>让我们一起来玩扫雷游戏！</p><p>给定一个代表游戏板的二维字符矩阵。 <strong>‘M’</strong> 代表一个<strong>未挖出的</strong>地雷，<strong>‘E’</strong> 代表一个<strong>未挖出的</strong>空方块，<strong>‘B’</strong> 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong>已挖出的</strong>空白方块，<strong>数字</strong>（’1’ 到 ‘8’）表示有多少地雷与这块<strong>已挖出的</strong>方块相邻，<strong>‘X’</strong> 则表示一个<strong>已挖出的</strong>地雷。</p><p>现在给出在所有<strong>未挖出的</strong>方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><ol><li><p>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 <strong>‘X’</strong>。</p></li><li><p>如果一个<strong>没有相邻地雷</strong>的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的<strong>未挖出</strong>方块都应该被递归地揭露。</p></li><li><p>如果一个<strong>至少与一个地雷相邻</strong>的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。</p></li><li><p>如果在此次点击中，若无更多方块可被揭露，则返回面板。</p><a id="more"></a></li></ol><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">解释:</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">解释:</span><br></pre></td></tr></table></figure><p> <strong>注意：</strong></p><ol><li>输入矩阵的宽和高的范围为 [1,50]。</li><li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li><li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li><li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li></ol><p>对于我们点击的每一个方块，有两种情况：</p><ul><li>当前点击的方块是未挖出的地雷，将其值改为 X；</li><li>当前点击的是为未挖出的空方块，我们需要统计它周围相邻的方块里地雷的数量cnt（即M 的数量）。如果 cnt 为 0 ，则将其改为 B，且递归地处理周围<strong>八个</strong>未挖出地方块，如果 cnt 不为 0 ，将其改为数字即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = click[<span class="number">0</span>], y = click[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//判断当前方块是否为地雷</span></span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == <span class="string">'M'</span>)&#123;</span><br><span class="line">            board[x][y] = <span class="string">'X'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(board, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计当前空方块周围地雷数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[tx][ty] == <span class="string">'M'</span>)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//地雷数大于零，直接修改当前方块为地雷数</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            board[x][y] = (<span class="keyword">char</span>) (cnt + <span class="string">'0'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//周围没有地雷，递归地对周围八个方块进行搜索</span></span><br><span class="line">            board[x][y] = <span class="string">'B'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">                <span class="comment">//碰到边界或者不是未挖出的方块时返回</span></span><br><span class="line">                <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length || board[tx][ty] != <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dfs(board, tx, ty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)，m 和 n 为面板的长宽。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;529-扫雷游戏&quot;&gt;&lt;a href=&quot;#529-扫雷游戏&quot; class=&quot;headerlink&quot; title=&quot;529. 扫雷游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minesweeper/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;529. 扫雷游戏&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;让我们一起来玩扫雷游戏！&lt;/p&gt;
&lt;p&gt;给定一个代表游戏板的二维字符矩阵。 &lt;strong&gt;‘M’&lt;/strong&gt; 代表一个&lt;strong&gt;未挖出的&lt;/strong&gt;地雷，&lt;strong&gt;‘E’&lt;/strong&gt; 代表一个&lt;strong&gt;未挖出的&lt;/strong&gt;空方块，&lt;strong&gt;‘B’&lt;/strong&gt; 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的&lt;strong&gt;已挖出的&lt;/strong&gt;空白方块，&lt;strong&gt;数字&lt;/strong&gt;（’1’ 到 ‘8’）表示有多少地雷与这块&lt;strong&gt;已挖出的&lt;/strong&gt;方块相邻，&lt;strong&gt;‘X’&lt;/strong&gt; 则表示一个&lt;strong&gt;已挖出的&lt;/strong&gt;地雷。&lt;/p&gt;
&lt;p&gt;现在给出在所有&lt;strong&gt;未挖出的&lt;/strong&gt;方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 &lt;strong&gt;‘X’&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个&lt;strong&gt;没有相邻地雷&lt;/strong&gt;的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的&lt;strong&gt;未挖出&lt;/strong&gt;方块都应该被递归地揭露。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个&lt;strong&gt;至少与一个地雷相邻&lt;/strong&gt;的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果在此次点击中，若无更多方块可被揭露，则返回面板。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>回文子串</title>
    <link href="https://hoo334.github.io/2020/08/19/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/08/19/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2020-08-19T02:18:27.000Z</published>
    <updated>2020-08-19T02:45:23.029Z</updated>
    
    <content type="html"><![CDATA[<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></h4><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>输入的字符串长度不会超过 1000 。</li></ul><p>我们枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同时就拓展，否则就停止拓展。</p><p>当回文长度为奇数时，回文中心就是一个字符；当回文长度为偶数时，回文中心为两个字符。一个长度为 n 的字符串，可能的回文中心有 2n - 1 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; n; index++)&#123;</span><br><span class="line">            <span class="comment">//回文长度为奇数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index, k = index; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//回文长度为偶数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index, k = index + <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将回文长度为奇数和偶数的两种情况合在一起，我们令 <code>0 &lt;= index &lt; 2n - 1</code>，回文中心<code>(j, k)</code>，其中<code>j = index / 2, k = j + (index mod 2)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">2</span> * n - <span class="number">1</span>; index++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index / <span class="number">2</span>, k = index / <span class="number">2</span> + index % <span class="number">2</span>; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;647-回文子串&quot;&gt;&lt;a href=&quot;#647-回文子串&quot; class=&quot;headerlink&quot; title=&quot;647. 回文子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/palindromic-substrings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;647. 回文子串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。&lt;/p&gt;
&lt;p&gt;具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>有序列表转换二叉搜索树</title>
    <link href="https://hoo334.github.io/2020/08/18/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/18/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-08-18T01:46:47.000Z</published>
    <updated>2020-08-18T02:07:15.539Z</updated>
    
    <content type="html"><![CDATA[<h4 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a></h4><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><p>我们需要构造出平衡的二叉树，每次让左右子树的结点个数接近，我们可以找出链表元素的中位数作为根节点的值。链表中小于根节点的元素个数与大于根节点的元素个数要么相等，要么相差 1。我们递归地对左右子树进行构造。</p><p>设当前链表左端点为 left， 右端点为 right，具体范围为<code>[left, right)</code>，左闭右开区间。定义左闭右开区间的好处是，可以方便表示初始列表<code>[head, null)</code>，如果使用左闭右闭区间，则第一次需要遍历到链表末尾来获取 right 的值。在找出链表中位数结点 mid后，我们可以使用<code>[left, mid)</code>和<code>[mid.next, right)</code>来分别表示左右子树对应的列表。</p><p>使用快慢指针法来得到链表的中位数结点，fast 指针每次移动两次，slow 指针每次移动一次，当 fast 到达边界（fast == right 或 fast.next == right，right 的前驱结点为链表的最后一个结点）时停止，此时 slow 指向的元素就是链表的中位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//左闭右开区间 [left, right)</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//得到中间结点</span></span><br><span class="line">        ListNode mid = getMid(left, right);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(mid.val);</span><br><span class="line">        <span class="comment">//递归构造左右子树</span></span><br><span class="line">        root.left = buildTree(left, mid);</span><br><span class="line">        root.right =  buildTree(mid.next, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getMid</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        ListNode slow = left;</span><br><span class="line">        ListNode fast = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != right &amp;&amp; fast.next != right)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n logn)，空间复杂度O(log n)。 n 是链表的长度。</p><p>寻找链表的中位数是一个比较耗时的操作，在二叉搜索树的构建过程是一个中序遍历，遍历结果就是链表，我们可以使用一个指针 ptr 来指向下一个需要建立的链表结点，在构建二叉搜索树的同时不断将 ptr 向后移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode ptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ptr = head;</span><br><span class="line">        <span class="keyword">int</span> length = getLength(head);</span><br><span class="line"><span class="comment">//左闭右闭区间 [left, right]</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//得到链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//计算 mid 位置</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        <span class="comment">//先构建左子树</span></span><br><span class="line">        root.left = buildTree(left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//左子树构建完时，ptr 指向根节点</span></span><br><span class="line">        root.val = ptr.val;</span><br><span class="line">        ptr = ptr.next;</span><br><span class="line">        <span class="comment">//构建右子树</span></span><br><span class="line">        root.right = buildTree(mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(log n)。n 为链表的长度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;109-有序链表转换二叉搜索树&quot;&gt;&lt;a href=&quot;#109-有序链表转换二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;109. 有序链表转换二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problem
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="https://hoo334.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="https://hoo334.github.io/2020/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-08-17T01:39:30.000Z</published>
    <updated>2020-08-17T01:49:06.285Z</updated>
    
    <content type="html"><![CDATA[<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p></blockquote><a id="more"></a><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回 <code>true</code> 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>返回 <code>false</code> 。</p><p>一颗树是平衡二叉树，当且仅当所有子树都是二叉平衡树，我们可以使用递归的方式来判断二叉树是否为平衡二叉树。</p><p>我们使用 height 函数来求树的最大高度，如果左右子树的高度不超过 1 ，再分别递归地遍历左右子节点，并判断左右子树是否为平衡二叉树。这是一个自顶向下的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(length(root.left) - length(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(length(root.left), length(root.right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，最坏情况下，二叉树为链表，遍历所有结点时间复杂度O(n)，计算高度时间复杂度为O(n)。</p><p>空间复杂度O(n)。</p><p>我们可以递归地判断当前结点的左右子树是否平衡，再判断以当前结点为根的树是否平衡，如果平衡，返回其高度（不小于 0 ），否则返回 - 1，代表不是平衡二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftLength = length(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightLength = length(root.right);</span><br><span class="line">        <span class="keyword">if</span>(leftLength == -<span class="number">1</span> || rightLength == -<span class="number">1</span> || Math.abs(leftLength - rightLength) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftLength, rightLength) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;110-平衡二叉树&quot;&gt;&lt;a href=&quot;#110-平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;110. 平衡二叉树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/balanced-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;110. 平衡二叉树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过1。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>图像渲染</title>
    <link href="https://hoo334.github.io/2020/08/16/%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/"/>
    <id>https://hoo334.github.io/2020/08/16/%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/</id>
    <published>2020-08-16T01:39:32.000Z</published>
    <updated>2020-08-16T01:46:30.340Z</updated>
    
    <content type="html"><![CDATA[<h4 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733. 图像渲染"></a><a href="https://leetcode-cn.com/problems/flood-fill/" target="_blank" rel="noopener">733. 图像渲染</a></h4><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p><p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p><p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>最后返回经过上色渲染后的图像。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">输出: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">解析: </span><br><span class="line">在图像的正中间，(坐标(sr,sc)&#x3D;(1,1)),</span><br><span class="line">在路径上所有符合条件的像素点的颜色都被更改成2。</span><br><span class="line">注意，右下角的像素没有更改为2，</span><br><span class="line">因为它不是在上下左右四个方向上与初始点相连的像素点。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>image</code> 和 <code>image[0]</code> 的长度在范围 <code>[1, 50]</code> 内。</li><li>给出的初始点将满足 <code>0 &lt;= sr &lt; image.length</code> 和 <code>0 &lt;= sc &lt; image[0].length</code>。</li><li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code>内。</li></ul><p><strong>方法一：DFS</strong></p><p>我们从起点开始进行深度优先搜索，每搜索到一个方格时，如果它的颜色与初始位置的方格颜色相同，我们就将其颜色改为新的颜色，并继续搜索。</p><p><strong>注意</strong>：在初始颜色和新颜色相同的情况下会造成死循环，仔细思考，这种情况不需要任何改变，直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        m = image.length;</span><br><span class="line">        n = image[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] != newColor)&#123;</span><br><span class="line">            fill(image, image[sr][sc], newColor, sr, sc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> originColor, <span class="keyword">int</span> newColor, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || image[x][y] != originColor)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        image[x][y] = newColor;</span><br><span class="line">        fill(image, originColor, newColor, x + <span class="number">1</span>, y);</span><br><span class="line">        fill(image, originColor, newColor, x - <span class="number">1</span>, y);</span><br><span class="line">        fill(image, originColor, newColor, x, y + <span class="number">1</span>);</span><br><span class="line">        fill(image, originColor, newColor, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。m 和 n 为图像的长宽。</p><p><strong>方法二：BFS</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">int</span> originColor = image[sr][sc];</span><br><span class="line">        <span class="keyword">if</span>(originColor == newColor)&#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = image.length, n = image[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr, sc&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] point = queue.poll();</span><br><span class="line">            image[point[<span class="number">0</span>]][point[<span class="number">1</span>]] = newColor;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> mx = point[<span class="number">0</span>] + dx[i];</span><br><span class="line">                <span class="keyword">int</span> my = point[<span class="number">1</span>] + dy[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(mx &gt;= <span class="number">0</span> &amp;&amp; mx &lt; m &amp;&amp; my &gt;= <span class="number">0</span> &amp;&amp; my &lt; n &amp;&amp; image[mx][my] == originColor)&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;mx, my&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。m 和 n 为图像的长宽。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;733-图像渲染&quot;&gt;&lt;a href=&quot;#733-图像渲染&quot; class=&quot;headerlink&quot; title=&quot;733. 图像渲染&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/flood-fill/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;733. 图像渲染&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。&lt;/p&gt;
&lt;p&gt;给你一个坐标 &lt;code&gt;(sr, sc)&lt;/code&gt; 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 &lt;code&gt;newColor&lt;/code&gt;，让你重新上色这幅图像。&lt;/p&gt;
&lt;p&gt;为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。&lt;/p&gt;
&lt;p&gt;最后返回经过上色渲染后的图像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://hoo334.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>有效的括号</title>
    <link href="https://hoo334.github.io/2020/08/14/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://hoo334.github.io/2020/08/14/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2020-08-14T01:33:14.000Z</published>
    <updated>2020-08-14T01:36:43.005Z</updated>
    
    <content type="html"><![CDATA[<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h4><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><a id="more"></a><p>使用栈的经典题目，我们将所有的左括号入栈，当遇到右括号时，如果栈为空或者栈顶元素不能与当前括号匹配，返回false。遍历到最后，如果栈为空则 返回 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.size() == <span class="number">0</span> || stack.pop() != <span class="string">'('</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.size() == <span class="number">0</span> || stack.pop() != <span class="string">'['</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.size() == <span class="number">0</span> || stack.pop() != <span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;20-有效的括号&quot;&gt;&lt;a href=&quot;#20-有效的括号&quot; class=&quot;headerlink&quot; title=&quot;20. 有效的括号&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;20. 有效的括号&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;{&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;}&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;[&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;]&amp;#39;&lt;/code&gt; 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意空字符串可被认为是有效字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>字符串相乘</title>
    <link href="https://hoo334.github.io/2020/08/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <id>https://hoo334.github.io/2020/08/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</id>
    <published>2020-08-13T02:11:21.000Z</published>
    <updated>2020-08-13T02:25:13.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">43. 字符串相乘</a></h4><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><code>num1</code> 和 <code>num2</code> 的长度小于110。</li><li><code>num1</code> 和 <code>num2</code> 只包含数字 <code>0-9</code>。</li><li><code>num1</code> 和 <code>num2</code> 均不以零开头，除非是数字 0 本身。</li><li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li></ol><p>我们可以模拟竖式计算来得到最后的结果。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200813101253597.png" alt="image-20200813101253597"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用 num1 的每一位乘 num2</span></span><br><span class="line">        <span class="keyword">int</span> len1 = num1.length(), len2 = num2.length();</span><br><span class="line">        String ans = <span class="string">"0"</span>;</span><br><span class="line">        <span class="comment">//从 num1 的最后一位开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//添加尾部的 0 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len1 - <span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">                sb.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算乘积</span></span><br><span class="line">            <span class="keyword">int</span> x = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> y = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> num = x * y + carry;</span><br><span class="line">                sb.append(num % <span class="number">10</span>);</span><br><span class="line">                carry = num / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果最后有进位，就将结果加入</span></span><br><span class="line">            <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">                sb.append(carry % <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//结果相加</span></span><br><span class="line">            ans = addStrings(ans, sb.reverse().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//字符串相加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num = x + y + carry;</span><br><span class="line">            carry = num / <span class="number">10</span>;</span><br><span class="line">            sb.append(num % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(m + n)。</p><p>我们可以优化竖式计算，num1 位数为 m，num2 位数为 n，num1 * num2 的最大总位数为 m * n。num1[i] * num2[j] 的结果为 tmp（可能为一位或者两位数），第一位位于 res[i + j]，第二位位于 res[i + j + 1]。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200813102303621.png" alt="image-20200813102303621"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> y = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> num = x * y + res[i + j + <span class="number">1</span>];</span><br><span class="line">                res[i + j + <span class="number">1</span>] = num % <span class="number">10</span>;</span><br><span class="line">                res[i + j] += num / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//第一位如果为 0，去掉第一位的 0</span></span><br><span class="line">            ans.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(m + n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;43-字符串相乘&quot;&gt;&lt;a href=&quot;#43-字符串相乘&quot; class=&quot;headerlink&quot; title=&quot;43. 字符串相乘&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/multiply-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;43. 字符串相乘&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定两个以字符串形式表示的非负整数 &lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt;，返回 &lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt; 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>克隆图</title>
    <link href="https://hoo334.github.io/2020/08/12/%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
    <id>https://hoo334.github.io/2020/08/12/%E5%85%8B%E9%9A%86%E5%9B%BE/</id>
    <published>2020-08-12T01:27:37.000Z</published>
    <updated>2020-08-12T01:49:45.646Z</updated>
    
    <content type="html"><![CDATA[<h4 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></h4><p>给你无向 <strong><a href="https://baike.baidu.com/item/连通图/6460995?fr=aladdin" target="_blank" rel="noopener">连通</a></strong> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank" rel="noopener"><strong>深拷贝</strong></a>（克隆）。</p><a id="more"></a><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p> <strong>示例 1：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812092919759.png" alt="image-20200812092919759"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812092941156.png" alt="image-20200812092941156"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812092954884.png" alt="image-20200812092954884"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[2],[1]]</span><br><span class="line">输出：[[2],[1]]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li>节点数不超过 100 。</li><li>每个节点值 <code>Node.val</code> 都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li><li>无向图是一个<a href="https://baike.baidu.com/item/简单图/1680528?fr=aladdin" target="_blank" rel="noopener">简单图</a>，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em> 的邻居。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ol><p><strong>方法一：DFS</strong></p><p>算法：</p><ol><li><p>使用一个哈希表存储所有已被访问和克隆得结点。哈希表中的 key 是原始图中的结点，value 是克隆图中对应结点。</p></li><li><p>从给定结点开始遍历图。如果某个结点已经被访问过，则返回其克隆图中的对应结点。</p><p>给定无向边 A - B，如果不对访问过的结点做标记，那么会陷入死循环中。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812093915504.png" alt="image-20200812093915504"></p></li><li><p>如果当前访问结点不在哈希表中，则创建它的克隆结点存储在哈希表中。在进入递归之前，必须先将克隆结点保存在哈希表中。如果不保证这种顺序，可能会导致死循环。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812094048633.png" alt="image-20200812094048633"></p></li><li><p>递归调用每个结点的邻接点。每一次调用返回其对应邻接点的克隆结点，最终返回这些克隆邻接点的列表，将其放入对应克隆结点的邻接表中。这样就可以克隆给定的结点和其邻接点。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果该结点已经访问过，直接从哈希表中取出对应的克隆结点返回</span></span><br><span class="line">        <span class="keyword">if</span>(visited.containsKey(node))&#123;</span><br><span class="line">            <span class="keyword">return</span> visited.get(node);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//克隆结点，注意到为了深拷贝，我们不会克隆它的邻接列表</span></span><br><span class="line">        Node cloneNode = <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="comment">//存储克隆结点</span></span><br><span class="line">        visited.put(node, cloneNode);</span><br><span class="line"><span class="comment">//遍历该结点的邻居，并更新克隆结点的邻居列表</span></span><br><span class="line">        <span class="keyword">for</span>(Node n : node.neighbors)&#123;</span><br><span class="line">            cloneNode.neighbors.add(cloneGraph(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)，其中 n 表示结点数量。</p><p><strong>方法二：BFS</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将给定的结点加入列表</span></span><br><span class="line">        queue.add(node);</span><br><span class="line">        <span class="comment">//克隆第一个结点并存储到哈希表</span></span><br><span class="line">        visited.put(node, <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//取出队列的头结点</span></span><br><span class="line">            Node n = queue.remove();</span><br><span class="line">            <span class="comment">//遍历该结点的邻居</span></span><br><span class="line">            <span class="keyword">for</span>(Node t : n.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited.containsKey(t))&#123;</span><br><span class="line">                    <span class="comment">//如果没有访问过，就克隆并存储在哈希表中</span></span><br><span class="line">                    visited.put(t, <span class="keyword">new</span> Node(t.val, <span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">                    <span class="comment">//将邻居结点加入队列中</span></span><br><span class="line">                    queue.add(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新当前结点的邻居列表</span></span><br><span class="line">                visited.get(n).neighbors.add(visited.get(t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.get(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)，其中 n 表示结点数量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;133-克隆图&quot;&gt;&lt;a href=&quot;#133-克隆图&quot; class=&quot;headerlink&quot; title=&quot;133. 克隆图&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/clone-graph/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;133. 克隆图&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你无向 &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/连通图/6460995?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;连通&lt;/a&gt;&lt;/strong&gt; 图中一个节点的引用，请你返回该图的 &lt;a href=&quot;https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;&lt;/a&gt;（克隆）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://hoo334.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>被围绕的区域</title>
    <link href="https://hoo334.github.io/2020/08/11/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
    <id>https://hoo334.github.io/2020/08/11/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</id>
    <published>2020-08-11T02:13:36.000Z</published>
    <updated>2020-08-11T02:30:16.102Z</updated>
    
    <content type="html"><![CDATA[<h4 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></h4><p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p><p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p>运行你的函数后，矩阵变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p><strong>解释:</strong></p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 <code>&#39;O&#39;</code> 都不会被填充为 <code>&#39;X&#39;</code>。 任何不在边界上，或不与边界上的 <code>&#39;O&#39;</code> 相连的 <code>&#39;O&#39;</code> 最终都会被填充为 <code>&#39;X&#39;</code>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p><p>自己的想法：从每一个字母<code>O</code>（不在边界上）开始DFS，遇到四个 X 返回，在返回过程中将 O 修改为 X；如果碰到边界，直接返回。</p><p>发现返回的条件太复杂，不会实现。</p><p>下面是官方题解：</p><p>给定矩阵中有三种元素：</p><ul><li>字母X</li><li>被字母 X 包围的字母 O</li><li>没有被字母 X 包围的字母 O</li></ul><p>要判断字母 O 是否被字母 X 包围比较困难，注意到：<strong>任何边界上的 <code>O</code> 都不会被填充为<code>X</code></strong>。我们可以想到，所有不被 X 包围的 O 都与边界上的 O 相连。我们利用这个性质判断 O 是否被 X 包围：</p><ul><li>对于每个边界上的 O，我们以它为起点，标记所有与之相连或间接相连的字母 O</li><li>遍历这个矩阵，对于每个字母：<ul><li>如果该字母被标记过，则表示它没有被字母X包围，将其恢复为 O</li><li>如果该字母没有被标记，则表示它被字母 X 包围，将其改为 X</li></ul></li></ul><p><strong>方法一：DFS</strong></p><p>使用深度优先搜索实现标记，我们将标记过的字母 O 改为 字母A。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        m = board.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">//标记与边界相连的字母 O</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//标记与边界相连的字母 O</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, m - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//处理每一个字母</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'A'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || board[x][y] != <span class="string">'O'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//标记与边界相连的字母 O</span></span><br><span class="line">        board[x][y] = <span class="string">'A'</span>;</span><br><span class="line">        dfs(board, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x - <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x, y + <span class="number">1</span>);</span><br><span class="line">        dfs(board, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。m，n为矩阵的长宽。</p><p><strong>方法二：BFS</strong></p><p>我们使用广度优先搜索来实现标记，同样，将标记过的字母 O 改为 字母A。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">//将边界上的字母 O 坐标加入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">'O'</span>) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span>(board[i][n - <span class="number">1</span>] == <span class="string">'O'</span>) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, n - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">'O'</span>) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, i&#125;);</span><br><span class="line">            <span class="keyword">if</span>(board[m - <span class="number">1</span>][i] == <span class="string">'O'</span>)queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;m - <span class="number">1</span>, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//将边界上的字母 O 坐标加入队列</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//从队列中取出一个字母 O，对其标记</span></span><br><span class="line">            <span class="keyword">int</span>[] t = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = t[<span class="number">0</span>], y = t[<span class="number">1</span>];</span><br><span class="line">            board[x][y] = <span class="string">'A'</span>;</span><br><span class="line"><span class="comment">//将当前字母 O 相连的字母 O 坐标加入队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n || board[nx][ny] != <span class="string">'O'</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//处理每一个字母</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'A'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)。m，n为矩阵的长宽。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;130-被围绕的区域&quot;&gt;&lt;a href=&quot;#130-被围绕的区域&quot; class=&quot;headerlink&quot; title=&quot;130. 被围绕的区域&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/surrounded-regions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;130. 被围绕的区域&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个二维的矩阵，包含 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt;（&lt;strong&gt;字母 O&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;找到所有被 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 围绕的区域，并将这些区域里所有的 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt; 用 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 填充。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://hoo334.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>和为K的子数组</title>
    <link href="https://hoo334.github.io/2020/08/10/%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://hoo334.github.io/2020/08/10/%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2020-08-10T07:17:39.000Z</published>
    <updated>2020-08-10T07:41:16.687Z</updated>
    
    <content type="html"><![CDATA[<h4 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></h4><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p><a id="more"></a><p><strong>示例 1 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure><p><strong>说明 :</strong></p><ol><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li></ol><p><strong>方法一：暴力</strong></p><p>考虑以 i 结尾和为 k 的连续子数组个数，我们需要统计符合条件的下标 j 的个数，其中 <code>0 &lt;= j &lt;= i</code>，且<code>[j...i]</code>这个子数组的和恰好为 k。我们可以枚举 j 的值，然后再使用 O(n)的时间复杂度来求和，那样就达到O(n^3) 时间复杂度。如果我们知道<code>[j, i]</code>子数组的和，就能在O(1)时间求出<code>[j - 1, i]</code>子数组的和，因此我们初始时令 j = i，在循环中使 j 变小，同时维护一个数组和 sum。我们就能在O(1)时间内得到子数组<code>[j...i]</code>的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum == k)&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)，空间复杂度O(1)。</p><p><strong>方法二：前缀和+哈希表优化</strong></p><p>我们定义 pre[i] 为 [0 … i] 内所有数的和，则有：<br>$$<br>pre[i] = pre[i - 1] + nums[i]<br>$$<br>那么 [j … i]子数组为 k ，这个条件可以转化为：<br>$$<br>pre[i] - pre[j - 1] == k<br>$$<br>简单移项得到：<br>$$<br>pre[j - 1] == pre[i] - k<br>$$<br>我们考虑 以 i 结尾的和为 k 的连续子数组时，只要统计有多少个前缀和为 pre[i] - k 的 pre[j] 即可。我们建立哈希表 map，使用和为键，出现的次数为相应的值，记录pre[i] 出现的次数，从左至右边更新 map，同时维护一个前缀和变量 pre，这样在计算 pre[i]时直接使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始值，和为 0 的子数组个数为 1</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="comment">//计算 pre[i]</span></span><br><span class="line">            pre += nums[i];</span><br><span class="line">            <span class="comment">//找到和为 pre[i] - k 子数组个数 </span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(pre - k))&#123;</span><br><span class="line">                count += map.get(pre - k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新 pre[i] 和的个数</span></span><br><span class="line">            map.put(pre, map.getOrDefault(pre, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;560-和为K的子数组&quot;&gt;&lt;a href=&quot;#560-和为K的子数组&quot; class=&quot;headerlink&quot; title=&quot;560. 和为K的子数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/subarray-sum-equals-k/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;560. 和为K的子数组&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个整数数组和一个整数 &lt;strong&gt;k，&lt;/strong&gt;你需要找到该数组中和为 &lt;strong&gt;k&lt;/strong&gt; 的连续的子数组的个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第201场周赛</title>
    <link href="https://hoo334.github.io/2020/08/10/Leetcode%E7%AC%AC201%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <id>https://hoo334.github.io/2020/08/10/Leetcode%E7%AC%AC201%E5%9C%BA%E5%91%A8%E8%B5%9B/</id>
    <published>2020-08-10T02:23:05.000Z</published>
    <updated>2020-08-10T09:03:13.264Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>第二次参加周赛，又是AC两道暴力题，菜鸡只会暴力/(ㄒoㄒ)/~~。</p><a id="more"></a><h4 id="5483-整理字符串-Easy"><a href="#5483-整理字符串-Easy" class="headerlink" title="5483. 整理字符串(Easy)"></a><a href="https://leetcode-cn.com/problems/make-the-string-great/" target="_blank" rel="noopener">5483. 整理字符串(Easy)</a></h4><p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p><p>一个整理好的字符串中，<strong>两个相邻字符</strong> <code>s[i]</code> 和 <code>s[i + 1]</code> 不会同时满足下述条件：</p><ul><li><code>0 &lt;= i &lt;= s.length - 2</code></li><li><code>s[i]</code> 是小写字符，但 <code>s[i + 1]</code> 是相同的大写字符；<strong>反之亦然</strong> 。</li></ul><p>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 <strong>两个相邻</strong> 字符并删除，直到字符串整理好为止。</p><p>请返回整理好的 <strong>字符串</strong> 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。</p><p><strong>注意：</strong>空字符串也属于整理好的字符串，尽管其中没有任何字符。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leEeetcode&quot;</span><br><span class="line">输出：&quot;leetcode&quot;</span><br><span class="line">解释：无论你第一次选的是 i &#x3D; 1 还是 i &#x3D; 2，都会使 &quot;leEeetcode&quot; 缩减为 &quot;leetcode&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abBAcC&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;s&quot;</span><br><span class="line">输出：&quot;s&quot;</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含小写和大写英文字母</li></ul><p>这题目描述简直离谱，一句话来说就是：不断删除字符串中的 “xX” 或 “Xx”两个字符，x 为某个字母小写，X 为小写字母 x 对应的大写字母。</p><p>我们直接使用 StringBuffer 来进行字符的删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">makeGood</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sb.length() - <span class="number">2</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>( Math.abs(sb.charAt(i) - sb.charAt(i + <span class="number">1</span>)) == <span class="number">32</span> )&#123;</span><br><span class="line">                sb.delete(i, i + <span class="number">2</span>);</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1545-找出第-N-个二进制字符串中的第-K-位-Medium"><a href="#1545-找出第-N-个二进制字符串中的第-K-位-Medium" class="headerlink" title="1545. 找出第 N 个二进制字符串中的第 K 位(Medium)"></a><a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/" target="_blank" rel="noopener">1545. 找出第 N 个二进制字符串中的第 K 位(Medium)</a></h4><p>给你两个正整数 <code>n</code> 和 <code>k</code>，二进制字符串 <code>Sn</code> 的形成规则如下：</p><ul><li><code>S1 = &quot;0&quot;</code></li><li>当 <code>i &gt; 1</code> 时，<code>Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code></li></ul><p>其中 <code>+</code> 表示串联操作，<code>reverse(x)</code> 返回反转 <code>x</code> 后得到的字符串，而 <code>invert(x)</code> 则会翻转 x 中的每一位（0 变为 1，而 1 变为 0）</p><p>例如，符合上述描述的序列的前 4 个字符串依次是：</p><ul><li><code>S1 = &quot;0&quot;</code></li><li><code>S2 = &quot;011&quot;</code></li><li><code>S3 = &quot;0111001&quot;</code></li><li><code>S4 = &quot;011100110110001&quot;</code></li></ul><p>请你返回 <code>Sn</code> 的 <strong>第 <code>k</code> 位字符</strong> ，题目数据保证 <code>k</code> 一定在 <code>Sn</code> 长度范围以内。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：&quot;0&quot;</span><br><span class="line">解释：S3 为 &quot;0111001&quot;，其第 1 位为 &quot;0&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4, k &#x3D; 11</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line">解释：S4 为 &quot;011100110110001&quot;，其第 11 位为 &quot;1&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1, k &#x3D; 1</span><br><span class="line">输出：&quot;0&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 2, k &#x3D; 3</span><br><span class="line">输出：&quot;1&quot;</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= 2n - 1</code></li></ul><p><strong>方法一：暴力</strong></p><p>菜鸡只会暴力。/(ㄒoㄒ)/~~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"0"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            StringBuffer temp = invertAndReverse(sb);</span><br><span class="line">            sb.append(<span class="number">1</span>).append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.charAt(k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuffer <span class="title">invertAndReverse</span><span class="params">(StringBuffer s)</span></span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span>)&#123;</span><br><span class="line">                sb.append(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：数学</strong></p><p>将 n 个字符串从大到小遍历 n - 1 次，计算第 n 个字符串中间位置 midPos，并判断 k 与 midPos 的位置关系：</p><ol><li><p>如果 k &gt; midPos，第 n 个字符串第 k 个数字等于 第 n - 1 个字符串的第 midPos * 2 - k 个数字，并累加当前取反次数。</p></li><li><p>如果 k &lt; midPos，无需处理，直接遍历第 n - 1 个字符串。</p></li><li><p>k == midPos，当前位置为 1，根据取反次数计算返回即可。 </p></li></ol><p>思路来自<a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/solution/zhi-she-ji-jian-dan-de-shu-xue-ji-suan-by-lirunjun/" target="_blank" rel="noopener">___rj</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以 n &#x3D; 3， k &#x3D; 5 来解释第 3 条规则：</span><br><span class="line">s1 &#x3D; 0</span><br><span class="line">s2 &#x3D; 011</span><br><span class="line">s3 &#x3D; 0111001</span><br><span class="line"></span><br><span class="line">所有的下标都是从 1 开始，n &#x3D; 3 时，midPos &#x3D; 2 ^ 2 &#x3D; 4，而 k &#x3D; 5，S3[5] 为 reverse(invert(S2))[5 - 4],为invert(s2)[4 - (5 - 4)],即 invert(s2)[3]。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> invertNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//计算第 n 个字符串的中间位置</span></span><br><span class="line">            <span class="keyword">int</span> midPos = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(k == midPos)&#123;<span class="comment">//等于中间位置，中间位置为 1 变换 invertNum 次得到的数</span></span><br><span class="line">                <span class="keyword">return</span> invertNum % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &gt; midPos)&#123;<span class="comment">//在第 n - 1个字符串中查找</span></span><br><span class="line">                k = <span class="number">2</span> * midPos - k;</span><br><span class="line">                ++invertNum;</span><br><span class="line">            &#125;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结果为 初始值 0 变换 invertNum 次得到</span></span><br><span class="line">        <span class="keyword">return</span> invertNum % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">'0'</span> : <span class="string">'1'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：递归</strong></p><p>和方法二类似，这里用递归实现。</p><p>思路来自<a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/solution/di-gui-shuang-bai-logn-by-233999/" target="_blank" rel="noopener">小名的魔法少爷</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(k == mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &lt; mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n - <span class="number">1</span>, k);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n - <span class="number">1</span>, <span class="number">2</span> * mid - k) == <span class="string">'0'</span> ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1546-和为目标值的最大数目不重叠非空子数组数目-Medium"><a href="#1546-和为目标值的最大数目不重叠非空子数组数目-Medium" class="headerlink" title="1546. 和为目标值的最大数目不重叠非空子数组数目(Medium)"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/" target="_blank" rel="noopener">1546. 和为目标值的最大数目不重叠非空子数组数目(Medium)</a></h4><p>给你一个数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>请你返回 <strong>非空不重叠</strong> 子数组的最大数目，且每个子数组中数字和都为 <code>target</code> 。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：总共有 2 个不重叠子数组 [(1,1),1,(1,1)] ，它们的和为目标值 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,3,5,1,4,2,-9], target &#x3D; 6</span><br><span class="line">输出：2</span><br><span class="line">解释：总共有 3 个子数组和为 6 。</span><br><span class="line">([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,6,6,3,5,4,1,2,8], target &#x3D; 10</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,0,0], target &#x3D; 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>0 &lt;= target &lt;= 10^6</code></li></ul><p>我们使用前缀和 + 哈希表来实现，此题与<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a>类似，使用 pre[i] 来表示[0 … i] 的子数组的和。使用一个 HashSet 存储已经出现过的连续子数组和 pre[i] ，在遍历的过程中判断是否存在和为 sum - target 的值（连续子数组 pre[j - 1]）：</p><ul><li>存在，证明 [j … i]是一个满足条件的结果。此时，需要将 HashSet 和 sum 清空，保证不会用到 [j … i] 的元素 ，同时将 sum 加入 HashSet。</li><li>不存在，继续将 pre[i] 加入 HashSet。</li></ul><p>思路来自<a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/solution/c-qian-zhui-he-tan-xin-shuang-bai-by-scyq/" target="_blank" rel="noopener">scyq</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)&#123;</span><br><span class="line">            sum += x;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(sum - target))&#123;</span><br><span class="line">                set.clear();</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1547-切棍子的最小成本-Hard"><a href="#1547-切棍子的最小成本-Hard" class="headerlink" title="1547. 切棍子的最小成本(Hard)"></a><a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/" target="_blank" rel="noopener">1547. 切棍子的最小成本(Hard)</a></h4><p>有一根长度为 <code>n</code> 个单位的木棍，棍上从 <code>0</code> 到 <code>n</code> 标记了若干位置。例如，长度为 <strong>6</strong> 的棍子可以标记如下：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200810164134879.png" alt="image-20200810164134879"></p><p>给你一个整数数组 <code>cuts</code> ，其中 <code>cuts[i]</code> 表示你需要将棍子切开的位置。</p><p>你可以按顺序完成切割，也可以根据需要更改切割的顺序。</p><p>每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。</p><p>返回切棍子的 <strong>最小总成本</strong> 。</p><p> <strong>示例 1：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200810170104715.png" alt="image-20200810170104715"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200810164337518.png" alt="image-20200810164337518"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 7, cuts &#x3D; [1,3,4,5]</span><br><span class="line">输出：16</span><br><span class="line">解释：按 [1, 3, 4, 5] 的顺序切割的情况如上所示。</span><br><span class="line"></span><br><span class="line">第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 &#x3D; 20 。</span><br><span class="line">而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 &#x3D; 16（如示例图中 7 + 4 + 3 + 2 &#x3D; 16）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 9, cuts &#x3D; [5,6,1,4,2]</span><br><span class="line">输出：22</span><br><span class="line">解释：如果按给定的顺序切割，则总成本为 25 。总成本 &lt;&#x3D; 25 的切割顺序很多，例如，[4，6，5，2，1] 的总成本 &#x3D; 22，是所有可能方案中成本最小的。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 10^6</code></li><li><code>1 &lt;= cuts.length &lt;= min(n - 1, 100)</code></li><li><code>1 &lt;= cuts[i] &lt;= n - 1</code></li><li><code>cuts</code> 数组中的所有整数都 <strong>互不相同</strong></li></ul><p>我们使用动态规划：<code>dp[i][j]</code> 表示切割<code>[i, j]</code>这段木棍所需要的最小成本，那么就在<code>[i, j]</code>之间找一个切割点，使切割成本最小。</p><p>状态转移方程为：<br>$$<br>dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cus[j] - cuts[i])<br>$$<br><code>dp[0][n]</code>为最后结果。我们从较小的木棍长度开始 dp，[i, j] 长度最短为 2 ，否则就没有切割点。</p><p>思路来自<a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/solution/java-qu-jian-dp-by-deena/" target="_blank" rel="noopener">Evelyn</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] cuts)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加头尾</span></span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        list.add(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : cuts)&#123;</span><br><span class="line">            list.add(x);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">int</span> m = list.size();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][m];</span><br><span class="line">        <span class="comment">//[i, j]从最短长度 2 开始 dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; m; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt; m; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">//list.get(j) - list.get(i)为切割[i, j]的成本</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + list.get(j) - list.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;第二次参加周赛，又是AC两道暴力题，菜鸡只会暴力/(ㄒoㄒ)/~~。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>计算二进制子串</title>
    <link href="https://hoo334.github.io/2020/08/10/%E8%AE%A1%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/"/>
    <id>https://hoo334.github.io/2020/08/10/%E8%AE%A1%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/</id>
    <published>2020-08-10T02:11:09.000Z</published>
    <updated>2020-08-10T02:20:17.113Z</updated>
    
    <content type="html"><![CDATA[<h4 id="696-计数二进制子串"><a href="#696-计数二进制子串" class="headerlink" title="696. 计数二进制子串"></a><a href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" rel="noopener">696. 计数二进制子串</a></h4><p>给定一个字符串 <code>s</code>，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p><p>重复出现的子串要计算它们出现的次数。</p><a id="more"></a><p><strong>示例 1 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;00110011&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br><span class="line"></span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数。</span><br><span class="line"></span><br><span class="line">另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</span><br></pre></td></tr></table></figure><p><strong>示例 2 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;10101&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>s.length</code> 在1到50,000之间。</li><li><code>s</code> 只包含“0”或“1”字符。</li></ul><p>我们可以将字符串 s 按照 0 和 1 的连续段分组，存在 counts 数组中，例如 s = 00111011，可以得到 counts = {2, 3, 1, 2}。</p><p>counts 数组中两个相邻的数一定为两种不同的字符。假设 counts 数组中相邻的两个数字为 u 和 v，那么可能为 u 个 0 ，v  个 1 或 u 个 1 ，v 个 0，这一对数字对答案的贡献为 min{u, v}。我们遍历所有相邻的数对，计算它们的贡献和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; counts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//生成 counts 数组</span></span><br><span class="line">        <span class="keyword">char</span> cur = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == cur)&#123;</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                counts.add(c);</span><br><span class="line">                cur = s.charAt(i);</span><br><span class="line">                c =  <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counts.add(c);</span><br><span class="line">        <span class="comment">//计算贡献和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.size(); i++)&#123;</span><br><span class="line">            ans += Math.min(counts.get(i), counts.get(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度和空间复杂度都为 O(n)。</p><p>我们可以发现，在对每一个数计算贡献时，我们只用到了前一个值，我们使用 last 来保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>, n = s.length(), last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ptr &lt; n)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(ptr);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(ptr &lt; n &amp;&amp; s.charAt(ptr) == c)&#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans += Math.min(count, last);</span><br><span class="line">            last = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;696-计数二进制子串&quot;&gt;&lt;a href=&quot;#696-计数二进制子串&quot; class=&quot;headerlink&quot; title=&quot;696. 计数二进制子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/count-binary-substrings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;696. 计数二进制子串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt;，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。&lt;/p&gt;
&lt;p&gt;重复出现的子串要计算它们出现的次数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="字符串" scheme="https://hoo334.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>复原IP地址</title>
    <link href="https://hoo334.github.io/2020/08/09/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <id>https://hoo334.github.io/2020/08/09/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</id>
    <published>2020-08-09T02:09:00.000Z</published>
    <updated>2020-08-10T09:04:07.745Z</updated>
    
    <content type="html"><![CDATA[<h4 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原IP地址</a></h4><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 <code>&#39;.&#39;</code>分隔。</p> <a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;25525511135&quot;</span><br><span class="line">输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><p><strong>方法一：暴力</strong></p><p>我们枚举三个切割点，将每一段转换为数字，如果都满足 0 ~ 255 则保存最后结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuffer ip = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span>; a &lt; <span class="number">4</span>; a++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; b &lt; <span class="number">4</span>; b++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; <span class="number">4</span>; c++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; <span class="number">4</span>; d++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(a + b + c + d == s.length())&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> n1 = Integer.parseInt(s.substring(<span class="number">0</span>, a));</span><br><span class="line">                        <span class="keyword">int</span> n2 = Integer.parseInt(s.substring(a, a + b));</span><br><span class="line">                        <span class="keyword">int</span> n3 = Integer.parseInt(s.substring(a + b, a + b + c));</span><br><span class="line">                        <span class="keyword">int</span> n4 = Integer.parseInt(s.substring(a + b + c));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(n1 &lt;= <span class="number">255</span> &amp;&amp; n2 &lt;= <span class="number">255</span> &amp;&amp; n3 &lt;= <span class="number">255</span> &amp;&amp; n4 &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                            ip.append(n1).append(<span class="string">'.'</span>).append(n2).append(<span class="string">'.'</span>).append(n3).append(<span class="string">'.'</span>).append(n4);</span><br><span class="line">                            <span class="keyword">if</span>(ip.length() == s.length() + <span class="number">3</span>) res.add(ip.toString());</span><br><span class="line">                            ip.delete(<span class="number">0</span>, ip.length());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                         </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：回溯</strong></p><p>我们使用递归函数 <code>dfs(segId, segStart)</code>表示我们正在从 <code>s[segStart]</code>的位置开始，搜索地址中的 segId 段，其中 segId 取值为 {0, 1, 2, 3}。由于 IP 地址每一段范围为 0 ~ 255 ，我们从 s[segStart] 开始，从小到大枚举这一段 IP 地址的结束位置 segEnd。如果满足要求则进行下一段搜索，递归调用 dfs(segId + 1, segEnd + 1)。</p><p>如果某一段中 s[segStart] = ‘0’ ，那么这一段只能为 0。</p><p>在递归搜索中，如果四段 IP 地址已经全部得到且遍历完了整个字符串，那么保存结果；如果还没有找到四段 IP 地址但已经遍历完了整个字符串，结束搜索，提前回溯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEG_COUNT = <span class="number">4</span>;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] segments = <span class="keyword">new</span> <span class="keyword">int</span>[SEG_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        dfs(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> segId, <span class="keyword">int</span> segStart)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到 4 段 ip 地址，并且遍历完了字符串，这就是一种答案</span></span><br><span class="line">        <span class="keyword">if</span>(segId == SEG_COUNT)&#123;</span><br><span class="line">            <span class="keyword">if</span>(segStart == s.length())&#123;</span><br><span class="line">                StringBuffer ip = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SEG_COUNT; i++)&#123;</span><br><span class="line">                    ip.append(segments[i]);</span><br><span class="line">                    <span class="keyword">if</span>(i != SEG_COUNT - <span class="number">1</span>)&#123;</span><br><span class="line">                        ip.append(<span class="string">'.'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(ip.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果还没找到四段 ip 地址就已经遍历完了字符串，那么提前 回溯</span></span><br><span class="line">        <span class="keyword">if</span>(segStart == s.length())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前数字为 0 ，那么这段 IP 只能为 0</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(segStart) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            segments[segId] = <span class="number">0</span>;</span><br><span class="line">            dfs(s, segId + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一般情况</span></span><br><span class="line">        <span class="keyword">int</span> addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> segEnd = segStart; segEnd &lt; s.length(); ++segEnd)&#123;</span><br><span class="line">            addr = addr * <span class="number">10</span> + (s.charAt(segEnd) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(addr &gt; <span class="number">0</span> &amp;&amp; addr &lt;= <span class="number">0xFF</span>)&#123;</span><br><span class="line">                segments[segId] = addr;</span><br><span class="line">                dfs(s, segId + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;93-复原IP地址&quot;&gt;&lt;a href=&quot;#93-复原IP地址&quot; class=&quot;headerlink&quot; title=&quot;93. 复原IP地址&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/restore-ip-addresses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;93. 复原IP地址&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。&lt;/p&gt;
&lt;p&gt;有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt;分隔。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>恢复二叉搜索树</title>
    <link href="https://hoo334.github.io/2020/08/08/%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/08/%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-08-08T01:46:58.000Z</published>
    <updated>2020-08-08T02:47:23.094Z</updated>
    
    <content type="html"><![CDATA[<h4 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">99. 恢复二叉搜索树</a></h4><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  &#x2F;</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">输出: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  3</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><ul><li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li><li>你能想出一个只使用常数空间的解决方案吗？</li></ul><p><strong>方法一：显式中序遍历</strong></p><p>我们知道 BST 的中序遍历是有序的，我们可以使用一个数组存储中序遍历的结点。在交换了两个结点之后的数组，如果我们将其画成折线图，我们会发现存在一段或两段 “下降” 的折线。下面看几个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">交换两个结点后的中序遍历序列:</span><br><span class="line">[1, 3, 2, 4], 存在一段下降的折线[3, 2]，我们交换 “3” 和 “2” 即可</span><br><span class="line">[1, 5, 3 ,4 ,2 ,6], 存在两段下降的折线[5, 3] 和[4, 2]，我们交换左边折线的结点“5” 和右边折线的结点 “2” 即可。</span><br><span class="line">总结：我们只需要找到一个下降折线的左边结点和一个下降折线的右边结点，而不管折线有一根和两根折线。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//存储中序遍历得到的结点</span></span><br><span class="line">        inOrder(root, nodes);</span><br><span class="line">        <span class="keyword">int</span> n = nodes.size(); </span><br><span class="line"><span class="comment">//寻找“下降”折线的左侧结点</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes.get(i).val &gt; nodes.get(i + <span class="number">1</span>).val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//寻找“下降”折线的右侧结点</span></span><br><span class="line">        <span class="keyword">for</span>(; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes.get(j).val &lt; nodes.get(j - <span class="number">1</span>).val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//交换结点的值</span></span><br><span class="line">        TreeNode n1 = nodes.get(i);</span><br><span class="line">        TreeNode n2 = nodes.get(j);</span><br><span class="line">        <span class="keyword">int</span> temp = n1.val;</span><br><span class="line">        n1.val = n2.val;</span><br><span class="line">        n2.val = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inOrder(root.left, nodes);</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        inOrder(root.right, nodes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度O(n)，时间复杂度O(n)。</p><p><strong>方法二：隐式中序遍历</strong></p><p>在方法一中，我们使用了一个数组来保存中序遍历的结点，我们可以在中序遍历的过程中找到两个交换的结点，从而避免了存储中序遍历的结点。</p><p>我们使用 pre 来指向前一个遍历的结点，pre.val &gt; root.val 代表这是一段下降的折线，那我们可以先保存折线左侧的结点，然后再保存折线右侧的结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode x = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode y = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode pre = <span class="keyword">new</span> TreeNode(Integer.MIN_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="comment">//交换结点的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = x.val;</span><br><span class="line">        x.val = y.val;</span><br><span class="line">        y.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="comment">//第一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span> &amp;&amp; pre.val &gt; root.val)&#123;</span><br><span class="line">            x = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个结点不为空才保存第二个结点</span></span><br><span class="line">        <span class="keyword">if</span>(x != <span class="keyword">null</span> &amp;&amp; pre.val &gt; root.val)&#123;</span><br><span class="line">            y = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新前一个遍历的结点 pre</span></span><br><span class="line">        pre = root;</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度O(h)，h 为二叉树的高度。时间复杂度O(n)。</p><p><strong>方法三：Morris 中序遍历</strong></p><p>Morris 非递归中序遍历空间复杂度可以降为O(1)。</p><p>Morris 遍历算法步骤如下（假设当前遍历到的结点为 x ）：</p><ol><li>如果 x 无左孩子，则访问 x 的右孩子， 即 x = x.right。</li><li>如果 x 有左孩子，则找到 x 左子树上的最右结点（即左子树中序遍历的最后一个结点，x 在中序遍历的前驱结点），记为 predecessor。根据 predecessor的右孩子是否为空，进行如下操作：<ul><li>如果 predecessor的右孩子为空，将其右孩子指向 x ，然后访问 x 的左孩子，即 x = x.left。</li><li>如果 predecessor的右孩子不为空，则此时其右孩子指向 x ，说明我们已经遍历完 x 的左子树，我们将 predecessor的右孩子置空，然后访问 x 的右孩子，即 x = x.right。</li></ul></li></ol><p>重复上述操作，直至访问完整棵树。</p><p>整个过程我们只多做一步：将当前结点左子树中的最右边的结点指向它，这样在左子树遍历完成后，我们可以通过这个指针回到 x，且能通过这个知道我们已经遍历完成了左子树，省去了栈的空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode x = <span class="keyword">null</span>, y = <span class="keyword">null</span>, pred = <span class="keyword">null</span>, predecessor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//寻找 predecessor 结点(root 结点中序遍历前一个结点)</span></span><br><span class="line">                predecessor = root.left;</span><br><span class="line">                <span class="keyword">while</span>(predecessor.right != <span class="keyword">null</span> &amp;&amp; predecessor.right != root)&#123;</span><br><span class="line">                    predecessor = predecessor.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span>(predecessor.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    predecessor.right = root;</span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左子树已经访问完了，我们需要断开连接</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(pred != <span class="keyword">null</span> &amp;&amp; root.val &lt; pred.val)&#123;</span><br><span class="line">                        y = root;</span><br><span class="line">                        <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">                            x = pred;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//更新前一个遍历的结点 pred</span></span><br><span class="line">                    pred = root;</span><br><span class="line">                    <span class="comment">//断开连接</span></span><br><span class="line">                    predecessor.right = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//继续遍历右子树</span></span><br><span class="line">                    root = root.right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有左孩子，直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(pred != <span class="keyword">null</span> &amp;&amp; root.val &lt; pred.val)&#123;</span><br><span class="line">                    y = root;</span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        x = pred;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pred = root;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换 x 和 y 的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = x.val;</span><br><span class="line">        x.val = y.val;</span><br><span class="line">        y.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)。</p><p>参见<a href="https://leetcode-cn.com/problems/recover-binary-search-tree/solution/san-chong-jie-fa-xiang-xi-tu-jie-99-hui-fu-er-cha-/" target="_blank" rel="noopener">王尼玛的幻灯片</a>更好地理解算法过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;99-恢复二叉搜索树&quot;&gt;&lt;a href=&quot;#99-恢复二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;99. 恢复二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/recover-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;99. 恢复二叉搜索树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;二叉搜索树中的两个节点被错误地交换。&lt;/p&gt;
&lt;p&gt;请在不改变其结构的情况下，恢复这棵树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="二叉搜索树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
  </entry>
  
  <entry>
    <title>相同的树</title>
    <link href="https://hoo334.github.io/2020/08/07/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <id>https://hoo334.github.io/2020/08/07/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</id>
    <published>2020-08-07T02:28:13.000Z</published>
    <updated>2020-08-07T02:36:27.862Z</updated>
    
    <content type="html"><![CDATA[<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></h4><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>方法一：DFS</strong></p><p>对于两棵树 root1，root2，如果 root1 和 root2 都为空，则返回 true；如果 root1 和 root2 中有一个为空，另一个不为空，则返回false。如果都不为空且它们的值相等，则递归判断左右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(min(m, n))，m，n为两棵树的节点数。空间复杂度O(min(m, n))。</p><p><strong>方法二：BFS</strong></p><p>我们使用两个队列来存储二叉树的层次遍历。判断这个队列中的结点值是否相同即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q1.offer(p);</span><br><span class="line">        q2.offer(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q1.isEmpty() &amp;&amp; !q2.isEmpty())&#123;</span><br><span class="line">            TreeNode n1 = q1.poll(), n2 = q2.poll();</span><br><span class="line">            <span class="keyword">if</span>(n1.val != n2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( (n1.left == <span class="keyword">null</span> ^ n2.left == <span class="keyword">null</span>) || (n1.right == <span class="keyword">null</span> ^ n2.right == <span class="keyword">null</span>) )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(n1.left != <span class="keyword">null</span>) q1.offer(n1.left);</span><br><span class="line">            <span class="keyword">if</span>(n1.right != <span class="keyword">null</span>) q1.offer(n1.right);</span><br><span class="line">            <span class="keyword">if</span>(n2.left != <span class="keyword">null</span>) q2.offer(n2.left);</span><br><span class="line">            <span class="keyword">if</span>(n2.right != <span class="keyword">null</span>) q2.offer(n2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(min(m, n))，m，n为两棵树的节点数。空间复杂度O(min(m, n))。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;100-相同的树&quot;&gt;&lt;a href=&quot;#100-相同的树&quot; class=&quot;headerlink&quot; title=&quot;100. 相同的树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/same-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;100. 相同的树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定两个二叉树，编写一个函数来检验它们是否相同。&lt;/p&gt;
&lt;p&gt;如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Easy" scheme="https://hoo334.github.io/tags/Leetcode-Easy/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>打家劫舍III</title>
    <link href="https://hoo334.github.io/2020/08/05/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/"/>
    <id>https://hoo334.github.io/2020/08/05/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/</id>
    <published>2020-08-05T01:38:57.000Z</published>
    <updated>2020-08-05T02:12:42.647Z</updated>
    
    <content type="html"><![CDATA[<h4 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></h4><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line"></span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 4 + 5 &#x3D; 9.</span><br></pre></td></tr></table></figure><p>很显然，对于每个房子，我们有偷和不偷两种状态，我们取的是这两种状态偷盗的金额的最大值。</p><p>我们用 <code>f(o)</code>表示选择结点 o 的情况下，o 结点的子树上被选择的结点的最大权值和；<code>g(o)</code>表示不选择结点 o 的情况下，o 结点的子树上被选择的结点的最大权值和；l 和 r 代表 o 的左右孩子。</p><ul><li>当 o 被选中时，l 和 r 都不能选中，<code>f(o) = f(l) + f(r)</code>;</li><li>当 o 不被选中时，l 和 r 都能被选中或<strong>不被选择</strong>，<code>g(o) = max(f(l), g(l)) + max(f(r), g(r))</code>;</li></ul><p>第二种情况：二叉树[4,1,null,2,null,3] 的偷盗最大金额为 7 ，选中 4 之后，不能选择子节点 1 ， 对于子节点 1 ，可以有选择 2 和 不选择 2 两种选择，选择 2 得到最后金额 6 ，不选择 2 得到最大金额 7 。即对于一个未选择的根节点，继续不选择子节点有可能会有更好的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; f = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 存储不选择结点的金额</span></span><br><span class="line">    Map&lt;TreeNode, Integer&gt; g = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//存储选择结点的金额</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">//返回选择根节点和不选择根节点的最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(f.getOrDefault(root, <span class="number">0</span>), g.getOrDefault(root, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line"><span class="comment">//选择根节点</span></span><br><span class="line">        f.put(root, root.val + g.getOrDefault(root.left, <span class="number">0</span>) + g.getOrDefault(root.right, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//不选择根节点</span></span><br><span class="line">        g.put(root, Math.max(f.getOrDefault(root.left, <span class="number">0</span>), g.getOrDefault(root.left, <span class="number">0</span>)) + </span><br><span class="line">            Math.max(f.getOrDefault(root.right, <span class="number">0</span>), g.getOrDefault(root.right, <span class="number">0</span>)) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，对二叉树做了一次后序遍历。</p><p>空间复杂度O(n)，栈空间O(n)，哈希表O(n)。</p><p>我们还可以对空间复杂度进行优化，可以看出，对于 <code>f(o)</code>或<code>g(o)</code>，它们的取值只与<code>f(l)</code>、<code>f(r)</code>、<code>g(l)</code>、<code>g(r)</code>有关，我们在递归返回时返回一个数组，这样就可以不适用哈希表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] rootStatus = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(rootStatus[<span class="number">0</span>], rootStatus[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dfs(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//l[0] 代表选择结点 l得到的金额，l[1] 代表不选择结点 l 得到的金额。</span></span><br><span class="line">        <span class="keyword">int</span>[] l = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] r = dfs(root.right);</span><br><span class="line">        <span class="keyword">int</span> selected = root.val + l[<span class="number">1</span>] + r[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> notSelected = Math.max(l[<span class="number">0</span>], l[<span class="number">1</span>]) + Math.max(r[<span class="number">0</span>], r[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;selected, notSelected&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，对二叉树做了一次后序遍历。</p><p>空间复杂度O(n)，栈空间O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;337-打家劫舍-III&quot;&gt;&lt;a href=&quot;#337-打家劫舍-III&quot; class=&quot;headerlink&quot; title=&quot;337. 打家劫舍 III&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;337. 打家劫舍 III&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。&lt;/p&gt;
&lt;p&gt;计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二叉树" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络(谢希仁)</title>
    <link href="https://hoo334.github.io/2020/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E8%B0%A2%E5%B8%8C%E4%BB%81)/"/>
    <id>https://hoo334.github.io/2020/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E8%B0%A2%E5%B8%8C%E4%BB%81)/</id>
    <published>2020-08-04T06:39:13.000Z</published>
    <updated>2020-08-15T09:08:45.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络体系概述"><a href="#计算机网络体系概述" class="headerlink" title="计算机网络体系概述"></a>计算机网络体系概述</h2><h3 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a><strong>计算机网络概述</strong></h3><h4 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h4><p>　　1）广义观点：只要是能实现远程信息处理的系统或能进一步达到资源共享的系统，都是计算机网络。</p><p>　　2）资源共享观点：计算机网络是 “以能够共享资源的方式互联起来的自治计算机系统的集合” 。该定义包含三层含义： 1、目的：资源共享；2、组成单元：分布在不同地理位置的多台独立的 “ 自治计算机”；3、网络中的计算机额必须遵循统一的规则–网络协议。</p><p>　　3）用户透明性观点：存在一个能够为用户自动管理的网络操作系统，它能够调用用户所需要的资源。　　</p><h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h4><p>　　1）从组成部分上来看：完整的计算机网络主要由<strong>硬件、软件、协议</strong>三大部分组成。硬件主要由主机、通信链路（双绞线、光纤）、交换设备（路由器、交换机）和通信处理机（网卡）等组成。软件主要是各种实现资源共享的软件和方便用户使用的各种工具软件（OS、FTP程序等），多属于应用层。协议规定了网络传输数据时所遵循的规范。</p><p>　　2）从工作方式来看：计算机网络可分为<strong>边缘部分</strong>和<strong>核心部分。</strong>边缘部分由供用户直接使用的主机使用，核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。</p><p>　　3）从功能组成上看，计算机网络由通信子网和资源子网组成，通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络有数据传输、交换、控制和存储的能力。资源子网向网络用户提供共享其他计算机的资源的服务。</p><h4 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h4><p>　　1）<strong>数据通信</strong>：实现联网计算机之间的各种信息的传输。</p><p>　　2）<strong>资源共享</strong>：软件、硬件、数据的共享。</p><p>　　3）分布式处理：当某个计算机系统负荷过重，将任务分配给其他计算机系统。</p><p>　　4）提高可靠性。</p><p>　　5）负载均衡： 将工作任务均衡地分配给计算机网络中的各台计算机。</p><h4 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h4><h5 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h5><p>　　1）广域网 WAN（Wide Area Network）：广域网提供长距离通信。</p><p>　　2）城域网 MAN（Metropolitan Area Network）：大多采用以太网技术 覆盖城市或街区。</p><p>　　3）局域网 LAN（Local Area Network）：覆盖范围较小，传统上，局域网使用广播技术，广域网使用交换技术。</p><p>　　4）个人区域网 PAN（Personal Area Network）：覆盖范围最小。</p><p>　　</p><h5 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h5><p>　　1）广播式网络：所有联网计算机共享一个公共通信信道。当一台计算机利用它发送报文分组时，其他的所有计算机都会接收到该分组，接收到的计算机会检查目的地址来判断是否为自己的分组，不是则丢弃。</p><p>　　2）点对点网络：每条物理线路连接一对计算机。如果没有直接相连的线路，它们之间的分组就要通过中间节点的存储转发到达目的节点。</p><p>　　是否采用分组存储转发与路由机制是点对点式网络与广播式网络的区别，广域网基本属于点对点网络。</p><h5 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h5><p>　　网络拓扑结构是指网络中结点（路由器、主机等）与通信线路（网线）之间的几何关系。</p><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/DTdmvoEqzWPRCy2.png" alt="img"></p><p>　　1）总线形： 建网方便，重负载时通信效率不高。</p><p>　　2）星形：便于集中控制管理，成本高，中心结点对故障敏感。</p><p>　　3）环形：所有计算机接口设备连成一个环。典型的令牌环局域网。环中信号单向传输。</p><p>　　4）网状形：每个结点至少有两条路径与其他结点相连，多用在局域网，可靠性高，成本高。</p><h5 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h5><p>　　1）公用网：电信公司出资建设的大型网络。</p><p>　　2）专用网：某个单位自建的网络。</p><p>　　</p><h5 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h5><p>　　交换技术时指各主机之间、各通信设备之间或主机与通信设备之间为交换信息之间所采用的数据格式和交换装置的方式。</p><p>　　1）电路交换网络：在源结点和目的结点之间建立一条专用的通路用来传输数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网是传统电话网络。</p><p>　　2）报文交换网络：用户数据加上源地址、目的地址、校验码等辅助信息，<strong>封装成报文</strong>，利用中间结点存储转发到达目的结点。</p><p>　　3）分组交换网络：<strong>将数据分成较短的固定长度的数据块</strong>，在每个数据块中加上目的地址、源地址和辅助信息组成分组以存储-转发方式传输。</p><p>　　</p><h5 id="按传输介质分"><a href="#按传输介质分" class="headerlink" title="按传输介质分"></a>按传输介质分</h5><p>　　传输介质分为有线和无线两大类，因此网络可分为有线网络和无线网络。有线网络分为双绞线网络、同轴电缆网络等。无线网络又可分为蓝牙、微波、无线电等类型。</p><p>　　　</p><h4 id="计算机网络标准化组织"><a href="#计算机网络标准化组织" class="headerlink" title="计算机网络标准化组织"></a>计算机网络标准化组织</h4><p>　　1）国际标准化组织（ISO）：制定主要标准 OSI参考模型、HDLC。</p><p>　　2）国际电信联盟（ITU）。</p><p>　　3）国际电气电子工程师协会（IEEE）。</p><p> 　</p><h4 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h4><p>　　1）带宽：网络通信线路所能传输数据的能力，是数字信道所能传输的 “最高数据率” 的同义词，单位 b/s。</p><p>　　2）时延：数据（一个分组或报文）从网络（或链路）的一端传送到另一端所需要的总时间，它由4部分构成 发送时延、传播时延、处理时延、排队时延。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/aDkJnfzV4wTejlB.png" alt="img"></p><p>​    3）时延带宽积：发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特。</p><p>　　时延带宽积 = 传播时延*信道带宽</p><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/ogeU1hSdpj54sB3.png" alt="img"></p><p>​        4）往返时延（Round-Trip Time）：从发送端发送数据开始，到发送端收到来自接收端的确认总共经过的时延。</p><p>　　5）吞吐量：单位时间内通过某个网络的数据量</p><p>　　6）速率：连接到计算机网络上的主机在数字信道上传送数据的速率，也称数据率，单位为b/s。通常把最高数据率称为带宽。</p><p>　　7）信道利用率 某一信道有百分之多少的时间是有数据通过的 信道利用率 = 有数据通过时间/（有+无）数据通过时间。</p><h3 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h3><h4 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h4><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/sqlSCvRFknEHVrJ.png" alt="img"></p><p> 　服务是垂直的，协议是水平的。</p><h4 id="计算机网络协议、接口、服务的概念"><a href="#计算机网络协议、接口、服务的概念" class="headerlink" title="计算机网络协议、接口、服务的概念"></a>计算机网络协议、接口、服务的概念</h4><p>  　　1. 协议：为进行网络中的数据交换而建立的规则、标准或约定称为网络协议（Network Protocol）,它是控制两个或多个对等实体进行通信的规则集合。协议由语法、语义和同步组成。语法规定了传输数据的格式。语义规定了所要完成的功能，即发出何种控制信息、完成何种动作和做出何种应答；同步规定了执行各种操作的条件、时序关系等。一个完整的协议通常具有线路管理、差错控制、数据转换等功能。</p><pre><code>    　　2. 接口：接口是同一结点内相邻两层间交换信息的交换点。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（Service Access Point）进行交互。服务是通过SAP提供给上层使用的。        　　3. 服务：服务是指下层为紧邻的上层提供的功能调用，它是垂直的。上层与下层交换一些命令使用服务原语。OSI将源语分为四类：请求，指示，响应，证实。</code></pre><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/49LkNCq6W3ySmKF.png" alt="img"></p><p> 　计算机网络提供的服务可按以下三种方式分类</p><p>　　<strong>1）面向连接服务与无连接服务。</strong></p><p>　　面向连接服务分为连接建立、数据传输和连接释放三个阶段。例如TCP。</p><p>　　无连接服务不需要建立连接，直接发送，尽最大努力交付，不保证通信的可靠性。例如IP，UDP</p><p>　　<strong>2）可靠服务与不可靠服务</strong></p><p>　　可靠服务指网络具有纠错、检错、应答机制，确保数据正确可靠传送到目的地。</p><p>　　不可靠服务是指网络只是尽量正确、可靠地传输，不能保证数据正确、可靠地传送到目的地。</p><p>　    <strong>3）有应答服务和无应答服务</strong></p><p>　　有应答服务是指接收方在收到数据后向发送方给出相应的应答。例如文件传输服务。</p><p>　　无应答服务是指接收方收到数据后不自动给出应答。</p><p>　　</p><h4 id="ISO-OSI-参考模型和TCP-IP模型"><a href="#ISO-OSI-参考模型和TCP-IP模型" class="headerlink" title="ISO/OSI 参考模型和TCP/IP模型"></a>ISO/OSI 参考模型和TCP/IP模型</h4><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/obOvLcMiUGETIAN.png" alt="img"></p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/DzZ8rgE3SOcYiR4.png" alt="img"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/eRNgk93nSQomYJV.png" alt="img"></p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/jVCxW8psaHF7EwO.png" alt="img"></p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/gTzGmJbDRMC5kwa.png" alt="img"></p><h3 id="本章小结及疑难点"><a href="#本章小结及疑难点" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="计算机网络与分布式计算机系统的主要区别是什么？"><a href="#计算机网络与分布式计算机系统的主要区别是什么？" class="headerlink" title="计算机网络与分布式计算机系统的主要区别是什么？"></a>计算机网络与分布式计算机系统的主要区别是什么？</h4><p>​        分布式系统最主要的特点是：整个系统中的各个计算机对用户都是透明的。用户通过输入命令就可以运行程序，用户并不知道是哪台计算机在为它运行程序。操作系统为用户选择一台最合适的计算机来运行其程序，并将运行的结果传送到合适的地方。</p><p>计算机网络则不同，用户必须先登录欲运行程序的计算机，然后按照计算机的地址，将程序通过计算机网络传送到该计算机上运行，最后根据用户的命令将结果传送到指定的计算机。两者的区别主要是软件的不同。</p><h4 id="为什么一个网络协议必须考虑到各种不利的情况？"><a href="#为什么一个网络协议必须考虑到各种不利的情况？" class="headerlink" title="为什么一个网络协议必须考虑到各种不利的情况？"></a>为什么一个网络协议必须考虑到各种不利的情况？</h4><p>​        因为网络协议如果不全面考虑不利的情况，那么当情况发生变化时，协议就会保持理想状况，一直等下去。</p><h4 id="因特网使用的-IP-协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么当初为什么不把因特网传输设计为可靠的呢？"><a href="#因特网使用的-IP-协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么当初为什么不把因特网传输设计为可靠的呢？" class="headerlink" title="因特网使用的 IP 协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么当初为什么不把因特网传输设计为可靠的呢？"></a>因特网使用的 IP 协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么当初为什么不把因特网传输设计为可靠的呢？</h4><p>​        传统电信网的主要用途使电话通信，并且普通电话机不是智能的，因此电信公司必须花费巨大的代价把电信网设计的非常好，以保证用户的通信质量。<br>计算机网络的先驱们认为，计算机网络和电信网的一个重大区别是终端设备的性能差别很大。于是，他们采用了 “端到端的可靠传输” 策略，即在传输层使用面向连接的 TCP 协议，这样既能使网络部分价格便宜且灵活可靠，又能保证端到端的可靠传输。</p><h4 id="端到端通信和点到点通信有什么区别？"><a href="#端到端通信和点到点通信有什么区别？" class="headerlink" title="端到端通信和点到点通信有什么区别？"></a>端到端通信和点到点通信有什么区别？</h4><p>​        由物理层、数据链路层和网络层组成的通信子网为网络环境中的主机提供点到点的服务，而传输层为网络中的主机提供端到端的通信。<br>直接相连的结点之间的通信称为<strong>点到点通信</strong>，它只提供一台机器到另一台机器之间的通信，不涉及程序或进程的概念。同时，点到点通信并不能保证数据传输的可靠性，也不能说明源主机和目的主机之间是哪两个进程在通信，这些工作都是由传输层来完成的。<br>端到端通信建立在点到点通信的基础上，它是由一段段的点到点通信信道构成的，是比点到点通信更高一级的通信方式，以完成应用程序（进程）之间的通信。“端” 是指用户程序的端口，端口号标识了应用层中不同的进程。</p><h4 id="如何理解传输速率、带宽和传播速率？"><a href="#如何理解传输速率、带宽和传播速率？" class="headerlink" title="如何理解传输速率、带宽和传播速率？"></a>如何理解传输速率、带宽和传播速率？</h4><p>​        传输速率指主机在<strong>数字信道上发送数据的速率</strong>，也称数据率或比特率，单位是 b/s 。<br>带宽在计算机网络中指数字信道所能传送的“最高数据传输速率”，常用来表示网络的通信线路传送数据的能力。<br>传播速率是指电磁波在信道中传播的速率，单位是 m/s。</p><h4 id="试从多个方面比较电路交换、报文交换和分组交换的优缺点。"><a href="#试从多个方面比较电路交换、报文交换和分组交换的优缺点。" class="headerlink" title="试从多个方面比较电路交换、报文交换和分组交换的优缺点。"></a>试从多个方面比较电路交换、报文交换和分组交换的优缺点。</h4><p>​        电路交换的主要特点：<br>1）通信一定由有三个阶段：建立连接、通信、释放连接。<br>2）在整个通信过程中，通信的双方自始至终占用着所使用的物理信道。<br>电路交换对通信线路的利用率比较低。静态分配传输带宽，当发生拥塞时通信质量不会下降。<br>目前常用的分组交换是使用无连接的 IP 协议。这种分组交换以分组作为传输的单位。采用存储转发技术，无连接建立和释放这两个阶段，传送数据较快。动态分配传输带宽，对通信链路是逐段占用的。分组在各路由器存储转发时需要排队，这就会造成一定的时延。<br>报文交换也采用存储转发技术，报文交换不再把 报文分割为更小的分组，而是把整个报文在网络的结点中存储下来，然后转发出去。传输数据的时延较大。</p><h4 id="协议与服务有何区别？有何关系？"><a href="#协议与服务有何区别？有何关系？" class="headerlink" title="协议与服务有何区别？有何关系？"></a>协议与服务有何区别？有何关系？</h4><p>​        协议是控制两个对等实体（或多个实体）进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。<br>协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。</p><h4 id="网络协议的三个要素是什么？各有什么含义？"><a href="#网络协议的三个要素是什么？各有什么含义？" class="headerlink" title="网络协议的三个要素是什么？各有什么含义？"></a>网络协议的三个要素是什么？各有什么含义？</h4><p>1）语法，即数据与控制信息的结构或格式。<br>2）语义，即需要发出何种控制信息、完成何种动作以及做出何种响应。<br>3）同步，即时间实现顺序的详细说明。</p><h4 id="试述具有五层协议的网络体系结构的要点，包括各层的主要功能。"><a href="#试述具有五层协议的网络体系结构的要点，包括各层的主要功能。" class="headerlink" title="试述具有五层协议的网络体系结构的要点，包括各层的主要功能。"></a>试述具有五层协议的网络体系结构的要点，包括各层的主要功能。</h4><p>1）物理层。在物理层上传送数据的单位是比特。物理层的任务就是透明地传送比特流。<br>2）数据链路层。将网络层交下来地 IP 数据报组装成帧，在两个相邻结点间地链路上“透明”地传送帧中的数据。<br>3）网络层。负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组或包进行传送。<br>4）传输层。传输层的任务就是负责向两个主机中进程之间的通信提供服务。<br>5）应用层。直接为用户的应用进程提供服务。</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a><strong>通信基础</strong></h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="数据、信号与码元"><a href="#数据、信号与码元" class="headerlink" title="数据、信号与码元"></a>数据、信号与码元</h5><p>　　1）数据：传送信息的实体。</p><p>　　2）信号：数据的电气或电磁表现，是数据在传输过程中的存在形式。</p><p>　　3）码元：用一个固定时长的信号波形表示一位k进制数字。</p><p>　　</p><h5 id="信源、信道与信宿"><a href="#信源、信道与信宿" class="headerlink" title="信源、信道与信宿"></a>信源、信道与信宿</h5><p>　　1）信源：产生与发送数据的源头 。2）信道：信号的传输媒介。3）信宿：接收数据的终点。</p><p>　　</p><h5 id="速率、波特与带宽"><a href="#速率、波特与带宽" class="headerlink" title="速率、波特与带宽"></a>速率、波特与带宽</h5><p>　　速率：单位时间传输的数据量。可以用码元传输速率和信息传输速率表示。</p><p>　　1）码元传输速率：单位时间内传输的码元个数。单位为波特Baud。</p><p>　　2）信息传输率：单位时间内传输的比特数，单位 b/s。</p><p>　　</p><h4 id="奈奎斯特定理和香农定理"><a href="#奈奎斯特定理和香农定理" class="headerlink" title="奈奎斯特定理和香农定理"></a>奈奎斯特定理和香农定理</h4><p>　　1）奈奎斯特定理：<strong>在理想低通信道中极限码元传输率为2W波特，其中W是理想低通信道的带宽单位为Hz。</strong>若用V来表示每个码元离散电平的数目，比如有16种不同的码元，采用NRZ码传输，发送一位需要1个信号周期，一个码元含有4bit信息量，若采用Manchester码 ，发送一位需要2个信号周期，一个码元含有2bit信息量。如果只有两种码元，采用NRZ，每个码元含有1bit信息量；采用Manchester，每个码元含有0.5bit信息量。</p><p>　　<strong>极限数据传输率 = 2W*log2(V)</strong></p><p>　　2）香农定理：给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率</p><p>　　<strong>信道的极限数据传输率 = W*log2(1+S/N)</strong></p><p> 　</p><h4 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h4><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/TgmOEQv4BAeCZXt.png" alt="img"></p><p> 　   归零编码（RZ）：高电平为1，低电平为0，在每个时钟周期中间均跳变到低电平。</p><p>　　非归零编码（NRZ）：高电平为1，低电平为0，无法传递时钟信号难以同步。</p><p>　　反转非归零码（NRZI）：用信号的翻转代表0，信号保持不变代表1。</p><p>　　曼彻斯特码（Manchester）：10 表示高电平，01表示低电平。以太网使用。</p><p>　　差分曼彻斯特码：若下一个电平为低，在码元边界反转，若为高电平则保持不变。</p><h4 id="电路交换、报文交换与分组交换"><a href="#电路交换、报文交换与分组交换" class="headerlink" title="电路交换、报文交换与分组交换"></a>电路交换、报文交换与分组交换</h4><p>　　1）电路交换：在进行数据传输前，两个结点之间必须<strong>建立一条双方独占的物理通信路径</strong>。时延小，有序传输，无冲突，实时性强。建立连接时间长，线路独占，灵活性差，难以规格化。</p><p>　　2) 报文交换：<strong>数据交换的单位是报文</strong>，报文携带有目标地址、源地址等信息。报文交换在交换结点采用存储转发的传输方式。无须建立连接，动态分配线路，提高线路可靠性提高线路利用率，提供多目标服务。转发时延大，需要较大缓存空间。</p><p>　　3）分组交换：<strong>限制每次传送数据块大小上限，</strong>采用存储–转发方式。无建立时延，线路利用率高、简化存储管理，加速传输，减少出错概率和重发数据量。存在传输时延，需要传输额外的信息量，当分组交换使用数据报服务时会出现失序、丢失或者重复分组，需要重新排序分组。采用虚电路服务，无失序问题但有呼叫建立、数据传输和虚电路释放三个过程。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/2LT6fPzRjcS7sOm.png" alt="img"></p><h4 id="数据报和虚电路"><a href="#数据报和虚电路" class="headerlink" title="数据报和虚电路"></a>数据报和虚电路</h4><p>　　<strong>分组交换可分为面向连接的虚电路方式和无连接的数据报方式</strong>。这两种服务方式都由网络层提供。（IP分组）数据报方式和虚电路方式是分组交换的两种方式。</p><p>　　1）数据报：高层协议先将报文拆成若干个带序号的数据单元，在网络层加上控制信息形成数据报分组。<strong>不同的分组可以走不同的路径，也可以按不同的顺序到达目的结点。</strong></p><p>　　2）虚电路：在发送发和接收方建立一条逻辑上相连的虚电路，连接一旦确立就固定了虚电路所对应的物理路径。与电路交换类似，分为虚电路建立、数据传输和虚电路释放。端系统每次建立虚电路时，选择一个未使用过的虚电路号分配给该虚电路。<strong>每个数据分组不仅要有分组号、校验和控制信息还要有它要通过的虚电路号。</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/b4jrLfc7wiYvuMe.png" alt="img"></p><h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a><strong>传输介质</strong></h3><h4 id="双绞线、同轴电缆、光纤与无线传输介质"><a href="#双绞线、同轴电缆、光纤与无线传输介质" class="headerlink" title="双绞线、同轴电缆、光纤与无线传输介质"></a>双绞线、同轴电缆、光纤与无线传输介质</h4><p>　　传输介质是发送设备和接收设备之间的物理线路。</p><p>　　1）双绞线：由两根采用一定规则并排绞合的互相绝缘的铜导线组合而成，绞合可以减少对相邻导线的电磁干扰。模拟传输和数字传输都可使用。</p><p>　　2）同轴电缆：由内导体、绝缘层、网状编织层和塑料外层构成。</p><p>　　3）光纤：主要由纤心和包层构成，利用光的全反射。</p><p>　　4）无线传输介质：无线电波 微光、红外光和激光。</p><p>　　</p><h4 id="物理层接口的特性"><a href="#物理层接口的特性" class="headerlink" title="物理层接口的特性"></a>物理层接口的特性</h4><p>　　1）机械特性：规定物理连接时所采用的规格、引线的数目、引脚的数量和排列情况。</p><p>　　2）电气特性：规定传输二进制位时，线路上信号的电压高低、阻抗匹配、传输速率和距离限制等。</p><p>　　3）功能特性：指明某条线上出现的某一电平的电压表示何种意义，接口部件的信号线用途。</p><p>　　4）规程特性：定义各条物理线路的工作规程和时序关系。</p><h3 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a><strong>物理层设备</strong></h3><h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><p>　　中继器又称转发器，主要功能是将信号整形并放大再转发出去，消除衰减，<strong>其原理是信号再生</strong>。有两个端口输入和输出端口。使用中继器连接的几个网段仍是一个局域网，它不能连接两个具有不同速率的局域网，它没有存储转发功能。中继器两端的网络部分是网段，而不是子网。</p><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>　　集线器实质上是一个多端口的中继器工作在物理层。当Hub工作时，一个端口收到数据信号后，将其整形放大，使之再生然后转发到其他所有端口，Hub在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，不具备信号的定向传输能力。Hub组成的网络是共享式网络，逻辑上仍是一个总线网，Hub只能在半双工状态下工作。集线器不能分割冲突域，例如一个带宽为10Mbps 的集线器上连接了8台计算机，8台计算机同时工作时，每台计算机真正拥有的带宽时1.25Mbps。</p><h3 id="本章小结及疑难点-1"><a href="#本章小结及疑难点-1" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="奈式准则和香农公式的主要区别是什么？这两个公式对数据通信的意义是什么？"><a href="#奈式准则和香农公式的主要区别是什么？这两个公式对数据通信的意义是什么？" class="headerlink" title="奈式准则和香农公式的主要区别是什么？这两个公式对数据通信的意义是什么？"></a>奈式准则和香农公式的主要区别是什么？这两个公式对数据通信的意义是什么？</h4><p>​        奈式准则指出了，码元传输的速率是受限的，不能任意提高，否则在接收端就无法正确判断码元是 1 还是 0（因为有码元之间的相互干扰）。</p><p>​        奈式准则是在理想条件下推导出的。在实际条件下，最高码元传输速率要比理想条件下得出的数值还要小些。奈式准则并没有对信息传输速率给出限制，要提高信息传输率就要提高每个码元所含的信息量。</p><p>​        香农公式给出了信息传输率的极限，即对于一定的传输带宽（Hz）和一定的信噪比，信息传输率的上限就确定了。要想提高信息的传输速率，必须设法提高传输线路的带宽或提高所传信号的信噪比。</p><h4 id="同步通信和异步通信的区别是什么？"><a href="#同步通信和异步通信的区别是什么？" class="headerlink" title="同步通信和异步通信的区别是什么？"></a>同步通信和异步通信的区别是什么？</h4><p>​        “异步通信”是一种很常用的通信方式。接收端必须时刻做好接收准备。发送端可以在任意时刻发送字符。异步通信可以用字符和帧作为发送单位，但必须注意字符或帧的开始和结束标识。</p><p>​        “同步通信”的通信双方必须先建立同步，即双方的时钟要调整到同一个频率。收发双方不停地接收连续的同步比特流。</p><h4 id="位同步和帧同步的区别是什么？"><a href="#位同步和帧同步的区别是什么？" class="headerlink" title="位同步和帧同步的区别是什么？"></a>位同步和帧同步的区别是什么？</h4><p>​        位同步是指接收端时钟已经调整到和发送端时钟完全一样，因此接收端收到比特流后，就能在每一位的中间位置进行判决。位同步的目的是为了将发送端发送的每一个比特都正确的接收下来。仅仅有位同步还不够，因为数据以帧为单位进行发送。一个帧必须有明确的界限，也就是有帧定界符。接收端在收到比特流后，必须能够正确地找出帧定界符，以便知道哪些比特构成一个帧。接收端确定了帧的准确位置就是完成了帧同步。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/MYGosKipFAkC62X.png" alt="image-20200427161642085"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/U3H9wYFLjGCya6D.png" alt="image-20200427161701168"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/CD5szARNdXO238P.png" alt="image-20200410102252708"></p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h3><h4 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h4><p>　　对网络层而言，数据链路层的基本任务是将源机器中来自网络层的数据传输到目标机器的网络层。</p><p>　　1）无确认的无连接服务。源机器发送数据帧时<strong>不需要先建立链路连接</strong>，目的机器收到数据帧时<strong>无需发回确认</strong>，对于<strong>丢失的帧交给上层处理</strong>。<strong>适用于实时通信或误码率较低的通信信道，如以太网</strong>。</p><p>　　2）有确认的无连接服务。源机器发送数据帧时<strong>不需要先建立链路连接</strong>，目的机器收到数据帧时<strong>必须发回确认。</strong>源机器在规定的时间内未收到确认信号时就<strong>重传丢失的帧</strong>。适用于误码率较高的通信信道，如无线通信。</p><p>​        3）有确认的面向连接服务。帧传输过程分为三个阶段：建立数据链路、传输帧、释放数据链路。目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧。适用于通信要求（可靠性、实时性）较高的场合。</p><p>　　</p><h4 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h4><p>　　数据链路层连接的建立、维持和释放过程称为链路管理，它主要用于面向连接的服务。链路两端的结点要通信必须首先确认对方已处于就绪状态，并交换一些必要的信息以对帧序号初始化，然后才能建立连接，在传输过程中能要维持连接，传输完成后要释放该连接。</p><p>　　</p><h4 id="帧定界、帧同步与透明传输"><a href="#帧定界、帧同步与透明传输" class="headerlink" title="帧定界、帧同步与透明传输"></a>帧定界、帧同步与透明传输</h4><p>　　两个工作站之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送。将一段数据的前后分别<strong>添加首部和尾部</strong>就构成了帧。首部和尾部含有很多控制信息，它们的一个重要作用是确定帧的边界，即<strong>帧定界</strong>。帧同步指的是接收方应能从收到的二进制比特流中区分帧的起始和终止。如在  <strong>HDLC 通信规程中用标识位F（01111110）来标识帧的开始和结束。</strong>检测到帧标识位 F 即认为是帧的开始，然后一旦检测到帧标识位 F 即表示帧的结束。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/sNDjvCmKV7gE1xI.png" alt="img"></p><p> 　如果在数据中刚好出现 01111110 的序列会误认为是帧的结束而抛弃后面的数据，要采取有效的措施解决这个问题，即透明传输。<strong>透明传输就是不管所传送数据是什么样的比特组合，都应当能在链路上传送。</strong></p><p> 　</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>　　由于收发双发各自的工作速率和缓存空间的差异可能发送方的发送能力大于接受方的接收能力的现象，流量控制实际上就是限制发送方的数据流量，使其发送速率不超过接收方的接收能力。</p><p>　　流量控制并不是数据链路层特有的功能，许多高层协议也提供此功能，只不过控制的对象不同而已。对于数据链路层来说，控制的是相邻两节点之间数据链路上的流量，对于传输层来说，控制的则是源端口到目的端口之间的流量。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/TcEumn3joNMX9Us.png" alt="img"></p><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>　　由于信道噪声等原因，帧在传输过程中可能会出现错误。用以使发送方确定接收方是否正确收到由其发送的数据的方法称为差错控制。通常，这些错误可分为位错和帧错。</p><p>　　位错指帧中某些位出现了差错。通常采用<strong>循环冗余校验（CRC）方式发现位错</strong>，通过自动重传请求（Automatic Repeat reQuest<strong>，ARQ）方式来重传出错的帧</strong>。发送方将数据帧加CRC校验码一起发送，接收方根据检错码对数据帧进行错误检测，若发现错误则丢弃，发送方超时重传该数据帧。ARQ法只需返回很少的控制信息就可有效确认所发数据帧是否被正确接收。</p><p>　　帧错指帧的丢失、重复或失序等错误在数据链路层引入<strong>定时器和编号机制</strong>，能保证每一帧最终都能有且仅有一次正确地交付给目的结点。</p><h3 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h3><p>　　数据链路层之所以要把比特组合成帧为单位传输，是为了在出错时只重发出错地帧，而不必重发全部数据，从而提高数据。为了接收方能正确地接收并检查所传输地帧，发送方必须依据一定地规则把网络层递交地分组封装成帧（称为组帧）。组帧主要解决帧定界、帧同步、透明传输等问题。</p><p>　　组帧既要加首部又要加尾部。 接收方依靠帧中地定界符来区分帧地开始和结尾。分组（IP数据报）仅是包含在帧中的数据部分。</p><h4 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h4><p>　　字符计数法是指<strong>在帧的头部使用一个计数字段来标明帧内字符数</strong>。如果计数字段出错后面的全部出错。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/zWNs7ADgBUthZQF.png" alt="img"></p><p> 　</p><h4 id="字符填充法的首尾定界符法"><a href="#字符填充法的首尾定界符法" class="headerlink" title="字符填充法的首尾定界符法"></a>字符填充法的首尾定界符法</h4><p>　　字符填充法使用一些特定的字符来定界一帧的开始（DLE STX）与结束（DLE ETX）。为了使信息位中出现的特殊字符不误认为帧的首尾定界符，可以在<strong>特殊字符前面填充一个转义字符（DLE）来加以区分</strong>（转义字符使ASCII 码中的控制字符，是一个字符 DLE只是一个代号），以实现数据的透明传输。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/tBpYfKaSMN3vyCk.png" alt="img"></p><p> 上图中信息部分含有一个转义字符DLE，因此在传输过程中添加一个转义字符，接收方将其去掉。</p><p>　　</p><h4 id="零比特填充的首尾标志法"><a href="#零比特填充的首尾标志法" class="headerlink" title="零比特填充的首尾标志法"></a>零比特填充的首尾标志法</h4><p>　　使用 01111110 来标志一帧的开始和结束。在信息位中遇到连续的5个1则自动在后面添加一个0。性能优于字符填充法。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/QXAdYuFaspT4J9S.png" alt="img"></p><h4 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h4><p>　　在物理层进行比特编码时，通常采用违规编码。例如曼彻斯特码。可以借用违规编码序列来定界帧的起始和终止。</p><p>　　<strong>目前较常用的组帧方法是比特填充法和违规编码法。</strong></p><h3 id="差错控制-1"><a href="#差错控制-1" class="headerlink" title="差错控制"></a>差错控制</h3><p> 　比特传输是传输差错的一种，这里仅讨论比特差错。通常利用编码技术来进行差错控制，主要有两类：<strong>自动重传请求ARQ</strong>和<strong>前向纠错FEC</strong>。<strong>在ARQ方式中，接收端检测出差错时通知发送端重发</strong>，直到收到正确的码字。<strong>在FEC 方式中，接收端不但能发现差错还能确定出错位置纠错</strong>。差错控制可分为检错编码和纠错编码。</p><h4 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4><p>　　1）奇偶校验码。在信息位后添加一位校验，以传输11100101 为例，如果是奇校验码 信息位中有5个1 为奇数则信息位为0，11100101 0 。如果是偶校验码 校验位为1 11100101 1。“奇”（“偶”）代表加上信息位之后的 “1” 的个数为 奇（偶）。它分为垂直奇偶校验、水平奇偶校验和水平垂直奇偶校验。</p><p>　　2）循环冗余码。又称多项式码，任意一个由二进制数位串组成的代码都可以与一个只含有0和1两个系数的多项式建立一一对应关系。</p><p>　　给定一个 m bit 的帧或报文，发送器生成 r bit 的序列称为帧检验序列（FCS）。形成的帧将由m+r bit 组成。发送方和接收方事先商定一个多项式 G(x) （最高位和最低位必须为1），使这个带校验码的帧刚好能被预先确定的多项式 G(x) 整除。接收方用同样的多项式去除收到的帧，如果无余数，认为无差错。</p><p>　　假设一个帧有 m 位，对应的多项式为 M(x)，计算冗余码的步骤如下;</p><p>　　a. 加0。假设G(x)的阶为 r ，在帧的低位端加上 r 个0。</p><p>　　b. 模2除（不涉及借位，0-1=1） 用帧的数据串除G(x)的数据串得到的余数为冗余码（共 r 位，前面的 0 不可以省略）。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/tgyXjxhYJPOEvR2.jpg" alt="img"></p><h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><p>　　以下海明码编码原理与过程。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/poDZz6wILR4KMNE.jpg" alt="img"></p><p> 　</p><h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h3><h4 id="流量控制、可靠传输与滑动窗口机制"><a href="#流量控制、可靠传输与滑动窗口机制" class="headerlink" title="流量控制、可靠传输与滑动窗口机制"></a>流量控制、可靠传输与滑动窗口机制</h4><p>　　流量控制涉及对链路上的帧的发送速率的控制，以使接收方有足够的缓冲空间来接收每个帧。</p><p>　　流量控制的基本方法是由接收方控制发送方的速率，常见的方式有两种：<strong>停止-等待协议</strong>和<strong>滑动窗口协议</strong>。</p><h5 id="停止-等待流量控制基本原理"><a href="#停止-等待流量控制基本原理" class="headerlink" title="停止-等待流量控制基本原理"></a>停止-等待流量控制基本原理</h5><p>　　发送方每发送一帧，都要等待接收方的应答信号才能发送下一帧，效率很低。</p><h5 id="滑动窗口流量控制基本原理"><a href="#滑动窗口流量控制基本原理" class="headerlink" title="滑动窗口流量控制基本原理"></a>滑动窗口流量控制基本原理</h5><p>　　在任意时刻，发送发都维持一组连续的允许发送的帧的序号，称为发送窗口。同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。<strong>发送方每接收到一个确认帧，发送窗口就向前滑动一个帧的位置。</strong></p><p>　　<strong>滑动窗口特性：</strong></p><p>　　a.只有接收窗口向前滑动（同时接收方发送了确认帧时），发送窗口才有可能向前移动（发送发接收到了确认帧）。</p><p>　　b.从滑动窗口概念上看，停止-等待协议、后退 N 帧协议和选择重传协议只在发送窗口大小与接收窗口大小上有所差别：</p><p>　　停止-等待协议：发送窗口大小 = 1，接收窗口大小 = 1</p><p>　　后退 N 帧协议：发送窗口 &gt; 1，接收窗口大小 = 1</p><p>　　选择重传协议：发送窗口 &gt; 1，接收窗口大小 &gt; 1</p><p>　　c.接收窗口大小为 1 时，可保证帧的有序接收。</p><p>　　d.<strong>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的，传输层的滑动窗口会改变。</strong></p><h5 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h5><p>　　数据链路层的可靠传输通常使用确认和超时重传两种机制来完成。确认是一种无数据的控制帧，这种控制帧使得接收方知道哪些内容被正确接收。有时候为了提高传输效率，将确认捎带在一个回复帧中，称为捎带确认。超时重传是发送方在发送数据帧后一段时间内没有收到确认帧，重新发送该数据帧。</p><p>　　自动重传请求（ARQ）通过接收方请求发送方重传出错的数据帧来恢复出错的帧。传统的自动重传请求分三种，停止-等待 ARQ，后退N帧 ARQ ，选择性重传 ARQ。</p><p>　　停止等待 ARQ：发送一帧，确认一帧。超时重传。</p><p>　　后退 N 帧 ARQ：可以连续发送窗口内的帧，接收方接收窗口为 1 可以保证按序接收数据帧。如果采用 n 比特对帧编号， 则其发送窗口W的大小应满足 <strong>1 &lt;= W &lt;= 2^n-1</strong> 。如果发送方窗口大于上限就会造成无法分辨新帧和旧帧。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/opi2d3rDtv9aZu6.png" alt="img"></p><p> 　2 号帧出错，丢弃窗口内所有帧。</p><p>　    选择重传 ARQ：设法只重传出现差错的数据帧或计时器超时的帧，必须加大接收窗口，接收发送序号不连续但仍处在接收窗口中的那些数据帧。等到所缺失的帧后一起交给主机。若采用 n 比特对帧编号则满足发送窗口<strong>W1 + W2 &lt;= 2^n</strong> 。接收窗口不应超过发送窗口 。一般情况下 <strong>W1=W2 = 2^(n-1)</strong>。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/B9UL7qNWwoVFgKk.png" alt="img"></p><p> <strong>GBN 和选择重传 都使用累计确认 收到 3 号帧的确认说明 接收方已经收到 0 - 3 号帧。</strong>　</p><p>　　信道效率：发送方在一个发送周期的时间内，有效地发送数据所需要地时间占整个发送周期的比率。</p><p>　　例如，发送方从开始发送数据开始到收到第一个确认帧为止，称为一个发送周期，设为T，发送方在这个周期内共发送L比特的数据，发送方的数据传输率为C，则发送方用于发送有效数据的时间为L/C，在这种情况下 信道利用率为 (L/C)/T。</p><p>　　信道吞吐率 = 信道利用率 * 发送方的发送速率。</p><h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><p>　　介质访问控制所要完成的任务是，为使用介质的每个结点隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输。用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制（Medium Access Control， MAC）子层。</p><h4 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h4><p>　　信道划分介质访问控制将使用介质的每个设备与来自同一通信信道上的其他设备的通信隔开，把时域和频域资源合理地分配给网络上地设备。在一条介质上同时携带多个传输信号的方法来提高系统的利用率，这就是多路复用。</p><p>　　1）频分多路复用（FDM）：将多路基带信号调制到不同频率载波上，再叠加形成一个复合信号的多路服用技术。</p><p>　　2）时分多路复用（TDM）：将一条物理信道按时间分成若干时间片，轮流地分配给多个信号使用。每个时间片由复用的一个信号占用。</p><p>　　3）波分多路复用（WDM）：在一根光纤中传输多种不同波长的光信号。</p><p>　　4）码分多路复用（CDM）：采用不同的编码来区分各路原始信号。</p><p>　　码分多址（Code Division Multiple Access ，CDMA）是码分复用的一种方式。每比特时间分成 m 个更短的时间槽，称为码片。当两个或多个站点同时发送时，各路数据在信道中线性相加。为从信道中分离出各路信号，要求<strong>各个站点的码片序列相互正交</strong>。</p><p>　　可以把多个站点发送的数据看作多个向量，这些向量都是两两正交的。发送方和接收方都有相同的、独一无二的码片序列。在信道中多个向量线性相加，在接收端用码片序列和信道中多个向量的和做规格化内积（点乘后取平均值）我们知道正交的向量点乘的结果为0，其他的向量可以忽略掉。只有发送方的向量做规格化内积。结果为 1 则代表 发送1 ，结果为 -1 代表发送0.。</p><p>　　</p><h4 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h4><p>　　当有两个或多个用户同时发送信息时，就会产生帧的冲突。为了解决帧的碰撞，每个用户须按照一定的规则重传它的帧，知道该帧无碰撞地通过。常用的协议有 ALOHA 协议、CSMA 协议、CSMA/CD协议、CSMA/CA协议等，他们的核心思想是：胜利者争用获得信道，从而获得信息的发送权。<strong>随机介质访问控制机制实质上是将一种广播信道转化为点到点信道的行为。</strong></p><h5 id="ALOHA-协议"><a href="#ALOHA-协议" class="headerlink" title="ALOHA 协议"></a>ALOHA 协议</h5><p>　　a. 纯 ALOHA 协议 ：不检测信道状态 直接发送 ，一段时间没收到确认 <strong>等待一段随机的时间</strong>后再发送，直到成功。假设网络负载（T 时间内所有站点发送的所有帧数）为G,纯ALOHA吞吐量（T时间内发送成功的平均帧数）为 S = G<em>e^(-2</em>G) 。当G=0.5时。 S = 0.184</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/SmI1ruGDC2xyXAQ.png" alt="img"></p><p>　　b.时隙 ALOHA 协议 ：把所有各站在时间上同步起来，并将时间划分为一段段等长的时隙，规定只能在每个时隙开始才能发送一个帧。在一个时隙内又两个或以上的帧到达时在下一个时隙产生碰撞碰撞后重传策略与纯 ALOHA 协议相似。网络吞吐量S与网络负载关系是 S = G*e^(-G) 。当G=0.5时。 S = 0.368</p><h5 id="CSMA-协议（Carrier-Sense-Multiple-Access，载波监听多路访问）"><a href="#CSMA-协议（Carrier-Sense-Multiple-Access，载波监听多路访问）" class="headerlink" title="CSMA 协议（Carrier Sense Multiple Access，载波监听多路访问）"></a>CSMA 协议（Carrier Sense Multiple Access，载波监听多路访问）</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/GN7rqSDIsl9ecpw.png" alt="img"></p><h5 id="CSMA-CD-协议-（Carrier-Sense-Multiple-Access-with-Collision-Detection，-载波监听多路访问-碰撞检测）有线局域网–以太网"><a href="#CSMA-CD-协议-（Carrier-Sense-Multiple-Access-with-Collision-Detection，-载波监听多路访问-碰撞检测）有线局域网–以太网" class="headerlink" title="CSMA/CD 协议 （Carrier Sense Multiple Access with Collision Detection， 载波监听多路访问/碰撞检测）有线局域网–以太网"></a>CSMA/CD 协议 （Carrier Sense Multiple Access with Collision Detection， 载波监听多路访问/碰撞检测）<strong>有线局域网–以太网</strong></h5><p>　　CSMA/CD 是 CDMA 的改进，CSMA/CD 适用于总线型网络或半双工网络。“载波监听”指发送前前检测总线上是否有其他站点在发送数据，若有则暂时不发送数据，等待信道变为空闲再发送。”碰撞检测“ 就是边发送边监听，即适配器边发送边监听信道上信号电压的变化情况，判断是否有其他站点是否也在发送数据。</p><p>　　<strong>CSMA/CD 的工作流程可概括为 “先听后发，边听边发，冲突停发，随机重发”。</strong></p><p>　　采用CSMA/CD 协议的以太网不可能进行全双工通信，只能进行半双工通信。</p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/CvOhY84VSxdtLwj.png" alt="img"></p><p> 　为了确保发送站在发送数据的同时能检测到可能存在的冲突，需要在发送完帧之前就能收到自己发送出去的数据，<strong>帧的传输时延至少要两倍于信号在总线中的传播时延</strong>，所以CSMA/CD 总线网中所有数据帧必须要大于一个最小帧长。<strong>最小帧长 = 总线传播时延*数据传输率*2。以太网最小帧长64B 最大帧长1500B。</strong></p><p>　　</p><p>　　二进制退避算法：确定基本退避时间，一般取两倍的总线端到端传播时延 2r 。定义参数 k ，它等于重传次数 <strong>k=min(重传次数，10)</strong>。从离散的整数集合 0 ~ 2^k -1 中随机取出一个数n，重传所需要退避的时间就是n倍的基本退避时间 2nr。当重传16次仍不成功抛弃此帧，向上层报告。</p><h5 id="CSMA-CA-协议-（Carrier-Sense-Multiple-Access-with-Collision-Avoidence）无线局域网"><a href="#CSMA-CA-协议-（Carrier-Sense-Multiple-Access-with-Collision-Avoidence）无线局域网" class="headerlink" title="CSMA/CA 协议 （Carrier Sense Multiple Access with Collision Avoidence）无线局域网"></a>CSMA/CA 协议 （Carrier Sense Multiple Access with Collision Avoidence）无线局域网</h5><p>　　无线局域网环境下，不能简单地搬用CSMA/CD 协议，特别是碰撞检测部分。主要有两个原因 a.接收信号的强度会远小于发送信号地强度，无线介质上信号强度的动态变化范围很大，若要实现碰撞检测，硬件上的花费就会过大。b.在无线通信中，并非所有站点都能听见对方，即存在“隐蔽站”问题。　　</p><p>　　CSMA/CA 采用二进制指数退避算法。任何一个站要发送数据帧时，不仅要等待一个时间间隔，还要进入争用窗口，并计算随机退避时间以便再次试图接入信道。</p><p>　　CSMA/CA 还使用预约信道、ACK帧、RTS/CTS 帧等三种机制来实现碰撞避免：</p><p>　　预约信道：发送方在发送数据的同时向其他站点通知自己传输数据需要的时间长度，以便让其他站点在这段时间内不会发送数据，从而避免碰撞。</p><p>　　ACK帧：所有站点在正确接收到发给自己的帧（除广播帧和组播帧）后，都需要向发送方发回一个ACK帧。</p><p>　　RTS/CTS 帧：可选的碰撞避免机制，主要解决无线网中的 “屏蔽站”问题。</p><p>　　CSMA/CD 与 CSMA/CA 区别：</p><p>　　CSMA/CD 可以检测冲突但无法避免；CSMA/CA 发送包的同时不能检测信道上有无冲突，只能尽量避免。</p><p>　　CSMA/CD 用于总线形以太网， CSMA/CA用于无线局域网 802.11 a/b/g/n等。</p><p>　　CSMA/CD 通过电缆中的电压变化来检测；CSMA/CA 采用能能量检测、载波检测、和能量载波混合检测三种检测信道空闲的方式。</p><p>　　总结：CSMA/CA 在发送数据前广播告知其他结点，让其他结点不要发送数据。CSMA/CD 发送前侦听，边发送边侦听，一旦出现碰撞停止发送。</p><p>　　</p><h4 id="轮询访问介质访问控制：令牌传递协议"><a href="#轮询访问介质访问控制：令牌传递协议" class="headerlink" title="轮询访问介质访问控制：令牌传递协议"></a>轮询访问介质访问控制：令牌传递协议</h4><p>　　在轮询访问中，用户不能随机地发送消息，而是要通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道的分配。典型的轮询访问介质访问控制协议是令牌传递协议，主要用在令牌环局域网中。当环上一个站希望传送帧时，必须等待令牌。一旦收到令牌，站点便可启动发送帧。帧在环上传送时，不管该帧是否是发给本站点的，所有站点都进行转发，直到该帧回到它的始发站，并<strong>由始发站撤销该帧</strong>。帧的目的站除转发帧外，应针对该帧维持一个副本。当计算机都不需要发送数据时，<strong>令牌在环形网上游荡</strong>。数据链路层研究的是<strong>点到点</strong>之间的通信。</p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><h4 id="局域网的基本概念和体系结构"><a href="#局域网的基本概念和体系结构" class="headerlink" title="局域网的基本概念和体系结构"></a>局域网的基本概念和体系结构</h4><p>　　局域网（LAN）是指在一个较小的物理范围内，将各种设备通过双绞线等连接介质互相连接起来组成资源和信息共享的计算机互联网络。</p><p>　　局域网的特性主要由三个要素决定：拓扑结构、传输介质、介质访问控制方式，最重要的是介质访问控制方式，决定局域网的技术特性。</p><p>　　常见的局域网拓扑结构：星形、环形、总线形和星形总线形复合型结构。</p><p>　　局域网的介质访问控制方式有 CSMA/CD、令牌总线和令牌环，其中前两种方法主要用于总线形局域网，令牌环主要用于环形局域网。</p><p>　　三种特殊的局域网拓扑实现如下：</p><p>　　以太网：逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构。</p><p>　　令牌环：逻辑拓扑是环形结构，物理拓扑是星形结构。</p><p>　　FDDI（光纤分布数字接口）：逻辑拓扑是环形结构，物理拓扑是双环结构。</p><p>　　<strong>IEEE 802标准定义的局域网参考模型只对应于OSI参考模型的数据链路层和物理层，将数据链路层拆分成两个子层：逻辑链路控制（LLC）子层和媒体接入控制（MAC）子层。与接入传输媒体有关的内容都放在MAC子层，主要功能包括：组帧和拆帧、比特传输差错检测、透明传输。LLC子层与传输媒体无关，它向网络层提供无确认无连接、面向连接、带确认无连接、告诉传送4种不同的连接服务类型。</strong></p><h4 id="以太网与IEEE-802-3"><a href="#以太网与IEEE-802-3" class="headerlink" title="以太网与IEEE 802.3"></a>以太网与IEEE 802.3</h4><h5 id="以太网的传输介质与网卡"><a href="#以太网的传输介质与网卡" class="headerlink" title="以太网的传输介质与网卡"></a>以太网的传输介质与网卡</h5><p>　　IEEE 802.3 标准是一种基带总线形的局域网标准。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/L8FeJPwOCcDUB4x.png" alt="img"></p><p> 　网卡工作在数据链路层和物理层。出厂时自带MAC地址。</p><h5 id="以太网的MAC帧"><a href="#以太网的MAC帧" class="headerlink" title="以太网的MAC帧"></a>以太网的MAC帧</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/FWhknbH3deVaCMv.png" alt="img"></p><p> 　由于总线上使用的是广播通信，因此网卡从网络上每收到一个MAC帧，首先用硬件检查MAC帧中的MAC地址，如果是发往本站的帧就留下否则丢弃。</p><p>　　以太网帧结构：</p><p>　　前导码：使接收端与发送端时钟同步。第一个字段7B，是前同步码，用来快速实现MAC帧的比特同步。第二个字段是帧开始定界符，1B。</p><p>　　注意：MAC帧并不需要帧结束符，在以太网传输帧时，各帧之间必须有一定的间隙。但不要误以为以太网帧不需要尾部，<strong>在数据链路层上帧既要加首部又要加尾部。</strong></p><p>　　地址：通常使用MAC地址，6B。</p><p>　　类型：2B，指出数据域中携带的数据应交给哪个协议实体处理。</p><p>　　数据：46~1500B，包含高层的协议信息。由于CSMA/CD 限制，以太网帧必须满足最小长度64B</p><p>　　校验码（FCS）：4B，采用32位循环冗余校验码（CRC），<strong>不但需要校验MAC帧的数据部分还要校验目的地址、源地址和类型字段，但不校验前导码</strong>。</p><h5 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h5><p>　　a. 100BASE-T 以太网：100Mb/s 星形拓扑结构以太网，半双工使用 CSMA/CD，全双工不使用CSMA/CD。</p><p>　　b. 吉比特以太网：1Gb/s 半双工使用 CSMA/CD，全双工不使用CSMA/CD。</p><p>　　c.10吉比特网：10Gb/s 只使用光纤作为传输媒体，只工作在全双工方式，没有争用问题，不使用CSMA/CD。</p><p>　　</p><h4 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h4><p>　　IEEE 802.11 是无线局域网的一系列协议标准，包括 802.11a 和802.11b等。它们制定了MAC 层协议，运行在多个物理层标准上。</p><p>　　802.11 的MAC 层采用CSMA/CA 协议进行介质访问控制。</p><p>　　无线局域网可分为两大类：固定基础设施无线局域网和无固定基础设施无线局域网自组织网络。</p><p>　　a. 有固定基础设施无线局域网：802.11标准规定无线局域网的最小构件是基本服务集（BSS）。一个基本服务集包括一个基站和若干移动站。BSS内可直接通信，与BSS外的站点通信时要通过本BSS的基站。基本服务集中的基站也称接入点，其作用和网桥相似。</p><p>　　b. 无固定基础设施无线局域网自组织网络</p><p>　　自组织网络没有上述基本服务集的接入点，而是由一些平等状态移动站相互通信组成的临时网络。各站点之间地位平等，中间结点都为转发结点，这些结点都具有路由器功能。</p><h4 id="令牌环网的基本原理"><a href="#令牌环网的基本原理" class="headerlink" title="令牌环网的基本原理"></a>令牌环网的基本原理</h4><p>　　令牌环网的每一站通过电缆与环接口干线耦合器（TCU）相连。TCU 的主要作用是，传递所有经过的帧，为接入站发送和接收数据提供接口。TCU 的状态有收听和发送状态。在令牌环网中有一个令牌沿着环形总线在入网结点计算机间依次传递，令牌实际上是一个特殊格式的MAC控制帧，它本身不包含信息，仅控制信道的使用，确保在同一时刻只有一个结点能够独占信道。</p><p>　　令牌环网物理上采用星形拓扑结构，逻辑上仍是环形拓扑结构。</p><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><h4 id="广域网基本概念"><a href="#广域网基本概念" class="headerlink" title="广域网基本概念"></a>广域网基本概念</h4><p>　　广域网通常指覆盖范围很广的长距离网络。广域网是因特网的核心部分，其任务是长距离运送主机所发送的数据。</p><p>　　广域网由一些结点交换机几连接这些交换机的链路组成。结点交换机的功能是将分组存储并转发。局域网使用的协议主要在数据链路层，而广域网使用的协议主要在网络层。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/lshEwS5eZCVgQk7.png" alt="img"></p><p> 　广域网一个重要问题是路由选择和分组转发。路由选择协议负责搜索分组从某个结点到目的结点的最佳传输路由，以便构造路由表，然后从路由表再构造出转发分组的转发表。分组通过转发表转发。PPP 协议和HDLC 协议是目前最常用的两种广域网数据链路层控制协议。</p><h4 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h4><p>　　PPP（Point-to-Point Protocol）是使用串行线路<strong>面向字节</strong>的协议，该协议应用再直接连接两个结点的链路上。设计的目的只要是用来通过拨号或专线方式建立点对点发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共同解决方案。</p><p>　　PPP协议有三个组成部分</p><p>　　1）链路控制协议（LCP）。一种扩展链路控制协议，用于建立、配置、测试和管理数据链路。</p><p>　　2）网络控制协议（NCP）。PPP协议采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</p><p>　　3）一个将IP数据报封装到串行链路的方法。IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传输单元（MTU）的限制。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/1b9RQXWtLTOj3Hn.png" alt="img"></p><p> 　标志字段F 仍为01111110 前后各占1B若它出现在信息字段中，必须做字节填充，使用的控制转义字符为 7D 。在PPP中，地址字段A占1B，规定为0xFF，控制字段C占1B，规定为0x03，两者的内容始终不变。<strong>PPP是面向字符的</strong>，因而所有PPP帧的长度都是整数个字节。协议字段占2B，说明信息段中运载的是什么种类的分组，以比特0开始的是诸如IP、IPX这样的网络层协议；以比特1开始的用来协商其他协议。信息段长度是可变的，大于等于0且小于等于1500B。FCS 检验地址字段、控制字段、协议字段和信息字段。</p><p>　　<strong>PPP提供差错检测但不提供纠错功能，只保证无差错接收。是不可靠的传输协议，也不使用序号和确认机制。仅支持点对点的链路通信。PPP只支持全双工链路。PPP的两端可以运行不同的网络协议。</strong></p><h4 id="HDLC-协议"><a href="#HDLC-协议" class="headerlink" title="HDLC 协议"></a>HDLC 协议</h4><p>　　高级数据链路控制（High-level Data Link Control）协议是ISO 制定的<strong>面向比特</strong>的数据链路层协议。</p><p>　　1）站。HDLC 有3种站类型：主站、从站和复合站。主站负责控制链路的操作，主站发出的帧成为<strong>命令帧</strong>。从站受控于主站，按主站的命令进行操作，发出的帧称为<strong>响应帧</strong>。有些站既有主站的功能又有从站的功能，称为复合站，可以发出两种帧。</p><p>　　2）数据操作方式</p><p>　　a. 正常相应方式。非平衡结构操作方式。主站向从站传输数据，从站响应传输，从站只有收到主站的许可后，才可进行响应。</p><p>　　b. 异步平衡方式。平衡结构操作方式。每个复合站都可以进行对另一站的数据传输。</p><p>　　c. 异步响应方式。非平衡结构操作方式。从站即使未收到主站的允许也可以传输。</p><p>　　3）HDLC 帧</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/4gb1UdZuOLzao5e.png" alt="img"></p><p> 　标志段F：8 bit，01111110。采用比特填充的首尾标志法实现透明传输。地址字段A：8 bit 使用非平衡方式传送数据时，站地址写入从站的地址，使用平衡方式传送数据时，站地址写入应答站的地址。控制字段C：根据其第一位或第一第二位的取值可以将HDLC 帧分为三类：</p><p>　　1）信息帧，第一位为0，用来传输数据信息，或使用捎带技术对数据进行确认。</p><p>　　2）监督帧，第一二位为10，用于流量控制和差错控制，执行对信息帧的确认、请求重发和请求暂停发送等功能。　</p><p>　　3）无编号帧，低一二位为11，用于提供对链路的建立、拆除等多种控制功能。</p><p>　　 <strong>PPP与HDLC区别：</strong></p><p>　　1）PPP面向字节，HDLC 面向比特</p><p>　　2）PPP帧比HDLC帧多一个2B的协议字段，当协议字段为0x0021时，表示信息字段是IP数据报。</p><p>　　3）PPP不使用序号和确认机制，只保证无差错接收，端到端差错检测由高层负责。HDLC信息帧使用了编号和确认机制，能够提供可靠传输。</p><h3 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h3><h4 id="网桥的概念及其基本原理"><a href="#网桥的概念及其基本原理" class="headerlink" title="网桥的概念及其基本原理"></a>网桥的概念及其基本原理</h4><p>　　两个或多个以太网通过网桥连接后，就成为一个覆盖范围更大的以太网，原来的以太网称为一个网段。网桥工作在链路层的MAC子层，可以使以以太网各网段成为隔离开的碰撞域。网桥处理数据是帧它工作在数据链路层，中继器放大器处理的对象是信号，它工作在物理层。</p><p>　　网桥的基本特点：</p><p>　　1）具备寻址和路径选择的能力，以确定帧的传输方向</p><p>　　2）从源网络接收帧，以目的网络的介质访问控制协议向目的网络转发该帧</p><p>　　3）网桥在不同或相同类型的LAN之间存储并转发帧，必要时还进行链路层上的协议转换。</p><p>　　4）网桥对接收到的帧不做任何修改，或只对帧的封装格式做很少的修改。</p><p>　　5）网桥可以通过帧翻译互联不同类型的局域网，即把原协议的信息段内容作为另一种协议的信息部分封装在帧中。</p><p>　　6）网桥应有足够大的缓冲空间。</p><p>　　网桥的优点：</p><p>　　1）能过滤通信量；2）扩大了物理范围；3）可使用不同的物理层；4）可互联不同类型的局域网；5）提高了可靠性；6）性能得到改善</p><p>　　网桥的缺点：</p><p>　　1）增大了时延；2）MAC子层没有流量控制功能（流量控制在LLC子层）；3）不同MAC子层的网桥接在一起时，需要进行帧格式的转换；4）网桥只适合用户数不多和通信量不大的局域网，否则广播信息太多引起广播风暴。</p><p>　　网桥必须具有路径选择的功能，接收到帧后要决定正确的路径，将该帧转送到响应的目的局域网站点。根据路径算法的不同，可将网桥分为透明网桥和源路由网桥。</p><p>　　1.透明网桥（选择的不是最佳路由）</p><p>　　接收与之连接的所有LAN传送的每一帧，到达帧的路由选择取决于源LAN 和目的LAN 。1）如果源LAN和目的LAN相同则丢弃；2）如果源LAN和目的LAN不同则转发此帧；3）如果目的LAN未知，那么扩散此帧。（网桥自学习算法）</p><p>　　2.源路由网桥（选择的是最佳路由）</p><p>　　路由选择由发送数据帧的源站负责，网桥只根据真正的路由信息对帧进行接收和转发。为了找到最佳的路由，源站以广播方式向目的站发送一个发现帧作为探测用。目的站也将一一发送应答帧；每个应答帧将通过原路径返回，途径的网桥把自己的标志记录在应答帧中；源站选出最佳路由。</p><p>　　3.两种网桥的比较</p><p>　　使用源路由网桥可以利用最佳路由，若两个以太网之间使用并联的路由器还可以是通信量较平均的分配给每个网桥。采用透明网桥时，只能使用生成树，而生成树并不能保证所有路由是最佳的，也不能在不同的链路中进行负载均衡。</p><p>　　透明网桥和源路由网桥中提到的最佳路由并不是经过路由器最少的路由，而是可以发送帧往返时间最短的路由。</p><h4 id="局域网交换机及其工作原理"><a href="#局域网交换机及其工作原理" class="headerlink" title="局域网交换机及其工作原理"></a>局域网交换机及其工作原理</h4><h5 id="局域网交换机"><a href="#局域网交换机" class="headerlink" title="局域网交换机"></a>局域网交换机</h5><p>　　以太网交换机是一个多端口的网桥，它工作在数据链路层。交换机能将网络分成更小的冲突域，为每个工作站提供更高的带宽。利用交换机还可以实现虚拟局域网（VLAN）不仅可以隔离冲突域还能隔离广播域。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>　　以太网交换机的原理是，检测以太端口来的数据帧的源和目的地的MAC地址，然后与系统内部的动态查找表进行比较，若数据帧的MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给响应的目的端口。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>　　a.交换机的每个端口都直接与单台主机相连，工作在全双工方式。</p><p>　　b.以太网交换机能同时连通许多对端口，使每对相互通信的主机都能像独占通信媒体那样无碰撞地传输数据。</p><p>　　c.即插即用。</p><p>　　d.交换速率高。</p><p>　　e.独占传输媒体地带宽</p><h5 id="两种交换方式"><a href="#两种交换方式" class="headerlink" title="两种交换方式"></a>两种交换方式</h5><p>　　a.直通式交换机只检查帧地目的地址，帧在接收后几乎马上就能被传出去。</p><p>　　b.存储转法式交换机先将接收到地帧缓存到高速缓冲器中，检查并转发。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/I3H5PKNcn1RFGxh.png" alt="img"></p><h3 id="本章小结及疑难点-2"><a href="#本章小结及疑难点-2" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="“链路”-和-“数据链路”-有何区别？"><a href="#“链路”-和-“数据链路”-有何区别？" class="headerlink" title="“链路” 和 “数据链路” 有何区别？"></a>“链路” 和 “数据链路” 有何区别？</h4><p>​        链路指从一个结点到相邻结点的一段物理线路，其中间没有任何其他任何的交换结点。在进行数据通信时，两台计算机之间的通信路径往往要通过许多段这样的链路。</p><p>​        数据链路则是另一个概念，要在一条线路上传送数据，除了必须要有一条物理线路外，还必须有一些通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p><h4 id="为什么-PPP-协议不使用帧的编号和确认机制来实现可靠传输？"><a href="#为什么-PPP-协议不使用帧的编号和确认机制来实现可靠传输？" class="headerlink" title="为什么 PPP 协议不使用帧的编号和确认机制来实现可靠传输？"></a>为什么 PPP 协议不使用帧的编号和确认机制来实现可靠传输？</h4><p>​        PPP 不使用序号和确认机制出于以下考虑：</p><p>​        若使用能够实现可靠传输的数据链路层协议（如 HDLC ），开销就会增大。当数据链路层出现差错的概率不大时，使用简单的 PPP 较为合理。</p><p>​        在因特网环境下， PPP 的信息字段放入的数据是 IP 数据报。假定数据链路层实现了非常可靠的传输协议，但在上升到网络层后仍可能由于网络拥塞而被丢弃。数据链路层的可靠传输并不能保证网络层的传输也是可靠的。</p><p>​        PPP 在帧格式中有帧校验序列 FCS 字段。对于每个接收到的帧， PPP 都要使用硬件进行 CRC 校验若发现有差错，则丢弃该帧（只要是上交到上一层的帧都是无差错的）。端到端的差错控制由高层协议负责。</p><h4 id="交换机和网桥的不同之处。"><a href="#交换机和网桥的不同之处。" class="headerlink" title="交换机和网桥的不同之处。"></a>交换机和网桥的不同之处。</h4><p>​        1）网桥的端口一般连接局域网，而交换机的端口一般直接与局域网的主机相连。</p><p>​        2）交换机允许多对计算机同时通信，而网桥仅允许每个网段上的计算机同时通信。</p><p>​        3）网桥采用存储转发方式进行转发，而以太网交换机还可以采用直通方式进行转发，且以太网交换机采用了专用的交换结构芯片，转发速度比网桥快。</p><h4 id="局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？"><a href="#局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？" class="headerlink" title="局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？"></a>局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？</h4><p>​        局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数量有限。局域网的地理范围较小，且为一个单位所拥有，采用广播通信方式十分方便。但广域网的地理范围很大，如果采用广播通信方式势必造成通信资源的极大浪费。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/LtEuor7PDM3xKzb.png" alt="image-20200410134049382"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a><strong>网络层的功能</strong></h3><h4 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h4><p>　　网络互联：将两个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备（中间设备）连接起来。</p><p>　　中继设备分以下四种：</p><p>　　1）物理层中继设备：中继器，集线器。</p><p>　　2）数据链路层中继设备：网桥或交换机。</p><p>　　3）网络层中继设备：路由器。</p><p>　　4）网络层以上的中继设备：网关。</p><p>　　使用物理层的中继设备时，只是把一个网络扩大了，从网络层的角度看仍是同一个网络。网络互联通常指用路由器进行网络互联和路由选择。</p><p>　　TCP/IP 体系在网络互联上采用的做法是在网络层采用标准化协议，相互连接的网络可以是异构的。</p><p>　　</p><h4 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h4><p>　　路由器主要完成两个功能：一是路由选择（确定哪一条路径），二是分组转发（当一个分组到达时采取的动作）。前者是根据特定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断更新和维护路由表。后者处理通过路由器的数据流，关键操作是转发表查询、转发及相关地队列管理和任务调度等。</p><p>　　1）路由选择：按照复杂的分布式算法，根据相邻路由器所得到地关于整个网络拓扑的变化情况，动态地选择路由。</p><p>　　2）分组转发：指路由器按照转发表将用户的 IP 数据报从合适的端口转发出去。</p><p>　　</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>　　因出现过量的分组而引起网络性能下降的现象称为拥塞。拥塞控制的作用是确保子网能够承载所达到的流量。</p><p>　　流量控制：抑制发送端的发送数据速率。</p><p>　　拥塞控制方法：</p><p>​        1）开环控制。在设计网络时事先将有关发生拥塞的因素考虑到。</p><p>​        2）闭环控制。采用检测系统监视。</p><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a><strong>路由算法</strong></h3><h4 id="静态路由与动态路由"><a href="#静态路由与动态路由" class="headerlink" title="静态路由与动态路由"></a>静态路由与动态路由</h4><p>​        静态路由算法（非自适应路由算法）。指由网络管理员手工配置的路由信息。</p><p>​        动态路由算法（自适应路由算法）。路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的。</p><p>　　</p><h4 id="距离-向量路由算法"><a href="#距离-向量路由算法" class="headerlink" title="距离-向量路由算法"></a>距离-向量路由算法</h4><p>　　在距离-向量路由算法中所有结点定期地将它们的整个路由选择表传送给所有与之相连的结点。这种路由表包含：1）每条路径的目的地（另一结点）；2）路径的代价（也称距离）。RIP中将距离定义为跳数–从源端口到目的端口的路由器个数。<strong>“好消息传的快，坏消息传的慢”</strong></p><p>　　</p><h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h4><p>　　链路状态路由算法要求每个参与该算法的结点都具有完全的网络拓扑信息。它们执行下述两项任务：1）主动测试所有邻接结点的状态。2）定期地将链路状态传播给所有其他结点。典型的链路状态算法是OSPF算法。</p><p>　　链路状态路由算法有3个特征：</p><p>　　1）向本自治系统中所有路由器发送信息，治理使用的方法是洪泛法，路由器通过所有端口向所有相邻的路由器发送信息。每个相邻的路由器又将信息发往所有其他的路由器。</p><p>　　2)发送的信息是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。</p><p>　　3）只有当链路状态发生变化时，路由器才向所有路由器发送此消息。</p><h4 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h4><p>　　因特网把路由选择协议分为两大类：</p><p>　　1）一个自治系统内部所使用的路由选择协议称为内部网关协议（IGP），也称域内路由选择，具体的协议有RIP 和OSPF 等。</p><p>　　2）自治系统之间所使用的路由选择协议称为外部网关协议（EGP），也称域间路由选择，用在不同自治系统的路由器之间交换路由信息。具体的协议有BGP。</p><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a><strong>IPv4</strong></h3><h4 id="IPv4分组"><a href="#IPv4分组" class="headerlink" title="IPv4分组"></a>IPv4分组</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/2S4LzoC5UadXEVb.png" alt="img"></p><p> 　一个IP分组由首部和数据两部分组成。首部前一部分长度固定，共20B。</p><p>　　1）版本。占4位。IP版本，目前使用4。</p><p>　　2）首部长度。占4位。<strong>以4B为单位</strong>，最大值为60B（4位最多表示15），最常用20B。</p><p>　　3）总长度。占16位。指首部和数据部分的总长度，<strong>单位为字节</strong>，所以最长65535B。</p><p>　　4）标识。占16位。它是一个计数器，每产生一个数据报就加1，并赋值给标识字段。</p><p>　　5）标志。占3位。X DF MF 共三位。<strong>DF=0表示可以分片。MF=1表示后面还有分片</strong>。</p><p>　　6）片偏移。占13位。它指出较长的分组在分片后，某片在原分组中的相对位置。<strong>以8B为单位</strong>。每个分片的长度一定是8B的整数倍。</p><p>　　7）首部校验和。占16位。只校验分组的首部，不校验数据部分。</p><p>　　8）生存时间（TTL）。占8位。数据段在网络中可通过的路由器的最大值。</p><p>　　9）协议。占8位指出分组携带的数据使用何种协议，6 代表 TCP，17 代表UDP。</p><p>　　10）源地址字段。占4B，标识发送方的IP地址。</p><p>　　11）目的地址字段。占4B，标识接收方的IP地址。</p><p>　　</p><p>　　分片例子：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/ms5cGHWLrvOjZJX.png" alt="img"></p><p> 　网络层转发分组的流程：</p><p>　　1）从首部中取出目的主机的IP地址 D，得出目的网络地址N。</p><p>　　2）若网络N与此路由器直接相连，把数据报直接交付给目的主机D。否则间接交付执行3。</p><p>　　3）若路由表中有目的地址为D的特定主机路由，把数据报传到下一跳路由器。否则执行4。</p><p>　　4）若路由表中有到达网络N的路由器，传给下一跳路由器，否则执行5。</p><p>　　5）若路由表中有一个默认路由，把数据报传给默认路由，否则执行6。</p><p>　　6）报告转发分组出错。</p><p>　　总结：检查接收主机是否与发送主机在同一局域网内–》 检查是否可以通过下一跳路由器直达接收主机 –》 检查是否可以通过下一跳路由器到达另一个路由器（可到达目的主机）–》报错。</p><p>　　注意：得到下一跳路由器IP地址后不是直接将下一跳路由器的IP之间填入IP数据报首部。而是将其封装在帧中，改变帧的接收MAC地址。通过这个MAC地址找到下一跳路由器。<strong>在不同网络中传送时，MAC帧中的源地址和目的地址要发生变化，网桥在转发帧时，不改变帧的源地址。</strong></p><p>　　</p><h4 id="IPv4地址与NAT"><a href="#IPv4地址与NAT" class="headerlink" title="IPv4地址与NAT"></a>IPv4地址与NAT</h4><h5 id="IPv4-地址"><a href="#IPv4-地址" class="headerlink" title="IPv4 地址"></a>IPv4 地址</h5><p>　　连接到因特网上的每台主机或路由器都分配一个32比特的全球唯一标识符，即IP地址。传统的IP地址是分类的地址，分为A，B，C，D，E五类。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/YOFb4qsouhinm6T.png" alt="img"></p><p>　　<strong>IP地址=网络号+主机号</strong></p><p>　　 特殊用途的IP地址：</p><p>　　a.主机号全0表示网络本身。</p><p>　　b.主机号全1表示网络的广播地址。</p><p>　　c. 127.0.0.0 保留为环路自检地址，此地址表示任意主机本身。</p><p>　　d.32位全为0，0.0.0.0表示本网络上的本主机</p><p>　　e.32位全为1 255.255.255.255 表示整个TCP/IP网络的广播地址，又称受限广播地址。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/FZVzXlYEQIjDyxP.png" alt="img"></p><h5 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h5><p>　　网络地址转换（NAT）是指将专用网络地址（如Internet）转换为公用地址（ 如Internet）。它使整个专用网只需一个全球IP地址就可以与因特网连通。工作在传输层。</p><p>　　一个典型NAT 转换表 WAN 138.76.29.7：5001 ；LAN 192.168.0.2：2233。NAT 工作在传输层。</p><p>　　私有IP地址只用于LAN，不用于WAN连接。私有IP网段如下：</p><p>　　A类：1个A类网段，<strong>10</strong>.0.0.0 ~ <strong>10</strong>.255.255.255.255</p><p>　　B类：16个B类网段，<strong>172.16</strong>.0.0 ~ <strong>172.31</strong>.255.255</p><p>　　C类：256个C类网段，<strong>192.168.0</strong>.0~<strong>192.168.255</strong>.255</p><h4 id="子网划分与子网掩码、CIDR"><a href="#子网划分与子网掩码、CIDR" class="headerlink" title="子网划分与子网掩码、CIDR"></a>子网划分与子网掩码、CIDR</h4><h5 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h5><p>　　子网划分纯属一个单位内部的事情，对外仍然表现为没有划分子网的网络。仅仅是把主机号这部分再进行划分。</p><h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>　　子网验码是一个与IP地址相对应的、长32bit的二进制串，由一串1和一串0组成。1对应网络号和子网号，0对应主机号。</p><p>　　</p><p>　　使用子网验码的分组转发如下：</p><p>　　a.从首部中取出目的主机的IP地址 D。</p><p>　　b.对<strong>路由器直接相连的网络</strong>逐个检查，用各网络的子网验码和D逐位做与操作，如果结果等于该网络的网络号，直接交付，否则间接交付执行c。</p><p>　　c.若路由表中有目的地址为D的特定主机路由，把数据报传到下一跳路由器。否则执行d。</p><p>　　d.检查路由表中每一行，如果子网掩码与D的与操作结果与目的网络地址网络号相同则传给下一跳路由器，否则执行e。</p><p>　　e.若路由表中有一个默认路由，把数据报传给默认路由，否则执行f。</p><p>　　f.报告转发分组出错。</p><p>　　总结：检查接收主机是否与发送主机在同一局域网内–》 检查是否可以通过下一跳路由器直达接收主机 –》 检查是否有默认路由–》报错。</p><h5 id="无分类域间路由选择（CIDR）"><a href="#无分类域间路由选择（CIDR）" class="headerlink" title="无分类域间路由选择（CIDR）"></a>无分类域间路由选择（CIDR）</h5><p>　　CIDR使用“网络前缀”的概念代替子网的概念。</p><p>　　<strong>CIDR使用斜线计法 IP地址/网络前缀占用比特数。</strong></p><h4 id="ARP、DHCP与ICMP"><a href="#ARP、DHCP与ICMP" class="headerlink" title="ARP、DHCP与ICMP"></a>ARP、DHCP与ICMP</h4><p>　　1）IP地址与硬件地址</p><p>　　IP地址由于路由器的隔离不能进行广播，这时候就只能通过数据链路层的MAC地址以广播方式寻址。</p><p>　　2）地址解析协议（ARP）</p><p>　　IP到MAC地址的映射，这就是地址解析协议（Address Resolution Protocol，ARP）。</p><p>　　<strong>ARP工作在网络层，先查看ARP缓存，如果没有目的IP对应的MAC地址则使用目的MAC地址为ff-ff-ff-ff-ff-ff的帧来封装并广播ARP请求分组。</strong>目的主机收到该 ARP 请求后向源主机发出 ARP 响应分组。</p><p>　　3）动态主机配置协议（DHCP）</p><p>　　动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）常用于给主机动态地分配IP地址，提供了即插即用地机制，允许一台计算机加入新的网络和获取IP地址。DHCP是<strong>应用层</strong>协议，它是基于UDP的。</p><p>　　4）网际控制报文协议（ICMP）</p><p>　　为了提高IP数据报交付成功的机会，在网络层使用了网际控制报文协议（Internet Control Message Protocol，ICMP）来让主机或路由器报告差错和异常情况。ICMP报文作为IP数据报的数据，加上数据报的首部，组成IP数据报发送出去。</p><p>　　ICMP报文有两种 ICMP差错报文和ICMP询问报文。</p><p>　　ICMP差错报文5种类型：</p><p>　　1）终点不可达。路由器或主机不能交付数据报。</p><p>　　2）源点抑制。路由器或主机由于拥塞丢弃数据报。</p><p>　　3）时间超过。路由器收到TTL=0的数据报。</p><p>　　4）参数问题。路由器或主机收到数据报中首部字段值不正确。</p><p>　　5）改变路由（重定向）。路由器把改变路由报文发送给主机。</p><p>　　不发送ICMP 差错报文的情况：</p><p>　　1）对ICMP 差错报文不发送。</p><p>　　2）对第一个分片的数据报片后续所有数据报片都不发送。</p><p>　　3）对组播地址的数据报不发送。</p><p>　　4)对具有特殊地址的数据报不发送。</p><p>　　</p><p>　　ICMP询问报文有4种类型：回送请求和回答报文、时间戳请求和回答报文、掩码地址请求和回答报文、路由器询问和通告报文。</p><p>　　<strong>ICMP的常见应用是分组间探测PING，PING使用了ICMP会送请求和回答报文。PING工作在应用层，直接使用网络层的ICMP回送请求和回答报文。</strong></p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="IPv6-特点"><a href="#IPv6-特点" class="headerlink" title="IPv6 特点"></a>IPv6 特点</h4><p>　　1）IPv6共128位，2）简化了IP分组头3）更好地支持选项</p><p>　　</p><h4 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h4><p>　　IPv6 数据报的目的地址可以是 单播、多播和组播。</p><p>　　IPv4 向IPv6 过渡可以采用双协议栈和隧道技术两种策略。双协议栈是指在一台设备上同时装有IPv4 和IPv6 协议栈。隧道技术是将整个IPv6数据报封装到IPv4的数据部分。</p><h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><h4 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h4><p>　　自治系统（Automatic System，AS）单一技术管理下的一组路由器。</p><p>　　</p><h4 id="域内路由和域间路由"><a href="#域内路由和域间路由" class="headerlink" title="域内路由和域间路由"></a>域内路由和域间路由</h4><p>　　1）内部网关协议（Internal Gateway Protocol，IGP）：在一个自治系统内部使用的路由选择协议。如 RIP、OSPF。</p><p>　　2） 外部网关协议（External Gateway Protocol，EGP）：自治系统之间的路由选择协议。如BGP-4。</p><p>　　</p><h4 id="路由信息协议（RIP）"><a href="#路由信息协议（RIP）" class="headerlink" title="路由信息协议（RIP）"></a>路由信息协议（RIP）</h4><p>　　网络中的每个路由器维护从它自身到每个目的网络的距离记录。RIP距离最大为15，超过15代表不可达。RIP默认在任意两个使用RIP的路由器之间每30秒广播一次RIP路由更新信息，以便自动建立并维护路由表。RIP中每个网络的子网掩码必须相同。</p><p>　　RIP 的特点：</p><p>　　1）仅和相邻路由器交换信息。</p><p>　　2）路由器交换的信息是当前路由器所知道的全部信息，即自己的额路由表。</p><p>　　3）按固定的时间间隔交换路由器信息，如每隔30秒。</p><p>　　</p><p>　　距离向量算法：</p><p>　　每个路由表都有三个关键数据：&lt;目的网络N，距离d，下一跳路由器X&gt;</p><p>　　1）对每个相邻路由器中发过来的RIP报文，先修改所有的项目，把“下一跳”字段中的地址都改为 X，并把所有“距离”字段加1。</p><p>　　2）对修改后的RIP报文中的每个项目，执行如下步骤。</p><p>　　a.当原来的路由表中没有目的网络N时，把该项目添加到路由表中。</p><p>　　b.当原来的路由表中有目的网络N，且下一跳路由器地址是X时，用收到的项目替换原路由表中的项目。</p><p>　　c.当原来的路由表中有目的网络N，且下一跳地址不是X时，选择距离较小的更新。</p><p>　　3）如果180 秒（RIP 默认超时时间为 180秒）还没有收到相邻路由器的更新路由器，那么把此相邻路由器记为不可达路由器。</p><p>　　</p><p>　　RIP最大优点是实现简单、开销小、收敛过程较快。</p><p>　　RIP缺点如下：</p><p>　　a.限制了网络的规模</p><p>　　b.路由器之间交换的是路由器中的完整路由表因此网络规模越大，开销也越大。</p><p>　　c.网络出现故障时，会出现慢收敛现象（需要较长时间才能将此信息传到所有路由器）俗称坏消息传的慢。</p><p>　　</p><h4 id="开放最短路径优先（OSPF）协议"><a href="#开放最短路径优先（OSPF）协议" class="headerlink" title="开放最短路径优先（OSPF）协议"></a>开放最短路径优先（OSPF）协议</h4><h5 id="OSPF-和-RIP-的区别。"><a href="#OSPF-和-RIP-的区别。" class="headerlink" title="OSPF 和 RIP 的区别。"></a>OSPF 和 RIP 的区别。</h5><p>　　a.OSPF 向本自治系统中的所有路由器发送信息，使用的是洪泛法。RIP仅向临近的路由器发送信息。</p><p>　　b.发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是部分信息。RIP发送整个路由表。</p><p>　　c.只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p><p>　　d.OSPF是网络层协议，它不使用UDP或TCP，而直接使用IP数据报传送（其IP数据报首部协议字段为89）.RIP是应用层协议，它在传输层使用UDP。</p><h5 id="OSPF-基本工作原理"><a href="#OSPF-基本工作原理" class="headerlink" title="OSPF 基本工作原理"></a>OSPF 基本工作原理</h5><p>　　各个路由器之间频繁地交换链路状态信息，所有路由器最终都能建立一个链路状态数据库。这个数据库就是全网的拓扑结构，它在全网范围内是一致的。每个路由器根据这个全网拓扑结构图，使用Dijkstra 最短路径算法计算从自己到各目的网络的最优路径，以此构造自己的路由表。当链路状态更新时需要重新计算。</p><p>　　注意：虽然使用Dijkstra算法能计算出完整的最优路径，但路由表中不会存储完整的路径，而只存储“下一跳”（只有到了下一跳路由器才能再知道下一跳怎样走）。</p><p>　　</p><p>　　OSPF 的五种分组类型：</p><p>　　a.问候分组，用来维持临站的可达性。</p><p>　　b.数据库描述分组，向临站给出自己的链路状态数据库中所有链路状态的摘要信息。</p><p>　　c.链路状态请求分组，向对方请求发送某些链路状态项目的详细信息。</p><p>　　d.链路状态更新分组，用洪泛法对全网更新链路状态。</p><p>　　e.链路状态确认分组，对链路更新分组的确认。</p><p>　　通常每隔10秒，每两个相邻路由器都要交换一次问候分组，以便知道哪些站可达。OSPF 还归档每隔一段时间就刷新数据库中的链路状态。</p><p>　　</p><h4 id="边界网关协议（BGP）"><a href="#边界网关协议（BGP）" class="headerlink" title="边界网关协议（BGP）"></a>边界网关协议（BGP）</h4><p>　　边界网关协议（Border Gateway Protocol，BGP）是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议。只能尽力寻找一条能够到达目的网络且比较好的路由，而非寻找一条最佳路由。<strong>BGP 是应用层协议，它是基于TCP的。</strong></p><p>　　BGP的工作原理如下：每个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP”发言人。一个BGP发言人要与其他自治系统中的BGP发言人交换路由信息，就要先建立TCP连接。在此连接上交换BGP报文以建立BGP会话，在利用BGP会话交换路由信息。</p><p>　　BGP特点：1）BGP 交换路由信息的结点数量级是自治系统的数量级。2）每个自治系统中的BGP发言人数目是很少的。</p><p>　　BGP共使用4种报文：</p><p>　　1）打开报文。用来与相邻的另一个BGP发言人建立关系。</p><p>　　2）更新报文。用来发送某一路由的信息，以及要撤销的多条路由。</p><p>　　3）保活报文。用来确认打开报文并周期性地证实临站关系。</p><p>　　4）通知报文。用来发送检测到地差错。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/orCBvgIw8smXcWj.png" alt="img"></p><h3 id="IP-组播"><a href="#IP-组播" class="headerlink" title="IP 组播"></a><strong>IP 组播</strong></h3><h4 id="组播的概念"><a href="#组播的概念" class="headerlink" title="组播的概念"></a>组播的概念</h4><p>　　人们所需要的组播机制是让源计算机一次发送的单个分组可以抵达用一个组标识的若干目标主机，并被它们正确接收。</p><p>　　组播一定仅应用于UDP。主机使用一个称为IGMP（因特网组管理协议）的协议加入组播组。主机在组播时仅发送一份数据，只有数据在传送路径出现分岔时才将分组复制后继续转发。组播需要路由器的支持。</p><h4 id="IP-组播地址"><a href="#IP-组播地址" class="headerlink" title="IP 组播地址"></a>IP 组播地址</h4><p>　　IP 组播使用 D类地址格式。D类地址前四位是1110，因此D类地址范围是 224.0.0.0 ~ 239.255.255.255.每个D类地址标志一个组播组。</p><p>　　组播数据报与一般IP数据报的区别是，前者使用D类IP 地址作为目的地址，并且首部中的协议字段值是2，表明使用IGMP。需要注意的是：</p><p>　　1）组播数据报也是“尽最大努力交付”，不提供可靠交付。</p><p>　　2）组播地址只能用于目的地址，而不能用于源地址。</p><p>　　3）对组播数据报不产生ICMP差错报文。</p><p>　　4）并非所有D类地址都可以作为组播地址。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/ev5FiWZCnjNrbsV.png" alt="img"></p><h4 id="IGMP-与组播路由算法"><a href="#IGMP-与组播路由算法" class="headerlink" title="IGMP 与组播路由算法"></a>IGMP 与组播路由算法</h4><p>　　IGMP 应视为 TCP/IP 的一部分，其工作可分为两个阶段：</p><p>　　1）当某台主机加入新的组播组时，该主机应向组播组地址发送一个IGMP 报文，声明自己要称为该组的成员。</p><p>　　2）本地组播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否仍继续时组的成员。</p><p>　　</p><h3 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a><strong>移动IP</strong></h3><h4 id="移动-IP-的概念"><a href="#移动-IP-的概念" class="headerlink" title="移动 IP 的概念"></a>移动 IP 的概念</h4><p>　　支持移动性的因特网体系结构与协议共称移动IP。它是为了满足移动结点在移动中保持其连接性而设计的。</p><p>　　基于IPv4 的移动IP定义三种功能实体：移动结点、本地代理和外部代理。本地代理和外部代理又称为移动代理。</p><p>　　1）移动结点。具有永久IP地址的移动结点。</p><p>　　2）本地代理。在一个网络环境中，一个移动结点的永久“居所”被称为归属网络，在归属网络中代表移动结点执行移动管理功能的实体称为本地代理。</p><p>　　3）外部代理。在外部网络中帮助移动结点完成移动管理功能的实体称为外部代理。</p><h4 id="移动IP通信过程"><a href="#移动IP通信过程" class="headerlink" title="移动IP通信过程"></a>移动IP通信过程</h4><p>　　移动IP为移动主机设置了两个IP地址，即主地址和辅地址。移动主机在本地网时，使用的是主地址。当移动到另一个网络时，需要获得一个临时的辅地址，但此时主地址仍不变，从外网移回本地网时，辅地址改变或撤销，主地址仍然保持不变。</p><h3 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h3><h4 id="路由器的组成和功能"><a href="#路由器的组成和功能" class="headerlink" title="路由器的组成和功能"></a>路由器的组成和功能</h4><p>　　路由器是一种具有多个输入/输出端口的专用计算机，其任务是连接异构网络并完成路由转发，在多个逻辑网络互联时必须使用路由器。如果源主机和目的主机在同一个网络上，那么直接交付而无需通过路由器。如果源主机和目的网络不在同一各网络上，路由器按照转发表指出的路由将数据报转发给下一个路由器，称为间接交付。</p><p>　　路由器由路由选择和分组转发两部分构成。路由器是网络层设备，它实现了网络模型的下三层。如果一个存储转发设备实现了某个层次的功能，那么它就可以互联两个在该层次上使用不同协议的网段。例如网桥实现了物理层和数据链路，网桥就可以互联两个物理层和数据链路层不同的网段。</p><p>　　路由选择部分也称控制部分，其核心构件是路由选择处理机。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/EBMz9khK71uWvjy.png" alt="img"></p><h4 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/SQFZdbVO8KBNiDj.png" alt="img"></p><h3 id="本章小结及疑难点-3"><a href="#本章小结及疑难点-3" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="“尽最大努力交付”有哪些含义？"><a href="#“尽最大努力交付”有哪些含义？" class="headerlink" title="“尽最大努力交付”有哪些含义？"></a>“尽最大努力交付”有哪些含义？</h4><p>​    1）不保证源主机发送的 IP 数据报一定无差错地交付到目的主机。</p><p>​    2）不保证源主机发送的 IP 数据报都在某一规定 的时间内交付到目的主机。</p><p>​    3）不保证源主机发送的 IP 数据报一定按发送时的顺序交付到目的主机。</p><p>​    4）不保证源主机发送的 IP 数据报不会重复交付给目的主机。</p><p>​    5）不故意丢弃 IP 数据报。丢弃 IP 数据报的情况是：<strong>路由器检测出首部校验和有错误；或由于网络中通信量过大，路由器或目的主机中的缓存已无存储空间。</strong></p><p><strong>交付目的主机的 IP 数据报都是 IP 数据报的首部没有出现差错或没有检测出来有差错的。</strong></p><p>​    总结：尽最大努力交付不保证 IP 数据报：无差错、准时到达、按序到达、不会重复交付。丢弃数据报的情况：缓存满。</p><h4 id="在互联网中，能否使用一个很大的交换机来代替全部的路由器？"><a href="#在互联网中，能否使用一个很大的交换机来代替全部的路由器？" class="headerlink" title="在互联网中，能否使用一个很大的交换机来代替全部的路由器？"></a>在互联网中，能否使用一个很大的交换机来代替全部的路由器？</h4><p>​        不行。交换机和路由器的功能是很不一样的。交换机和在一个单个的网络中和若干个计算机相连，并且可以将一个计算机发送过来的帧转发给另一个计算机。从这点上看，交换机具有集线器的转发帧的功能。但交换机比集线器的功能强很多。集线器在同一时间只允许一个计算机和其他计算机进行通信，但交换机允许多个计算机同时进行通信。</p><p>​        路由器连接两个或几个网络，路由器可在网络之间转发分组（即 IP 数据报）。这些互联的网络是异构的。如果存在异构网络互联，使用交换机是不行的。</p><h4 id="当运行-PING-127-0-0-1-时，这个-IP-数据报将发给谁？"><a href="#当运行-PING-127-0-0-1-时，这个-IP-数据报将发给谁？" class="headerlink" title="当运行 PING 127.0.0.1 时，这个 IP 数据报将发给谁？"></a>当运行 PING 127.0.0.1 时，这个 IP 数据报将发给谁？</h4><p>​        127.0.0.1 是环回地址。主机将测试用的 IP 数据报发给本主机的 ICMP（而不是发送到互联网上）以便进行环回测试。</p><h4 id="全-1-的-IP-地址是否是向整个互联网进行广播的一种地址？"><a href="#全-1-的-IP-地址是否是向整个互联网进行广播的一种地址？" class="headerlink" title="全 1 的 IP 地址是否是向整个互联网进行广播的一种地址？"></a>全 1 的 IP 地址是否是向整个互联网进行广播的一种地址？</h4><p>​        不是。在 IP 地址中的全 1 地址表示仅在本网络上（发送这个 IP 数据报的主机所连局域网）进行广播。这种广播叫做受限的广播。如果网络号是具体的网络号，主机号全 1 叫做定向广播，这是对某一个具体的网络（网络号指明的网络）上的所有主机进行广播的一种地址。</p><h4 id="IP-协议有分片的功能，但广域网中的分组则不必分片。这是为什么？"><a href="#IP-协议有分片的功能，但广域网中的分组则不必分片。这是为什么？" class="headerlink" title="IP 协议有分片的功能，但广域网中的分组则不必分片。这是为什么？"></a>IP 协议有分片的功能，但广域网中的分组则不必分片。这是为什么？</h4><p>​        IP 数据报可能要经过许多个网络，而源主机事先并不知道后面要经过的这些网络中分组的最大长度是多少，当超过某个网络的最大长度限制时就需要分片。</p><p>​        广域网能够通过的分组的最大长度是该广域网中所有主机都事先知道的，源主机不可能发送网络不支持的过长分组。</p><h4 id="链路层广播和-IP-广播有何区别？"><a href="#链路层广播和-IP-广播有何区别？" class="headerlink" title="链路层广播和 IP 广播有何区别？"></a>链路层广播和 IP 广播有何区别？</h4><p>​        链路层广播使用数据链路层协议，在一个以太网史昂实现对该局域网上所有主机的 MAC 帧进行广播。</p><p>​        IP 广播则是用 IP 协议，通过互联网实现的对一个网络上的所有主机的 IP 数据报广播。</p><h4 id="当路由器利用-IP-数据报首部中的-“首部校验和”-字段检测出在传输过程中出现了差错时，就简单地将其丢弃。为什么不发送一个-ICMP-报文给源主机呢？"><a href="#当路由器利用-IP-数据报首部中的-“首部校验和”-字段检测出在传输过程中出现了差错时，就简单地将其丢弃。为什么不发送一个-ICMP-报文给源主机呢？" class="headerlink" title="当路由器利用 IP 数据报首部中的 “首部校验和” 字段检测出在传输过程中出现了差错时，就简单地将其丢弃。为什么不发送一个 ICMP 报文给源主机呢？"></a>当路由器利用 IP 数据报首部中的 “首部校验和” 字段检测出在传输过程中出现了差错时，就简单地将其丢弃。为什么不发送一个 ICMP 报文给源主机呢？</h4><p>​        IP 协议并不要求源主机重传有差错的数据报。保证无差错传输是由 TCP 协议完成的。另一方面，首部校验和只能校验出 IP 数据报的首部是否出现差错，但不知道首部中的源地址字段有没有出错，如果出错，将数据报传到错误的地址也是无意义的。</p><h4 id="有人认为，不使用-CIDR-也行。例如，使用-CIDR-时，给某单位分配了一个地址块-20，相当于-16-个-C-类地址块。如果不使用-CIDR-，而直接给该单位分配-16-个-C-类地址块，那么在效果上不是一样吗？"><a href="#有人认为，不使用-CIDR-也行。例如，使用-CIDR-时，给某单位分配了一个地址块-20，相当于-16-个-C-类地址块。如果不使用-CIDR-，而直接给该单位分配-16-个-C-类地址块，那么在效果上不是一样吗？" class="headerlink" title="有人认为，不使用 CIDR 也行。例如，使用 CIDR 时，给某单位分配了一个地址块 /20，相当于 16 个 C 类地址块。如果不使用 CIDR ，而直接给该单位分配 16 个 C 类地址块，那么在效果上不是一样吗？"></a>有人认为，不使用 CIDR 也行。例如，使用 CIDR 时，给某单位分配了一个地址块 /20，相当于 16 个 C 类地址块。如果不使用 CIDR ，而直接给该单位分配 16 个 C 类地址块，那么在效果上不是一样吗？</h4><p>​        如果不采用 CIDR ，而直接分配 16 个 C 类地址块，相当于给该单位分配了 16 个 C 类网络。这个单位对外界来说，是 16 个 C 类网络。每一个 C 类网络都要在本单位外面的路由表中占有一个表项，使得路由表更大了。当本单位内的许多主机相互通信时，由于跨越了不同的网络，都必须使用路由器来转发 IP 数据报，开销增大。</p><h4 id="IP-数据报中的首部校验和并不检验数据报中的数据，这样做的优缺点是什么？计算首部校验和为什么不使用-CRC-校验码？"><a href="#IP-数据报中的首部校验和并不检验数据报中的数据，这样做的优缺点是什么？计算首部校验和为什么不使用-CRC-校验码？" class="headerlink" title="IP 数据报中的首部校验和并不检验数据报中的数据，这样做的优缺点是什么？计算首部校验和为什么不使用 CRC 校验码？"></a>IP 数据报中的首部校验和并不检验数据报中的数据，这样做的优缺点是什么？计算首部校验和为什么不使用 CRC 校验码？</h4><p>​        优点是不校验数据部分可以加快分组转发的速度，缺点是数据部分出现差错不能及早发现，由上层检查数据是否出错。不使用 CRC 可减少路由器进行校验的时间。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/rPoZzSghkIDjyR6.png" alt="image-20200411110119434"></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h3><h4 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h4><p>　　传输层向它上面的应用层提供通信服务，属于面向通信部分的最高层，同时也是用户功能中的最底层。</p><p>　　<strong>传输层</strong>位于网络层上，它为运行在不同主机上的<strong>进程</strong>之间提供了逻辑通信，<strong>网络层</strong>提供<strong>主机</strong>之间的逻辑通信。即使网络层协议不可靠（网络层协议使分组丢失、混乱或重复），传输层同样能为应用程序提供可靠的服务。</p><p>　　传输层的功能如下：</p><p>　　1）提供应用进程之间的通信（端到端的通信）。与网络层的区别是，网络层提供的是主机之间的逻辑通信。</p><p>　　2）复用和分用。复用是指发送方不同的应用进程都可以使用同一个传输层协议传输数据；分用指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的进程。</p><p>　　注意：传输层的复用和分用与网络层复用分用功能不同。网络层的复用是指发送方不同协议的数据都可以封装成IP数据报发送出去，分用是指接收方的网络层在剥去首部后把数据交付给相应的协议。</p><p>　　3）传输层还要对收到的报文进行差错检测（首部和数据部分）。而网络层只检测 IP 数据报的首部，不检验数据部分是否出错。</p><p>　　4）提供两种不同的传输协议，即面向连接的 TCP 和面向无连接的 UDP。网络层无法同时实现两种协议（在网络层要么只提供面向连接的服务，如虚电路；要么只提供无连接服务，如数据报，不可能在网络层同时存在这两种方式）。</p><p>　　当传输层采用 TCP 时尽管下面的网络是不可靠的，但这种逻辑通信通道就相当于一条全双工的可靠信道。当传输层采用 UDP 时，这种逻辑信道仍是一条不可靠信道。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/3FQL42bwSgD95yh.png" alt="img"></p><h4 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h4><h5 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h5><p>　　端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道将其报文段中的数据向上交付给应用层相应的进程。端口是传输层服务访问点（TSAP），它在传输层的作用类似于 IP 地址在网络层的作用，或MAC地址在数据链路层的作用，只不过IP地址和MAC地址标识的是主机，而端口标识的是主机中的应用进程。</p><p>　　数据链路层的SAP 是MAC地址，网络层的SAP是IP地址，传输层的SAP 是端口。</p><h5 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h5><p>　　应用进程通过端口号进行标识，端口号长16个比特，能够表示65536 个不同的端口号。</p><p>　　端口号只具有本地意义，即端口号只标识本计算机应用层中的各进程，在因特网中不同计算机的相同端口号是没有联系的。根据端口号范围可将端口分为两类：</p><p>　　1）服务端使用的端口号。这里分为两类，最重要的一类是<strong>熟知端口号</strong>，数值为<strong>0~1023</strong>，IANA（互联网地址指派机构）把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有用户都知道。另一类为登记端口号，数值为 1024~49151。它是供没有熟知端口的应用程序使用的，使用这类端口必须在IANA登记。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/wcfgOCdMm4XUkRv.png" alt="img"></p><p> 　2）客户端使用的端口号，数值为 49152~65535 ，这类端口号仅在客户进程运行时才动态地选择，因此又称短暂端口号（也称临时端口）。</p><h5 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h5><p>　　在网络中通过IP地址来区别不同地主机，通过端口号来标识和区分一台主机中不同应用进程。在网络中采用发送方和接收方地套接字（Socket）组合来识别端点。</p><p>　　套接字 = （主机IP地址，端口号）</p><p>　　它唯一地标识网络中的一台主机和其上的一个应用。</p><p>　　</p><h4 id="无连接服务与面向连接服务"><a href="#无连接服务与面向连接服务" class="headerlink" title="无连接服务与面向连接服务"></a>无连接服务与面向连接服务</h4><p>　　面向连接服务就是在通信双方进行通信之前，必须先建立连接，在通信过程中，整个连接的情况一直被实时地监控和管理。通信结束后，应该释放这个连接。</p><p>　　无连接服务是指两个实体之间地通信不需要先建立好连接，需要通信时，直接将信息发送到“网络”中，让该信息地传递在网上尽力而为地往目的地传送。</p><p>　　TCP/IP 协议族 在 IP 上使用了两个传输协议：一个是面向连接的传输控制协议（Transmission Control Protocol，TCP），采用TCP时，传输层向上提供的是一条全双工的可靠逻辑信道；另一个是无连接的用户数据报协议（User Datagram Protocol，UDP），采用UDP时，传输层向上提供的是一条不可靠的逻辑信道。</p><p>　　TCP 在传送数据之前必须先建立连接，数据传送后要释放连接。TCP 不提供广播或组播服务。由于TCP提供面向连接的可靠传输服务，不可避免地增加了许多开销，如确认、流量控制、计时器及连接管理等。TCP 更适合可靠性更重要地场合，如 FTP，HTTP，TELNET等。</p><p>　　UDP 是一个无连接地非可靠传输层协议。它在IP之上仅提供两个附加服务：多路复用和对数据地错误检查。UDP 比较简单，执行速度快、实时性好。使用 UDP 的应用主要包括小文件传送协议（TFTP）、DNS、SMTP和实时传输协议（RTP）。</p><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><h4 id="UDP-数据报"><a href="#UDP-数据报" class="headerlink" title="UDP 数据报"></a>UDP 数据报</h4><h5 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h5><p>　　UDP 具有如下优点：1) UDP 无须建立连接。2）无连接状态。3）分组首部开销小，TCP 有20B的首部开销，UDP 仅有8B的开销。4）应用层能更好地控制要发送的数据和发送时间。</p><p>　　UDP 常用于一次性传输较少数据的网络应用如 DNS等。UDP 提供尽最大努力交付，不保证可靠交付。UDP 是面向报文的。报文不可分割，是UDP数据报处理的最小单位。</p><p>　　</p><h5 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/f6CQvHwS4l57PYu.png" alt="img"></p><p>　　1）源端口。源端口号。在需要对方回信时选用，不用可为全0.</p><p>　　2）目的端口。目的端口号。交付报文时必须使用到。</p><p>　　3）长度。UDP 数据报的长度（包括首部和数据），其最小值是 8B。</p><p>　　4）校验和。检测UDP数据报在传输中是否有错。有错就丢弃。</p><p>　　当传输 层从IP 层收到 UDP 数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口上交给应用进程。如果接收方UDP发现收到的报文中目的端口号不正确，丢弃报文，并由ICMP发送“端口不可达”差错报文给发送方。</p><p>　　</p><h4 id="UDP-校验"><a href="#UDP-校验" class="headerlink" title="UDP 校验"></a>UDP 校验</h4><p>　　在计算校验和时要在UDP数据报之前增加12B的伪首部，仅仅是为了计算校验和。</p><p>　　<strong>IP 数据报的校验和只检验IP数据报的首部，UDP的校验和则检查首部和数据部分。</strong></p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><h4 id="TCP-协议的特点"><a href="#TCP-协议的特点" class="headerlink" title="TCP 协议的特点"></a>TCP 协议的特点</h4><p>　　TCP 是在不可靠的 IP 层上实现的可靠数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。</p><p>　　TCP 协议的特点：</p><p>　　1）TCP 是面向连接的传输层协议。</p><p>　　2）每条TCP 连接只能有两个端点，每条TCP 连接只能是点对点的。</p><p>　　3）TCP 提供可靠的交付服务，保证传输的数据无差错、不丢失、不重复且有序。</p><p>　　4）TCP 提供全双工通信，允许双方的应用进程在任何时候都能发送数据，为此 TCP 连接的两端都设有发送缓存和接收缓存。</p><p>　　5）TCP 是面向字节流的。</p><p>　　</p><h4 id="TCP-报文段"><a href="#TCP-报文段" class="headerlink" title="TCP 报文段"></a>TCP 报文段</h4><p>　　TCP 传送的数据单元称为报文段。一个TCP 报文段分为 TCP 首部和TCP 数据两部分。整个TCP 报文作为 IP 数据报的数据部分封装在 IP 数据报中。其首部的前20B是固定的。TCP 报文段首部最短为20B，后面有4N字节是根据需要而增加的选项，通常长度是4B的整数倍。</p><p>　　TCP 报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/ZrPKCWlDYTie6Mj.png" alt="img"></p><p> 　1）源端口和目的端口 各占2B。端口是传输层和应用层的服务接口，运输层的复用和分用功能都通过端口实现。</p><p>　　2）序号字段 占4B。TCP 是面向字节流的（TCP 传送时是逐个字节传送的），所以<strong>TCP连接传送得数据流中得每个字节都编上一个序号。序号字段得值指的是本报文段所发送的数据的第一个字节的序号</strong>。</p><p>　　3）确认号字段，占4B。<strong>是期望收到对方下一个报文段的数据的第一个字节的序号。若确认号为 N，则表明到序号 N-1 为止的所有数据都已正确收到。</strong></p><p>　　4）数据偏移（首部长度）占4位。表示首部的长度 以4B为单位。</p><p>　　5）保留字段。占6位。</p><p>　　6）紧急位URG。URG=1时，表明紧急指针字段有效。告诉系统报文段中有紧急数据。URG 要配合紧急指针使用，即数据从第一个字节到紧急指针所指字节就是紧急数据。</p><p>　　7）确认位ACK。只有当ACK=1时确认号字段才有效。当ACK=0时确认号无效。<strong>TCP 规定，在连接建立后所有传送的报文段必须把ACK置1。</strong></p><p>　　8）推送位PSH。接收TCP 收到PSH=1的报文段，就尽快地交付给应用进程。</p><p>　　9）复位位RST。当RST=1时表明TCP连接中出现严重错误，必须释放连接再重新建立运输连接。</p><p>　　10）同步位SYN。同步SYN=1表示这是一个连接请求或连接接收报文。当SYN=1，ACK=0时表示这是一个连接请求报文，若对方同意建立连接，则在相应报文中使用SYN=1，ACK=1。</p><p>　　11）终止位FIN。用来释放一个连接。FIN表明此报文段的额发送方的数据已发送完毕。</p><p>　　12）窗口字段。占2B它指出现在允许对方发送的数据量。</p><p>　　13）校验和。占2B。校验和字段检验的范围包括首部和数据两部分。计算校验和也要在TCP报文段前面加上12B的伪首部。</p><p>　　14）紧急指针字段。占16位，指出本报文段中紧急数据有多少字节。</p><p>　　15）选项字段。长度可变。TCP 只规定了一种窜巷，即最大报文长度MSS。MSS是TCP报文段中数据字段的最大长度。</p><p>　　16）填充字段。使整个首部长度是4B的整数倍。</p><h4 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h4><p>　　TCP 是面向连接的协议，因此每个TCP 连接都有三个阶段：<strong>连接建立、数据传送和连接释放</strong>。</p><p>　　TCP 连接建立过程中，要解决以下三个问题：</p><p>　　1）要使每一方都能够确知对方的存在。</p><p>　　2）要允许双方协商一些参数</p><p>　　3）能够运输实体资源。</p><p>　　TCP 把连接作为最基本的抽象，每条TCP连接有两个端点，TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口。TCP连接的端口称为套接字。端口拼接到IP地址即构成套接字。</p><p>　　1、TCP 连接的建立：三次握手。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/blFim8spoScZdGB.png" alt="img"></p><p> 　服务端的资源是在第二次握手时分配的，客户端的资源是在第三次握手时分配的，使得服务器易收到SYN洪泛攻击。</p><h5 id="为什么不采用“两次握手”建立连接？"><a href="#为什么不采用“两次握手”建立连接？" class="headerlink" title="为什么不采用“两次握手”建立连接？"></a><strong>为什么不采用“两次握手”建立连接？</strong></h5><p>　　防止两次握手情况下将已经失效的连接请求报文突然又传到服务器而产生错误。以客户 A 向服务器 B 建立连接为例。A 向 B 先发送连接请求 ，但是网络拥堵没有及时到达，还没有到达 B ，A的就超时重传了，再次发送了一个连接请求。等第一个请求报文到达服务器时服务器给出确认报文。收到第二个报文服务器认为又要请求连接，又给出确认报文。在网络拥堵时就会浪费服务器资源。</p><p>　　如果是三次握手，第二次的请求报文不是服务器想要的报文，连接建立失败。</p><p>　　2、TCP 连接的释放：四次挥手。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/5wOiGbaTICBSJ4j.png" alt="img"></p><h5 id="为什么不采用“三次挥手”释放连接，且发送最后一次挥手报文要等待2MSL时间呢？"><a href="#为什么不采用“三次挥手”释放连接，且发送最后一次挥手报文要等待2MSL时间呢？" class="headerlink" title="为什么不采用“三次挥手”释放连接，且发送最后一次挥手报文要等待2MSL时间呢？"></a><strong>为什么不采用“三次挥手”释放连接，且发送最后一次挥手报文要等待2MSL时间呢？</strong></h5><p>　　1）确保A发送的 最后一个确认报文能够到达B，如果 A 不等待 2MSL， 若A返回的最后一个确认报文段丢失，B不能正常关闭，而此时A已经关闭，不可能再重传。</p><p>　　2)防止出现“已失效的连接请求报文段”。A 在发送最后一个确认报文段之后，再经过2MSL可保证本连接持续的时间内产生的所有报文段从网络中消失。</p><p>　　</p><h4 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h4><p>　　TCP 使用了校验、序号、确认和重传等机制来达到这一目的。</p><h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><p>　　TCP 首部的序号字段用来保证数据能有序提交给应用层，TCP 把数据视为一个无结构但有序的字节流，序号建立在传送的字节流上，而不建立在报文段上。</p><p>　　TCP 连接传送的数据流中的每个字节都编上一个序号。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/frq8gsQlw239Y1h.png" alt="img"></p><p>　　上图中第一个报文段序号为0，第二个为3。</p><h5 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h5><p>　　<strong>TCP 首部的确认号是期望收到对方的下一个报文段的第一个字节的序号。</strong></p><p>　　<strong>TCP 默认使用累计确认，即TCP 只确认数据流中至第一个丢失字节为止的字节。</strong></p><h5 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h5><p>　　有两种事件会导致TCP 对报文段进行重传，超时和冗余 ACK。</p><p>　　1）超时</p><p>　　TCP 每发送一个报文段，就对这个报文段设置一次计时器。重传时间到期未收到确认则重传。</p><p>　　2）冗余ACK（冗余确认）</p><p>　　TCP 规定每当比期望序号大的失序报文到达时，就发送一个冗余ACK，指明下一个期望字节的序号。</p><h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><p>　　TCP 提供流量控制服务来消除发送方使接收方缓冲区溢出的可能性，流量控制是一个速度匹配服务。</p><p>　　TCP 提供一种基于滑动窗口协议的流量控制机制，这里介绍TCP如何使用窗口机制来实现流量控制。</p><p>　　在通信过程中，接收方根据自己的接收缓存的大小，动态地调整发送方地发送窗口大小，这称为<strong>接收窗口 rwnd</strong>，即调整TCP首部中“窗口”字段值，来限制发送方向向网络注入报文地速率。同时发送方根据其对当前网络拥塞程序的估计而确定的窗口值，这称为<strong>拥塞窗口 cwnd</strong>。</p><p>　　例如，在通信中，有效数据只从A发往B，而B仅向A发送确认报文，这时B可通过设置确认报文段首部的窗口字段来将rwnd通知给A。<strong>rwnd即接收方允许连续接收的最大能力，单位是字节。</strong></p><p> 　传输层和数据链路层的流量控制的区别是：传输层定义端到端用户之间的流量控制、数据链路层定义两个中间结点的流量控制。另外，数据链路层的滑动窗口协议的大小不能动态变化，传输层的可以动态变化。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Dodg3HIf7sBjJbW.png" alt="img"></p><h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a><strong>TCP 拥塞控制</strong></h4><p>　　所谓拥塞控制，是为了防止过多的数据注入网络，保证网络中的路由器或链路不致过载。</p><p>　　拥塞控制与流量控制的区别：拥塞控制是网络能够承受现有的网络复合，是一个全局性的过程，涉及所有主机、所有的路由器，以及与降低网络传输性能有关的所有因素。流量控制往往是指点对点 的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率。</p><p>　　发送方在确定发送报文段的速率时，既要根据接收方的接收能力，又要从全局考虑不要使网络发生拥塞。因此，TCP 协议要求发送方维护以下两个窗口：　　</p><p>　　1）接收窗口cwnd，接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量。由接收方根据其放在TCP报文首部的窗口值通知发送方。</p><p>　　2）拥塞窗口cwnd，发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络的当前容量。</p><p>　　<strong>发送窗口的上限值应取接收窗口 rwnd 和拥塞窗口 cwnd 中较小的一个。</strong></p><p>　　<strong><img src="https://gitee.com/hoo334/picgo/raw/master//img/2wIRxO9r1jsymtp.png" alt="img"></strong></p><p> 　接收窗口的大小可根据TCP报文的窗口字段通知发送方，发送方如何维护拥塞窗口呢？下面讲慢开始和拥塞避免算法。</p><h5 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h5><h6 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h6><p>　　在TCP 刚连接好并开始发送TCP 报文时，先令拥塞窗口 cwnd=1，即一个最大报文段长度MSS，每收到一个对新报文的确认后将 cwnd加1，即增大一个MSS。逐步加大发送方的拥塞窗口。</p><p>　　例如，A 向 B 发送数据，发送时 A 的拥塞窗口为 2，那么 A 一次可以发送两个 TCP 报文段，经过一个 RTT 后，A 收到 B 对刚才两个报文的确认，于是把拥塞窗口调整为 4，下一次发送时就可以一次发送4个报文段。</p><p>　　<strong>使用慢开始算法后，每经过一个传输轮次（一个RTT），拥塞窗口 cwnd 就会加倍，即cwnd 的大小指数式增长。这样慢开始一直把拥塞窗口 cwnd 增大到一个规定的慢开始门限 ssthresh（阈值），然后改用拥塞避免算法。</strong></p><h6 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h6><p>　　<strong>发送端的拥塞窗口 cwnd 每经过一个 RTT 就增加一个MSS的大小，而不是加倍，时cwnd按线性规律缓慢增长，当出现一次超时（网络拥塞）时，令慢开始门限 ssthresh 等于当前cwnd 的一半。</strong></p><h6 id="网络拥塞的处理"><a href="#网络拥塞的处理" class="headerlink" title="网络拥塞的处理"></a>网络拥塞的处理</h6><p>　　网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段，只要对方检测到超时事件的发生，就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方 cwnd 值得一般 （但不能小于2）.然后把拥塞窗口cwnd 重新设置为1，执行慢开始算法。这样做得目的是迅速减少主机发送到网络中得分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。</p><p>　　拥塞避免并不能完全避免拥塞。</p><p>　<img src="https://gitee.com/hoo334/picgo/raw/master//img/vD9GEh5pFyoHwIq.png" alt="img"></p><h5 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h5><p>　　 快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</p><h6 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h6><p>　　快重传技术采用了冗余ACK来检测丢包的发生。同样，冗余 ACK 也用于网络拥塞的检测（丢了包意味着网络出现了拥塞）。快重传并非取消重传计时器，而是在某些情况下更早地重传丢失地报文段。</p><p>　　<strong>当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。</strong></p><h6 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h6><p>　　发送端收到连续的三个冗余 ACK（即重复确认）时，执行“乘法减小”算法，把慢开始门限 ssthresh 设置为出现拥塞时发送方cwnd的一半。与满开始（慢开始算法将拥塞窗口cwnd设置为 1）的不同之处是，它把cwnd 的值设置为慢开始门限ssthresh 改变之后的值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p><p>　　由于跳过了 cwnd 从1起始的慢开始过程，所以称为快恢复。快恢复算法实现的过程如下图。虚线为慢开始的处理过程。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/RQCNmEf41ZLnPO8.png" alt="img"></p><p> 　在流量控制中，发送方发送数据的量由接收方决定，在拥塞控制中，则由发送方自己通过检测 网络状况来决定。实际上，慢开始、拥塞避免、快重传和快恢复几种算法应是同时应用在拥塞控制机制中，<strong>当发送方检测到超时的时候，就开始慢开始和拥塞避免，当发送方接收发到冗余 ACK 时就采用快重传和快恢复。</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/kHdKev7JVR15yna.png" alt="img"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/UvJc6VCxe7fIGim.png" alt="image-20200507213947478"></p><h3 id="知识结构图"><a href="#知识结构图" class="headerlink" title="知识结构图"></a>知识结构图</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/p1mQsEuLAqKbizO.png" alt="image-20200411154708823"></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><h4 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户/服务器模型"></a>客户/服务器模型</h4><p>　　在客户/服务器模型（Client/Server，C/S）模型中，有一个总是打开的主机称为服务器，它服务于许多来自其他称为客户机的主机请求。</p><p>　　其工作流程如下：</p><p>　　1）服务器处于接收请求的状态。</p><p>　　2）客户机发出服务请求，并等待接收结果。</p><p>　　3）服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机。</p><p>　　客户程序必须知道服务器程序的地址。常见的使用客户/服务器模型的应用包括 Web、文件传输协议（FTP）、远程登录和电子邮件等。</p><p>　　客户/服务器模型的主要特点还有：</p><p>　　1）网络中各计算机的地位不平等，服务器可以通过对用户权限的控制来达到管理客户机的目的。整个网络的管理工作由少数服务器担当。</p><p>　　2）客户机之间不直接通信。</p><p>　　3）可扩展性不佳，受服务器硬件和带宽的限制，服务器支持的客户机有限。</p><p>　　</p><h4 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h4><p>　　在C/S 模型中，服务器性能的好坏决定了整个系统的性能。当大量的用户请求服务时，服务器必然成为系统的瓶颈。P2P 模型的思想是整个网络中的传输内容不再被保留在中心服务器上，每个结点都同时具有下载、上传的功能，其权利和义务都是大体对等的。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/YfH16xOIqM4p5SB.png" alt="img"></p><p> 　与C/S 模型相比，P2P 模型的优点主要体现在：</p><p>　　1）减轻服务器的计算压力，消除了对某个服务器的完全依赖。</p><p>　　2）多个客户机之间可以直接共享文档。</p><p>　　3）可扩展性好。</p><p>　　4）网络健壮性强。</p><h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><h4 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h4><p>　　因特网采用层次树状结构的命名方法。采用这种命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即域名（Domain Name）。域（Domain）是名字空间中一个可被管理的划分。域可以划分为子域，子域也能划分。这样就形成了顶级域、二级域、三级域等。每个域名都由标号序列组成，各标号之间用（“.”）隔开。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/jiIY6to5ZTGnhbB.png" alt="img"></p><p> 　域名中标号要注意：</p><p>　　1）标号中的英文不区分大小写。</p><p>　　2）标号中除连字符（-）外不允许使用其他的标点符号。</p><p>　　3）每个标号不超过 63 个字符，多标号组成的完整域名最长不超过 255 个字符。</p><p>　　4）级别最低的域名写在最左边，级别最高的域名写在最右边。</p><p>　　</p><p>　　顶级域名（Top Level Domain）分为如下三大类：</p><p>　　1）国家顶级域名。国家和某些地区的域名，“.cn”表示中国。</p><p>　　2）通用顶级域名。常见的“.com”（公司）、“.net”（网络服务机构）、“.org”（非盈利性组织）</p><p>　　3）基础结构域名。 arpa 用于反向域名解析。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/MYlKHhTdcOXG1yo.png" alt="img"></p><h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><p>　　域名到 IP 地址的解析是由运行在域名服务器上的程序完成的，一个服务器所管辖的范围称为区。每个域名服务器不但能够进行一些域名到 IP 地址的解析，而且还必须具有连向其他域名服务器的信息。当自己不能进行域名到 IP 地址的转换时，能够知道到什么地方去找其他域名服务器。</p><p>　　DNS 使用了大量的域名服务器，它们以层次方式组织。采用分布式设计的 DNS，是一个在因特网上实现分布式数据库的精彩范例。</p><p>　　主要有 4 种类型的域名服务器：</p><p>　　1）根域名服务器。根域名服务器是最高层次的服务器，所有根域名服务器都知道所有顶级域名服务器的 IP 地址。根域名服务器也是最重要的域名服务器。<strong>根域名服务器用来管理顶级域（如.com），通常它并不直接把待查询的域名直接转换为 IP 地址，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。</strong></p><p>　　2）顶级域名服务器。负责管理在该顶级域名服务器注册的所有二级域名。收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当查找的域名服务器的 IP 地址）。</p><p>　　3）授权域名服务器（权限域名服务器）。授权域名服务器总能将其管辖的主机名转换为该主机的IP 地址。</p><p>　　4）本地域名服务器。当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给该主机的本地域名服务器。我们在 Windows 系统中配置“本地连接” 时，就需要填写 DNS 地址，这个地址就是本地 DNS 的地址。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/TWcnYbumtrf46jG.png" alt="img"></p><h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><p>　　域名解析是指把<strong>域名映射成为 IP 地址</strong>或把 IP 地址映射成域名的过程。前者称为<strong>正向解析</strong>，后者称为反向解析。当客户端需要域名解析时，通过本机的额DNS 客户端构造一个 DNS 的请求报文， 以 <strong>UDP 数据报</strong>方式发往本地域名服务器。域名解析有两种方式：递归查询和递归与迭代相结合的查询。<strong>递归查询给根服务器造成的负载过大，在实际中几乎不使用。</strong></p><p>　　常用递归与迭代相结合的查询方式如下图所示。 </p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/mL9shJUbPAdkfYS.png" alt="img"></p><p> 　假定客户机想获知域名为 y.abc.com主机地 IP 地址，域名解析地过程（用使用 8 个UDP 报文）如下：</p><p>　　1）客户机向本地域名服务器发出 DNS 请求报文。</p><p>　　2）本地域名服务器收到后查询本地缓存，若有记录直接返回。若没有记录，以 DNS 客户的身份向根域名服务器发起解析请求。</p><p>　　3)根域名服务器收到请求后，判断该域名属于 .com 域，将对应的顶级域名服务器 dns.com 的 IP 地址返回给本地域名服务器。</p><p>　　4）本地域名服务器向 顶级域名服务器 dns.com 发出解析请求报文。</p><p>　　5）顶级域名服务器 dns.com 接收到请求后，判断该域名属于 abc.com域，因此将对应的授权域名服务器 dns.abc.com 的 IP 地址返回给本地域名服务器。</p><p>　　6）本地域名服务器向 dns.abc.com 发起解析请求报文。</p><p>　　7）授权域名服务器 dns.abc.com 收到请求后将 查询结果返回给本地域名服务器。</p><p>　　8）本地域名服务器将查询结果保存到本地缓存，同时返回给客户机。</p><p>　　为了提高 DNS 的查询效率，并减少互联网上的 DNS 查询报文数量，在域名服务器中广泛地使用了高速缓存。当一个 DNS 服务器接收到 DNS 查询结果时，它能将该 DNS 信息缓存在高速缓存中。</p><p>　　</p><h3 id="文件传输协议（FTP）"><a href="#文件传输协议（FTP）" class="headerlink" title="文件传输协议（FTP）"></a>文件传输协议（FTP）</h3><h4 id="FTP-的工作原理"><a href="#FTP-的工作原理" class="headerlink" title="FTP 的工作原理"></a>FTP 的工作原理</h4><p>　　文件传输协议（File Transfer Protocol，FTP）是因特网上使用的最广泛的文件传输协议。FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。它屏蔽了各计算机系统的细节，适合于在异构网络中的任意计算机之间传送文件。</p><p>　　FTP 提供以下功能：</p><p>　　1）提供不同种类主机系统之间的文件传输能力。</p><p>　　2）以用户权限管理的方式提供用户对远程 FTP 服务器上的文件管理能力。</p><p>　　3）以匿名 FTP 的方式提供公用文件共享的能力。</p><p>　　FTP 采用 客户/服务器的工作方式，它使用 TCP 可靠的传输服务。一个 FTP 服务器可同时为多个客户机进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接收新的请求；另外由若干从属进程，负责处理单个请求。</p><p>　　其工作步骤如下：</p><p>　　1）打开熟知端口21（控制端口），使客户进程能够连接上。</p><p>　　2）等待客户进程发连接请求。</p><p>　　3）启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程处理完客户的请求后终止。</p><p>　　4）回到等待状态。</p><p>　　</p><h4 id="控制连接与数据连接"><a href="#控制连接与数据连接" class="headerlink" title="控制连接与数据连接"></a>控制连接与数据连接</h4><p>　　FTP 在工作时使用两个并行的 TCP 连接：<strong>一个控制连接（端口号21），一个是数据连接（端口号20）</strong>。</p><p>　　1）控制连接。服务器监听21端口，等待客户连接，控制连接用来传递控制信息 以7位 ASCII 格式传送。</p><p>　　2）数据连接。服务器端接收到客户端发来的文件传输请求后，创建数据传送进程和数据连接。数据连接用来连接客户端和服务器端的数据传送进程，数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</p><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><h4 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h4><p>　　一个电子邮件系统应具有三个最主要的组成构件，用户代理（User Agent）、邮件服务器和电子邮件使用的协议，如 SMTP、POP3（或 IMAP）等。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/GkUHhObCvaygi7Z.png" alt="img"></p><p>​        用户代理（UA）：用户与电子邮件系统的接口。通常情况下，就是一个运行在PC上的程序。</p><p>　　邮件服务器：组成电子邮件系统的核心。邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件的传送情况。邮件服务器采用C/S方式工作，但是它能够同时充当客户和服务器。</p><p>　　邮件发送协议和读取协议：邮件发送协议用于在用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，通常使用 SMTP；邮件读取协议用于用户代理从邮件服务器读取邮件，如 POP3；SMTP 主动将邮件推到服务器，POP3 向邮件服务器发出请求拉取用户邮箱的邮件。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/3iuyE4KN7TogBsz.png" alt="img"></p><h4 id="电子邮件格式与MIME"><a href="#电子邮件格式与MIME" class="headerlink" title="电子邮件格式与MIME"></a>电子邮件格式与MIME</h4><p>　　1、电子邮件格式</p><p>​        一个电子邮件分为信封和内容两大部分，邮件内容又分为首部和主体两部分。To：为收件人，Subject：为主题。</p><p>　　2、多用途网络邮件扩充 MIME</p><p>　　SMTP 只能传送一定长度的 ASCII 码且无法传送可执行文件及其他二进制对象，因此提出了多用途网络邮件扩充（Multipurpose Internet Mail Extensions）。MIME 增加了邮件主体的结构，并定义了传送非ASCII 码的编码规则。并未改动SMTP 或取代它。</p><p>　　MIME 主要包括以下三部分内容：</p><p>　　1）5 个新的邮件首部字段，包括 MIME 版本、内容描述、内容标识、内容传送编码和内容类型。</p><p>　　2）定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</p><p>　　3）定义了传送编码，可对任何内容格式进行格式转换。</p><p>　　</p><h4 id="SMTP-和-POP3"><a href="#SMTP-和-POP3" class="headerlink" title="SMTP 和 POP3"></a>SMTP 和 POP3</h4><h5 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h5><p>　　简单邮件传输协议（Simple Mail Transfer Protocol）是一种提供可靠且有效的电子邮件传输的协议，它控制两个相互通信的 SMTP 进程交换信息。<strong>SMTP 使用 C/S 方式。使用 TCP 连接，端口号为25</strong>。SMTP 通信有以下三个阶段：</p><p>　　1）连接建立</p><p>​        发件人的邮件到达邮件服务器缓存之后，邮件服务器每隔一段时间对邮件缓存扫描一次。如果有邮件使用 SMTP 熟知端口（25）与接收方服务器 SMTP 服务器建立 TCP 连接。连接成功后接收方发出 220 Service ready 。发送方服务器向接收方发出 HELLO 命令，附上发送方的主机名。SMTP 不使用中间邮件服务器，TCP 总是在发送方和接收方这两个邮件服务器之间建立。</p><p>　　2）邮件传送</p><p>　　连接建立后，邮件的传送从 MAIL 命令开始，MAIL命令后面有发件人的地址。若接收方SMTP已经准备好接收 则回复 250 OK。接着发送一个或多个 RCPT命令给接收方服务器，每发送一个RCPT 命令都有相应的信息返回 250 OK 或 550 No such user here。RCPT的作用是检测接收方是否做好了接收邮件的准备。获取 OK 的答复之后客户端使用 DATA 命令，表示开始传输邮件的内容。</p><p>　　3）连接释放</p><p>　　邮件发送完后，SMTP 客户发送 QUIT 命令SMTP 服务器返回211（服务关闭）。</p><p>　　</p><h5 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h5><p>　　邮局协议（Post Office Protocol，POP）是一个非常简单但功能有限的邮件读取协议。POP 也使用C/S 工作方式，在传输层使用 TCP，端口号为 110。POP 有两种工作方式：下载并保留，下载并删除。这里的保留和删除指是否保留服务器上的邮件。</p><p>　　另一个邮件接收协议是因特网报文存取协议（IMAP），它比POP复杂得多，IMAP 为用户提供了创建文件夹等命令。</p><p>　　</p><h3 id="万维网（WWW）"><a href="#万维网（WWW）" class="headerlink" title="万维网（WWW）"></a>万维网（WWW）</h3><h4 id="WWW-的概念与组成结构"><a href="#WWW-的概念与组成结构" class="headerlink" title="WWW 的概念与组成结构"></a>WWW 的概念与组成结构</h4><p>　　万维网（Word Wide Web，WWW）是一个资料空间，在这个空间中：一样有用的事务称为一样资源，并由一个“全域统一资源定位符（URL）”标识。这些资源通过超文本传输协议（HTTP）传送给使用者。</p><p>　　万维网的内核部分是由三个标准构成的：</p><p>　　1）统一资源定位符（URL）。负责标识万维网上的各种文档。</p><p>　　2）超文本传输协议（HTTP）。应用层协议，使用TCP连接进行可靠的传输。</p><p>　　3）超文本标记语言（HTML）。一种文档结构的标记语言。</p><p>　　URL 的一般形式是：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><p>　　常见的协议有 http、ftp 等。</p><p>　　万维网以C/S方式工作，浏览器是用户计算机上的万维网客户程序。</p><p>　　</p><h4 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h4><p>　　HTTP 是面向事务的应用层协议，它规定了在浏览器和服务器之间的请求和响应的格式与规则，是万维网上能够可靠地交换文件的重要基础。</p><h5 id="HTTP-的操作过程"><a href="#HTTP-的操作过程" class="headerlink" title="HTTP 的操作过程"></a>HTTP 的操作过程</h5><p>　　浏览器要访问 WWW 服务器时，首先要完成对 WWW 服务器的域名解析。一旦获得了服务器的 IP 地址，浏览器就通过TCP向服务器发送连接建立请求。</p><p>　　每个万维网站点都有一个服务器进程，它不断地监听 TCP 的端口80（默认），当监听到连接请求后就向浏览器建立连接。TCP 连接建立后，浏览器就向服务器发送请求获取某个页面的 HTTP 请求。服务器收到 HTTP 请求后，将构件所请求 Web 页的必需信息，通过 HTTP 的响应返回给浏览器。浏览器再将信息进行解释，然后将Web 页显示给用户，最后TCP 连接释放。</p><p>　　访问一个网站发生的事件，以访问清华网站为例。</p><p>　　1）浏览器分析链接指向页面的 URL （<a href="http://www.tsinghua.edu.cn/chn/index.htm）。" target="_blank" rel="noopener">http://www.tsinghua.edu.cn/chn/index.htm）。</a></p><p>　　2）浏览器向 DNS 请求解析 <a href="http://www.tsinghua.edu.cn" target="_blank" rel="noopener">www.tsinghua.edu.cn</a> 的 IP 地址。</p><p>　　3）域名系统 DNS 解析出清华大学服务器的 IP 地址。</p><p>　　4）浏览器与该服务器建立 TCP 连接（默认端口号为 80）</p><p>　　5）浏览器发出 HTTP 请求：GET/chn/index.htm。</p><p>　　6）服务器通过 HTTP 响应把文件 index.htm 发送给浏览器。</p><p>　　7）TCP 连接释放。</p><p>　　8）浏览器解释文件 index.htm，并将Web 页显示给用户。</p><p>　　总结：DNS 解析 IP 地址，建立 TCP 连接，客户端发送 HTTP 请求，服务端响应 HTTP，TCP 连接释放，浏览器渲染页面。</p><h5 id="HTTP-的特点"><a href="#HTTP-的特点" class="headerlink" title="HTTP 的特点"></a>HTTP 的特点</h5><p>　　HTTP 是无状态的，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问的相同。因为服务器并不记得曾经访问过的这个用户，也不记得为该客户曾经服务过多少次。</p><p>　　HTTP 的无状态设计使服务器更容易支持大量并发的 HTTP 请求。在实际应用中，通常使用 Cookie 加数据库的方式来跟踪用户的活动。Cookie 是一个存储在用户主机中的文本文件，里面有一串识别码，用于Web 服务识别用户。</p><p>　　HTTP 既可以使用非持久连接，也可以使用持久连接（HTTP/1.1支持）。</p><p>　　对于非持久连接，每个网页元素的传输都需要单独建立一个TCP连接（5 张图片 5 个 TCP 连接），请求一个万维网文档所需要的事件是该文档的传输时间加上两倍往返时间 RTT。（一个 RTT 用于 TCP 连接，另一个RTT 用于请求和接收文档。三次握手的第三次可以发送HTTP请求）。</p><p>　　所谓持久连接，指万维网服务器在发送响应后仍然保持这条连接，使同一个客户和服务器可以继续在这条连接上传送后续的 HTTP 请求与响应报文。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/ChsAGEzXFHxfRVk.png" alt="img"></p><p> 　持久连接又分为非流水线和流水线两种方式。对于非流水线方式，客户收到前一个响应后才能发出下一个请求。HTTP/1.1 默认方式是使用流水线的持久连接。</p><h5 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h5><p>　　HTTP 是面向文本的，因此报文中的每个字段都是一些 ASCII 码串，并且每个字段的长度都是不确定的。</p><p>　　有两类 HTTP 报文：请求报文和响应报文。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/nib94M5QDNgkAy3.png" alt="img"></p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/HqsRhgfN4BPynmj.png" alt="img"></p><h3 id="知识结构图-1"><a href="#知识结构图-1" class="headerlink" title="知识结构图"></a>知识结构图</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/mN2ThOy3YQ47BdH.png" alt="image-20200507171655791"></p><h2 id="协议总结"><a href="#协议总结" class="headerlink" title="协议总结"></a>协议总结</h2><h3 id="应用层协议：（应用程序）"><a href="#应用层协议：（应用程序）" class="headerlink" title="应用层协议：（应用程序）"></a><strong>应用层协议：（应用程序）</strong></h3><h4 id="使用TCP"><a href="#使用TCP" class="headerlink" title="使用TCP"></a>使用TCP</h4><p>　　HTTP（Hypertext Transfer Protocol ）超文本传输协议 &lt;端口号 80&gt;， 面向事务的应用层协议。</p><p>　　FTP（File Transfer Protocol ）文件传输协议&lt;端口号21&gt;减少或消除不同操作系统下处理文件的不兼容性。 </p><p>　　TELNET 远程登录协议 &lt;端口号23&gt; 。</p><p>　　SMTP （Simple Mail Transfer Protocol ）简单邮件传输协议 &lt;端口号25&gt; 用于发送邮件。 </p><p>　　POP3 (Post Office Protocol 3) 即邮局协议的第3 个版本，用于接受邮件。 </p><p>　　IMAP4 (Internet Message Access Protocol 4) Internet 信息访问协议的第 4 版本 。</p><h4 id="使用UDP"><a href="#使用UDP" class="headerlink" title="使用UDP"></a>使用UDP</h4><p>　　DHCP(Dynamic Host Configuration Protocol)动态主机分配协议，使用 UDP 协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。实 现即插即用连网。 </p><p>　　DNS(Domin Name System<em>)</em> 域名系统协议，同时占用TCP和UDP的 53 端口。区域传送使用TCP，<strong>域名解析使用UDP</strong>。书上没有写区域传送的内容，只讲了域名解析，我将DNS归于UDP中，其实是不对的。</p><h3 id="传输层协议：（进程-端口）-数据单元：数据段"><a href="#传输层协议：（进程-端口）-数据单元：数据段" class="headerlink" title="传输层协议：（进程/端口） 数据单元：数据段"></a><strong>传输层协议：（进程/端口） 数据单元：数据段</strong></h3><p>　　TCP  （Transmission Control Protocol ）传输控制协议提供可靠的面向连接的服务，传输数据前须先建立连接，结束后释放。可靠的全双工信道。可靠、有序、无丢失、不重复。</p><p>　　UDP (User Datagram Protocol ）用户数据报协议发送数据前无需建立连接，不使用拥塞控制，不保证可靠交付，最大努力交付。 </p><p>　　RTP(Real-time Transport Protocol ）实时传送协议 。</p><h3 id="网络层协议：（路由器）数据单元：数据报"><a href="#网络层协议：（路由器）数据单元：数据报" class="headerlink" title="网络层协议：（路由器）数据单元：数据报"></a><strong>网络层协议：（路由器）数据单元：数据报</strong></h3><p>　　IP (IPv4 · IPv6) (Internet Protocol) 网络之间互连的协议。</p><p>　　ARP (Address Resolution Protocol) 即地址解析协议，实现通过IP 地址得 知其物理地址。 </p><p>　　RARP (Reverse Address Resolution Protocol)反向地址转换协议允许局域 网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP地址。 </p><p>　　 ICMP (Internet Control Message Protocol ）Internet 控制报文协议。它是TCP/IP 协议族的一个子协议，用于在IP 主机、路由器之间传递控制消息。</p><p>　　 RIP (Router information protocol) 路由信息协议是一种在网关与主机之间交换路由选择信息的标准。 </p><p>　　OSPF (Open Shortest Path First)开放式最短路径优先,分布式链路状态协议。 </p><h3 id="数据链路层：（网卡、网桥、交换机）数据单元：帧"><a href="#数据链路层：（网卡、网桥、交换机）数据单元：帧" class="headerlink" title="数据链路层：（网卡、网桥、交换机）数据单元：帧"></a><strong>数据链路层：（网卡、网桥、交换机）数据单元：帧</strong></h3><p>　　ARQ（Automatic Repeat-reQuest ）自动重传请求协议，错误纠正协议之一，包括停止等待ARQ 协议和连续ARQ 协议，错误侦测、正面确认、逾时重传与负面确认继以重传等机制。</p><p>　　纯 ALOHA 协议 ：不检测信道状态 直接发送 ，一段时间没收到确认 <strong>等待一段随机的时间</strong>后再发送，直到成功。</p><p>　　时隙 ALOHA 协议 ：把所有各站在时间上同步起来，并将时间划分为一段段等长的时隙，规定只能在每个时隙开始才能发送一个帧。</p><p>　　 CSMA/CD(Carrrier Sense Multiple Access with Collision Detection)载波监听多点接入/碰撞检测协议。<strong>以太网</strong>，总线型网络，协议的实质是载波监听和碰撞检测。载波监听即发数据前先检测总线上是否有其他计算机在发送数据，如暂时不发数据，避免碰撞。碰撞检测为计算机边发送数据边检测信道上的信号电压大小。 </p><p>　　CSMA/CA(Carrier Sense Multiple Access with Collision Avoidence) <strong>无线局域网，</strong>CSMA/CA 采用二进制指数退避算法。任何一个站要发送数据帧时，不仅要等待一个时间间隔，还要进入争用窗口，并计算随机退避时间以便再次试图接入信道。</p><p>　　PPP(Point-to-Ponit Protocol)点对点协议，<strong>广域网，面向字节</strong>，由三部分组成：一个将IP 数据报封装到串行链路的方法；一个用于建立、配置和测试数据链路连接的链路控制协议。</p><p>　　HDLC  （High-Level Data Link Control ）高级数据链路控制，<strong>广域网，面向比特</strong>，同步网上传输数据的数据链路层协议。 </p><p>　　 ATM  （Asynchronous Transfer Mode ）异步传递方式，建立在电路交换和分组交换的基础上的一种面向连接的快速分组交换技术。 “异步”是指将ATM 信元“异步插入”到同步的 SDH 比特流中。如同步插入则用户在每帧中所占的时隙相对位置固定不变。“同步”是指网络中各链路上的比特流都是受同一非常精确的主时钟的控制。Wi-Fi 、WiMAX 、DTM 、令牌环、以太网、FDDI 、帧中继、 GPRS 、 EVDO 、HSPA 、L2TP 、ISDN 。</p><p>　　</p><h3 id="物理层：（中继器、集线器）数据单元：比特"><a href="#物理层：（中继器、集线器）数据单元：比特" class="headerlink" title="物理层：（中继器、集线器）数据单元：比特"></a><strong>物理层：（中继器、集线器）数据单元：比特</strong></h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/YITdvmGgt7KWQy1.png" alt="img"></p><p> 参考：<a href="https://www.cnblogs.com/newsouls/p/5436266.html" target="_blank" rel="noopener">https://www.cnblogs.com/newsouls/p/5436266.html</a></p><p>　　</p>]]></content>
    
    <summary type="html">
    
      计算机网络
    
    </summary>
    
    
      <category term="笔记" scheme="https://hoo334.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库系统概论</title>
    <link href="https://hoo334.github.io/2020/08/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    <id>https://hoo334.github.io/2020/08/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</id>
    <published>2020-08-04T06:39:13.000Z</published>
    <updated>2020-08-15T09:08:38.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库系统概论"><a href="#数据库系统概论" class="headerlink" title="数据库系统概论"></a>数据库系统概论</h2><h3 id="数据库系统的作用"><a href="#数据库系统的作用" class="headerlink" title="数据库系统的作用"></a>数据库系统的作用</h3><h4 id="数据与数据管理"><a href="#数据与数据管理" class="headerlink" title="数据与数据管理"></a>数据与数据管理</h4><p>　　1）数据。描述事物的符号记录称为数据。数据是数据库中存储的对象，也是数据库管理系统处理的对象。数据和关于数据的解释是不可分的。</p><p>　　2）数据管理。数据处理是指对各种数据进行采集、存储、检索、加工、传播和应用等一系列活动的总和。数据管理是对数据进行有效的分类、组织、编码、存储、检索、维护和应用，它是数据处理的中心问题。</p><h4 id="数据管理技术的产生与发展"><a href="#数据管理技术的产生与发展" class="headerlink" title="数据管理技术的产生与发展"></a>数据管理技术的产生与发展</h4><p>　　1）人工管理阶段。面向应用程序，一个数据集只能对应一个程序，没有相应的软件系统专门负责数据的管理工作。当多个应用程序涉及某些相同的数据时，必须由各自的应用程序分别定义和管理这些数据，无法共享利用，存在大量冗余。</p><p>　　2）文件系统阶段。利用文件系统管理数据就是由专门的软件对数据进行统一管理。对于一个特定的应用，数据被集中组织存放在多个数据文件组中，并针对该文件组来开发特定的应用程序。文件系统利用“按文件名访问，按记录进行存取”的管理技术，可以对文件进行修改、插入和删除。</p><p>　　文件系统的弊端：数据共享性差，数据冗余和不一致。数据独立性差。数据孤立。数据获取困难。完整性问题（也称为一致性约束）。原子性问题。并发访问异常。安全性问题。</p><p>　　3）数据库管理系统阶段。数据库管理系统是由一个相互关联的数据的集合和一组用以访问、管理和控制这些数据的程序组成。这个数据集合通常称为数据库。</p><p>　　数据库管理系统的优点：</p><p>　　a. 数据整体结构化。</p><p>　　b.数据的共享度高，冗余度低，易扩充。<strong>数据独立性</strong>高。</p><p>　　c.数据独立性是用来描述数据与应用程序之间的依赖程度，包括数据的物理独立性和数据的逻辑独立性。</p><p>　　<strong>物理独立性</strong>是指用户的应用程序与存储在磁盘上数据库中的数据是相互独立的。</p><p>　　<strong>逻辑独立性</strong>是指用户的应用程序与数据的逻辑结构是相互独立的。</p><p>　　d.数据由数据库管理系统统一管理和控制</p><p>　　DBMS 必须提供：<strong>数据的安全性保护。数据的完整性检查。并发控制。数据库恢复。</strong></p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>　　数据模型是一个描述数据语义、数据与数据之间联系、数据操作，以及一致性（完整性）约束的概念工具的集合。通过数据模型可以对现实世界的数据特征进行抽象。</p><h4 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h4><p>　　数据模型应满足三方面的要求：一是能比较真实地模拟现实世界；二是容易被人所理解；三是便于在计算机上实现。</p><p>　　1）<strong>概念模型</strong>。又称信息模型，它按用户的观点或认识对现实世界的数据和信息进行建模，主要用于数据库设计。常用的概念模型有 E-R 模型，OO 模型。</p><p>　　2）<strong>逻辑模型</strong>。逻辑层是数据抽象的中间层，用于描述数据库数据的整体逻辑结构。该层的数据抽象称为逻辑数据模型。它是用户通过数据库管理系统看到的现实世界，是按计算机系统的观点对数据建模，即数据的计算机实现形式，主要用于 DBMS 的实现。</p><p>　　3）<strong>物理模型</strong>。物理层是数据抽象的最低层，用来描述数据的物理存储结构和存取方法。它不但由 DBMS 的设计决定，而且与操作系统、计算机硬件密切相关。</p><h4 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h4><p>　　1）<strong>数据结构</strong>。数据结构描述数据库的组成对象（数据）以及对象之间的联系。</p><p>　　2）<strong>数据操作</strong>。数据操作指对数据库中各种对象的实例允许执行的操作集合，包括操作及有关的操作规则。</p><p>　　3）<strong>数据的完整性约束条件</strong>。完整性规则是给定数据模型中数据及其联系所具有的制约和依存规则，用以限定复合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。</p><p>　　数据模型有：层次模型、网状模型、关系模型、面向对象模型、XML模型。</p><h4 id="数据抽象与数据库三级模式"><a href="#数据抽象与数据库三级模式" class="headerlink" title="数据抽象与数据库三级模式"></a>数据抽象与数据库三级模式</h4><h5 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a><strong>数据抽象</strong></h5><p>　　1）物理层抽象。最低层次的抽象，描述数据实际上是怎样存储的。</p><p>　　2）逻辑层抽象。描述数据库中存储什么数据以及这些数据之间存在什么关系。</p><p>　　3）视图层抽象。最高层次的抽象，只描述整个数据库的某个部分。</p><h5 id="数据库的三级模式"><a href="#数据库的三级模式" class="headerlink" title="数据库的三级模式"></a><strong>数据库的三级模式</strong></h5><p>　　模式是数据库中全体数据的逻辑结构和特征的描述，它仅仅设计型的描述，不涉及具体的值。模式的一个具体值称为模式的一个实例。</p><p>　　数据库的三级模式结构是指数据库管理系统提供的外模式、模式和内模式 3 个不同的抽象级别观察数据库中数据的角度。</p><p>　　1）模式。也称为逻辑层数据抽象。是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。DBMS 提供 数据定义语言（DDL）来严格定义模式。模式对应于表。</p><p>　　2）外模式。对应于视图层数据抽象，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述。</p><p>　　3）内模式。也称存储模式，对应于物理层数据抽象，它是数据的物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p><h5 id="数据库的两层映像功能与数据独立性"><a href="#数据库的两层映像功能与数据独立性" class="headerlink" title="数据库的两层映像功能与数据独立性"></a><strong>数据库的两层映像功能与数据独立性</strong></h5><p>　　1）<strong>外模式/模式映像</strong>。定义了外模式与模式之间的对应关系。当模式改变时，由数据库管理员对各个外模式/模式的映像作相应的改变，可以保持外模式不变。<strong>保证了数据与程序的逻辑独立性，简称为数据的逻辑独立性。</strong></p><p>　　2）<strong>模式/内模式映像</strong>。当数据库的存储结构改变了，由数据库管理员对模式。内模式映像作相应的改变，可以使模式保持不变。<strong>保证了数据与程序的物理独立性，简称为数据的物理独立性。</strong></p><h3 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h3><h4 id="数据库系统组成"><a href="#数据库系统组成" class="headerlink" title="数据库系统组成"></a>数据库系统组成</h4><p>　　从DBMS角度来看：数据库系统结构是外模式/模式/内模式的三级模式；从用户角度看：数据库系统分为单用户结构、主从式结构、分布式结构、客户/服务器、浏览器/应用服务器/数据库服务器等结构。</p><p>　　数据库中包含 4 类数据：用户数据、元数据、索引和应用元数据。用户数据就是通过结构化的关系（二维表）组织的所有业务数据的集合；元数据是对关系数据库结构的描述数据和数据库的有关统计数据，也成为数据字典；索引是为了改进数据库的性能和可访问性而建立的附件数据；应用元数据是用户窗体、报表、查询和其他形式的应用组件。</p><h4 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h4><h5 id="DBMS-的功能"><a href="#DBMS-的功能" class="headerlink" title="DBMS 的功能"></a><strong>DBMS 的功能</strong></h5><p>　　1）数据定义。DBMS 提供数据定义语言（Data Definition Language，DDL），用户通过它可以方便的对数据库中的数据对象进行定义。</p><p>　　2）数据组织、存储和管理。DBMS 分类组织、存储和管理各种数据，包括数据字典、用户数据、数据的存取路径等。</p><p>　　3）数据操纵。DBMS 还提供数据操纵语言（Data Manipulation Language，DML）用户通过它实现增删改查。</p><p>　　4）数据库的事务管理和运行。数据库在建立、运行和维护时由 DBMS 统一管理、统一控制，以保证数据的安全性、完整性、多用户对数据的并发操作以及发生故障后的系统恢复。</p><p>　　5）数据库的建立和维护。数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。</p><h5 id="DBMS-的组成"><a href="#DBMS-的组成" class="headerlink" title="DBMS 的组成"></a><strong>DBMS 的组成</strong></h5><p>　　1）模式更新。对数据库中的逻辑结构进行修改。</p><p>　　2）查询。</p><p>　　3）更新。</p><p>　　4）查询处理器。对用户请求的 SQL 操作进行查询优化。</p><p>　　5）存储管理器。根据执行策略，从数据库中取数据或更新数据。</p><p>　　6）事务管理器。负责保证系统的完整性，保证多个同时运行的事务不发生冲突。</p><h2 id="关系模型与关系代数"><a href="#关系模型与关系代数" class="headerlink" title="关系模型与关系代数"></a>关系模型与关系代数</h2><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>　　1）关系模型的数据结构为二维表，亦称关系，每个表（关系）有唯一的名字。</p><p>　　2）关系数据库是表的集合，即关系的集合。 </p><h4 id="关系数据结构的形式化定义"><a href="#关系数据结构的形式化定义" class="headerlink" title="关系数据结构的形式化定义"></a>关系数据结构的形式化定义</h4><p>　　1）域。域是一组具有相同数据类型的值的集合。如{‘男’，‘女’}。</p><p>　　2）笛卡儿积。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/c3YP65x9nMUm7EK.png" alt="img"></p><p> 　3）码。</p><p>　　　　超码：属性集 A 可以唯一标识关系 r 总中的一个元组，则称属性集 A 为关系 r 的一个超码。</p><p>　　　　候选码：对于关系 r 的一个或多个属性的集合 A ，如果属性集 A 的任何真子集都不能成为关系的超码，则称属性集 A 为候选码。</p><p>　　　　主码：若一个关系有多个候选码，可以选定其中一个候选码作为该关系的主码。</p><p>　　　　总结：主码 属于 候选码 属于 超码。</p><h4 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h4><p>　　关系完整性的约束条件：</p><p>　　1）实体完整性。主码不能为空。</p><p>　　2）参照完整性。外码要么为空要么能等于被参照关系的某个元组的主码。</p><p>　　3）用户自定义完整性。限制关系中某些属性的值符合业务语义要求。如限制性别为男或女。</p><p>　　</p><h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><p>　　关系操作有查询操作和更新操作两大类。查询操作又可分为选择、投影、连接、除、并、交、差、笛卡儿积等。其中<strong>选择、投影、集合并、集合差和笛卡儿积是 5 种基本关系操作</strong>。</p><p>​        关系代数</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/wNd74x2S3sOeajV.png" alt="img"></p><p> 　在连接中把不能连接的元组丢弃称为<strong>自然连接</strong>，把左关系中不能连接的元组保留到结果关系称为<strong>左外连接</strong>，把右关系中不能连接的元组保留到结果关系中称为<strong>右外连接</strong>，把左右关系中不能连接的元组都保留到结果关系中称为<strong>全外连接</strong>。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/6kVrK947GniRo5f.png" alt="img"></p><p>　　关系代数例题</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/qnDoKAmvJxYUhdk.png" alt="img"></p><p>　　1）查找选修了 08-09 学年第一学期（08091）开出的全部课程的学生学号和姓名。</p><p>　　解析：先找出所有08-09 学年第一学期的课程号，然后用选课关系表除这些课程号得到选修了08-09 学年第一学期全部课程学生的学号，再和学生表连接然后投影出学号和姓名。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/M8QDBnxT6GNHA4r.png" alt="img"></p><p>　　2）查找至少选修了一门其直接先修课编号为 CS012 的课程的学生学号和姓名。</p><p>　　解析：先找出先修课编号为 CS012 的课程然后依次连接选修关系和学生关系，最后投影出学生学号（没选过先修课编号为 CS012 的课程的同学会连接失败，如果选了多门先修课编号为 CS012 的课程的同学，投影会将学生学号和姓名去重）。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/CJ1dBG6NVYhOEtn.png" alt="img"></p><p>　　3）查找至少选修了学号为0703010 的学生所选课程的学号和姓名。</p><p>　　解析：先找出学号为0703010的学生所选的课程号，然后用选修关系除这些课程号，得到至少选修了学号为0703010 的学生所选课程的学号，再和学生表连接，投影出学号和姓名。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/mOjbEfyIU97XVFH.png" alt="img"></p><h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><h3 id="SQL-概述"><a href="#SQL-概述" class="headerlink" title="SQL 概述"></a>SQL 概述</h3><p>　　SQL 语言由 4 部分组成，包括数据定义语言 DDL、数据操纵语言 DML、数据控制语言和其他。</p><p>　　1）数据定义语言（Data Definition Language，DDL）：主要用于定义数据库的逻辑结构，包括数据库，基本表，视图和索引等，扩展 DDL 还支持存储过程、函数、对象、触发器等的定义。DDL 包括 3 类语言，即定义、修改和删除。</p><p>　　2）数据操纵语言（Data Manipulation Language，DML）：主要用于对数据库的数据进行检索和更新，其中更新操作包括插入、删除和修改数据。</p><p>　　3）数据控制语言（Data Control Language，DCL）：主要用于对数据库的对象进行授权、用户维护（包括创建、修改和删除）、完整性规则定义和事务定义等。</p><p>　　4）其他：主要是嵌入式 SQL 语言和动态 SQL 语言的定义。</p><p>　　</p><p>　　SQL特点：风格统一。高度非过程化。面向集合的操作方式。同一种语法结构提供两种使用方式（独立使用SQL对数据库进行操作，嵌入到高级语言中）。语言简洁，易学易用。</p><p>　　SQL主要动词：</p><p>　　1）数据查询：select；</p><p>　　2）数据定义：create、alter、drop；</p><p>　　3）数据操纵：insert、update、delete；</p><p>　　4）数据控制：grant、revoke；</p><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><p>　　where 子句可以实现关系代数中的选择运算，用于查询满足选择条件的元组。where 子句中常用的查询条件如下所示：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/5NmKQzuGXSE8p3H.png" alt="img"></p><p> 　% 表示任意长度的字符串，_表示任意一个字符， escape ‘ \ ‘ 表示 \ 后的符号不是通配符。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/bJOVFf4XQM53hxK.png" alt="img"></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>　　外连接：</p><p>　　1）左外连接</p><p>　　　　select xxx </p><p>　　　　from 表a <strong>left outer join</strong> 表b <strong>on</strong> a.xx=b.xx</p><p>　　2）右外连接</p><p>　　　　select xxx </p><p>　　　　from 表a <strong>right outer join</strong> 表b <strong>on</strong> a.xx=b.xx</p><p> 　3）全外连接</p><p>　　　　select xxx </p><p>　　　　from 表a <strong>full outer join</strong> 表b <strong>on</strong> a.xx=b.xx</p><h3 id="嵌套子查询"><a href="#嵌套子查询" class="headerlink" title="嵌套子查询"></a>嵌套子查询</h3><h4 id="使用-in-的子查询"><a href="#使用-in-的子查询" class="headerlink" title="使用 in 的子查询"></a>使用 in 的子查询</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Ut6bKM5lAWsTPiL.png" alt="img"></p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/Hm7MZoWqi2VEt9F.png" alt="img"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/BhbMpFjTZxcPXUn.png" alt="img"></p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/Sq2ceb7Lfpahj8E.png" alt="img"></p><h4 id="使用比较运算符的子查询"><a href="#使用比较运算符的子查询" class="headerlink" title="使用比较运算符的子查询"></a>使用比较运算符的子查询</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/vt87Oam4YzwJxES.png" alt="img"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/OdEwbPAcBqGKonx.png" alt="img"></p><h4 id="使用存在量词-exists-的子查询"><a href="#使用存在量词-exists-的子查询" class="headerlink" title="使用存在量词 exists 的子查询"></a>使用存在量词 exists 的子查询</h4><p>　　SQL 查询提供量词运算。量词有两种：一是存在量词，二是全称量词。全程量词可以用存在量词替代，故 SQL 语句仅提供存在量词的运算，使用谓词 exists 表示，全称量词转化通过 not exists 谓词来实现。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/hM1PlF8UboEXQqe.png" alt="img"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/KN9bScEkCjZJhMf.png" alt="img"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/XEBS7msaRO3tfek.png" alt="img"></p><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/bLqFIkXJCKAzrGa.png" alt="img"></p><p> 　如果指定 distinct 谓词，表示在计算时首先消除&lt;列名&gt;取重复值的元组，然后再进行统计。</p><h4 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h4><p>　　在 SQL 查询中，往往需要对数据进行分组运算，分组运算的目的是为了细化聚合函数的作用对象。如果不对查询结果进行分组，则聚合函数作用于整个查询结果；如果对查询结果进行分组，则聚合函数分别作用于每个组，查询结果是按组聚合输出。SQL 语句中通过 group by 和having 子句来实现分组运算，其中：</p><p>　　group by 子句对查询结果按某一列或某几列进行分组，值相等的分为一组；</p><p>　　having 子句对分组的结果进行选择，仅输出满足条件的组。该子句必须与group by 子句配合使用。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/mWZfg9ps8JA73nF.png" alt="img"></p><p> 　聚合函数可以直接使用在 having 子句中，也可以用于子查询中，但<strong>在 where 子句中不可以直接使用聚合函数。</strong></p><h4 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/h7m4821v9RjIJGN.png" alt="img"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/heOE2QcbPfitLYI.png" alt="img"></p><p> 或者</p><p>　　select studentNo, avg(score) as avgScore</p><p>　　from score </p><p>　　group by studentNo</p><p>　　having count(*) &gt;5</p><p>　　order by avgScore</p><p>　　limit 0,1</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/NRbIMlTqom1LdJS.png" alt="img"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/kT2RU6ud3DBzLAf.png" alt="img"></p><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p>　　SQL 支持集合运算。select 语句查询的结果是集合，多个 select 语句的结果可以进行集合操作，传统的集合操作主要包括并 union、交 intersect、差 except 运算，<strong>在执行集合运算时要求参与运算的查询结果的列数一样，其对应列的数据类型必须一致。</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/QvEbtCTGPunSkRr.png" alt="img"></p><h3 id="SQL-查询一般格式"><a href="#SQL-查询一般格式" class="headerlink" title="SQL 查询一般格式"></a>SQL 查询一般格式</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/d5JLQ4SFejksW8t.png" alt="img"></p><h3 id="SQL-数据定义语言"><a href="#SQL-数据定义语言" class="headerlink" title="SQL 数据定义语言"></a>SQL 数据定义语言</h3><p>　　数据库中的关系集合必须由数据定义语言 DDL 来定义，包括：数据库模式、关系模式、每个属性的值域、完整性约束、每个关系的索引集合和关系的物理存储结构等。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/IADEaU95sFGYO8Q.png" alt="img"></p><h4 id="数据库的定义"><a href="#数据库的定义" class="headerlink" title="数据库的定义"></a>数据库的定义</h4><h5 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/oZAH7Sla91zNXuF.png" alt="img"></p><h5 id="数据库的删除"><a href="#数据库的删除" class="headerlink" title="数据库的删除"></a>数据库的删除</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/QXKwkRidjT6Aq4L.png" alt="img"></p><h4 id="基本表的定义"><a href="#基本表的定义" class="headerlink" title="基本表的定义"></a>基本表的定义</h4><h5 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/6rCEphyxYKgv3bi.png" alt="img"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/BNoTkclZdWVqS3L.png" alt="img"></p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/ntiAphIVuWEmoXP.png" alt="img"></p><h5 id="基本表的修改"><a href="#基本表的修改" class="headerlink" title="基本表的修改"></a>基本表的修改</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/A9nHdB8csqLz6p5.png" alt="img"></p><p>　　 基本表在修改过程中，不可以删除列，一次仅执行一种操作。</p><h5 id="基本表的删除"><a href="#基本表的删除" class="headerlink" title="基本表的删除"></a>基本表的删除</h5><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/ZO6B1CmIU9dGKEe.png" alt="img"></p><p> 　若选择 restrict ，则该表的删除有限制条件，即该表不能有视图，触发器以及被他表所引用，该项为默认项。</p><p>　　若选择 cascade， 则该表的删除没有限制条件，在删除基本表的同时，也删除建立在该表上的所有索引，完整性规则，触发器和视图。</p><h4 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h4><p>　　如果数据有序，则检索速度是非常快的，对表中的记录进行排序有两种方案：一是对记录进行物理上的重新组织。二是不改变物理顺序，通过建立索引来实现数据记录的重新排列，称为逻辑排序。</p><p>　　一张表可以建立多个索引，可以从不同的角度加快查询速度，如果索引建立的比较多，会给数据维护带来较大的系统开销。</p><p>　　索引通常是由指针构成的记录，指针逻辑上按照索引关键字进行排序，但不改变表中记录的物理顺序。索引和基本表分别存储。</p><p>　　如果索引文件中的记录<strong>按照某个搜索码值指定的顺序物理存储</strong>，那么该搜索码对应的索引就称为<strong>主索引</strong>，也叫<strong>聚集索引</strong>。<strong>搜索码值顺序与索引文件中记录的物理顺序不同</strong>的那些索引称为<strong>辅助索引</strong>或<strong>非聚集索引</strong>。</p><h5 id="索引的建立"><a href="#索引的建立" class="headerlink" title="索引的建立"></a>索引的建立</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/B3SlMcuEm9wDe4s.png" alt="img"></p><h5 id="索引的删除"><a href="#索引的删除" class="headerlink" title="索引的删除"></a>索引的删除</h5><p>　　索引一旦建立，用户就不需要管理它，由系统自动维护。如果某个关系经常要执行插入、删除和修改操作，系统会花费很多时间来维护索引，从而降低基本表的更新速度，因此可删除那些不经常使用的索引。删除索引的语法为：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/OUpFAjhemWIoxsi.png" alt="img"></p><h3 id="SQL-数据更新语言"><a href="#SQL-数据更新语言" class="headerlink" title="SQL 数据更新语言"></a>SQL 数据更新语言</h3><p>　　SQL 数据更新语句包括 3 条：插入 insert、删除 delete、修改 update。</p><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="　　插入数据"></a>　　插入数据</h4><h5 id="插入一条元组"><a href="#插入一条元组" class="headerlink" title="插入一条元组"></a>插入一条元组</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/6vrnQYmcUW9O31k.png" alt="img"></p><h5 id="插入多条元组"><a href="#插入多条元组" class="headerlink" title="插入多条元组"></a>插入多条元组</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/HfeLn6dDRWCwyAZ.png" alt="img"></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="　删除数据"></a>　删除数据</h4><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/9yTpORSIfmKBXYj.png" alt="img"></p><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="　　修改数据"></a>　　修改数据</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/5mzi2Dy9jEgW3t4.png" alt="img"></p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>　　视图是虚表，是从一个或几个基本表（或视图）中导出的表，在系统的数据字典中仅存放了视图的定义，不存放视图对应的数据。</p><h4 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/R9MgBo7XGwK2Y8a.png" alt="img"></p><p> 　with check option ：当对视图进行插入、删除和更新操作时必须满足视图定义的谓词条件。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/eETgZ48mJ17ASh3.png" alt="img"></p><h4 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h4><p>　　查询是对视图进行的最主要的操作。从用户的角度来看，查询视图与查询基本表的方式是完全一样的。</p><h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p>　　更新视图指通过视图来插入、删除和修改基本表中的数据。由于视图是一个虚表，不实际存放数据，对视图的更新最终要转换为对基本表的更新，因此，如果视图的定义中包含了表达式，或聚合运算，或消除重复值运算，则不能对视图进行更新操作。</p><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/FiN2qdoAf8LMkCu.png" alt="img"></p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/VeDnJizjmpqPsXB.png" alt="img"></p><p> 　1）查询在2005-2008 年之间没有归还图书的读者编号、读者姓名、读者工作单位、图书编号、图书名称和借书日期。</p><p>　　分析：将读者、借阅、书籍三个关系连接起来然后判断书籍是否应该在 2005~2008年之间归还且书籍归还日期为空。</p><p>　　select rd.readerNo, rd.readerName, rd.workUnit, bk.bookNo, bk.bookName, br.borrowDate</p><p>　　from Reader rd, Borrow br, Book bk</p><p>　　where rd.readerNo=br.readerNo and br.bookNo=bk.bookNo and year(shouldDate) between 2005 and 2008 and br.returnDate is null</p><p>　　2)查询没有借书的读者姓名（分别用 in 子查询和存在量词子查询表达）。</p><p>　　分析：首先在借阅表中找出所有借过书还没有归还的读者号，然后判断每一个读者的读者号是否在前面找出的读者号里面，不在则代表没有借书。</p><p>　　select readerName</p><p>　　from Reader</p><p>　　where readerNo not in(</p><p>　　select distinct readerNo</p><p>　　from Borrow</p><p>　　where returnDate is null ); </p><p>　　select readerName</p><p>　　from Reader</p><p>　　where not exists (</p><p>　　select *</p><p>　　from Borrow</p><p>　　where Reader.readerNo=Borrow.readerNo and returnDate is null );</p><p>　　3)查询既借阅了“离散数学”又借阅了“数据库系统概念”两本书的读者编号、读者姓名、借书日期和图书名称。</p><p>　　分析：先找出借阅了离散数学的读者编号，再去看该读者是否借阅了数据库系统概念。</p><p>　　select rd.readerNo, rd.readerName, br.borrowDate, bk.bookName</p><p>　　from Reader rd, Borrow br, Book bk</p><p>　　where rd.readerNo=br.readerNo and br.bookNo=bk.bookNo and bookName=’离散数学’</p><p>　　and exists (</p><p>　　select * </p><p>　　from Borrow, Book</p><p>　　where Borrow.bookNo=Book.bookNo and rd.readerNo=Borrow.readerNo and Book.bookName=’数据库系统概念’ );</p><p>　　4）查询没有借阅’“经济管理”类图书的读者编号、读者姓名和出生日期（分别用 in 子查询和存在量词子查询表达）。</p><p>　　分析：先找出借阅了经济管理类书籍的读者号，然后判断每一个读者编号是否在前面找到的读者号中。</p><p>　　select readerNo, readerName, substring(identitycard,7,8) as birthday</p><p>　　from Reader</p><p>　　where readerNo not in (</p><p>　　select readerNo</p><p>　　from Borrow</p><p>　　where bookNo in(</p><p>　　select bookNo</p><p>　　from Book</p><p>　　where classNo in(</p><p>　　select classNo</p><p>　　from BookClass</p><p>　　where className=’经济管理’ )));</p><p>　　</p><p>　　</p><p>　　select readerNo, readerName, reader, substring(identitycard,7,8) as birthday</p><p>　　from Reader</p><p>　　where not exists(</p><p>　　select *</p><p>　　from Borrow br, Book bk, BookClass bc</p><p>　　where br.bookNo=bk.bookNo and bk.classNo=bc.classNo and bc,className=’经济管理’ and br.readerNo = Reader.readerNo);</p><p>　　</p><p>　　5)查询至少借阅了“马永强”所借的所有图书的读者编号、读者姓名、和工作单位。</p><p>　　分析：马永强所借的书他都借过 即 没有马永强借的书是他没有借的</p><p>　　select readerNo, readerName, workUnit</p><p>　　from Reader r1        //遍历每一位读者</p><p>　　where r1.readerNo not in(</p><p>　　select readerNo</p><p>　　from Borrow b1    //读者借书</p><p>　　where not exists(</p><p>　　select *</p><p>　　from Reader r2</p><p>　　where r2.readerName=’马永强’ and not exists(</p><p>　　select *</p><p>　　from Borrow b2      //马永强借书</p><p>　　where r2.readerNo=b2.readerNo and b1.bookNo=b2.bookNo and b2.returnDate is null)));</p><h2 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h2><h3 id="数据冗余导致的问题"><a href="#数据冗余导致的问题" class="headerlink" title="数据冗余导致的问题"></a>数据冗余导致的问题</h3><p>　　1）冗余存储：信息被重复存储，导致浪费大量存储空间。</p><p>　　2）更新异常：当重复的信息的一个副本被修改，所有副本都必须进行同样的修改。因此当更新数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的风险。</p><p>　　3）插入异常：只有当一些信息事先已经存放在数据库中时，另外一些信息才能存入数据库中。</p><p>　　4）删除异常：删除某些信息时可能丢失其他信息。</p><h3 id="函数依赖定义"><a href="#函数依赖定义" class="headerlink" title="函数依赖定义"></a>函数依赖定义</h3><h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><p>　　在关系R中，若属性或者属性集 A 中 两个元组的值相等，如果这两个元祖中对应的属性或者属性集B中的值也相同，则记作A—&gt;B。 A函数决定B； 或者 B函数依赖于A。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/E4hlWZPTntAf6KX.png" alt=""></p><h4 id="平凡与非平凡函数依赖"><a href="#平凡与非平凡函数依赖" class="headerlink" title="平凡与非平凡函数依赖"></a>平凡与非平凡函数依赖</h4><p>　　对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。若不特别声明，总是讨论非平凡函数依赖。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Yrj2GxN84q5mglZ.png" alt=""></p><h4 id="完全函数依赖和部分函数依赖"><a href="#完全函数依赖和部分函数依赖" class="headerlink" title="完全函数依赖和部分函数依赖"></a>完全函数依赖和部分函数依赖</h4><p>　　完全函数依赖：（学号,课号）——&gt;成绩;   单独一个学号，不能决定成绩，单独一个课程，也不能决定成绩；只有二者同时，才能决定；</p><p>　　部分函数依赖：（学号,课号）——&gt;姓名；学号和课号能决定姓名, 单独一个 学号 也能决定 姓名；</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/W4s5Xqyj9JPelo1.png" alt=""></p><h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><p>　　学号—&gt;系号，系号—&gt;系主任;       系主任   传递依赖于  学号</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/8MYz1S5RQP7LhxO.png" alt=""></p><h3 id="函数依赖理论"><a href="#函数依赖理论" class="headerlink" title="函数依赖理论"></a>函数依赖理论</h3><h4 id="码、超码、候选码和主码"><a href="#码、超码、候选码和主码" class="headerlink" title="码、超码、候选码和主码"></a>码、超码、候选码和主码</h4><p>　　码是一个或多个属性的集合。</p><p>　　超码是一个或多个属性的集合，超码中的这些属性可以让我们在一个实体集中唯一地标识一个实体。</p><p>　　候选码是极小的超码集，也就是它的任意真子集都不是超码，而他本身是超码。</p><p>　　主码是被选中用来在一个关系中区分不同元组的候选码。</p><p>　　<strong>候选码的确定：</strong></p><p>　　设关系模式R中U=ABC…….等N个属性，U中的属性在FD中有四种范围：</p><p>　　(1)左右出现;<br>　　(2)只在左部出现;<br>　　(3)只在右部出现;<br>　　(4)不在左右出现;</p><p>　　算法：按以下步骤求候选键：<br>　　1.只在FD右部出现的属性，不属于候选码;<br>　　2.只在FD左部出现的属性，一定存在于某候选码当中;<br>　　3.外部属性一定存在于任何候选码当中;  (左右都不出现)</p><p>　　4.其他属性逐个与2,3的属性组合，求属性闭包，直至X的闭包等于U,若等于U,则X为候选码。</p><p>　　例1：R&lt;U,F&gt;,U=(A,B,C,D,E,G),F={AB–&gt;C,CD–&gt;E,E–&gt;A.A–&gt;G},求候选码以及主属性。</p><p>　　因为：G只在右边出现，所以候选码肯定不包含G，BD只出现在左边，所以，候选码中肯定有BD，而BD的闭包还是BD，则对BD进行组合,除了G以外,BD可以跟A,C,E进行组合。</p><p>  　　<strong>先看ABD</strong><br>  　　ABD本身自包ABD,而AB–&gt;C,CD–&gt;E,A–&gt;G,所以ABD的闭包为ABDCEG=U<br> 　 　<strong>再看BDC</strong><br>　　  CD–&gt;E,E–&gt;A,A–&gt;G,BDC本身自包,所以BDC的闭包为BDCEAG=U<br> 　　 <strong>最后看BDE</strong><br>　　  E–&gt;A,A–&gt;G,AB–&gt;C,BDE本身自包,所以BDE的闭包为BDEAGC=U</p><p>  　　因为(ABD)、(BCD)、(BDE)的闭包都是ABCDEG所以本问题的候选码有3个分别是ABD、BCD和BDE</p><p> 　　候选码：ABD，BCD，BDE；</p><p>　　主属性（主要的属性，能决定其他属性的)：ABCDE;</p><p>　　非主属性：G；  　　</p><h4 id="Armstrong-公理系统"><a href="#Armstrong-公理系统" class="headerlink" title="Armstrong 公理系统"></a>Armstrong 公理系统</h4><p>　　设关系模式R&lt;U,F&gt;，其中U为属性集，F是U上的一组函数依赖，那么有如下推理规则</p><p>　　① A1自反律：若Y⊆X⊆U，则X→Y为F所蕴含；                    即：ABC→AB；   AB——&gt;A (平凡依赖函数)；<br>　　② A2增广律：若X→Y为F所蕴含，且Z⊆U，则XZ→YZ为F所蕴含；<br>　　③ A3传递律：若X→Y，Y→Z为F所蕴含，则X→Z为F所蕴含。<br>　　根据上面三条推理规则，又可推出下面三条推理规则：<br>　　④ 合并规则：若X→Y，X→Z，则X→YZ为F所蕴含；<br>　　⑤ 伪传递规则：若X→Y，WY→Z，则XW→Z为F所蕴含；  即：A→B，AC→BC；BC→D ；得出AC→D；<br>　　⑥ 分解规则：若X→Y，Z⊆Y，则X→Z为F所蕴含。      即：A→BC;  能得出：  A→B，A→C；  </p><h4 id="属性集闭包"><a href="#属性集闭包" class="headerlink" title="属性集闭包"></a>属性集闭包</h4><p>　　闭包就是由一个属性直接或间接推导出的所有属性的集合。</p><p>　　例如：f={a-&gt;b，b-&gt;c，a-&gt;d，e-&gt;f}；由a可直接得到b和d，间接得到c，则a的闭包就是{a，b，c，d}；</p><p>　　已知关系R(A1，A2，A3，A4，A5，A6)，函数依赖集F为{ (A2，A3)——&gt;A4，A3——&gt;A6，(A2，A5)——&gt;A1 }， 问(A2，A3)关于F的属性闭包为：{A2，A3,A4,A6}；  因为：A2，A3能带到A4，A3能得到A6；</p><p>　　已知关系R(A，B，C，D，E，F，G)，函数依赖集F为{ A ——&gt;B，B——&gt;D，AD——&gt;EF，AG——&gt;C}， 问：A关于F的属性闭包为:{A,B,D,E,F}；     因为：A能得到B，B能得到D，AD能得到EF;  </p><h4 id="最小函数依赖集（正则覆盖）"><a href="#最小函数依赖集（正则覆盖）" class="headerlink" title="最小函数依赖集（正则覆盖）"></a><strong>最小函数依赖集（正则覆盖）</strong></h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>　　如果函数依赖集F满足以下条件，则称F为一个极小函数依赖集。也称为最小依赖集或最小覆盖。</p><p>　　(1)F中任一函数依赖的右部仅含有一个属性。</p><p>　　(2)F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价。</p><p>　　(3)F中不存在这样的函数依赖X→A，X有真子集Z使得F-{X→A}U{Z→A}与F等价。</p><h5 id="最小依赖集通用算法"><a href="#最小依赖集通用算法" class="headerlink" title="最小依赖集通用算法"></a><strong>最小依赖集通用算法</strong></h5><p>　　① 用分解的法则，使F中的任何一个函数依赖的右部仅含有一个属性；</p><p>　　② 去掉多余的函数依赖：从第一个函数依赖X→Y开始将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，看X+是否包含Y，若是，则去掉X→Y；否则不能去掉，依次做下去。直到找不到冗余的函数依赖；</p><p>　　③ 去掉各依赖左部多余的属性。一个一个地检查函数依赖左部非单个属性的依赖。<strong>例如XY→A，若要判 X 为多余的，则以X→A代替XY→A，若 A 属于(Y)+，则 X 是多余属性（A 不通过 XY→A，通过 Y 就可以得到 A ，证明 X 是冗余的。），若 X 为多余的则用 Y→A 替代 XY→A。</strong></p><h5 id="最小依赖集案例"><a href="#最小依赖集案例" class="headerlink" title="最小依赖集案例"></a>最小依赖集案例</h5><p>　　例1：关系模式R(U，F)中，U=ABCDEG，F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;BC}；求F的最小函数依赖集</p><p>　　步骤：</p><p>　　（1）用分解的法则，使F中的任何一个函数依赖的右部仅含有一个属性；得到：F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;B，ADG-&gt;C}；</p><p>　　（2）去掉多余的函数依赖：从第一个函数依赖X→Y开始将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，依次做下去。直到找不到冗余的函数依赖；</p><p>　　　　① 去掉B-&gt;D，此时F={DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;B，ADG-&gt;C}，此条件下得出B的闭包 B+ = B；B+不包含D，所以B-&gt;D保留。</p><p>　　　　②去掉DG-&gt;C，此时F={B-&gt;D,BD-&gt;E,AG-&gt;B,ADG-&gt;B，ADG-&gt;C}，此时DG闭包DG+ = DG，不包含C,所以不能去掉DG-&gt;C.</p><p>　　　　③ 去掉BD-&gt;E，此时F={B-&gt;D，DG-&gt;C,AG-&gt;B,ADG-&gt;B，ADG-&gt;C}，此时闭包BD+ = BD,不包含E，所以不能去掉BD-&gt;E，继续保留。</p><p>　　　　④去掉AG-&gt;B，此时F={B-&gt;D，DG-&gt;C,BD-&gt;E,ADG-&gt;B，ADG-&gt;C}；此时AG+ = AG，不包含B，所以不能去掉AG-&gt;B，继续保留。</p><p>　　　　⑤去掉ADG-&gt;B，此时F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;C}，此时ADG+ = ADGCBE,包含了B，所以删除ADG-&gt;B，不保留。</p><p>　　　　⑥去掉ADG-&gt;C，此时F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B}，此时ADG+ = ADGCBD,包含了C，所以删除ADG-&gt;C，不保留。</p><p>　　　　综上所得，此时得到F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B}；</p><p>　　（3）去掉各依赖左部多余的属性。一个一个地检查函数依赖左部非单个属性的依赖。</p><p>　　此时函数依赖左边非单个属性有：DG-&gt;C,BD-&gt;E,AG-&gt;B；所以做如下操作：</p><p>　　　　①先来看DG-&gt;C，<strong>判断 D 是否多余，用 D-&gt;C 代替 DG-&gt;C 并求 DG - D = G 的闭包</strong>，此时G的闭包G+ = G，不包含C，保留D。判断 G 是否多余，求 DG - G = D 的闭包，此时D+ = D，不包含C，所以G也不能去掉；</p><p>　　　　②再来看BD-&gt;E，判断 B 是否多余，求 BD - B = D 的闭包，此时D的闭包D+ = D，不含E，保留B。判断 D 是否多余，求 BD - D = B 的闭包，此时B+ = BDE，包含了E，所以<strong>去掉D。</strong></p><p>　　　　③最后再来看 AG-&gt;B，判断 A 是否多余，求 AG - A = G 的闭包，G+ = G，不包含B，不能去掉A。判断 G 是否多余，求 AG - G = A 的闭包，A的闭包A+ =A，不含B，不能去掉G，还是AG-&gt;B ；</p><p>　　所以最后得出：F的最小函数依赖集是：F={B-&gt;D，DG-&gt;C,B-&gt;E,AG-&gt;B}；</p><h4 id="无损连接分解判定"><a href="#无损连接分解判定" class="headerlink" title="无损连接分解判定"></a>无损连接分解判定</h4><h5 id="判断表法"><a href="#判断表法" class="headerlink" title="判断表法"></a>判断表法</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/lHaYsVfUW1kOC69.png" alt=""></p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/JAR2xnFpjH6qCoD.png" alt=""></p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/vg6JaYUop15BFlO.png" alt=""></p><h5 id="无损连接定理"><a href="#无损连接定理" class="headerlink" title="无损连接定理"></a>无损连接定理</h5><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/5qiw86uL2yGmSPZ.png" alt=""></p><p>　　案例（1）：关系模式R（SAIP），F={S—&gt;A,SI—&gt;P};  ρ={R1(SA),R2(SIP)}检测分解是否为无损连接？</p><p>　　因为：R1∩R2 = S ；R1—R2 = A； R2—R1 = IP；所以得出：S —&gt;A；或者S —&gt;IP； 而 S —&gt;A 在F={S—&gt;A,SI—&gt;P}中，所以此分解是无损连接。</p><p>　　举例（2）：已知R&lt;U,F&gt;，U={A,B,C}，F={A→B}，如下的两个分解：<br>　　① ρ1={AB,BC}；</p><p>　　② ρ2={AB,AC}；</p><p>　　因为：AB∩BC = B；AB—BC = A；BC—AB = C；得出；B→A，或者 B→A，两个都不包含在F={A→B}中，所以 ρ1 分解是有损的。</p><p>　　因为：AB∩AC = A；AB—AC = B；AC—AB = C；得出：A→B，或者A→C，而A→B包含在F={A→B}中，所以 ρ2 分解是无损的。</p><h4 id="保持依赖分解判定"><a href="#保持依赖分解判定" class="headerlink" title="保持依赖分解判定"></a>保持依赖分解判定</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/rZvdit19IXUeu46.png" alt=""></p><p>　　</p><p>​        案例（1）：关系模式R&lt;U, F&gt;，U=｛A, B, C, D, E｝，F＝{B→A，D→A，A→E，AC→B｝则分解ρ={R1（ABCE），R2（CD）｝是否满足保持函数依赖。</p><p>　　因为：B→A，A→E，AC→B在R1上成立，D→A在R1和R2上都不成立，因此需做进一步判断。</p><p>　　由于B→A，A→E，AC→B都是被保持的（因为它们的元素都在R1中），因此我们要进一步判断的是D→A是不是也被保持。</p><p>　　①先看R1：因为：result = D；result ∩R1 = ф (空集)；所以：t=ф，result=D；</p><p>　　②再看R2：因为：result = D；result ∩R2 = D；D+ = DA; D+ ∩ R2 = D; 所以：t=D，result=D；</p><p>　　一个循环后result未发生变化，因此最后result=D，并未包含A，所以D→A未被保持，该分解不是保持依赖的。</p><p>　　案例（2）：关系R&lt;U,F&gt;，U={A,B,C,D,E}，F={A→C,B→C,C→D,DE→C,CE→A}，R的一个分解为R1(AD)，R2(AB)，R3(BE)，R4(CDE)，R5(AE)，判断这个分解是否具有函数依赖性。</p><p>　　因为：,C→D,DE→C均在R4(CDE)中被保持，而A→C,B→C，CE→A，在R1….R5上都不成立，需要进一步判断。</p><p>　　（1）A→C；</p><p>　　①先看R1：因为：result = A；result ∩R1 = A ； A+ = ACD ； A+ ∩ R1 = AD；所以：t=AD，result=AD； 此时，result改变，则，进入R2；</p><p>　　②再看R2：因为：result = AD；result ∩R2 = ф，最后还是result = AD；</p><p>　　③再看R3：因为：result = AD；result ∩R3 = ф，最后还是result = AD；</p><p>　　④再看R4：因为：result = AD；result ∩R4 = D，D+ = D; D+ ∩ R4= D；最后还是result = AD；</p><p>　　⑤再看R5：因为：result = AD；result ∩R5 = A，最后还是result = AD；</p><p>　　最后result = AD 并未包含C；所以，所以D→A未被保持，该分解不是保持依赖的；</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/9ndTFcB2j7MrzIP.png" alt="image-20200413172034818"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/svSjHaFopgIeTwL.png" alt="image-20200413172105632"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/XU2MsqG8edf6HIh.png" alt="image-20200413172128282"></p><h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p>　　（1）：1NF：每个分量都是不可再分的数据项（值、原子）。即：属性中，不能存在复合属性 或者 多值属性。</p><p>　　（2）：2NF：每一个非主属性 完全函数依赖 于 候选键（码）。注意：这里是码（不是主属性）；即：不能存在 非主属性部分函数依赖于码。</p><p>　　（3）：3NF：每一个非主属性 都不传递依赖于 码。 即：不能存在非主属性对于码的传递函数依赖。</p><p>　　（4）：BCNF：不存在 主属性 对于 码 的 部分函数依赖 与 传递函数依赖。判断方法：箭头左边的必须是候选码（不能只是一个属性，部分码）。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/f8IdKbFRrWoZPw3.png" alt=""></p><p>　　<strong>判断范式的方法：</strong></p><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/RcqhALHKwyl9GUX.png" alt=""></p><p> 　　例1：R（A，B，C），F={A-&gt;B, B-&gt;A, A-&gt;C}</p><p>　　　　L ：No，R：C，LR：A，B</p><p>　　　　计算A+ = ABC ，A 是候选码</p><p>　　　　计算B+ = ABC，B 是候选码</p><p>　　　　主属性： A，B ；非主属性： C</p><p>　　　　1）看非主属性是否部分依赖于主属性，发现没有部分依赖。</p><p>　　　　2）看非主属性是否传递依赖于主属性，发现 B -&gt; A -&gt; C ，C 传递依赖于 B，<strong>但这个传递依赖成立的条件是 A -&gt; B 不成立，否则A -&gt; C 推不出来。</strong>故没有部分传递依赖。</p><p>　　　　3）看所有依赖左边是否全部为候选码，所有依赖左边依次是 A，B，A 全部为 候选码 故为 BCNF 范式。</p><p>　　　　例2：R（A，B，C，D），F={B-&gt;D, D-&gt;B, AB-&gt;C}</p><p>　　　　L：A， R：C，LR：B，D</p><p>　　　　L 一定为主属性，将 L 和 LR 组合为 AB，AD</p><p>　　　　主属性： A，B，D ；非主属性： C</p><p>　　　　AB+ = ABCD；AD+ = ABCD；故 AB，AD为候选码。</p><p>　　　　1）查看部分依赖。 C 完全依赖于 AB，没有部分依赖。</p><p>　　　　2）查看传递依赖。C直接完全依赖于候选码 AB，没有传递依赖。</p><p>　　　　3）查看是否全为候选码。所有依赖左边依次是 B，D，AB ，B，D不为 候选码 故为 3NF 范式。</p><h4 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h4><h5 id="3NF-分解"><a href="#3NF-分解" class="headerlink" title="3NF 分解"></a><strong>3NF 分解</strong></h5><p>　　1）计算最小函数依赖</p><p>　　2）将最小函数依赖依次分解，得到 3NF 保持函数依赖分解。</p><p>　　3）将保持依赖分解添加一个候选码到结果中，得到 3NF 无损连接分解。</p><h5 id="BCNF-分解"><a href="#BCNF-分解" class="headerlink" title="BCNF 分解"></a><strong>BCNF 分解</strong></h5><p>　　R(A，B，C，D)，F={A-&gt;B，C-&gt;D}一直找不是候选码的函数依赖项 A-&gt;B，将依赖集分解为两部分：</p><p>　　1）AB</p><p>　　2）ACD (B 可由A 推出)</p><p>　　继续分解 ACD。</p><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/yL3SnojMe8WakFN.png" alt=""></p><p>　　例： R（A，B，C，D，E，F），F={AE-&gt;F，A-&gt;B, BC-&gt;D, CD-&gt;A, CE-&gt;F}</p><h5 id="3NF-分解例子"><a href="#3NF-分解例子" class="headerlink" title="3NF 分解例子"></a><strong>3NF 分解</strong>例子</h5><p>　　<strong>1）计算最小函数依赖集</strong>，这里省略，可以看到 F 的最小函数依赖集就是它本身。</p><p>　　<strong>2）计算候选码</strong></p><p>　　L：C，E</p><p>　　R：F</p><p>　　LR：A，B，D</p><p>　　L 一定为主属性，将 L 和 LR 组合为 ACE，BCE，CDE。</p><p>　　主属性： A，B，C，D ，E；非主属性： F</p><p>　　ACE+ = ABCDEF；BCE+ = ABCDEF；CDE+ = ABCDEF；故ACE，BCE，CDE为候选码。</p><p> 　　<strong>3）分解</strong></p><p>　　将上面的函数依赖依次分解得到：AEF，AB，BCD，CDA，CEF。</p><p>　　得到 3NF 保持函数依赖分解 : AEF，AB，BCD，CDA，CEF</p><p>　　任意添加一个候选码进去(这里选 ACE)。</p><p>　　得到 3NF 无损连接依赖分解 : AEF，AB，BCD，CDA，CEF，ACE</p><h5 id="BCNF-分解例子"><a href="#BCNF-分解例子" class="headerlink" title="BCNF 分解例子"></a><strong>BCNF 分解例子</strong></h5><p>　　<strong>依次分解左边不是候选码的依赖项</strong></p><p>　　AE-&gt;F，A-&gt;B, BC-&gt;D, CD-&gt;A, CE-&gt;F 左边全部都不是候选码，都需要分解。</p><p>　　第一次分解 AE-&gt;F：</p><p>　　AEF， 剩下 R=（ABCDE），F={A-&gt;B, BC-&gt;D, CD-&gt;A} （F可以被导出，若 F 在依赖的左边需要使用其他依赖代替）</p><p>　　第二次分解 A-&gt;B：</p><p>　　AB，剩下 R=（ACDE）， F={AC-&gt;D, CD-&gt;A} （B可以被导出，<strong>丢失BC-&gt; D</strong>）</p><p>　　第三次分解 CD-&gt;A：</p><p>　　CDA，剩下 R=（CDE）， F={} （A可以被导出）</p><p>　　CDE为候选码分解停止。</p><p>　　故 BCNF 分解为 AEF，AB，CDA，CDE</p><p>参考：</p><p>　　<a href="https://blog.csdn.net/prdslf001001/article/details/80336835" target="_blank" rel="noopener">https://blog.csdn.net/prdslf001001/article/details/80336835</a></p><p>　　<a href="https://www.bilibili.com/video/av73467859/" target="_blank" rel="noopener">https://www.bilibili.com/video/av73467859/</a></p><p>　　<a href="https://www.bilibili.com/video/BV1eE411a79r/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1eE411a79r/</a></p><h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E - R模型"></a>E - R模型</h2><h3 id="数据库设计过程"><a href="#数据库设计过程" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h3><p>​    1）需求分析：了解和分析系统将要提供的功能及未来数据库的用户需求。</p><p>​    2）概念设计：根据需求分析中得到的信息，设计者此阶段须选择适当的数据模型将这些需求转化为数据库的概念模式。例如 <strong>E - R 模型</strong> 是概念设计。</p><p>​    3）逻辑设计：将概念设计转化为所选择的数据库管理系统支持的逻辑数据模型，即数据库模式。逻辑数据库设计的任务是将 E - R 模型转化为关系数据库模式。</p><p>​    4）模式求精：对已得到的关系数据库模式进行分析找出潜在的问题并加以改进和优化。</p><p>​    5）物理设计：为逻辑数据库选取一个最适合现实应用的物理结构。</p><p>​    6）应用与安全设计：数据库系统必须指出哪些用户可以访问数据库以及他们通过哪些存储过程访问数据库。</p><h3 id="E-R-模型基本概念及表示"><a href="#E-R-模型基本概念及表示" class="headerlink" title="E - R 模型基本概念及表示"></a>E - R 模型基本概念及表示</h3><h4 id="实体与实体集"><a href="#实体与实体集" class="headerlink" title="实体与实体集"></a>实体与实体集</h4><p>​    实体是客观世界中可区别于其他事物的“事物”或“对象”。</p><p>​    实体的两个特征：独立存在（一个实体的存在不依赖于其他实体）、可区别于其他实体。</p><p>​    实体集是指具有相同类型及相同性质（或属性）的实体集合。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>​    实体是通过一组属性来描述的，属性是实体集中每个实体都具有的描述性性质。在已实体集中，所有实体都具有相同的属性。</p><p>​    每个属性所允许的取值范围或集合称为该属性的<strong>域</strong>。</p><p>​    E - R 模型中的属性可按如下类型划分：</p><p>​    1）简单属性和复合属性。简单属性是指不能再分为更小部分的属性。复合属性指可以进一步划分为更小部分的属性。</p><p>​    2）单值属性和多值属性。如果某属性对一个特定实体任何时候都只能有单独的一个值，则称该属性为单值属性，否则为多值属性。例如一个studentNo 属性只对应一个学号，为单值属性。一个phoneNumber属性可能有不同数目的值，为多值属性。</p><p>​    3）空值（NULL）属性。当某个属性上没有值时可以使用 NULL 值。</p><p>​    4）派生属性，这类属性的值可以从其他属性的值派生出来。例如实体集 Student 的 age 属性表示学生的年龄，它可以由当前日期和生日属性的值计算得到。</p><p>​    在 E - R 图中，实体集用矩形表示，属性用椭圆表示，多值属性用双椭圆表示，派生属性用虚线椭圆表示，属性与实体之间用连线表示。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/2lqtAhLbzMSsjE4.png" alt="image-20200405101025891"></p><h4 id="联系与联系集"><a href="#联系与联系集" class="headerlink" title="联系与联系集"></a>联系与联系集</h4><p>​    联系集是 n （n &gt;= 2）个实体集上的数学关系，这些实体集不必互异。</p><p>​    参与联系的实体集的数目称为联系集的度。</p><p>​    下图中，Student 与 Course 之间有 Enroll 联系集，选课联系集上有 Score 属性。课程里面的 PriorCourse 属性参照 Course 关系。 </p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/kKAVRhcFCMYjawT.png" alt="image-20200405101234923"></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="映射约束"><a href="#映射约束" class="headerlink" title="映射约束"></a>映射约束</h4><p>​    映射基数指一实体集中的一个实体通过一个联系集能同时与另一个实体集相联系的实体数目。在二元联系中，共有 4 种映射基数：1：1（一对一）、1：m（一对多）、m：1（多对一）、m：n（多对多）。</p><p>​    在 E - R 图中，“—&gt;”指向参与联系集中“一”方实体集，线段“—”表示参与联系集中的“多”方实体集。</p><h4 id="码约束"><a href="#码约束" class="headerlink" title="码约束"></a>码约束</h4><h5 id="实体集的码"><a href="#实体集的码" class="headerlink" title="实体集的码"></a>实体集的码</h5><p>​    码是一个或多个属性的集合。</p><p>​    超码是一个或多个属性的集合，超码中的这些属性可以让我们在一个实体集中唯一地标识一个实体。</p><p>​    候选码是极小的超码集，也就是它的任意真子集都不是超码，而他本身是超码。</p><p>​    主码是被选中用来在一个关系中区分不同元组的候选码。</p><h5 id="联系集的码"><a href="#联系集的码" class="headerlink" title="联系集的码"></a>联系集的码</h5><p>​    二元联系集的主码选择依赖于联系集的映射基数，具体如下。</p><p>​    1）一对一：主码可以使用参与联系集中的任何一方实体集的主码；</p><p>​    2）一对多和多对一：主码由“多的一方实体集的主码组成；</p><p>​    3）多对多：主码由参与联系集中所有实体集的主码组成。</p><h4 id="参与约束"><a href="#参与约束" class="headerlink" title="参与约束"></a>参与约束</h4><p>​    如果实体集 A 中的每个实体都参与到联系集 R 中至少一个联系中，则称实体集 A 全部参与联系集 R。</p><h4 id="存在依赖与弱实体集"><a href="#存在依赖与弱实体集" class="headerlink" title="存在依赖与弱实体集"></a>存在依赖与弱实体集</h4><p>​    存在一类实体集，其属性不足以形成主码，它们必须依赖于其他实体集的存在而存在，称这样的实体集为<strong>弱实体集</strong>。与此相对，其属性可以形成主码的实体集称为<strong>强实体集</strong>。弱实体集所依赖的强实体集称为<strong>标识实体集</strong>。弱实体集必须与一个标识实体集相关联才有意义，该实体集称为<strong>标识实体集</strong>。</p><p>​    对于弱实体集，必须满足下列限制：</p><p>​    1）标识实体集和弱实体集必须是一对多联系集。</p><p>​    2）弱实体集在标识联系集中是全部参与。</p><p>​    E - R 图使用双矩形表示弱实体集，双菱形表示标识联系，用虚下划线表示弱实体集的部分码。下图描述了 CourseClass 及其标识实体集 Course 之间的标识联系集 Arrange 。注意标识联系集没有描述性属性，因为任何所需的属性都可和弱实体相关联。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/JW8oG15VvgYqley.png" alt="image-20200405103558371"></p><h3 id="E-R-模型转化为关系模型"><a href="#E-R-模型转化为关系模型" class="headerlink" title="E - R 模型转化为关系模型"></a>E - R 模型转化为关系模型</h3><h4 id="E-R-模型转化方法"><a href="#E-R-模型转化方法" class="headerlink" title="E - R 模型转化方法"></a>E - R 模型转化方法</h4><p>​    1）强实体集转化方法：将实体集的每个属性对应为关系模式的属性，实体集的码作为关系模式的码。</p><p>​    2）弱实体集转化方法：弱实体集对应的关系模式属性由弱实体集本身的描述属性加上所依赖的强实体集的主码属性组成。<strong>主码由所依赖的强实体集主码和弱实体集的部分码组成</strong>。</p><p>​    3）联系集转化方法    </p><p>​        联系集一般转化方法：一个联系集转化为一个关系模式。联系集的主码设置见“联系集的主码“。</p><p>​        一对多或多对一联系集的转化：在 ”多“ 方的实体集中添加 ”一“ 方的主码，使 ”一“ 方的主码成为 ”多“ 方 的外码。</p><p>​    4）复合属性及多值属性转化方法：对于复合属性，应为每个子属性创建一个单独的属性，而不是为复合属性自身创建的一个单独的属性。</p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Kfh8vNiTAQraPkX.png" alt="image-20200414081715392"></p><p>​    <img src="https://gitee.com/hoo334/picgo/raw/master//img/cdBWLxwvRQb9FnV.png" alt="image-20200414081741823"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Ex5MTBGdXacLkyV.png" alt="image-20200414081901050"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/jGQMRbT2FCctdne.png" alt="image-20200414081801666"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/GPsadUnVFbQJm9l.png" alt="image-20200414081819570"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/eAio7uRHx3bcEQX.png" alt="image-20200414081934207"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/roiPmwSHdhaqDV4.png" alt="image-20200414101333649"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/a1hWbyZrOe6kMSC-1594978995215.png" alt="image-20200414101352852"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/IqghOSjkUmcQD7M.png" alt="image-20200414101445958"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/jJVGegbAKdwCi1S.png" alt="image-20200414101457645"></p><h2 id="数据库完整性与安全性"><a href="#数据库完整性与安全性" class="headerlink" title="数据库完整性与安全性"></a>数据库完整性与安全性</h2><h3 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h3><h4 id="SQL-存取控制机制"><a href="#SQL-存取控制机制" class="headerlink" title="SQL 存取控制机制"></a>SQL 存取控制机制</h4><p>​    SQL 支持受控的存取保护，即在自主存取控制中，用户对于不同的数据对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户。因此自主存取控制非常灵活。</p><p>​    自主存取控制通过 SQL 的 grant 和 revoke 语句实现。</p><p>​    用户权限是由两个要素组成的：数据对象和操作对象。</p><p>​    用户的存取权限：该用户可以在哪些数据对象上进行哪些类型的操作。定义存取权限称为授权。</p><p>​    自主存取控制能够通过授权机制有效地控制其他用户对敏感数据的存取。</p><h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><p>​    创建用户语句 create user 的语法如下：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/PMcSmGxa3O7JzBb.png" alt="image-20200405154743908"></p><p>​    只有系统的超级用户才有权创建一个新的数据库用户。新创建的数据库用户有 3 种权限 connect、resource 和 dba。默认为 connect 权限，拥有 connect 权限的用户不能创建新用户、模式和基本表，只能登录数据库。然后由 dba 或其他用户给他转授权限。拥有 resource 权限的用户可以创建基本表和视图，并称为所创建对象的属主，但不能创建模式和新用户。数据库对象的属主可以使用 grant 语句把该对象上的存取权限授予其他用户。拥有 dba 权限的用户是系统中的超级用户，可以创建新用户、模式、基本表和视图等；dba 拥有所有数据库对象的存取权限，还可以将这些权限授予给一般用户。</p><h5 id="权限的授予与收回"><a href="#权限的授予与收回" class="headerlink" title="权限的授予与收回"></a>权限的授予与收回</h5><p>​    grant 和 revoke 有两种权限：目标权限和命令权限。</p><h6 id="命令权限的授予与收回"><a href="#命令权限的授予与收回" class="headerlink" title="命令权限的授予与收回"></a>命令权限的授予与收回</h6><p>​    命令级权限主要指 DDL 操作权限。命令权限的授予语句 grant 和 收回语句 revoke 的语法分别为：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/jWhtYLXsdeT6iAE.png" alt="image-20200405155559635"></p><p>​    其中 &lt; command_list &gt; 可以是 create database、create default、create function、create procedure、create rule、create table、create view、create index、backup database 和 backup log 等。</p><p>​    一次可以授予多种权限，授予多种权限时，权限之间用逗号分隔。</p><p>​    all：表示上述所有权限。</p><p>​    public：表示所有用户。</p><p>​    &lt; username_list &gt;：指定的用户名列表。如果将某组权限同时授予多个用户，则用户名之间用逗号分隔。</p><h6 id="目标权限的授予与收回"><a href="#目标权限的授予与收回" class="headerlink" title="目标权限的授予与收回"></a>目标权限的授予与收回</h6><p>​    目标权限主要指对对象的 DML 操作权限。对象权限的授予语句 grant 和收回语句 revoke 的语法分别为：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/iEl5Mm3Tw8tWVQ6.png" alt="image-20200405160348795"></p><p>​    其中 &lt; command_list &gt; 可以是 update、select、insert、delete、execute 和 all 。execute 针对存储过程授予执行权限，update、select、insert、delete 针对基本表和视图授权， all 指全部的权限。</p><p>​    cascade ：级联收回。</p><p>​    restrict：默认值，若转赋了权限，则不能收回。</p><p>​    with grant option：将指定对象上的目标权限授予其他安全账户的能力，但是不允许循环授权。即不允许将其得到的权限授予其祖先。</p><h3 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h3><h4 id="完整性约束条件"><a href="#完整性约束条件" class="headerlink" title="完整性约束条件"></a>完整性约束条件</h4><p>​    完整性约束条件作用的对象可以是关系、元组、列 3 种。列约束主要是列的类型、取值范围、精度、是否允许空值等的约束条件。元组约束是元组中属性间的联系的约束。关系约束是若干元组间、关系集合上以及关系之间的约束。</p><p>​    完整性约束条件涉及的这 3 类对象，其状态可以是静态的，也可以是动态的。</p><p>​    静态约束是指数据库每一确定状态时的数据对象所应满足的约束条件，它反映数据库状态合理性的约束，这是最重要的一类完整性约束。</p><p>​    静态约束主要表现在：</p><p>​    1）静态列级约束：对一个列的取值域的说明。对数据类型（类型，长度、单位、精度等）、数据格式、对取值范围或取值集合的约束、对空值的约束和其他约束。</p><p>​    2）静态元组约束：规定元组的各个列之间的约束关系。</p><p>​    3）静态关系约束：在一个关系的各个元组之间或若干关系之间存在各种联系或约束。常见的静态关系约束有：<strong>实体完整性约束、参照完整性约束和函数依赖约束</strong>。</p><p>​    </p><p>​    动态约束是指数据库从一种状态转变为另一种状态时的新、旧值之间所应满足的约束条件，它是反映数据库状态变迁的约束。</p><p>​    动态约束主要表现在：</p><p>​    1）动态列级约束。修改列定义或列值时应满足的约束条件。<strong>包括修改列定义时的约束</strong>（将允许空值的列修改为不允许空值，记录中有一列为空值，拒绝修改）<strong>修改列值时的约束</strong>（修改列值有时需要参照其旧值）。</p><p>​    2）动态元组约束：指需改元组的值时元组中各个字段间需要满足某种约束条件。</p><p>​    3）动态关系约束：动态关系约束是加在关系变化前后状态上的限制条件。例如，事物一致性、原子性等约束条件。</p><p>​    </p><p>​    完整性约束又可以分为立即执行的约束和延迟执行的约束。</p><p>​    立即执行约束：检查是否违背完整性约束的时机是在一条语句执行完后立即检查。</p><p>​    延迟执行约束：需要延迟到整个事务执行结束后再进行检查。</p><p>​    </p><h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>​    实体完整性要求基本表的主码值唯一且不允许为空值。primary key 指定</p><p>​    实体完整性的检查和违约处理：</p><p>​    1）检查主码是否唯一。如果不唯一则拒绝插入或修改。（索引或顺序查找）</p><p>​    2）检查主码的各个属性是否为空，只要有一个为空则拒绝插入或修改。</p><h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><p>​    参照完整性为若干个表中的相应元组建立联系。参照完整性定义是使用 create table 语句中的 foreign key 和 references 短语来实现，或通过 alter table 语句中的 add foreign key 来实现。</p><p>​    参照完整性的检查和违约处理：</p><p>​    1）拒绝执行。如果发生了违约，阻止操作。</p><p>​    2）级联操作。当删除或修改被参照关系的某个元组造成了与参照关系的不一致时，则删除或修改参照表中所有不一致的元组。级联操作必须在定义外码时给出定义（在外码定义最后追加 on delete/update cascade）。</p><p>​    3）设置为空值。如果外码可以为空，发生了违约则将外码置空。</p><p>​    4）置空值删除。删除被参照关系的元组，并将被参照关系中相应元组的外码置空值。</p><h4 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h4><h5 id="属性上的约束"><a href="#属性上的约束" class="headerlink" title="属性上的约束"></a>属性上的约束</h5><p>​    包括：列值非空、列值唯一、设置默认值和满足 check 定义。如果不满足则拒绝相应的操作。</p><p>​    以上约束分别通过 not null、unique、default+默认值、check 实现。</p><h5 id="元组上的约束"><a href="#元组上的约束" class="headerlink" title="元组上的约束"></a>元组上的约束</h5><p>​    元组上的约束可以设置不同属性之间的取值相互约束条件，也是用 check 实现。插入元组或修改属性的值时，RDBMS 检查元组上的约束条件是否满足，否则拒绝操作。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/fNQagDl4ZItoTWi.png" alt="image-20200405164250636"></p><p>​    第一个 check 为属性上的约束，放在属性定义后，第二个 check 为元组上的约束。    </p><h4 id="完整性约束的修改"><a href="#完整性约束的修改" class="headerlink" title="完整性约束的修改"></a>完整性约束的修改</h4><p>​    要修改约束必须先删除约束，然后加入新的约束。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/n9JVSWwL5aC14o8.png" alt="image-20200405164505007"></p><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>​    若要对 select 语句返回的结果值进行逐行处理，必须使用游标。可对游标的当前位置进行更新、查询和删除，使用游标必须经历 5 个步骤：</p><p>​    1）定义游标：declare；</p><p>​    2）打开游标：open；</p><p>​    3）逐行提取游标集中的行：fetch；</p><p>​    4）关闭游标：close；</p><p>​    5）释放游标：deallocate；</p><h4 id="游标的使用"><a href="#游标的使用" class="headerlink" title="游标的使用"></a>游标的使用</h4><h5 id="定义游标"><a href="#定义游标" class="headerlink" title="定义游标"></a>定义游标</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/vcoWwbID6UaBy2i.png" alt="image-20200405165033658"></p><p>​    read only 表示当前游标集中的元组仅可以查询，不可以修改。update表示可以对当前游标集中的元组进行更新操作，如果有 of &lt; columnName_list &gt;，表示仅可以对游标集中指定的属性列进行更新操作。</p><h5 id="打开游标"><a href="#打开游标" class="headerlink" title="打开游标"></a>打开游标</h5><p>​    系统按照游标的定义从数据库中将数据检索出来，放在内存的游标集中，并为游标集指定一个游标，该游标指向游标集中的第一个元组。</p><p>​    打开游标的语法：open &lt; cursorName &gt;</p><h5 id="获取当前游标值"><a href="#获取当前游标值" class="headerlink" title="获取当前游标值"></a>获取当前游标值</h5><p>​    要对当前游标所指向的元组进行操作，必须获取当前游标所指向的元组，其语法是</p><p>​    fetch &lt; cursorName &gt; into &lt; @variableName_list &gt;</p><p>​    <strong>获取当前游标的值，必须将当前游标所指向的元组的各个属性值分别用变量接收，其变量个数、数据类型必须与定义游标中的 select 子句所定义的属性（或表达式）个数数据类型相一致。</strong></p><p>​    SQL Server 中，变量名前面必须使用 @ 符号，使用一个 @ 符号位局部变量，使用两个 @ 为全局变量。</p><p>​    执行一次该语句，系统将当前游标所指向的元组属性放到变量中，然后游标自动下移一个元组。当游标移至尾部，则不可以再读取游标，必须关闭游标再重新打开游标。可以通过检查全局变量 @@FETCH_STATUS 来判断是否已经读完游标集中所有行。</p><p>​    @@FETCH_STATUS 的值有：</p><p>​    0 ：fetch 语句成功，表示已经从游标集中获取了元组值。</p><p>​    1：fetch 语句失败或此行不在结果集中。</p><p>​    2：被提取的行不存在。</p><h5 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h5><p>​    close  &lt; cursorName &gt;</p><h5 id="释放游标所占用的存储空间"><a href="#释放游标所占用的存储空间" class="headerlink" title="释放游标所占用的存储空间"></a>释放游标所占用的存储空间</h5><p>deallocate  &lt; cursorName &gt;</p><h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/NUanJEF7lpHYyhA.png" alt="image-20200405195554371"></p><h4 id="对当前游标集的修改"><a href="#对当前游标集的修改" class="headerlink" title="对当前游标集的修改"></a>对当前游标集的修改</h4><p>​    可以对当前游标集中的元组执行删除和更新操作。</p><h5 id="删除游标集中的当前行"><a href="#删除游标集中的当前行" class="headerlink" title="删除游标集中的当前行"></a>删除游标集中的当前行</h5><p>​    delete from &lt; tableName &gt; where current of &lt; cursorName  &gt;</p><h5 id="更新游标集中的当前行"><a href="#更新游标集中的当前行" class="headerlink" title="更新游标集中的当前行"></a>更新游标集中的当前行</h5><p>​    update &lt; tableName &gt;</p><p>​    set &lt; columnName &gt;=&lt; expr &gt;[,&lt; columnName &gt;=&lt; expr &gt;…]</p><p>​    where current of &lt; cursorName &gt;</p><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>​    存储过程是为了完成特定功能汇集而成的一组命名了的 SQL 语句集合，该集合编译后存放在数据库中，可按实际情况重新编译。</p><p>​    使用存储过程的优点：将业务操作封装、便于事务管理、实现一定程度的安全性保护、特别适合统计和查询操作、减少网络通信量。</p><h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/vXtEcyQObCRpxT6.png" alt="image-20200405200322658"></p><p>​    output：输出参数，被调用者获取使用。</p><h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><p>​    存储过程创建后存放在数据库中，当要使用存储过程时，必须执行命令 execute。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/GlUWZ8rtMVhSO5y.png" alt="image-20200405200618013"></p><h4 id="修改和删除存储过程"><a href="#修改和删除存储过程" class="headerlink" title="修改和删除存储过程"></a>修改和删除存储过程</h4><h5 id="修改存储过程"><a href="#修改存储过程" class="headerlink" title="修改存储过程"></a>修改存储过程</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/z1no7G8baR5Yp9t.png" alt="image-20200405200745811"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/s79bqRDMnWKrEvm.png" alt="image-20200405200755212"></p><h5 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h5><p>​    drop procedure &lt; procedureName &gt;</p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>​    触发器是用户定义在关系表上的一类由事件驱动的存储过程，由服务器自动激活。触发器可以进行更为复杂的检查和操作，具有更精细和强大的数据控制能力。</p><p>​    有两个特殊的表用在触发器语句中，不同的数据库其名称不一样。以SQL Server 为例介绍触发器。</p><p>​    1）deleted 表。存储 delete 和 update 语句执行时所影响的行的拷贝，在 delete 和 update 语句执行前被作用的行转移到 deleted 表中，即将被删除的元组或修改前的元组值存入该表中。</p><p>​    2）inserted 表。存储 insert 和 update 语句执行时所映像的行的拷贝，在 insert 和 update 语句执行期间，新行被同时加到 inserted 表和触发器中，即将被插入的元组或修改后的元组存入该表中，同时也更新基本表。</p><h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/KzmCBDclWnp6hxR.png" alt="image-20200405201801494"></p><p>​    &lt;insert|update|delete&gt; ：触发器事件。</p><h4 id="修改和删除触发器"><a href="#修改和删除触发器" class="headerlink" title="修改和删除触发器"></a>修改和删除触发器</h4><p>​    修改触发器：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/rSV8gNdlaT6vQwx.png" alt="image-20200405202018722"></p><p>​    删除触发器：</p><p>​    drop trigger &lt; triggerName &gt;</p><h4 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h4><p>​    触发器常用于保证完整性，并在一定程度上实现安全性，如用触发器来进行审计。</p><h2 id="事务管理与恢复"><a href="#事务管理与恢复" class="headerlink" title="事务管理与恢复"></a>事务管理与恢复</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h4><p>​    对于用户而言，事务是具有完整逻辑意义的数据库操作序列的集合。对于数据库管理系统而言，事务则是一个读写操作序列。这些操作是一个不可分割的逻辑工作单元，要么都做，要么都不做。</p><p>​    通常有有两种类型的事务结束语句：</p><p>​    1）事务提交（commit）：将成功完成事务的执行结果（即更新）永久化，并释放事务占有的全部资源。</p><p>​    2）事务回滚（rollback）：中止当前事务、撤销其对数据库所做的更新，并释放事务占有的全部资源。</p><p>​    </p><p>SQL Server 数据库提供了 3 种类型的事务模式：显式事务、隐式事务及自定义事务。</p><p>​    显式事务是指用户使用了 Transact-SQL 事务语句所定义的事务，其事务语句包括：</p><p>​    事务开始：begin transaction</p><p>​    事务提交：commit transaction，commit work</p><p>​    事务回滚：rollback transaction，rollback work</p><p>​    隐式事务是指事务提交或回滚后，SQL Server 自动开始新的事务。该类事务不需要采用 begin transaction 语句标识事务的开始。</p><p>​    自动定义事务模式：当一个语句成功执行后，它被自动提交，而当执行过程中出错时，则被自动回滚。</p><h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h4><p>​    1）原子性（Atomicity）。事务的所有操作要么全部被执行，要么都不执行。</p><p>​    2）一致性（Consistency）。一个单独执行的事务应保证其执行结果的一致性，即总是将数据库从一个一致性状态转化到另一个一致性状态。</p><p>​    3）隔离性（Isolation）。当多个事务并发执行时，一个事务的执行不能影响另一个事务，即并发执行的各个事务不能相互干扰。</p><p>​    4）持久性（Durability）。一个事务提交成功后，它对数据库的改变必须是永久的，即使随后系统出现故障。</p><h4 id="事务并发执行与调度"><a href="#事务并发执行与调度" class="headerlink" title="事务并发执行与调度"></a>事务并发执行与调度</h4><p>​    数据库管理系统允许多个事务并发执行，其主要优点是增加系统吞吐量和减少平均响应时间。</p><p>​    </p><p>​    并发事务带来的问题：</p><p>​    1）<strong>脏读（Dirty Read）</strong>：一个事务正在访问数据并对数据进行修改，修改还没有提交到数据库，这是另外一个事务访问了这个数据，然后使用了这个数据。这个数据更改之前的数据，另一个事务读到的数据是“脏数据”，依靠“脏数据”所做的操作是不正确的。</p><p>　2）<strong>丢失修改（Lost to modify）</strong>：一个事务读取一个数据时，另外一个事务也访问了该数据，在第一个事务中修改数据后，第二个事务也修改了这个数据。第一个事务内的修改结果丢失，因此称作丢失修改。例如事务1读取某表中的数据 A=20 ，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改丢失。</p><p>　3）<strong>不可重复读（Unrepeatable read）</strong>：在一个事务内多次读同一个数据在这个事务还没有结束时，另一个事务也访问该数据。在第一个事务的两次读之间，另一个事务可能已经修改了数据，导致两次读取的数据可能不太一样。</p><p>　4）<strong>幻读（Phanatom read）</strong>：幻读与不可重复读类似。发生在一个事务读了几行数据，接着另一个并发 事务插入了一些数据。在随后的查询中第一个事务就会发现多了一些原本不存在的记录，好像发生了幻觉。    </p><h4 id="事务调度及正确性准则"><a href="#事务调度及正确性准则" class="headerlink" title="事务调度及正确性准则"></a>事务调度及正确性准则</h4><p>​    事务并发执行顺序是随机的，将由多个事务操作组成的随机执行序列称为一个调度。对于一组事务操作组成的调度序列而言，应满足下列条件：</p><p>​    1）该调度包括该组事务的全部操作；</p><p>​    2）属于同一个事务的操作应保持在原事务中的执行顺序。</p><p>​    串行调度：在调度 S 中，如果属于同一事务的操作都是相邻的，则称 S 是串行调度。</p><p>​    冲突操作：在一个调度 S 中，如果 A 和 B 是不同事务在相同数据对象上的操作，并且其中至少有一个是写操作，则称 A 与 B 是冲突操作。</p><p>​    冲突等价：如果一调度 S 可以经过交换一系列非冲突操作执行的顺序而得到一个新的调度 S‘ ，则称 S 与 S’ 是冲突等价的。</p><p>​    冲突可串行化：如果一调度 S 与一串行调度是冲突等价 的，则称 S 是冲突可串行化的。</p><h5 id="判断调度是否可串行化的方法"><a href="#判断调度是否可串行化的方法" class="headerlink" title="判断调度是否可串行化的方法"></a>判断调度是否可串行化的方法</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/KOWfz9e1juAwros.png" alt="image-20200406101649482"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/4C2VSsKYmMUngI8.png" alt="image-20200406101753978"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/W5y9jOtbTdmeuCz.png" alt="image-20200406101814976"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/1uJ9kfFZqtl7VEz.png" alt="image-20200406101908368"></p><p>​    图 10-2(a) 中，对于 A 的并发访问：R1(A), W1(A), R2(A), W2(A)，存在 W1(A)后执行R2(A)，W1(A)后执行W2(A)。故 T1 -&gt; T2。优先图中无环可以串行化。</p><p>​    图 10-2(b) 中，对于 A 的并发访问：R2(A), W2(A), R1(A), W1(A) ，存在 W2(A)后执行R1(A)，W2(A)后执行W1A)。故 T2 -&gt; T1。优先图中无环可以串行化。</p><p>​    图10-8 中，对于 A 的并发访问：R4(A), W4(A), R6(A), W6(A)，存在 W4(A)后执行R6(A)，W4(A)后执行W6(A)。故 T4-&gt; T6。对于 B 的并发访问：R6(B), W6(B), R4(B), W4(B)，存在 W6(B)后执行R4(B)，W6(B)后执行W4(B)。故 T6-&gt; T4。优先图中有环，不可串行化。</p><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="基于封锁的协议"><a href="#基于封锁的协议" class="headerlink" title="基于封锁的协议"></a>基于封锁的协议</h4><p>​    并发控制机制大体上可分为悲观的和乐观的两种。悲观的并发控制方法认为数据库 的一致性经常会收到破坏，因此在事务访问数据对象前采取一定措施加以控制，只有得到访问许可时，才能访问数据对象，如<strong>基于封锁的并发控制方法</strong>。而乐观的并发控制方法则认为数据库的一致性通常不会得到破坏，故事务执行时可直接访问数据对象，只在事务结束时才验证数据库的一致性是否会遭到破坏，如基于有效性验证方法。</p><p>​    基于封锁的并发控制方法的基本思想是：当事务 <em>T</em> 需访问数据对象 <em>Q</em> 时，先申请对 <em>Q</em> 的锁。如批准获得，则 <em>T</em> 继续执行，且此后不允许其他任何事物修改 <em>Q</em>，直到事务 <em>T</em> 释放 <em>Q</em> 上的锁为止。</p><p>​    基本锁类型：</p><p>​    1）共享锁（Shared Lock，记为 S ）：如果事务 <em>T</em> 获得的对象 <em>Q</em> 上的共享锁，则 <em>T</em> 可读 <em>Q</em> 但不能写 <em>Q</em> 。</p><p>​    2）排他锁（eXclusive lock，记为 X ）：如果事务 <em>T</em> 获得的对象 <em>Q</em> 上的排他锁，则 <em>T</em> 可读 <em>Q</em> 又能写 <em>Q</em> 。</p><p>​    <strong>一个数据对象 <em>Q</em> 上可能有多个（被不同事务拥有的）共享锁，但任何时候只能有一个排他锁。</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/sNHdY7A2PhBy3ET.png" alt="image-20200406104004431"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/JX7bQ8va4hoMHNK.png" alt="image-20200406104529309"></p><p>​    图10-13 中的调度存在以下问题：</p><p>​    1）脏读。T2 步骤 11 读了 T1 修改后的数据，而T1 在步骤 12 回滚了。</p><p>​    2）不可重复读。如 T3 两次读到 A 的值不同。</p><p>​    3）不可串行化。</p><p>​    出现上述问题的原因是<strong>事务过早地释放了锁</strong>，如果规定事务在结束后才释放其持有地锁则可以保证调度的可串行性。但这会导致系统性能下降。</p><h4 id="两阶段封锁协议"><a href="#两阶段封锁协议" class="headerlink" title="两阶段封锁协议"></a>两阶段封锁协议</h4><p>​    两阶段封锁协议要求每个事务分两个阶段提出申请锁和解锁申请。</p><p>​    1）增长阶段：事务可以获得锁，但不能释放锁。</p><p>​    2）缩减阶段：事务可以释放锁，但不能获得新锁。</p><p>​    一开始，事务处于增长阶段，事务根据需要获得锁。一旦该事务释放了锁，它就进入了缩减阶段，不能再发出加锁请求。</p><p>​    两阶段封锁协议能保证冲突可串行化。对于任何事务，调度中该事务获得其最后加锁的时刻（增长阶段结束点）称为事务的封锁点。多个事务可以根据它们的封锁点进行排序，而这个顺序就是并发事务的一个冲突可串行化顺序。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/6OxDya25XE3bVAo.png" alt="image-20200406105546498"></p><p>​    图10-14 采用了两阶段封锁，允许 T4 在获得全部锁后（A 和 B 上的排他锁）提前释放部分锁（步骤 7 释放了 A 上的排他锁），T5得以提前执行，从而提高了 T4 和 T5 的并发度，该调度是可串行化 的。</p><p>​    两阶段封锁保证了并发执行事务的正确性，但仍存在两个主要问题：</p><p>​    1）可能导致死锁，即持有锁的事务出现相互等待都不能继续执行。解除死锁的一个简单方法是超时机制。如果一个事务为某个锁等待的时间过长，可以悲观得认为死锁已经发生，回滚该事务并重启。</p><p>​    2）不能避免读脏数据。</p><p>​    另一个两阶段封锁得变体是强两阶段封锁协议，它要求事务提交之前不得释放任何锁。事务可以按其提交得顺序串行化。</p><h4 id="封锁协议总结"><a href="#封锁协议总结" class="headerlink" title="封锁协议总结"></a>封锁协议总结</h4><p>在运用 X 锁和 S 锁这两种基本封锁对数据对象加锁时，还要约定一些规则。例如，何时申请 X 锁和 S 锁、封锁时间、何时释放等。这些规则称为封锁协议。</p><p>对并发操作的不正确调度可能会带来脏读、丢失修改、不可重复读等不一致性问题。三级封锁协议分别在不同程度上解决了这些问题，为并发操作的正确调度提供一定的保证。</p><ol><li>一级封锁协议，事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。</li><li>二级封锁协议，在一级封锁协议基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁。</li><li>三级封锁协议，在一级封锁协议基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。</li></ol><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/RkMmTrJnKHz3OWl.png" alt="image-20200511093025700"></p><p>总结：三个等级的封锁协议都是事务结束后释放 X 锁，不同的是一级封锁对于读取数据不加 S 锁，二级封锁加 S 锁，但在读取操作结束后就释放，三级封锁加 S 锁，在事务结束后释放。一级封锁保证不会丢失修改，二级封锁保证不会丢失修改和脏读，三级封锁保证不会丢失修改、脏读和可重复读。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/GvaPKLouCjOWF9s.png" alt="image-20200511095857695"></p><h4 id="活锁与死锁"><a href="#活锁与死锁" class="headerlink" title="活锁与死锁"></a>活锁与死锁</h4><p>活锁就是一个事务一直处于“饥饿”状态。死锁即为临界资源的循环占用。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/F5Vo6EMKPB9akYb.png" alt="image-20200511100149015"></p><p>避免出现“饥饿”现象的最简方法为采用 FCFS 策略。</p><p>避免死锁的方法有<strong>预防死锁</strong>和<strong>诊断并解除死锁</strong>两种。</p><p>预防死锁：</p><ol><li>一次封锁法，每个事务必须一次将所有使用的数据全部加锁。</li><li>顺序封锁法，对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁。</li></ol><p>诊断和解除死锁</p><ol><li>超时法，如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。</li><li>等待图法，出现环则发现死锁。</li></ol><h4 id="封锁的粒度"><a href="#封锁的粒度" class="headerlink" title="封锁的粒度"></a>封锁的粒度</h4><p>封锁对象的大小称为封锁粒度。封锁对象可以是逻辑单元，也可以是物理单元。封锁粒度与系统的并发度和并发控制的开销密切相关，封锁的粒度越大，并发度越小，系统的开销也越小；封锁的粒度越小，并发度较高，系统开销也较大。</p><h5 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h5><p>多粒度树的根结点是整个数据库，表示最大的数据粒度。叶节点表示最小的数据粒度。</p><p>多粒度封锁协议允许多粒度树中的每个结点被独立地加锁，对一个结点加锁意味着这个结点所有子节点也被加以同样类型的锁。在多粒度封锁中，一个数据对象可能以两种方式封锁：显式封锁和隐式封锁。显示封锁是应事务的要求直接加到数据对象上的锁；隐式封锁是该数据对象没有被独立加锁，由于其上级结点加锁而使该数据对象加上了锁。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Mix5FDt8dfVoYwX.png" alt="image-20200511122559581"></p><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>意向共享锁（Intent Share Lock，IS 锁）意向排他锁（Intent Exclusive Lock，IX 锁）；共享意向排他锁（Share Intent Exclusive Lock，SIX 锁）。</p><ol><li>IS 锁，如果对一个数据对象加 IS 锁，表示它的子结点拟加 S 锁。</li><li>IX 锁，如果对一个数据对象加 IX 锁，表示它的子结点拟加 X 锁。</li><li>SIX 锁，如果对一个数据对象加 SIX 锁，表示对它加 S 锁，再加 IX 锁。</li></ol><p>在具有意向锁的多粒度封锁方法中，任意事务 T 要对一个数据对象加锁，必须先对它的上层结点加意向锁。申请封锁时应该按自上而下的次序进行，释放封锁时则应该按自下而上的次序进行。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/WrXlch5Ly9KAwoS.png" alt="image-20200511123052840"></p><p>图 b 中，所谓锁的强度是指它对其他锁的排斥程度。一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然。</p><h4 id="其他并发控制机制"><a href="#其他并发控制机制" class="headerlink" title="其他并发控制机制"></a>其他并发控制机制</h4><p>并发控制的方法除了封锁技术外还有时间戳方法、乐观控制法和多版本并发控制等。</p><p>时间戳方法给每一个事务盖上一个时标，即事务开始执行的时间。每个事务具有唯一的时间戳，并按照这个时间戳来解决事务的冲突操作。</p><p>乐观控制阀认为书屋执行时很少发生冲突，不对事务进行特殊的管制，而是让它自由执行，事务提交前再进行正确性检查。如果发生冲突则回滚事务。</p><p>多版本并发控制是指数据库中通过维护数据对象的多个版本信息来实现高效并发控制的一种策略。</p><h3 id="恢复与备份"><a href="#恢复与备份" class="headerlink" title="恢复与备份"></a>恢复与备份</h3><h4 id="故障分类及恢复策略"><a href="#故障分类及恢复策略" class="headerlink" title="故障分类及恢复策略"></a>故障分类及恢复策略</h4><p>​    1）事务故障。事务未运行至正常终止点就夭折了。</p><p>​    2）系统故障。突发事件导致系统停止运行。</p><p>​    3）介质故障。硬件损坏。</p><p>​    4）其他故障。有人攻击。</p><h4 id="事务访问数据方式"><a href="#事务访问数据方式" class="headerlink" title="事务访问数据方式"></a>事务访问数据方式</h4><p>​    对于一个事务而言，它是通过 3 个地址空间同数据库进行交互：</p><p>​    1）保存数据库元素的磁盘块空间——物理数据库。</p><p>​    2）缓冲区管理器所管理的内存地址空间——数据缓冲区。</p><p>​    3）事务的局部地址空间——事务工作区。</p><p>​    当事务要读取数据库元素时，首先必须将该元素从物理数据库读取到数据缓冲区中，除非它已经在缓冲区中，然后再将缓冲区中的内容读到事务工作区中。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/GZAjXMbNu4z7apB.png" alt="image-20200406111338451"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/TcfswaB6NqoKzdp.png" alt="image-20200406111426865"></p><h4 id="基于日志的故障恢复策略"><a href="#基于日志的故障恢复策略" class="headerlink" title="基于日志的故障恢复策略"></a>基于日志的故障恢复策略</h4><p>​    日志是 DBMS 记录数据库全部更新操作的序列文件。通常一个数据库系统只有一个日志文件，为所有事务共享，其主要特点有：</p><p>​    1）日志文件记录了数据库的全部更新顺序。</p><p>​    2）每条日志都记录在日志的尾部，故日志文件是一个追加文件。</p><p>​    3）DBMS 允许事务的并发执行导致日志文件是“交错的”。</p><p>​    4）属于单个事务的日志顺序与该事务的更新操作顺序是一致的。</p><p>​    5）日志记录通常是先写到日志缓冲区中，然后写到稳定存储器中。</p><p>​    数据库中的日志记录有两种类型：</p><p>​    1）记录数据更新操作的日志记录，包括 update，insert 和 delete 操作。</p><p>​    2）记录事务操作的日志记录，包括start，commit 和 abort 操作。</p><p>​    它们的具体记录格式如下：</p><p>​    &lt; Ti, A, V1,V2 &gt; 表示 Ti 对数据元素 A 执行了更新操作，V1为 A 更新前的值，V2表示 A 更新后的值。</p><p>​    &lt; Ti, START &gt; 表示事务 Ti 已经开始。此时 DBMS 完成对事务的初始化工作，如分配事务工作区等。</p><p>​    &lt; Ti, COMMIT &gt; 表示事务 Ti 已经提交。</p><p>​    &lt; Ti, ABORT &gt; 表示事务已经终止，即事务执行失败。</p><p>​    为了保证数据库能运用日志进行恢复，要求日志文件必须放到稳定存储器上，并且要求每条日志记录必须在其所包含数据元素的更新值写到稳定存储器之前写到稳定存储器上，即<strong>先写日志</strong>规则。</p><h5 id="UNDO-操作"><a href="#UNDO-操作" class="headerlink" title="UNDO 操作"></a>UNDO 操作</h5><p>​    事务 T 执行过程中修改了数据库后，可能由于某种原因事务中止或系统崩溃，可使用 UNDO 恢复技术将 T 修改的全部数据对象值恢复到 T 开始前的状态。</p><p>​    对于要 UNDO 的事务 T ，日志中记录有 &lt;T, START&gt; 以及 T 对数据库的所有更新操作的日志记录。UNDO 过程为：从 T 的最后一条更新日志开始，从日志尾向日志头（反向）依次将 T 更新的数据元素恢复为旧值（V1）。</p><p>​    之所以需要 UNDO ，是因为故障发生时未提交事务的修改可能已写到磁盘上。</p><h5 id="REDO-操作"><a href="#REDO-操作" class="headerlink" title="REDO 操作"></a>REDO 操作</h5><p>​    REDO 操作时对已提交事务进行重做，将数据库状态恢复到事务结束后的状态。</p><p>​    对于要 REDO 的事务 T，日志中已经记录了 &lt;T, START&gt;  ，T 的所有更新操作日志以及 &lt;T, COMMIT&gt;。REDO 的过程为：从 T 的第一条更新日志记录来时，从日志头向日志尾（顺向）依次将 T 更新的数据元素值恢复为新值（V2）。</p><p>​    需要 REDO 的原因是，故障发生时可能有些已提交事务的更新数据还未写到磁盘上。</p><h5 id="并发执行事务的基本恢复过程"><a href="#并发执行事务的基本恢复过程" class="headerlink" title="并发执行事务的基本恢复过程"></a>并发执行事务的基本恢复过程</h5><p>​    1）分析阶段。从日志头开始顺向扫描日志，以确定重做事务集和撤销事务集。将既有  &lt;T, START&gt;又有 &lt;T, COMMIT&gt; 日志记录的事务 T 加入重做事务集。将只有  &lt;T, START&gt;没有 &lt;T, COMMIT&gt; 日志记录的事务 T 加入撤销事务集。</p><p>​    2）撤销阶段。从日志尾反向扫描日志，对每一条属于撤销事务集中的事务更新操作日志依次执行 UNDO 操作。</p><p>​    3）重做阶段。从日志头顺向扫描日志，对每一条属于重做事务集中的事务更新操作日志依次执行 REDO 操作。</p><h4 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h4><p>​    检查点是周期性地向日志中写一条检查点记录并记录所有当前活跃的事务，为恢复管理器提供信息，以决定从日志的何处开始恢复。在日志记录中使用 &lt; Checkpoint L &gt;来指定检查点 L 。</p><p>​    图10-19 是系统崩溃时的不同事务状态类型，其中 Tc 为完成最近检查点时刻，Tf 为故障发生时刻。 </p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/TgmJlz6Qevkprni.png" alt="image-20200406114406231"></p><h4 id="备份与介质故障恢复"><a href="#备份与介质故障恢复" class="headerlink" title="备份与介质故障恢复"></a>备份与介质故障恢复</h4><p>​    动态备份是指备份操作与用户事务的执行并发进行，备份期间允许对数据库进行存取或修改。静态备份则要等待用户事务结束然后备份。</p><p>​    具体进行数据备份时可以有两种方式，一种是全备份，一种是增量备份。</p><p>​    全备份是指每次备份全部数据库，而增量备份只备份上次备份后更新过的数据。</p>]]></content>
    
    <summary type="html">
    
      数据库
    
    </summary>
    
    
      <category term="笔记" scheme="https://hoo334.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>课程表</title>
    <link href="https://hoo334.github.io/2020/08/04/%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <id>https://hoo334.github.io/2020/08/04/%E8%AF%BE%E7%A8%8B%E8%A1%A8/</id>
    <published>2020-08-04T02:07:41.000Z</published>
    <updated>2020-08-04T03:00:25.042Z</updated>
    
    <content type="html"><![CDATA[<h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></h4><p>你这个学期必须选修 <code>numCourse</code> 门课程，记为 <code>0</code> 到 <code>numCourse-1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：<code>[0,1]</code></p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><a id="more"></a><p> <strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li>输入的先决条件是由 <strong>边缘列表</strong> 表示的图形，而不是 邻接矩阵 。详情请参见<a href="http://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">图的表示法</a>。</li><li>你可以假定输入的先决条件中没有重复的边。</li><li><code>1 &lt;= numCourses &lt;= 10^5</code></li></ol><p>此题可以看作判断一个有向图是否存在环，如果图中存在环，则不存在拓扑排序。如果图中不存在环，则可能存在不止一种拓扑排序。</p><p>不存在拓扑排序：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200804101354711.png" alt="image-20200804101354711"></p><p>存在拓扑排序：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200804101551878.png" alt="image-20200804101551878"></p><p>上图中存在拓扑排序中的一种为：[0, 2, 1, 3, 5, 6, 4]。</p><p>求拓扑序列方法：不断取下<strong>「入度」为零</strong>的结点直到图中没有结点或没有入度为零的结点，按取下结点的顺序就得到了拓扑排序。</p><p>边缘列表就是存储图的每一条边， <code>[[1,0]]</code>代表存在一条结点 0 到结点 1 的边。</p><p><strong>方法一：BFS</strong></p><p>我们首先统计每个结点的出边信息和入度信息，首先将入度为零的结点加入队列，取下一个结点，并将该结点所指向的结点入度减一，同时将入度减为零的结点加入队列，不断重复这个步骤直到队列为空，取下结点的顺序就是拓扑排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;<span class="comment">//edges[i] 为结点 i 所指向的结点数组</span></span><br><span class="line">    <span class="keyword">int</span>[] indeg;<span class="comment">//indeg[i]为结点 i 的入度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            <span class="comment">//存在 edge[1] 到 edge[0] 的边，把edge[0] 加入到 edge[1]</span></span><br><span class="line">            edges.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//edge[0] 入度加一</span></span><br><span class="line">            ++indeg[edge[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//queue 存储入度为 0 的结点</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indeg[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//visited 记录已经取下的结点个数</span></span><br><span class="line">        <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="comment">//取下一个入度为 0 的结点</span></span><br><span class="line">            <span class="keyword">int</span> u = queue.poll();</span><br><span class="line">            <span class="comment">//将该结点所指向的结点的入度减一</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v : edges.get(u))&#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">//将入度为 0 的结点加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(indeg[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能取下所有结点则存在拓扑排序</span></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(n+m)，其中 n 为课程数，m 为先修课程的要求数。空间复杂度 O(n+m)。</p><p><strong>方法二：DFS</strong></p><p>我们也可以使用深度优先搜索来找到拓扑排序，我们使用一个栈来存储拓扑排序。对于任意一个结点，我们首先访问该结点，继续访问该结点指向的结点，一直递归地进行这个操作，直到当前访问的结点出度为 0 ，就开始递归返回，在返回的过程中将结点加入栈中。对所有未搜索过的结点进行深度优先搜索，最后得到的栈中，从栈顶到栈底就是拓扑排序。</p><p>对于图中的任意结点有三个状态：</p><ul><li>未搜索，还没有搜索到这个结点；</li><li>搜索中，已经搜索过这个结点，还未回溯到该结点，此时这个结点还没有入栈；</li><li>已完成，已经搜索过这个结点，已经将该结点入栈。</li></ul><p>每一轮深度优先搜索开始时，我们选择一个未搜索过的结点。</p><p>算法流程：</p><ul><li><p>将当前搜索的结点 u 标记为搜索中，遍历该结点所指向的每一个结点 v</p><ul><li>如果 v 为 未搜索 ，那么开始搜索 v，等待回溯到 u；</li><li>如果 v 为搜索中，那么图中存在一个环，不存在拓扑序列；</li><li>如果 v 为已完成，v 已经在栈中，u 还不在栈中，满足栈中 u 在 v 的上方，不用操作。</li></ul></li><li><p>当 u 所指向的所有结点都为 已完成 时，将 u 放入栈中，将其标为 已完成。</p></li></ul><p>由于我们不需要拓扑序列，只用判断它是否存在，我们只用一个布尔值来代替栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//visited[i] 为结点 i 的状态，0 代表未搜索，1 代表搜索中，2 代表已完成</span></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            edges.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//拓扑序列存在时搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++)&#123;</span><br><span class="line">            <span class="comment">//不断选取未搜索的结点进行 DFS</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将当前结点 u 状态改为 搜索中</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//选取 u 所指向的结点进行 DFS</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : edges.get(u))&#123;</span><br><span class="line">            <span class="comment">//u 指向的结点 v 未搜索过，递归地搜索</span></span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="comment">//搜索过程中出现环，返回</span></span><br><span class="line">                <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visited[v] == <span class="number">1</span>)&#123;<span class="comment">//存在环，将 valid 设为false，返回</span></span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将结点 u 设为已完成状态</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(n+m)，其中 n 为课程数，m 为先修课程的要求数。空间复杂度 O(n+m)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;207-课程表&quot;&gt;&lt;a href=&quot;#207-课程表&quot; class=&quot;headerlink&quot; title=&quot;207. 课程表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/course-schedule/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;207. 课程表&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;你这个学期必须选修 &lt;code&gt;numCourse&lt;/code&gt; 门课程，记为 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;numCourse-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：&lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="DFS" scheme="https://hoo334.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://hoo334.github.io/tags/BFS/"/>
    
  </entry>
  
</feed>
