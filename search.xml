<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DFS &amp; BFS Medium</title>
    <url>/2020/04/20/DFS&amp;BFSMedium/</url>
    <content><![CDATA[<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h4><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>

<p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1 ，则以其为起始结点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对网格中的每个 1 都做深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//发现一个岛屿</span></span><br><span class="line">                    ++ count;</span><br><span class="line">                    <span class="comment">//将该 1 相连的 1 全部置为 0</span></span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">		<span class="comment">//将第 r 行，第 c 列的 1 相邻的 1 全部置为 0</span></span><br><span class="line">        grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(r-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="string">'1'</span>) dfs(grid, r-<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span>(r+<span class="number">1</span> &lt;rows &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) dfs(grid, r+<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span>(c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="string">'1'</span>)dfs(grid, r, c-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(c+<span class="number">1</span> &lt; cols &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>)dfs(grid, r, c+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//发现一个岛屿</span></span><br><span class="line">                    grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                    ++count;</span><br><span class="line">                    </span><br><span class="line">                    Queue&lt;Integer&gt; neighbors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    neighbors.add(i*cols+j);</span><br><span class="line">                    <span class="comment">//BFS</span></span><br><span class="line">                    <span class="keyword">while</span>(! neighbors.isEmpty())&#123;</span><br><span class="line">                        <span class="comment">//得到保存的行列信息</span></span><br><span class="line">                        <span class="keyword">int</span> id = neighbors.remove();</span><br><span class="line">                        <span class="keyword">int</span> r = id / cols;</span><br><span class="line">                        <span class="keyword">int</span> c = id % cols;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//将第 i 行，第 j 列的 1 相邻的 1 全部置为 0</span></span><br><span class="line">                        <span class="keyword">if</span>(r-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add((r-<span class="number">1</span>)*cols+c);</span><br><span class="line">                            grid[r-<span class="number">1</span>][c] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(r+<span class="number">1</span> &lt;rows &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add((r+<span class="number">1</span>)*cols+c);</span><br><span class="line">                            grid[r+<span class="number">1</span>][c] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add(r*cols + c - <span class="number">1</span>);</span><br><span class="line">                            grid[r][c-<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(c+<span class="number">1</span> &lt; cols &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add(r*cols + c + <span class="number">1</span>);</span><br><span class="line">                            grid[r][c+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>利用gradle添加依赖</title>
    <url>/2020/04/04/Gradle%E4%BE%9D%E8%B5%96%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="利用gradle添加依赖"><a href="#利用gradle添加依赖" class="headerlink" title="利用gradle添加依赖"></a>利用gradle添加依赖</h1><p>1、新建一个gradle项目</p>
<p>可以看到build.gradle</p>
<p><img src="https://i.loli.net/2020/04/04/qxOINuGoR7pAsE2.png" alt="img"></p>
<p> 2、编写gradle.properties</p>
<p><img src="https://i.loli.net/2020/04/04/Bj2opT4nKwUvLyq.png" alt="img"></p>
<p> 3、修改build.gradle编译jar，利用${key} 来获取key的值</p>
<p><img src="https://i.loli.net/2020/04/04/AjhOQ9rK3IHnL8D.png" alt="img"></p>
<p> 4、等待gradle自动导入</p>
<p><img src="https://i.loli.net/2020/04/04/WKCFrN3MavV6ncg.png" alt="img"></p>
<p> 可以看到已经导入完成，开始玩耍。。。</p>
<p>如果遇到依赖下载慢的情况 在build.gradle文件repositories加入：           </p>
<p>maven{ url’<a href="http://maven.aliyun.com/nexus/content/groups/public/&#39;}" target="_blank" rel="noopener">http://maven.aliyun.com/nexus/content/groups/public/&#39;}</a></p>
<p>使用阿里云的maven仓库</p>
<p>mavenLocal()可以让项目先检查本地的仓库，有的话不用下载。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>E-R 模型</title>
    <url>/2020/04/05/E-R-%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="数据库设计过程"><a href="#数据库设计过程" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h3><p>​    1）需求分析：了解和分析系统将要提供的功能及未来数据库的用户需求。</p>
<p>​    2）概念设计：根据需求分析中得到的信息，设计者此阶段须选择适当的数据模型将这些需求转化为数据库的概念模式。例如 <strong>E - R 模型</strong> 是概念设计。</p>
<p>​    3）逻辑设计：将概念设计转化为所选择的数据库管理系统支持的逻辑数据模型，即数据库模式。逻辑数据库设计的任务是将 E - R 模型转化为关系数据库模式。</p>
<p>​    4）模式求精：对已得到的关系数据库模式进行分析找出潜在的问题并加以改进和优化。</p>
<p>​    5）物理设计：为逻辑数据库选取一个最适合现实应用的物理结构。</p>
<p>​    6）应用与安全设计：数据库系统必须指出哪些用户可以访问数据库以及他们通过哪些存储过程访问数据库。</p>
<h3 id="E-R-模型基本概念及表示"><a href="#E-R-模型基本概念及表示" class="headerlink" title="E - R 模型基本概念及表示"></a>E - R 模型基本概念及表示</h3><h4 id="实体与实体集"><a href="#实体与实体集" class="headerlink" title="实体与实体集"></a>实体与实体集</h4><p>​    实体是客观世界中可区别于其他事物的“事物”或“对象”。</p>
<p>​    实体的两个特征：独立存在（一个实体的存在不依赖于其他实体）、可区别于其他实体。</p>
<p>​    实体集是指具有相同类型及相同性质（或属性）的实体集合。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>​    实体是通过一组属性来描述的，属性是实体集中每个实体都具有的描述性性质。在已实体集中，所有实体都具有相同的属性。</p>
<p>​    每个属性所允许的取值范围或集合称为该属性的<strong>域</strong>。</p>
<p>​    E - R 模型中的属性可按如下类型划分：</p>
<p>​    1）简单属性和复合属性。简单属性是指不能再分为更小部分的属性。复合属性指可以进一步划分为更小部分的属性。</p>
<p>​    2）单值属性和多值属性。如果某属性对一个特定实体任何时候都只能有单独的一个值，则称该属性为单值属性，否则为多值属性。例如一个studentNo 属性只对应一个学号，为单值属性。一个phoneNumber属性可能有不同数目的值，为多值属性。</p>
<p>​    3）空值（NULL）属性。当某个属性上没有值时可以使用 NULL 值。</p>
<p>​    4）派生属性，这类属性的值可以从其他属性的值派生出来。例如实体集 Student 的 age 属性表示学生的年龄，它可以由当前日期和生日属性的值计算得到。</p>
<p>​    在 E - R 图中，实体集用矩形表示，属性用椭圆表示，多值属性用双椭圆表示，派生属性用虚线椭圆表示，属性与实体之间用连线表示。</p>
<p><img src="https://i.loli.net/2020/04/05/2lqtAhLbzMSsjE4.png" alt="image-20200405101025891"></p>
<h4 id="联系与联系集"><a href="#联系与联系集" class="headerlink" title="联系与联系集"></a>联系与联系集</h4><p>​    联系集是 n （n &gt;= 2）个实体集上的数学关系，这些实体集不必互异。</p>
<p>​    参与联系的实体集的数目称为联系集的度。</p>
<p>​    下图中，Student 与 Course 之间有 Enroll 联系集，选课联系集上有 Score 属性。课程里面的 PriorCourse 属性参照 Course 关系。 </p>
<p><img src="https://i.loli.net/2020/04/05/kKAVRhcFCMYjawT.png" alt="image-20200405101234923"></p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="映射约束"><a href="#映射约束" class="headerlink" title="映射约束"></a>映射约束</h4><p>​    映射基数指一实体集中的一个实体通过一个联系集能同时与另一个实体集相联系的实体数目。在二元联系中，共有 4 种映射基数：1：1（一对一）、1：m（一对多）、m：1（多对一）、m：n（多对多）。</p>
<p>​    在 E - R 图中，“—&gt;”指向参与联系集中“一”方实体集，线段“—”表示参与联系集中的“多”方实体集。</p>
<h4 id="码约束"><a href="#码约束" class="headerlink" title="码约束"></a>码约束</h4><h5 id="实体集的码"><a href="#实体集的码" class="headerlink" title="实体集的码"></a>实体集的码</h5><p>​    码是一个或多个属性的集合。</p>
<p>​    超码是一个或多个属性的集合，超码中的这些属性可以让我们在一个实体集中唯一地标识一个实体。</p>
<p>​    候选码是极小的超码集，也就是它的任意真子集都不是超码，而他本身是超码。</p>
<p>​    主码是被选中用来在一个关系中区分不同元组的候选码。</p>
<h5 id="联系集的码"><a href="#联系集的码" class="headerlink" title="联系集的码"></a>联系集的码</h5><p>​    二元联系集的主码选择依赖于联系集的映射基数，具体如下。</p>
<p>​    1）一对一：主码可以使用参与联系集中的任何一方实体集的主码；</p>
<p>​    2）一对多和多对一：主码由“多的一方实体集的主码组成；</p>
<p>​    3）多对多：主码由参与联系集中所有实体集的主码组成。</p>
<h4 id="参与约束"><a href="#参与约束" class="headerlink" title="参与约束"></a>参与约束</h4><p>​    如果实体集 A 中的每个实体都参与到联系集 R 中至少一个联系中，则称实体集 A 全部参与联系集 R。</p>
<h4 id="存在依赖与弱实体集"><a href="#存在依赖与弱实体集" class="headerlink" title="存在依赖与弱实体集"></a>存在依赖与弱实体集</h4><p>​    存在一类实体集，其属性不足以形成主码，它们必须依赖于其他实体集的存在而存在，称这样的实体集为<strong>弱实体集</strong>。与此相对，其属性可以形成主码的实体集称为<strong>强实体集</strong>。弱实体集所依赖的强实体集称为<strong>标识实体集</strong>。弱实体集必须与一个标识实体集相关联才有意义，该实体集称为<strong>标识实体集</strong>。</p>
<p>​    对于弱实体集，必须满足下列限制：</p>
<p>​    1）标识实体集和弱实体集必须是一对多联系集。</p>
<p>​    2）弱实体集在标识联系集中是全部参与。</p>
<p>​    E - R 图使用双矩形表示弱实体集，双菱形表示标识联系，用虚下划线表示弱实体集的部分码。下图描述了 CourseClass 及其标识实体集 Course 之间的标识联系集 Arrange 。注意标识联系集没有描述性属性，因为任何所需的属性都可和弱实体相关联。</p>
<p><img src="https://i.loli.net/2020/04/05/JW8oG15VvgYqley.png" alt="image-20200405103558371"></p>
<h3 id="E-R-模型转化为关系模型"><a href="#E-R-模型转化为关系模型" class="headerlink" title="E - R 模型转化为关系模型"></a>E - R 模型转化为关系模型</h3><h4 id="E-R-模型转化方法"><a href="#E-R-模型转化方法" class="headerlink" title="E - R 模型转化方法"></a>E - R 模型转化方法</h4><p>​    1）强实体集转化方法：将实体集的每个属性对应为关系模式的属性，实体集的码作为关系模式的码。</p>
<p>​    2）弱实体集转化方法：弱实体集对应的关系模式属性由弱实体集本身的描述属性加上所依赖的强实体集的主码属性组成。<strong>主码由所依赖的强实体集主码和弱实体集的部分码组成</strong>。</p>
<p>​    3）联系集转化方法    </p>
<p>​        联系集一般转化方法：一个联系集转化为一个关系模式。联系集的主码设置见“联系集的主码“。</p>
<p>​        一对多或多对一联系集的转化：在 ”多“ 方的实体集中添加 ”一“ 方的主码，使 ”一“ 方的主码成为 ”多“ 方 的外码。</p>
<p>​    4）复合属性及多值属性转化方法：对于复合属性，应为每个子属性创建一个单独的属性，而不是为复合属性自身创建的一个单独的属性。</p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><img src="https://i.loli.net/2020/04/14/Kfh8vNiTAQraPkX.png" alt="image-20200414081715392"></p>
<p>​    <img src="https://i.loli.net/2020/04/14/cdBWLxwvRQb9FnV.png" alt="image-20200414081741823"></p>
<p><img src="https://i.loli.net/2020/04/14/Ex5MTBGdXacLkyV.png" alt="image-20200414081901050"></p>
<p><img src="https://i.loli.net/2020/04/14/jGQMRbT2FCctdne.png" alt="image-20200414081801666"></p>
<p><img src="https://i.loli.net/2020/04/14/GPsadUnVFbQJm9l.png" alt="image-20200414081819570"></p>
<p><img src="https://i.loli.net/2020/04/14/eAio7uRHx3bcEQX.png" alt="image-20200414081934207"></p>
<p><img src="https://i.loli.net/2020/04/14/roiPmwSHdhaqDV4.png" alt="image-20200414101333649"></p>
<p><img src="https://i.loli.net/2020/04/14/a1hWbyZrOe6kMSC.png" alt="image-20200414101352852"></p>
<p><img src="https://i.loli.net/2020/04/14/IqghOSjkUmcQD7M.png" alt="image-20200414101445958"></p>
<p><img src="https://i.loli.net/2020/04/14/jJVGegbAKdwCi1S.png" alt="image-20200414101457645"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 运行时数据区</title>
    <url>/2020/04/04/JVM%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h1><p><img src="https://i.loli.net/2020/03/24/ML2CpVz6XdqoJkl.png" alt=""></p>
<p> <img src="https://i.loli.net/2020/03/24/VfYt7yh4pav9ure.png" alt=""></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Git上传本地项目</title>
    <url>/2020/04/04/Git%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="Git上传本地项目"><a href="#Git上传本地项目" class="headerlink" title="Git上传本地项目"></a>Git上传本地项目</h1><p><strong>如何将本地项目push到GitHub上？</strong></p>
<p>GitHub新建一个 repostory 找到URL 例如：<a href="https://github.com/hoo334/test.git" target="_blank" rel="noopener">https://github.com/hoo334/test.git</a></p>
<p>找到项目文件夹 右键git bash here</p>
<p><strong>git init</strong></p>
<p>*<em>git add . *</em></p>
<p><strong>git commit -m “提交信息”</strong></p>
<p><strong>git remote add origin URL</strong></p>
<p><strong>git push -u origin master</strong></p>
<p><strong>提交更新到Github</strong></p>
<p><strong>git status （可选 查看更改文件）</strong></p>
<p><strong>git add 你想要提交更改的文件 或者git add .</strong></p>
<p><strong>git commit -m “提交信息”</strong></p>
<p><strong>git push  origin master</strong></p>
<p><strong>如果操作失误就直接删掉目录内的.git整个文件夹 重新git init。</strong></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 深拷贝和浅拷贝</title>
    <url>/2020/04/04/Java%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="Java-深拷贝和浅拷贝"><a href="#Java-深拷贝和浅拷贝" class="headerlink" title="Java 深拷贝和浅拷贝"></a>Java 深拷贝和浅拷贝</h1><p>　　在浅拷贝中，如果原型对象的成员变量是基本类型时，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</p>
<p>　　对应的深拷贝，如果时成员变量为引用对象也复制一份给复制对象。</p>
<p>　　</p>
<p><strong>实现</strong></p>
<p>　　<strong>1、新建一个 Person 和 PersonId 类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> PersonId personId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.personId = <span class="keyword">new</span> PersonId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        personId.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person cloned = (Person)<span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", personId="</span> + personId +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonId</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PersonId&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　<strong>2、使用 CloneDemo 类来测试浅拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>,<span class="number">20</span>,<span class="number">123</span>);</span><br><span class="line">        Person cloned = person.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"original: "</span>+person);</span><br><span class="line">        System.out.println(<span class="string">"cloned: "</span>+cloned);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Modify Age and Id: "</span>);</span><br><span class="line">        cloned.setAge(<span class="number">55</span>);</span><br><span class="line">        cloned.setId(<span class="number">234</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"original: "</span>+person);</span><br><span class="line">        System.out.println(<span class="string">"cloned: "</span>+cloned);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　<strong>3、输出</strong></p>
<p><img src="https://i.loli.net/2020/04/04/rXmNxfSUGDFlCnW.png" alt="img"></p>
<p> 　可以看到我们修改了拷贝对象的年龄和ID，原始对象的年龄还是20，原始对象的ID却变成了我们修改后的值，我们并没有对原始对象的ID进行修改，这里说明浅拷贝对于对象仅仅是拷贝了一个对象的引用而已。</p>
<p>　　<strong>4、接下来我们修改 Person 类的 clone() 方法，实现深拷贝。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Person cloned = (Person)<span class="keyword">super</span>.clone();</span><br><span class="line">    cloned.personId = personId.clone();</span><br><span class="line">    <span class="keyword">return</span> cloned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　<strong>5、为了拷贝PersonId 的对象我们需要PersonId 类实现 Cloneable 接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonId</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PersonId&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonId <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (PersonId)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　<strong>6、再次运行 CloneDemo 输出</strong></p>
<p><img src="https://i.loli.net/2020/04/04/3jUA4G2YcBlKQCq.png" alt="img"></p>
<p> 　可以看到 原始对象的ID 值没有被修改。</p>
<p>　　<strong>7、使用序列化实现深拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> PersonId personId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.personId = <span class="keyword">new</span> PersonId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        personId.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">try</span>(ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(bout)) &#123;</span><br><span class="line">                out.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>(InputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray()))&#123;</span><br><span class="line">                ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">                <span class="keyword">return</span> (Person)in.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            CloneNotSupportedException e2 = <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">            e2.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> e2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", personId="</span> + personId +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonId</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PersonId&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonId <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (PersonId)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　所有写入流的对象都要实现 Serializable 接口。将 Person 对象写入流中然后再从流中读取出来实现深拷贝。</p>
<p>　　 输出：</p>
<p><img src="https://i.loli.net/2020/04/04/q4buBy96jFGdP73.png" alt="img"></p>
<p><strong>总结</strong></p>
<p>　　<strong>若要实现深拷贝，如果对象中引用了其他对象，必须将引用的对象也克隆。</strong></p>
<p>　　</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Object</title>
    <url>/2020/04/14/Object/</url>
    <content><![CDATA[<h1 id="java-lang-Object"><a href="#java-lang-Object" class="headerlink" title="java.lang.Object"></a>java.lang.Object</h1><p>类Object是类层次结构的根。 每个类都有Object作为超类。 所有对象，包括数组，实现这个类的方法。</p>
<h3 id="类层次结构"><a href="#类层次结构" class="headerlink" title="类层次结构"></a>类层次结构</h3><p><img src="https://i.loli.net/2020/04/14/6IRKvZyzNhxYTgk.png" alt="image-20200414205022670"></p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>public Object(){}</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives"></a>registerNatives</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 中有两种方法：Java 方法和本地方法。Java 方法是由 Java 语言编写，编译成字节码，存储在 class 文件中。本地方法是由其他语言（比如 C 、C++ 、汇编）编写的，编译成和处理器相关的机器代码。本地方法保存在动态链接库中，格式是各个平台专有的。Java 方法是平台无关的，但本地方法不是。运行中的 Java 程序调用本地方法是，虚拟机装载包含这个本地方法的动态库。本地方法是联系 Java 程序和底层主机操作系统的连接方法。</p>
<p>本地方法的实现是由其他语言编写并保存在动态链接库中，因此在 Java 类中不需要方法实现。registerNatives() 本质上就是一个本地方法，但这又是一个区别于一般本地方法的本地方法，从本地方法名可以猜测出该方法是用来注册本地方法的。上述代码的功能就是先定义了registerNatives()方法，然后当该类被加载的时候，调用该方法完成对该类中本地方法的注册。</p>
<p>凡是包含registerNatives()本地方法的类，同时也包含了其他本地方法。所以，显然，当包含registerNatives()方法的类被加载的时候，<strong>注册的方法就是该类所包含的除了registerNatives()方法以外的所有本地方法</strong>。</p>
<p>一个Java程序要想调用一个本地方法，需要执行两个步骤：第一，通过System.loadLibrary()将包含本地方法实现的动态文件加载进内存；第二，当Java程序需要调用本地方法时，虚拟机在加载的动态文件中定位并链接该本地方法，从而得以执行本地方法。registerNatives()方法的作用就是取代第二步，让程序主动将本地方法链接到调用方，当Java程序需要调用本地方法时就可以直接调用，而不需要虚拟机再去定位并链接。</p>
<h4 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<p>返回运行时类的Object 。 返回Class对象被 static synchronized 所表示的类方法修饰。<br>实际结果的类型是Class&lt;? extends |X|&gt;，其中|X| 是getClass被调用时静态类型的擦除。 例如，下列代码不需要强制转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Number n = <span class="number">0</span>; </span><br><span class="line">Class&lt;? extends Number&gt; c = n.getClass();</span><br></pre></td></tr></table></figure>



<h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回该对象的哈希码值。 为其他哈希表提供支持，例如 java.util.HashMap 。<br>一般 hashCode 满足以下规则：</p>
<ul>
<li><p>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用，hashCode方法都必须始终返回同一个值。在一个应用程序与另一个应用程序的执行过程中，执行hashCode方法所返回的值可以不一致。</p>
</li>
<li><p>如果两个对象由 equals() 判断为 true ，那么他们的哈希码值必须相等。</p>
</li>
<li><p>如果两个对象由 equals() 判断为 false ，那么他们的哈希码值可以相等。应该为不同的对象生成不同的哈希码来提高哈希表的性能。哈希码值一般是将对象地址转成一个整数来得到。</p>
</li>
</ul>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断某个其他对象是否 “等于” 这个对象。默认比较的是两个对象的地址，当且仅当 this 和 obj 同时指向同一个对象时返回 true。</p>
<p>按照约定，equals要满足以下规则。</p>
<ul>
<li><strong>自反性</strong>:  x.equals(x) 一定是true</li>
<li><strong>对null</strong>:  x.equals(null) 一定是false</li>
<li><strong>对称性</strong>:  x.equals(y)  和 y.equals(x)结果一致</li>
<li><strong>传递性</strong>:  a 和 b equals , b 和 c  equals，那么 a 和 c也一定equals。</li>
<li><strong>一致性</strong>:  在某个运行时期间，2个对象的状态的改变不会影响equals的决策结果，那么，在这个运行时期间，无论调用多少次equals，都返回相同的结果。</li>
</ul>
<p>通常 equals 方法被重写时，必须重写 hashcode 方法。如果重写了 equals 方法，没有重写 hashcode 方法，判断两个值相等的对象时，当 equals 方法判断为 true（对象的值相等则为 true）时，由于两个值相等的对象地址不一样，所以生成的 hashcode 也不一样。违反了 hashcode 的规则：equals 为 true 两个对象的哈希码值必须相等。</p>
<h4 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<p>创建并返回此对象的副本。按照惯例，返回的对象应该通过调用<code>super.clone</code>获得。</p>
<p><code>clone</code>的方法<code>Object</code>执行特定的克隆操作。  首先，如果此对象的类不实现接口<code>Cloneable</code>  ，则抛出<code>CloneNotSupportedException</code> 。  请注意，所有数组都被认为是实现接口<code>Cloneable</code>  ，并且数组类型<code>T[]</code>的<code>clone</code>方法的返回类型是<code>T[]</code>  ，其中T是任何引用或原始类型。  否则，该方法将创建该对象的类的新实例，并将其所有字段初始化为完全符合该对象的相应字段的内容，就像通过赋值一样。  这些字段的内容本身不被克隆。 因此，该方法执行该对象的“浅拷贝”，而不是“深度拷贝”操作。 </p>
<p><code>Object</code>类本身并不实现接口<code>Cloneable</code>  ，因此在类别为<code>Object</code>的对象上调用<code>clone</code>方法将导致运行时抛出异常</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>返回一个代表对象的字符串。这个字符串中含有对象的相关信息，便于阅读。建议所有的子类重写这个方法。</p>
<p>Object 类的 toString 方法返回对象的类名 + ‘@’ + 对象的哈希码值得十六进制数。</p>
<h4 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>唤醒<strong>任意</strong>一个正在等待该对象的监视器的线程。一个线程通过调用 wait 方法来等待对象的监视器。被唤醒的线程只有在当前线程放弃了对象的锁之后才能被执行。被唤醒的线程与其他线程平等竞争对象的锁。该方法只能由作为该对象的监视器的所有者线程调用。</p>
<p>线程有三种方式称为对象监视器的所有者：</p>
<ol>
<li><p>通过执行对象的同步方法。</p>
</li>
<li><p>通过执行对象的同步语句（锁住此对象）。</p>
</li>
<li><p>执行类的同步静态方法。</p>
</li>
</ol>
<h4 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>唤醒<strong>所有</strong>一个正在等待该对象的监视器的线程。一个线程通过调用 wait 方法来等待对象的监视器。</p>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>使当前线程阻塞直到另一个线程调用此对象的 notify 方法或 notifyAll 方法或指定的时间已过，当前线程变为就绪状态。当前线程必须拥有此对象的监视器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                               <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           timeout++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       wait(timeout);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>与只有一个参数的 wait 方法类似，更加精细地控制等待被唤醒的时间直到放弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使当前线程阻塞直到另一个线程调用此对象的 notify 方法或 notifyAll 方法。</p>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>当垃圾收集器确定不再有该对象的引用时调用。finalize 方法通常的目的是在对象不可撤销丢弃之前执行清除动作。甚至finalize 方法可以让此对象再次可用于其他线程而避免被垃圾收集器清除。finalize 方法只能调用一次。</p>
<p>参考：</p>
<p><a href="https://blog.csdn.net/Saintyyu/article/details/90452826" target="_blank" rel="noopener">https://blog.csdn.net/Saintyyu/article/details/90452826</a></p>
]]></content>
      <categories>
        <category>JDK 源码分析</category>
      </categories>
      <tags>
        <tag>java.lang包</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring+JDBC征服数据库</title>
    <url>/2020/04/04/Spring+JDBC%E5%BE%81%E6%9C%8D%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Spring-JDBC征服数据库"><a href="#Spring-JDBC征服数据库" class="headerlink" title="Spring+JDBC征服数据库"></a>Spring+JDBC征服数据库</h1><p>Spring将数据访问过程中固定的和可变的部分明确划分为两个不同的类，<strong>模板(template)</strong>和<strong>回调(callback)</strong>。模板管理过程中固定的部分，回调处理自定义的数据访问代码。</p>
<p>Spring的模板类处理数据访问的固定部分–事务控制、管理资源以及处理异常。同时，应用程序相关的数据访问–语句、绑定参数以及整理结果集在回调的实现中处理。</p>
<p>以Spittr这个应用来演示JDBC。</p>
<p>我们先定义Spitter和Spittle两个实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.domain;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String fullname;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> updateByEmail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spitter</span><span class="params">(Long id, String username, String password, String fullname, String email, <span class="keyword">boolean</span> updateByEmail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.fullname = fullname;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">        <span class="keyword">this</span>.updateByEmail = updateByEmail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFullname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fullname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUpdateByEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> updateByEmail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spittle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Spitter spitter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date postedDate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spittle</span><span class="params">(Long id, Spitter spitter, String message, Date postedDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.spitter = spitter;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.postedDate = postedDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">getSpitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spitter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getPostedDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> postedDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后定义SpittleRepository、SpitterRepository两个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spitter <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spitter <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Spitter&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Spring的JDBC框架承担了资源管理和异常处理的工作，从而简化了JDBC代码，让我们只需编写从数据库读写数据的必要代码。</p>
<p>Spring为JDBC提供了三个模板供选择：</p>
<p>JdbcTemplate:最基本的Spring JDBC 模板，支持简单的JDBC数据库访问功能以及基于索引参数的查询。</p>
<p>NamedParameterJdbcTemplate：使用该模板类进行查询时可以将值以命名参数的形式绑定到SQL中，而不是简单的使用索引参数。</p>
<p>对于大多数JDBC任务来说，JdbcTemplate就是最好的方案。</p>
<p>我们定义JdbcSpitterRepository实现SpitterRepository接口，定义JdbcSpittleRepository实现SpittleRepository接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jdbc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.simple.SimpleJdbcInsert;</span><br><span class="line"><span class="keyword">import</span> spittr.db.SpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcSpitterRepository</span> <span class="keyword">implements</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSERT_SPITTER = <span class="string">"insert into Spitter(username,password,fullname,email,updateByEmail) values(?,?,?,?,?) "</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_SPITTER = <span class="string">"select id,username,password,fullname,email,updateByEmail from Spitter "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcSpitterRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span> </span>&#123;</span><br><span class="line">        Long id = spitter.getId();</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> spitterId = insertSpitterAndReturnId(spitter);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Spitter(spitterId,spitter.getUsername(),spitter.getPassword(),spitter.getFullname(),spitter.getEmail(),spitter.isUpdateByEmail());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">         jdbcTemplate.update(<span class="string">"update Spitter set username=?, password=?, fullname=?, email=?, updateByEmail=? where id =? "</span>,</span><br><span class="line">                 spitter.getUsername(),</span><br><span class="line">                 spitter.getPassword(),</span><br><span class="line">                 spitter.getFullname(),</span><br><span class="line">                 spitter.getEmail(),</span><br><span class="line">                 spitter.isUpdateByEmail(),</span><br><span class="line">                 id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> spitter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">insertSpitterAndReturnId</span><span class="params">(Spitter spitter)</span></span>&#123;</span><br><span class="line">        SimpleJdbcInsert jdbcInsert = <span class="keyword">new</span> SimpleJdbcInsert(jdbcTemplate).withTableName(<span class="string">"Spitter"</span>);</span><br><span class="line">        jdbcInsert.setGeneratedKeyName(<span class="string">"id"</span>);</span><br><span class="line">        Map&lt;String, Object&gt;args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">"username"</span>,spitter.getUsername());</span><br><span class="line">        args.put(<span class="string">"password"</span>,spitter.getPassword());</span><br><span class="line">        args.put(<span class="string">"fullname"</span>,spitter.getFullname());</span><br><span class="line">        args.put(<span class="string">"email"</span>,spitter.getEmail());</span><br><span class="line">        args.put(<span class="string">"updateByEmail"</span>,spitter.isUpdateByEmail());</span><br><span class="line">        <span class="keyword">long</span> spitterId = jdbcInsert.executeAndReturnKey(args).longValue();</span><br><span class="line">        <span class="keyword">return</span> spitterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSpitter</span><span class="params">(Spitter spitter)</span></span>&#123;</span><br><span class="line">        jdbcTemplate.update(INSERT_SPITTER,</span><br><span class="line">                spitter.getUsername(),</span><br><span class="line">                spitter.getPassword(),</span><br><span class="line">                spitter.getFullname(),</span><br><span class="line">                spitter.getEmail(),</span><br><span class="line">                spitter.isUpdateByEmail());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(SELECT_SPITTER+<span class="string">"where id = ?"</span>,<span class="keyword">new</span> SpitterRowMapper(),id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spitter&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(SELECT_SPITTER+<span class="string">"order by id"</span>,<span class="keyword">new</span> SpitterRowMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForLong(<span class="string">"select count(id) from spitter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(SELECT_SPITTER+<span class="string">"where username = ?"</span>,<span class="keyword">new</span> SpitterRowMapper(),username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpitterRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Spitter</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spitter <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Spitter(rs.getLong(<span class="string">"id"</span>),rs.getString(<span class="string">"username"</span>),rs.getString(<span class="string">"password"</span>),</span><br><span class="line">                    rs.getString(<span class="string">"fullname"</span>),rs.getString(<span class="string">"email"</span>),rs.getBoolean(<span class="string">"updateByEmail"</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.simple.SimpleJdbcInsert;</span><br><span class="line"><span class="keyword">import</span> spittr.db.SpittleRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcSpittleRepository</span> <span class="keyword">implements</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_SPITTLE = <span class="string">"select sp.id, s.id as spitterId, s.username, s.password, s.fullname, s.email, s.updateByEmail, sp.message, sp.postedTime from Spitter s, Spittle sp where s.id = sp.spitter"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_SPITTLE_BY_ID = SELECT_SPITTLE+<span class="string">" and sp.id=?"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_SPITTLE_BY_SPITTER_ID = SELECT_SPITTLE+<span class="string">" and s.id=? order by sp.postedTime desc"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_RECENT_SPITTLES = SELECT_SPITTLE+<span class="string">" order by sp.postedTime desc limit ?"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcSpittleRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForLong(<span class="string">"select count(id) from Spittle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> jdbcTemplate.queryForObject(SELECT_SPITTLE_BY_ID,<span class="keyword">new</span> SpittleRowMapper(),id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> spittleId = insertSpittleAndReturnId(spittle);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Spittle(spittleId,spittle.getSpitter(),spittle.getMessage(),spittle.getPostedDate());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(SELECT_SPITTLE_BY_SPITTER_ID,<span class="keyword">new</span> SpittleRowMapper(),id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findRecent(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(SELECT_RECENT_SPITTLES,<span class="keyword">new</span> SpittleRowMapper(),count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"delete from Spittle where id = ?"</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">insertSpittleAndReturnId</span><span class="params">(Spittle spittle)</span></span>&#123;</span><br><span class="line">        SimpleJdbcInsert jdbcInsert = <span class="keyword">new</span> SimpleJdbcInsert(jdbcTemplate).withTableName(<span class="string">"Spittle"</span>);</span><br><span class="line">        jdbcInsert.setGeneratedKeyName(<span class="string">"id"</span>);</span><br><span class="line">        Map&lt;String,Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">"spitter"</span>,spittle.getSpitter().getId());</span><br><span class="line">        args.put(<span class="string">"message"</span>,spittle.getMessage());</span><br><span class="line">        args.put(<span class="string">"postedTime"</span>,spittle.getPostedDate());</span><br><span class="line">        <span class="keyword">long</span> spittleId = jdbcInsert.executeAndReturnKey(args).longValue();</span><br><span class="line">        <span class="keyword">return</span> spittleId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Spittle</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spittle <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Spittle(rs.getLong(<span class="string">"id"</span>),</span><br><span class="line">                    <span class="keyword">new</span> Spitter(rs.getLong(<span class="string">"spitterId"</span>),rs.getString(<span class="string">"username"</span>),</span><br><span class="line">                            rs.getString(<span class="string">"password"</span>),rs.getString(<span class="string">"fullname"</span>),</span><br><span class="line">                            rs.getString(<span class="string">"email"</span>),rs.getBoolean(<span class="string">"updateByEmail"</span>)),</span><br><span class="line">                    rs.getString(<span class="string">"message"</span>),rs.getTimestamp(<span class="string">"postedTime"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到Spring中JDBC将获取连接，捕获异常都封装在JdbcTemplate中让我们更关注数据操作代码。对于增删改查四个方面，JdbcTemplate都为我们封装了一系列的函数。</p>
<p>SimpleJdbcInsert 可以简化我们的插入操作，指定一个数据库中的表名，然后传入一个Map，Key为数据表中的表项名，Value为插入的值，并可以指定一个返回的值。</p>
<p>通过update方法来实现删改。</p>
<p>查询基本类型例如Long等有对应的queryForLong方法等，若要将查询结果处理成为对象或对象集合，我们需要实现RowMapper接口实现将查询结果的一行映射为对象。</p>
<p>其实以上的代码我们并不能运行，因为我们还没有指定数据库数据源我们写一个JdbcConfig配置类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> spittr.db.jdbc.JdbcSpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.db.jdbc.JdbcSpittleRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">                .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">                .addScripts(<span class="string">"classpath:spittr/db/jdbc/schema.sql"</span>,<span class="string">"classpath:spittr/db/jdbc/test-data.sql"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcSpitterRepository <span class="title">spitterRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcSpitterRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcSpittleRepository <span class="title">spittleRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcSpittleRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们使用EmbeddedDatabaseBuilder来新建一个嵌入式数据库，这里我们选择H2，addScripts方法可以执行我们写好的SQL脚本。</p>
<p>将数据源注入到JdbcTemplate就可以使用它了，是不是很方便？？</p>
<p>我们还可以使用DriverManagerDataSource来配置基于JDBC驱动的数据源。</p>
<p>我们定义了dataSource、jdbcTemplate、spitterRepository、spittleRepository和transactionManager五个bean，dataSource bean 用来注入到jdbcTemplate bean中，jdbcTemplate bean 用来注入到用到它的repository实现中。spitterRepository和spittleRepository bean 用来注入到使用到它们的类。transactionManager bean 用来实现 事务管理，这里我们没有用到它。</p>
<p>下面是测试类的一部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.jdbc.JdbcSpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span></span>=JdbcConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JdbcSpitterRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  JdbcSpitterRepository spitterRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">4</span>, spitterRepository.count());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Spitter&gt; spitters = spitterRepository.findAll();</span><br><span class="line">    assertEquals(<span class="number">4</span>, spitters.size());</span><br><span class="line">    assertSpitter(<span class="number">0</span>, spitters.get(<span class="number">0</span>));</span><br><span class="line">    assertSpitter(<span class="number">1</span>, spitters.get(<span class="number">1</span>));</span><br><span class="line">    assertSpitter(<span class="number">2</span>, spitters.get(<span class="number">2</span>));</span><br><span class="line">    assertSpitter(<span class="number">3</span>, spitters.get(<span class="number">3</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们使用JdbcConfig类配置应用上下文，自动装配相应的repository实现。</p>
<p>这里需要注意的是@Transactional注解当它置于方法前时表示该方法使用事务处理，当它置于类前时表示该类的所有方法都使用事务处理。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>下载文泉学堂 PDF</title>
    <url>/2020/04/04/%E4%B8%8B%E8%BD%BD%E6%96%87%E6%B3%89%E5%AD%A6%E5%A0%82%20PDF/</url>
    <content><![CDATA[<h1 id="下载文泉学堂-PDF"><a href="#下载文泉学堂-PDF" class="headerlink" title="下载文泉学堂 PDF"></a>下载文泉学堂 PDF</h1><p>　　今天画了20多大洋买了一本电子书，这本书居然只能在他们自己的网站上看。只能在他们自己的网站上我也忍了，但是这个体验非常糟糕，不能快速翻页一直在异步加载图片而不是一次性全部加载好的。最骚的是写这个阅读器的人把你看过的页码统统模糊掉，你想要往上翻又要加载一次，体验非常的糟糕，就想着能不能把这本书的pdf下载下来。</p>
<p>　　最后找到了一个方法：</p>
<p>　　1）安装油猴扩展，具体方法见百度。</p>
<p>　　2）安装下载脚本。<a href="https://greasyfork.org/zh-CN/scripts/396025-文泉学堂pdf下载" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/396025-%E6%96%87%E6%B3%89%E5%AD%A6%E5%A0%82pdf%E4%B8%8B%E8%BD%BD</a></p>
<p>　　3）打开文泉学堂 pdf 阅读器，点击某一页 pdf 即可开始下载，下载的比较慢，稍等一会你能看见自动翻页，必须等待前两个pdf 下载完后才能挂后台，chrome 有一个连续下载的提示框。</p>
<p>　　4）将下载的多个 pdf 合并为一个 pdf 。<a href="https://dl.pconline.com.cn/download/364420.html" target="_blank" rel="noopener">https://dl.pconline.com.cn/download/364420.html</a></p>
<p>　　参考：<a href="https://github.com/Kevin0z0/wenquan-pdf-download" target="_blank" rel="noopener">https://github.com/Kevin0z0/wenquan-pdf-download</a></p>
<p>　　感谢大佬，tql。</p>
<p>　　所有下载的pdf请在24小时内删除，请勿传播或进行营利，一切法律责任由用户自己承担，与本人无关。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>SQL语言</title>
    <url>/2020/04/04/SQL%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h3 id="SQL-概述"><a href="#SQL-概述" class="headerlink" title="SQL 概述"></a>SQL 概述</h3><p>　　SQL 语言由 4 部分组成，包括数据定义语言 DDL、数据操纵语言 DML、数据控制语言和其他。</p>
<p>　　1）数据定义语言（Data Definition Language，DDL）：主要用于定义数据库的逻辑结构，包括数据库，基本表，视图和索引等，扩展 DDL 还支持存储过程、函数、对象、触发器等的定义。DDL 包括 3 类语言，即定义、修改和删除。</p>
<p>　　2）数据操纵语言（Data Manipulation Language，DML）：主要用于对数据库的数据进行检索和更新，其中更新操作包括插入、删除和修改数据。</p>
<p>　　3）数据控制语言（Data Control Language，DCL）：主要用于对数据库的对象进行授权、用户维护（包括创建、修改和删除）、完整性规则定义和事务定义等。</p>
<p>　　4）其他：主要是嵌入式 SQL 语言和动态 SQL 语言的定义。</p>
<p>　　</p>
<p>　　SQL特点：风格统一。高度非过程化。面向集合的操作方式。同一种语法结构提供两种使用方式（独立使用SQL对数据库进行操作，嵌入到高级语言中）。语言简洁，易学易用。</p>
<p>　　SQL主要动词：</p>
<p>　　1）数据查询：select；</p>
<p>　　2）数据定义：create、alter、drop；</p>
<p>　　3）数据操纵：insert、update、delete；</p>
<p>　　4）数据控制：grant、revoke；</p>
<h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><p>　　where 子句可以实现关系代数中的选择运算，用于查询满足选择条件的元组。where 子句中常用的查询条件如下所示：</p>
<p><img src="https://i.loli.net/2020/04/04/5NmKQzuGXSE8p3H.png" alt="img"></p>
<p> 　% 表示任意长度的字符串，_表示任意一个字符， escape ‘ \ ‘ 表示 \ 后的符号不是通配符。</p>
<p><img src="https://i.loli.net/2020/04/04/bJOVFf4XQM53hxK.png" alt="img"></p>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>　　外连接：</p>
<p>　　1）左外连接</p>
<p>　　　　select xxx </p>
<p>　　　　from 表a <strong>left outer join</strong> 表b <strong>on</strong> a.xx=b.xx</p>
<p>　　2）右外连接</p>
<p>　　　　select xxx </p>
<p>　　　　from 表a <strong>right outer join</strong> 表b <strong>on</strong> a.xx=b.xx</p>
<p> 　3）全外连接</p>
<p>　　　　select xxx </p>
<p>　　　　from 表a <strong>full outer join</strong> 表b <strong>on</strong> a.xx=b.xx</p>
<h3 id="嵌套子查询"><a href="#嵌套子查询" class="headerlink" title="嵌套子查询"></a>嵌套子查询</h3><h4 id="使用-in-的子查询"><a href="#使用-in-的子查询" class="headerlink" title="使用 in 的子查询"></a>使用 in 的子查询</h4><p><img src="https://i.loli.net/2020/04/04/Ut6bKM5lAWsTPiL.png" alt="img"></p>
<p> <img src="https://i.loli.net/2020/04/04/Hm7MZoWqi2VEt9F.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/04/04/BhbMpFjTZxcPXUn.png" alt="img"></p>
<p> <img src="https://i.loli.net/2020/04/04/Sq2ceb7Lfpahj8E.png" alt="img"></p>
<h4 id="使用比较运算符的子查询"><a href="#使用比较运算符的子查询" class="headerlink" title="使用比较运算符的子查询"></a>使用比较运算符的子查询</h4><p><img src="https://i.loli.net/2020/04/04/vt87Oam4YzwJxES.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/04/04/OdEwbPAcBqGKonx.png" alt="img"></p>
<h4 id="使用存在量词-exists-的子查询"><a href="#使用存在量词-exists-的子查询" class="headerlink" title="使用存在量词 exists 的子查询"></a>使用存在量词 exists 的子查询</h4><p>　　SQL 查询提供量词运算。量词有两种：一是存在量词，二是全称量词。全程量词可以用存在量词替代，故 SQL 语句仅提供存在量词的运算，使用谓词 exists 表示，全称量词转化通过 not exists 谓词来实现。</p>
<p><img src="https://i.loli.net/2020/04/04/hM1PlF8UboEXQqe.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/04/04/KN9bScEkCjZJhMf.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/04/04/XEBS7msaRO3tfek.png" alt="img"></p>
<h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p><img src="https://i.loli.net/2020/04/04/bLqFIkXJCKAzrGa.png" alt="img"></p>
<p> 　如果指定 distinct 谓词，表示在计算时首先消除&lt;列名&gt;取重复值的元组，然后再进行统计。</p>
<h4 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h4><p>　　在 SQL 查询中，往往需要对数据进行分组运算，分组运算的目的是为了细化聚合函数的作用对象。如果不对查询结果进行分组，则聚合函数作用于整个查询结果；如果对查询结果进行分组，则聚合函数分别作用于每个组，查询结果是按组聚合输出。SQL 语句中通过 group by 和having 子句来实现分组运算，其中：</p>
<p>　　group by 子句对查询结果按某一列或某几列进行分组，值相等的分为一组；</p>
<p>　　having 子句对分组的结果进行选择，仅输出满足条件的组。该子句必须与group by 子句配合使用。</p>
<p><img src="https://i.loli.net/2020/04/04/mWZfg9ps8JA73nF.png" alt="img"></p>
<p> 　聚合函数可以直接使用在 having 子句中，也可以用于子查询中，但<strong>在 where 子句中不可以直接使用聚合函数。</strong></p>
<h4 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h4><p><img src="https://i.loli.net/2020/04/04/h7m4821v9RjIJGN.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/04/04/heOE2QcbPfitLYI.png" alt="img"></p>
<p> 或者</p>
<p>　　select studentNo, avg(score) as avgScore</p>
<p>　　from score </p>
<p>　　group by studentNo</p>
<p>　　having count(*) &gt;5</p>
<p>　　order by avgScore</p>
<p>　　limit 0,1</p>
<p><img src="https://i.loli.net/2020/04/04/NRbIMlTqom1LdJS.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/04/04/kT2RU6ud3DBzLAf.png" alt="img"></p>
<h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p>　　SQL 支持集合运算。select 语句查询的结果是集合，多个 select 语句的结果可以进行集合操作，传统的集合操作主要包括并 union、交 intersect、差 except 运算，<strong>在执行集合运算时要求参与运算的查询结果的列数一样，其对应列的数据类型必须一致。</strong></p>
<p><img src="https://i.loli.net/2020/04/04/QvEbtCTGPunSkRr.png" alt="img"></p>
<h3 id="SQL-查询一般格式"><a href="#SQL-查询一般格式" class="headerlink" title="SQL 查询一般格式"></a>SQL 查询一般格式</h3><p><img src="https://i.loli.net/2020/04/04/d5JLQ4SFejksW8t.png" alt="img"></p>
<h3 id="SQL-数据定义语言"><a href="#SQL-数据定义语言" class="headerlink" title="SQL 数据定义语言"></a>SQL 数据定义语言</h3><p>　　数据库中的关系集合必须由数据定义语言 DDL 来定义，包括：数据库模式、关系模式、每个属性的值域、完整性约束、每个关系的索引集合和关系的物理存储结构等。</p>
<p><img src="https://i.loli.net/2020/04/04/IADEaU95sFGYO8Q.png" alt="img"></p>
<h4 id="数据库的定义"><a href="#数据库的定义" class="headerlink" title="数据库的定义"></a>数据库的定义</h4><h5 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h5><p><img src="https://i.loli.net/2020/04/04/oZAH7Sla91zNXuF.png" alt="img"></p>
<h5 id="数据库的删除"><a href="#数据库的删除" class="headerlink" title="数据库的删除"></a>数据库的删除</h5><p><img src="https://i.loli.net/2020/04/04/QXKwkRidjT6Aq4L.png" alt="img"></p>
<h4 id="基本表的定义"><a href="#基本表的定义" class="headerlink" title="基本表的定义"></a>基本表的定义</h4><h5 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h5><p><img src="https://i.loli.net/2020/04/04/6rCEphyxYKgv3bi.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/04/04/BNoTkclZdWVqS3L.png" alt="img"></p>
<p> <img src="https://i.loli.net/2020/04/04/ntiAphIVuWEmoXP.png" alt="img"></p>
<h5 id="基本表的修改"><a href="#基本表的修改" class="headerlink" title="基本表的修改"></a>基本表的修改</h5><p><img src="https://i.loli.net/2020/04/04/A9nHdB8csqLz6p5.png" alt="img"></p>
<p>　　 基本表在修改过程中，不可以删除列，一次仅执行一种操作。</p>
<h5 id="基本表的删除"><a href="#基本表的删除" class="headerlink" title="基本表的删除"></a>基本表的删除</h5><p>　　<img src="https://i.loli.net/2020/04/04/ZO6B1CmIU9dGKEe.png" alt="img"></p>
<p> 　若选择 restrict ，则该表的删除有限制条件，即该表不能有视图，触发器以及被他表所引用，该项为默认项。</p>
<p>　　若选择 cascade， 则该表的删除没有限制条件，在删除基本表的同时，也删除建立在该表上的所有索引，完整性规则，触发器和视图。</p>
<h4 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h4><p>　　如果数据有序，则检索速度是非常快的，对表中的记录进行排序有两种方案：一是对记录进行物理上的重新组织。二是不改变物理顺序，通过建立索引来实现数据记录的重新排列，称为逻辑排序。</p>
<p>　　一张表可以建立多个索引，可以从不同的角度加快查询速度，如果索引建立的比较多，会给数据维护带来较大的系统开销。</p>
<p>　　索引通常是由指针构成的记录，指针逻辑上按照索引关键字进行排序，但不改变表中记录的物理顺序。索引和基本表分别存储。</p>
<p>　　如果索引文件中的记录<strong>按照某个搜索码值指定的顺序物理存储</strong>，那么该搜索码对应的索引就称为<strong>主索引</strong>，也叫<strong>聚集索引</strong>。<strong>搜索码值顺序与索引文件中记录的物理顺序不同</strong>的那些索引称为<strong>辅助索引</strong>或<strong>非聚集索引</strong>。</p>
<h5 id="索引的建立"><a href="#索引的建立" class="headerlink" title="索引的建立"></a>索引的建立</h5><p><img src="https://i.loli.net/2020/04/04/B3SlMcuEm9wDe4s.png" alt="img"></p>
<h5 id="索引的删除"><a href="#索引的删除" class="headerlink" title="索引的删除"></a>索引的删除</h5><p>　　索引一旦建立，用户就不需要管理它，由系统自动维护。如果某个关系经常要执行插入、删除和修改操作，系统会花费很多时间来维护索引，从而降低基本表的更新速度，因此可删除那些不经常使用的索引。删除索引的语法为：</p>
<p><img src="https://i.loli.net/2020/04/04/OUpFAjhemWIoxsi.png" alt="img"></p>
<h3 id="SQL-数据更新语言"><a href="#SQL-数据更新语言" class="headerlink" title="SQL 数据更新语言"></a>SQL 数据更新语言</h3><p>　　SQL 数据更新语句包括 3 条：插入 insert、删除 delete、修改 update。</p>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="　　插入数据"></a>　　插入数据</h4><h5 id="插入一条元组"><a href="#插入一条元组" class="headerlink" title="插入一条元组"></a>插入一条元组</h5><p><img src="https://i.loli.net/2020/04/04/6vrnQYmcUW9O31k.png" alt="img"></p>
<h5 id="插入多条元组"><a href="#插入多条元组" class="headerlink" title="插入多条元组"></a>插入多条元组</h5><p><img src="https://i.loli.net/2020/04/04/HfeLn6dDRWCwyAZ.png" alt="img"></p>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="　删除数据"></a>　删除数据</h4><p>　　<img src="https://i.loli.net/2020/04/04/9yTpORSIfmKBXYj.png" alt="img"></p>
<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="　　修改数据"></a>　　修改数据</h4><p><img src="https://i.loli.net/2020/04/04/5mzi2Dy9jEgW3t4.png" alt="img"></p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>　　视图是虚表，是从一个或几个基本表（或视图）中导出的表，在系统的数据字典中仅存放了视图的定义，不存放视图对应的数据。</p>
<h4 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h4><p><img src="https://i.loli.net/2020/04/04/R9MgBo7XGwK2Y8a.png" alt="img"></p>
<p> 　with check option ：当对视图进行插入、删除和更新操作时必须满足视图定义的谓词条件。</p>
<p><img src="https://i.loli.net/2020/04/04/eETgZ48mJ17ASh3.png" alt="img"></p>
<h4 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h4><p>　　查询是对视图进行的最主要的操作。从用户的角度来看，查询视图与查询基本表的方式是完全一样的。</p>
<h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p>　　更新视图指通过视图来插入、删除和修改基本表中的数据。由于视图是一个虚表，不实际存放数据，对视图的更新最终要转换为对基本表的更新，因此，如果视图的定义中包含了表达式，或聚合运算，或消除重复值运算，则不能对视图进行更新操作。</p>
<h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p><img src="https://i.loli.net/2020/04/04/FiN2qdoAf8LMkCu.png" alt="img"></p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><img src="https://i.loli.net/2020/04/04/VeDnJizjmpqPsXB.png" alt="img"></p>
<p> 　1）查询在2005-2008 年之间没有归还图书的读者编号、读者姓名、读者工作单位、图书编号、图书名称和借书日期。</p>
<p>　　分析：将读者、借阅、书籍三个关系连接起来然后判断书籍是否应该在 2005~2008年之间归还且书籍归还日期为空。</p>
<p>　　select rd.readerNo, rd.readerName, rd.workUnit, bk.bookNo, bk.bookName, br.borrowDate</p>
<p>　　from Reader rd, Borrow br, Book bk</p>
<p>　　where rd.readerNo=br.readerNo and br.bookNo=bk.bookNo and year(shouldDate) between 2005 and 2008 and br.returnDate is null</p>
<p>　　2)查询没有借书的读者姓名（分别用 in 子查询和存在量词子查询表达）。</p>
<p>　　分析：首先在借阅表中找出所有借过书还没有归还的读者号，然后判断每一个读者的读者号是否在前面找出的读者号里面，不在则代表没有借书。</p>
<p>　　select readerName</p>
<p>　　from Reader</p>
<p>　　where readerNo not in(</p>
<p>　　select distinct readerNo</p>
<p>　　from Borrow</p>
<p>　　where returnDate is null ); </p>
<p>　　select readerName</p>
<p>　　from Reader</p>
<p>　　where not exists (</p>
<p>　　select *</p>
<p>　　from Borrow</p>
<p>　　where Reader.readerNo=Borrow.readerNo and returnDate is null );</p>
<p>　　3)查询既借阅了“离散数学”又借阅了“数据库系统概念”两本书的读者编号、读者姓名、借书日期和图书名称。</p>
<p>　　分析：先找出借阅了离散数学的读者编号，再去看该读者是否借阅了数据库系统概念。</p>
<p>　　select rd.readerNo, rd.readerName, br.borrowDate, bk.bookName</p>
<p>　　from Reader rd, Borrow br, Book bk</p>
<p>　　where rd.readerNo=br.readerNo and br.bookNo=bk.bookNo and bookName=’离散数学’</p>
<p>　　and exists (</p>
<p>　　select * </p>
<p>　　from Borrow, Book</p>
<p>　　where Borrow.bookNo=Book.bookNo and rd.readerNo=Borrow.readerNo and Book.bookName=’数据库系统概念’ );</p>
<p>　　4）查询没有借阅’“经济管理”类图书的读者编号、读者姓名和出生日期（分别用 in 子查询和存在量词子查询表达）。</p>
<p>　　分析：先找出借阅了经济管理类书籍的读者号，然后判断每一个读者编号是否在前面找到的读者号中。</p>
<p>　　select readerNo, readerName, substring(identitycard,7,8) as birthday</p>
<p>　　from Reader</p>
<p>　　where readerNo not in (</p>
<p>　　select readerNo</p>
<p>　　from Borrow</p>
<p>　　where bookNo in(</p>
<p>　　select bookNo</p>
<p>　　from Book</p>
<p>　　where classNo in(</p>
<p>　　select classNo</p>
<p>　　from BookClass</p>
<p>　　where className=’经济管理’ )));</p>
<p>　　</p>
<p>　　</p>
<p>　　select readerNo, readerName, reader, substring(identitycard,7,8) as birthday</p>
<p>　　from Reader</p>
<p>　　where not exists(</p>
<p>　　select *</p>
<p>　　from Borrow br, Book bk, BookClass bc</p>
<p>　　where br.bookNo=bk.bookNo and bk.classNo=bc.classNo and bc,className=’经济管理’ and br.readerNo = Reader.readerNo);</p>
<p>　　</p>
<p>　　5)查询至少借阅了“马永强”所借的所有图书的读者编号、读者姓名、和工作单位。</p>
<p>　　分析：马永强所借的书他都借过 即 没有马永强借的书是他没有借的</p>
<p>　　select readerNo, readerName, workUnit</p>
<p>　　from Reader r1        //遍历每一位读者</p>
<p>　　where r1.readerNo not in(</p>
<p>　　select readerNo</p>
<p>　　from Borrow b1    //读者借书</p>
<p>　　where not exists(</p>
<p>　　select *</p>
<p>　　from Reader r2</p>
<p>　　where r2.readerName=’马永强’ and not exists(</p>
<p>　　select *</p>
<p>　　from Borrow b2      //马永强借书</p>
<p>　　where r2.readerNo=b2.readerNo and b1.bookNo=b2.bookNo and b2.returnDate is null)));</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>事务</title>
    <url>/2020/04/04/%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a><strong>什么是事务</strong></h3><p>　　事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a><strong>事务的四大特性</strong></h3><p>　　1）<strong>原子性（Atomicity）</strong>：事务是最小的执行单位，不允许分割。事务的原子性确保动作全部完成，要么完全不起作用。</p>
<p>　　2）<strong>一致性（Consistency）</strong>：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。</p>
<p>　　3）<strong>隔离性（Isolation）</strong>：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。</p>
<p>　　4）<strong>持久性（Durability）</strong>：一个事务被提交后。它对数据库中数据的改变是持久的，即使数据库故障也不应该有任何影响。</p>
<p>　　</p>
<h3 id="并发事务会带来的问题"><a href="#并发事务会带来的问题" class="headerlink" title="并发事务会带来的问题"></a><strong>并发事务会带来的问题</strong></h3><p>　　1）<strong>脏读（Dirty Read）</strong>：一个事务正在访问数据并对数据进行修改，修改还没有提交到数据库，这是另外一个事务访问了这个数据，然后使用了这个数据。这个数据更改之前的数据，另一个事务读到的数据是“脏数据”，依靠“脏数据”所做的操作是不正确的。</p>
<p>　　2）<strong>丢失修改（Lost to modify）</strong>：一个事务读取一个数据时，另外一个事务也访问了该数据，在第一个事务中修改数据后，第二个事务也修改了这个数据。第一个事务内的修改结果丢失，因此称作丢失修改。例如事务1读取某表中的数据 A=20 ，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改丢失。</p>
<p>　　3）<strong>不可重复读（Unrepeatable read）</strong>：在一个事务内多次读同一个数据在这个事务还没有结束时，另一个事务也访问该数据。在第一个事务的两次读之间，另一个事务可能已经修改了数据，导致两次读取的数据可能不太一样。</p>
<p>　　4）<strong>幻读（Phanatom read）</strong>：幻读与不可重复读类似。发生在一个事务读了几行数据，接着另一个并发 事务插入了一些数据。在随后的查询中第一个事务就会发现多了一些原本不存在的记录，好像发生了幻觉。</p>
<p>　　<strong>不可重复读与幻读区别</strong>：不可重复读–多次读取数据发现某些列的值被修改。幻读–多次读取数据发现记录变少或者变多。</p>
<p>　　总结：脏读：事务读取到还没来得及修改的数据；丢失修改：多个事务修改同一数据，后面的修改会覆盖掉前面的修改。不可重复读：多次访问一个数据，中间有事务修改数据导致数据不一致；幻读：多次查询记录，中间有事务删除或者增加了记录，导致了记录不一致。</p>
<p>　　</p>
<h3 id="MySQL默认隔离级别"><a href="#MySQL默认隔离级别" class="headerlink" title="MySQL默认隔离级别"></a><strong>MySQL默认隔离级别</strong></h3><p>　　SQL标准定义了四个隔离级别：</p>
<p>　　1）<strong>READ-UNCOMMITTED（读取未提交</strong>）：最低的隔离级别，允许读取未提交的数据变更，可能导致脏读、幻读或不可重复读。</p>
<p>　　2）<strong>READ-COMMITTED（读取已提交）</strong>：允许并发事务读取已经提交的数据，可以阻止脏读，幻读或不可重复读仍可能发生。</p>
<p>　　3）<strong>REPEATABLE-READ（可重复读）</strong>：对同一字段的多次读取结果都是一致的，除非是数据本身被事务自己修改，可以组织脏读和不可重复读，幻读仍可能发生。</p>
<p>　　4）<strong>SERIALIZABLE（可串行化）</strong>：最高的隔离级别。所有事务依次执行。</p>
<p><img src="https://i.loli.net/2020/04/04/OpzAI9n7via2DHf.png" alt="img"></p>
<p> MySQL InnoDB 存储引擎默认支持隔离级别是可重复读。InnoDB 存储引擎在 REPEATABLE-READ（可重复读）事务隔离级别下使用的是 Next-Key Lock锁算法，可以避免幻读的产生。因此InnoDB的可重复读达到了SQL标准的SERIALIZABLE（可串行化）隔离级别。</p>
<p>参考：<a href="https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL</a></p>
<p>　　</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Spring之旅</title>
    <url>/2020/04/04/Spring%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h1 id="Spring之旅"><a href="#Spring之旅" class="headerlink" title="Spring之旅"></a>Spring之旅</h1><p>Spring是一个开源框架，Spring根本使命：简化Java开发。</p>
<p>为了简化java开发的复杂性，Spring使用如下4种策略：</p>
<p>1、基于POJO(Plain Old Java Object 简单Java对象 )的轻量级和最小侵入性编程。</p>
<p>2、通过依赖注入和面向接口实现松耦合。</p>
<p>3、基于切面和惯例进行声明式编程。</p>
<p>4、通过切面和模板减少样板式代码。</p>
<p>这里以一个骑士出征的例子来解释一些相关概念</p>
<p>首先定义一个骑士接口，其中有一个embarkOnQuest方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Knight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始行动</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">embarkOnQuest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后再定义一个远征行动接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Quest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">embark</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下一步定义一个拯救少女行动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RescueDamselQuest</span> <span class="keyword">implements</span> <span class="title">Quest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//开始行动拯救少女</span></span><br><span class="line">        System.out.println(<span class="string">"Embarking on a quest to rescue the damsel"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>再定义一个屠杀巨龙行动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">//杀巨龙行动</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlayDragonQuest</span> <span class="keyword">implements</span> <span class="title">Quest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrintStream printStream;</span><br><span class="line">    <span class="comment">//依赖注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SlayDragonQuest</span><span class="params">(PrintStream printStream)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printStream = printStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printStream.println(<span class="string">"Embarking on quest to slay the dragon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来定义一个英勇的骑士类实现骑士接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javapackage hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BraveKnight</span> <span class="keyword">implements</span> <span class="title">Knight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Quest quest;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖注入，而不是BraveKnight含有Quest对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BraveKnight</span><span class="params">(Quest quest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quest = quest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embarkOnQuest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quest.embark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这里有人可能就写成下面这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BraveKnight</span> <span class="keyword">implements</span> <span class="title">Knight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Quest quest;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BraveKnight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        quest = <span class="keyword">new</span> RescueDamselQuest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embarkOnQuest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quest.embark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是有一种情况：骑士不仅仅可以去杀龙还可以去拯救少女这里将它写死就不太合适，采用传递一个Quest对象，只要实现了Quest类的接口，任何类都可以传进来，骑士就可以去做很多行动，不是只执行一个任务。</p>
<p>这是依赖注入(DI)的一种方式：构造器注入</p>
<p>同样SlayDragonQuest类中也有依赖注入：将一个PrintStream对象注入到SlayDragonQuest中。</p>
<p>骑士出征之前和之后需要法师的吟唱，骑士类拥有法师类对象似乎不是一个好的选择，法师不应该被骑士拥有，有的骑士也不想法师吟唱这里先定义一个法师类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法师吟唱类 骑士出征之前之后需要法师吟唱</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minstrel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PrintStream printStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Minstrel</span><span class="params">(PrintStream printStream)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printStream = printStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AOP 应用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singBeforeQuest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printStream.println(<span class="string">"Fa la la,the knight is so brave!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singAfterQuest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printStream.println(<span class="string">"Tee hee hee , the brave knight did embark on a quest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法师的吟唱是骑士的出征非关键因素，这里利用AOP来实现法师吟唱模块化。</p>
<p>有多个Quest对象可以被注入到BraveKnight中，到底选择哪一个来注入呢？？</p>
<p>这里利用XML来正确装配这些对象。</p>
<p>装配的方式有：自动装配、XML显式装配、Java显式装配。</p>
<p>先定义knight.xml来解决骑士到底要做什么的问题。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line">&lt;bean id=<span class="string">"knight"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.BraveKnight"</span>&gt;</span><br><span class="line">    &lt;constructor-arg ref=<span class="string">"quest"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"quest"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.SlayDragonQuest"</span>&gt;</span><br><span class="line">        &lt;constructor-arg value=<span class="string">"#&#123;T(System).out&#125;"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>使用<bean></bean>声明一个bean 其中id为自己指定的名字 class为bean的类</p>
<p><constructor-arg> 元素为构造器参数 ref为依赖的bean，第一个constructor元素就决定了将一个id为quest的bean注入到id为knight的对象中。第二个constructor元素中 value代表将一个System.out值传入构造器。</p>
<p>第一个constructor元素就决定了骑士去杀龙而不是拯救少女。</p>
<p>等等，法师吟唱在哪？？？</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"knight"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.BraveKnight"</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">"quest"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"quest"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.SlayDragonQuest"</span>&gt;</span><br><span class="line">        &lt;constructor-arg value=<span class="string">"#&#123;T(System).out&#125;"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"minstrel"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.Minstrel"</span>&gt;</span><br><span class="line">        &lt;constructor-arg value=<span class="string">"#&#123;T(System).out&#125;"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:aspect ref=<span class="string">"minstrel"</span>&gt;</span><br><span class="line">            &lt;aop:pointcut id=<span class="string">"embark"</span> expression=<span class="string">"execution(* *.embarkOnQuest(..))"</span>/&gt;</span><br><span class="line">            </span><br><span class="line">            &lt;aop:before pointcut-ref=<span class="string">"embark"</span> method=<span class="string">"singBeforeQuest"</span>/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;aop:after pointcut-ref=<span class="string">"embark"</span> method=<span class="string">"singAfterQuest"</span>/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>&lt;aop:aspect ref=”minstrel”&gt;这一句将法师类声明为一个切面(AOP)。</p>
<p>pointcut定义了一个切入点，before决定在切入点之前做什么，after决定在切入点之后做什么。</p>
<p>来到验证阶段，看看骑士到底干了啥事？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnightMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("minstrel.xml");</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"knight.xml"</span>);</span><br><span class="line">        Knight knight = context.getBean(Knight<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        knight.embarkOnQuest();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ClassPathXmlApplicationContext 从xml文件中读取bean装配信息。</p>
<p>注释的第一行决定了法师要出来吟唱，通过控制台可以看到法师出来吟唱了，并且骑士执行的是杀龙的行动。</p>
<p><img src="https://i.loli.net/2020/04/04/iZRbHgK6a12jsmz.png" alt="img"></p>
<p>法师吟唱</p>
<p>没有注释的第二行决定法师不出来吟唱，执行的也是杀龙任务，也可以将xml里面的配置改为拯救少女，可能这个骑士他不喜欢拯救少女吧。</p>
<p><img src="https://i.loli.net/2020/04/04/OnfcdCHIohMaiSx.png" alt="img"></p>
<p>法师不吟唱</p>
<p>这个例子 初步展示了DI、AOP的思想。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找 Medium</title>
    <url>/2020/04/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEMedium/</url>
    <content><![CDATA[<h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<p>由于题目要求时间复杂度为O(log n)，这提示我们使用二分查找。</p>
<p>数组本身不是有序的，进行旋转后只是局部有序的，还能二分查找吗？</p>
<p>可以发现，我们将数组从中间分成左右两部分后，左右部分中一定有一个部分是有序的。例如示例中我们从 <code>6</code> 这个位置分开为<code>[4,5,6]</code> 和 <code>[7,0,1,2]</code> ，其中左边 <code>[4,5,6]</code> 这个部分的数组是有序的。</p>
<p>这启示我们可以在常规二分查找上改动，每次判断分割出来的两个部分，哪个是有序的，根据有序的部分改变二分搜索的上下界。</p>
<ul>
<li>如果 <code>[1, mid-1]</code> 是有序数组，且 <code>target</code>  的大小满足 <code>[nums[l], nums[mid])</code> ，则我们将搜索范围缩小到 <code>[1, mid-1]</code> ，否则在<code>[mid+1, r]</code> 中寻找。</li>
<li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code>  的大小满足 <code>[nums[mid+1], nums[r])</code> ，则我们将搜索范围缩小到 <code>[mid+1, r]</code> ，否则在<code>[1, mid-1]</code> 中寻找。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//左边部分有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="comment">//target 在有序部分</span></span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt;= nums[mid])&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//target 不在有序部分</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//右边部分有序</span></span><br><span class="line">                 <span class="comment">//target 在有序部分</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; target &lt;= nums[n-<span class="number">1</span>])&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//target 不在有序部分</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(logN)，空间复杂度 O(1)。</p>
<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li>
</ul>
<p>采用快速幂等法。有递归和迭代两个版本。</p>
<p><strong>递归版本</strong></p>
<p>快速幂算法的本质是分治算法。例如在计算 x^64 时我们可以看作求 x^32 的平方，进而可以看作求 x^16 的四次方……</p>
<p>再来看一般情况如果需要求 x^77 ，可以看作 x^38 * x^38 *x，对 x^38 可以看作 x^19 的平方，x^19 可以看作 x^9 * x^9 * x……</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="comment">// n 为负数时，求 -n 次方并取倒数</span></span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//n 不是偶数时需要乘 x</span></span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(logN)，空间复杂度 O(logN)。</p>
<p><strong>迭代版本</strong></p>
<p>以 x^77 为例，首先看 77 这个整数，77化为二进制得到1001101，我们可以将 77 表示为 64+8+4+1。我们只需算出 x 的 2 的指数倍次方的结果就可以表示 x 的所有次方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="keyword">while</span>(N != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (N &amp; <span class="number">1</span>) == <span class="number">1</span> )&#123;</span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 计算 x 的 2 的指数次方结果</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            N = N &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(logN)，空间复杂度 O(1)。</p>
<p>迭代法真是妙蛙种子吃着妙脆角妙进了米奇妙妙屋，妙到家了。</p>
<h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></h4><p>给定一个包含 <em>n</em> + 1 个整数的数组 <em>nums*，其数字都在 1 到 *n</em> 之间（包括 1 和 <em>n</em>），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><strong>不能</strong>更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 <em>O</em>(1) 的空间。</li>
<li>时间复杂度小于 <em>O</em>(<em>n</em>2) 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ol>
<p>方法一： 二分查找</p>
<p>定义 cnt[i] 表示 nums 数组中小于等于 i 的数有多少个，假设重复的数是 target，那么[1, target-1]里的所有数满足cnt[i] &lt; i，[target, n]里的所有数满足 cnt[i] &gt; i。</p>
<p>以示例 1 为例，列出 cnt 的值</p>
<table>
<thead>
<tr>
<th>nums</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>cnt</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<p>示例中重复的整数是2，[1, 1]中的数满足 cnt[i] &lt;= i， [2,4]中的数满足cnt[i] &gt;= i。</p>
<p>由于只有一个整数重复了两次以上，我们考虑 target 整数出现了 2 次和 3 次及以上的情况：</p>
<ul>
<li>target 出现了两次 [1, target -1]范围内满足 cnt[i] = i</li>
<li>target 出现了三次及以上，代表[1,n]范围内有整数没有出现，当没有出现的整数 i 小于 target 则[i, target]的cnt 值减一，满足条件。当没有出现的整数 j 大于 target 则[target, j-1]的cnt 值均加一，满足条件。</li>
</ul>
<p>那么我们怎么利用 cnt 数组来找到重复出现的数字呢？</p>
<p>由于 nums 数组是有序的，我们可以想到使用二分查找，在二分查找的过程中统计 cnt 的值，根据 cnt 的值来判断重复的数字在[left, mid - 1] 或[mid + 1, right]区间中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//统计cnt</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= mid)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//cnt[i] &lt;= mid，重复的数字在[mid + 1, r]区间</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= mid)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//cnt[i] &gt; mid，重复的数字在[l, mid - 1]</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//当 l &gt; r时，mid 为重复的数字 </span></span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(nlogn) 空间复杂度O(1)</p>
<p>方法二：快慢指针</p>
<p>快慢指针通常用来判断链表中是否有环，我们可以对 nums 数组建图每个位置 i 连一条 i -&gt; nums[i]的边，由于存在重复的数字target，target 位置至少有两条指向它的边，因此存在环，就转换为找环的入口问题。</p>
<p>以示例 1 为例我们建立得到的图如下</p>
<p><img src="https://i.loli.net/2020/05/26/O28ubKGxAYr14n7.png" alt="image-20200526115632169"></p>
<p>我们可以先使用快慢指针走进环中，再将慢指针放到起点，快慢指针一起走，直到快慢指针相遇就是结果。</p>
<p>为什么将慢指针放到起点一起走，直到快慢指针相遇就是结果呢？。</p>
<p>假设环长为 <em>L</em>，从起点到环的入口的步数是 <em>a</em>，从环的入口继续走 <em>b</em> 步到达相遇位置，从相遇位置继续走 <em>c</em> 步回到环的入口。快指针比慢指针多走了 <em>k</em> 圈。表示为 2(<em>a</em>+<em>b</em>)=<em>a</em>+<em>b</em>+<em>k</em> <em>L</em>。进而得到 <em>a</em>=(<em>k</em>−1)<em>L</em>+(<em>L</em>−<em>b</em>)=(<em>k</em>−1)<em>L</em>+<em>c</em></p>
<p>如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了 a 步之后到达环的入口，快指针在环里走了 k−1 圈之后又走了 c 步，由于从相遇位置继续走 c 步即可回到环的入口，因此快指针也到达环的入口。两个指针在环的入口相遇，相遇点就是答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//快慢指针相遇</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">		<span class="comment">//慢指针从头开始走，快慢指针相遇时得到环的入口点</span></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n) 空间复杂度O(1)</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>事务管理与恢复</title>
    <url>/2020/04/06/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h4><p>​    对于用户而言，事务是具有完整逻辑意义的数据库操作序列的集合。对于数据库管理系统而言，事务则是一个读写操作序列。这些操作是一个不可分割的逻辑工作单元，要么都做，要么都不做。</p>
<p>​    通常有有两种类型的事务结束语句：</p>
<p>​    1）事务提交（commit）：将成功完成事务的执行结果（即更新）永久化，并释放事务占有的全部资源。</p>
<p>​    2）事务回滚（rollback）：中止当前事务、撤销其对数据库所做的更新，并释放事务占有的全部资源。</p>
<p>​    </p>
<p>SQL Server 数据库提供了 3 种类型的事务模式：显式事务、隐式事务及自定义事务。</p>
<p>​    显式事务是指用户使用了 Transact-SQL 事务语句所定义的事务，其事务语句包括：</p>
<p>​    事务开始：begin transaction</p>
<p>​    事务提交：commit transaction，commit work</p>
<p>​    事务回滚：rollback transaction，rollback work</p>
<p>​    隐式事务是指事务提交或回滚后，SQL Server 自动开始新的事务。该类事务不需要采用 begin transaction 语句标识事务的开始。</p>
<p>​    自动定义事务模式：当一个语句成功执行后，它被自动提交，而当执行过程中出错时，则被自动回滚。</p>
<h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h4><p>​    1）原子性（Atomicity）。事务的所有操作要么全部被执行，要么都不执行。</p>
<p>​    2）一致性（Consistency）。一个单独执行的事务应保证其执行结果的一致性，即总是将数据库从一个一致性状态转化到另一个一致性状态。</p>
<p>​    3）隔离性（Isolation）。当多个事务并发执行时，一个事务的执行不能影响另一个事务，即并发执行的各个事务不能相互干扰。</p>
<p>​    4）持久性（Durability）。一个事务提交成功后，它对数据库的改变必须是永久的，即使随后系统出现故障。</p>
<h4 id="事务并发执行与调度"><a href="#事务并发执行与调度" class="headerlink" title="事务并发执行与调度"></a>事务并发执行与调度</h4><p>​    数据库管理系统允许多个事务并发执行，其主要优点是增加系统吞吐量和减少平均响应时间。</p>
<p>​    </p>
<p>​    并发事务带来的问题：</p>
<p>​    1）<strong>脏读（Dirty Read）</strong>：一个事务正在访问数据并对数据进行修改，修改还没有提交到数据库，这是另外一个事务访问了这个数据，然后使用了这个数据。这个数据更改之前的数据，另一个事务读到的数据是“脏数据”，依靠“脏数据”所做的操作是不正确的。</p>
<p>　2）<strong>丢失修改（Lost to modify）</strong>：一个事务读取一个数据时，另外一个事务也访问了该数据，在第一个事务中修改数据后，第二个事务也修改了这个数据。第一个事务内的修改结果丢失，因此称作丢失修改。例如事务1读取某表中的数据 A=20 ，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改丢失。</p>
<p>　3）<strong>不可重复读（Unrepeatable read）</strong>：在一个事务内多次读同一个数据在这个事务还没有结束时，另一个事务也访问该数据。在第一个事务的两次读之间，另一个事务可能已经修改了数据，导致两次读取的数据可能不太一样。</p>
<p>　4）<strong>幻读（Phanatom read）</strong>：幻读与不可重复读类似。发生在一个事务读了几行数据，接着另一个并发 事务插入了一些数据。在随后的查询中第一个事务就会发现多了一些原本不存在的记录，好像发生了幻觉。    </p>
<h4 id="事务调度及正确性准则"><a href="#事务调度及正确性准则" class="headerlink" title="事务调度及正确性准则"></a>事务调度及正确性准则</h4><p>​    事务并发执行顺序是随机的，将由多个事务操作组成的随机执行序列称为一个调度。对于一组事务操作组成的调度序列而言，应满足下列条件：</p>
<p>​    1）该调度包括该组事务的全部操作；</p>
<p>​    2）属于同一个事务的操作应保持在原事务中的执行顺序。</p>
<p>​    串行调度：在调度 S 中，如果属于同一事务的操作都是相邻的，则称 S 是串行调度。</p>
<p>​    冲突操作：在一个调度 S 中，如果 A 和 B 是不同事务在相同数据对象上的操作，并且其中至少有一个是写操作，则称 A 与 B 是冲突操作。</p>
<p>​    冲突等价：如果一调度 S 可以经过交换一系列非冲突操作执行的顺序而得到一个新的调度 S‘ ，则称 S 与 S’ 是冲突等价的。</p>
<p>​    冲突可串行化：如果一调度 S 与一串行调度是冲突等价 的，则称 S 是冲突可串行化的。</p>
<h5 id="判断调度是否可串行化的方法"><a href="#判断调度是否可串行化的方法" class="headerlink" title="判断调度是否可串行化的方法"></a>判断调度是否可串行化的方法</h5><p><img src="https://i.loli.net/2020/04/06/KOWfz9e1juAwros.png" alt="image-20200406101649482"></p>
<p><img src="https://i.loli.net/2020/04/06/4C2VSsKYmMUngI8.png" alt="image-20200406101753978"></p>
<p><img src="https://i.loli.net/2020/04/06/W5y9jOtbTdmeuCz.png" alt="image-20200406101814976"></p>
<p><img src="https://i.loli.net/2020/04/06/1uJ9kfFZqtl7VEz.png" alt="image-20200406101908368"></p>
<p>​    图 10-2(a) 中，对于 A 的并发访问：R1(A), W1(A), R2(A), W2(A)，存在 W1(A)后执行R2(A)，W1(A)后执行W2(A)。故 T1 -&gt; T2。优先图中无环可以串行化。</p>
<p>​    图 10-2(b) 中，对于 A 的并发访问：R2(A), W2(A), R1(A), W1(A) ，存在 W2(A)后执行R1(A)，W2(A)后执行W1A)。故 T2 -&gt; T1。优先图中无环可以串行化。</p>
<p>​    图10-8 中，对于 A 的并发访问：R4(A), W4(A), R6(A), W6(A)，存在 W4(A)后执行R6(A)，W4(A)后执行W6(A)。故 T4-&gt; T6。对于 B 的并发访问：R6(B), W6(B), R4(B), W4(B)，存在 W6(B)后执行R4(B)，W6(B)后执行W4(B)。故 T6-&gt; T4。优先图中有环，不可串行化。</p>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="基于封锁的协议"><a href="#基于封锁的协议" class="headerlink" title="基于封锁的协议"></a>基于封锁的协议</h4><p>​    并发控制机制大体上可分为悲观的和乐观的两种。悲观的并发控制方法认为数据库 的一致性经常会收到破坏，因此在事务访问数据对象前采取一定措施加以控制，只有得到访问许可时，才能访问数据对象，如<strong>基于封锁的并发控制方法</strong>。而乐观的并发控制方法则认为数据库的一致性通常不会得到破坏，故事务执行时可直接访问数据对象，只在事务结束时才验证数据库的一致性是否会遭到破坏，如基于有效性验证方法。</p>
<p>​    基于封锁的并发控制方法的基本思想是：当事务 <em>T</em> 需访问数据对象 <em>Q</em> 时，先申请对 <em>Q</em> 的锁。如批准获得，则 <em>T</em> 继续执行，且此后不允许其他任何事物修改 <em>Q</em>，直到事务 <em>T</em> 释放 <em>Q</em> 上的锁为止。</p>
<p>​    基本锁类型：</p>
<p>​    1）共享锁（Shared Lock，记为 S ）：如果事务 <em>T</em> 获得的对象 <em>Q</em> 上的共享锁，则 <em>T</em> 可读 <em>Q</em> 但不能写 <em>Q</em> 。</p>
<p>​    2）排他锁（eXclusive lock，记为 X ）：如果事务 <em>T</em> 获得的对象 <em>Q</em> 上的排他锁，则 <em>T</em> 可读 <em>Q</em> 又能写 <em>Q</em> 。</p>
<p>​    <strong>一个数据对象 <em>Q</em> 上可能有多个（被不同事务拥有的）共享锁，但任何时候只能有一个排他锁。</strong></p>
<p><img src="https://i.loli.net/2020/04/06/sNHdY7A2PhBy3ET.png" alt="image-20200406104004431"></p>
<p><img src="https://i.loli.net/2020/04/06/JX7bQ8va4hoMHNK.png" alt="image-20200406104529309"></p>
<p>​    图10-13 中的调度存在以下问题：</p>
<p>​    1）脏读。T2 步骤 11 读了 T1 修改后的数据，而T1 在步骤 12 回滚了。</p>
<p>​    2）不可重复读。如 T3 两次读到 A 的值不同。</p>
<p>​    3）不可串行化。</p>
<p>​    出现上述问题的原因是<strong>事务过早地释放了锁</strong>，如果规定事务在结束后才释放其持有地锁则可以保证调度的可串行性。但这会导致系统性能下降。</p>
<h4 id="两阶段封锁协议"><a href="#两阶段封锁协议" class="headerlink" title="两阶段封锁协议"></a>两阶段封锁协议</h4><p>​    两阶段封锁协议要求每个事务分两个阶段提出申请锁和解锁申请。</p>
<p>​    1）增长阶段：事务可以获得锁，但不能释放锁。</p>
<p>​    2）缩减阶段：事务可以释放锁，但不能获得新锁。</p>
<p>​    一开始，事务处于增长阶段，事务根据需要获得锁。一旦该事务释放了锁，它就进入了缩减阶段，不能再发出加锁请求。</p>
<p>​    两阶段封锁协议能保证冲突可串行化。对于任何事务，调度中该事务获得其最后加锁的时刻（增长阶段结束点）称为事务的封锁点。多个事务可以根据它们的封锁点进行排序，而这个顺序就是并发事务的一个冲突可串行化顺序。</p>
<p><img src="https://i.loli.net/2020/04/06/6OxDya25XE3bVAo.png" alt="image-20200406105546498"></p>
<p>​    图10-14 采用了两阶段封锁，允许 T4 在获得全部锁后（A 和 B 上的排他锁）提前释放部分锁（步骤 7 释放了 A 上的排他锁），T5得以提前执行，从而提高了 T4 和 T5 的并发度，该调度是可串行化 的。</p>
<p>​    两阶段封锁保证了并发执行事务的正确性，但仍存在两个主要问题：</p>
<p>​    1）可能导致死锁，即持有锁的事务出现相互等待都不能继续执行。解除死锁的一个简单方法是超时机制。如果一个事务为某个锁等待的时间过长，可以悲观得认为死锁已经发生，回滚该事务并重启。</p>
<p>​    2）不能避免读脏数据。</p>
<p>​    另一个两阶段封锁得变体是强两阶段封锁协议，它要求事务提交之前不得释放任何锁。事务可以按其提交得顺序串行化。</p>
<h4 id="封锁协议总结"><a href="#封锁协议总结" class="headerlink" title="封锁协议总结"></a>封锁协议总结</h4><p>在运用 X 锁和 S 锁这两种基本封锁对数据对象加锁时，还要约定一些规则。例如，何时申请 X 锁和 S 锁、封锁时间、何时释放等。这些规则称为封锁协议。</p>
<p>对并发操作的不正确调度可能会带来脏读、丢失修改、不可重复读等不一致性问题。三级封锁协议分别在不同程度上解决了这些问题，为并发操作的正确调度提供一定的保证。</p>
<ol>
<li>一级封锁协议，事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。</li>
<li>二级封锁协议，在一级封锁协议基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁。</li>
<li>三级封锁协议，在一级封锁协议基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。</li>
</ol>
<p><img src="https://i.loli.net/2020/05/11/RkMmTrJnKHz3OWl.png" alt="image-20200511093025700"></p>
<p>总结：三个等级的封锁协议都是事务结束后释放 X 锁，不同的是一级封锁对于读取数据不加 S 锁，二级封锁加 S 锁，但在读取操作结束后就释放，三级封锁加 S 锁，在事务结束后释放。一级封锁保证不会丢失修改，二级封锁保证不会丢失修改和脏读，三级封锁保证不会丢失修改、脏读和可重复读。</p>
<p><img src="https://i.loli.net/2020/05/11/GvaPKLouCjOWF9s.png" alt="image-20200511095857695"></p>
<h4 id="活锁与死锁"><a href="#活锁与死锁" class="headerlink" title="活锁与死锁"></a>活锁与死锁</h4><p>活锁就是一个事务一直处于“饥饿”状态。死锁即为临界资源的循环占用。</p>
<p><img src="https://i.loli.net/2020/05/11/F5Vo6EMKPB9akYb.png" alt="image-20200511100149015"></p>
<p>避免出现“饥饿”现象的最简方法为采用 FCFS 策略。</p>
<p>避免死锁的方法有<strong>预防死锁</strong>和<strong>诊断并解除死锁</strong>两种。</p>
<p>预防死锁：</p>
<ol>
<li>一次封锁法，每个事务必须一次将所有使用的数据全部加锁。</li>
<li>顺序封锁法，对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁。</li>
</ol>
<p>诊断和解除死锁</p>
<ol>
<li>超时法，如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。</li>
<li>等待图法，出现环则发现死锁。</li>
</ol>
<h4 id="封锁的粒度"><a href="#封锁的粒度" class="headerlink" title="封锁的粒度"></a>封锁的粒度</h4><p>封锁对象的大小称为封锁粒度。封锁对象可以是逻辑单元，也可以是物理单元。封锁粒度与系统的并发度和并发控制的开销密切相关，封锁的粒度越大，并发度越小，系统的开销也越小；封锁的粒度越小，并发度较高，系统开销也较大。</p>
<h5 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h5><p>多粒度树的根结点是整个数据库，表示最大的数据粒度。叶节点表示最小的数据粒度。</p>
<p>多粒度封锁协议允许多粒度树中的每个结点被独立地加锁，对一个结点加锁意味着这个结点所有子节点也被加以同样类型的锁。在多粒度封锁中，一个数据对象可能以两种方式封锁：显式封锁和隐式封锁。显示封锁是应事务的要求直接加到数据对象上的锁；隐式封锁是该数据对象没有被独立加锁，由于其上级结点加锁而使该数据对象加上了锁。</p>
<p><img src="https://i.loli.net/2020/05/11/Mix5FDt8dfVoYwX.png" alt="image-20200511122559581"></p>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>意向共享锁（Intent Share Lock，IS 锁）意向排他锁（Intent Exclusive Lock，IX 锁）；共享意向排他锁（Share Intent Exclusive Lock，SIX 锁）。</p>
<ol>
<li>IS 锁，如果对一个数据对象加 IS 锁，表示它的子结点拟加 S 锁。</li>
<li>IX 锁，如果对一个数据对象加 IX 锁，表示它的子结点拟加 X 锁。</li>
<li>SIX 锁，如果对一个数据对象加 SIX 锁，表示对它加 S 锁，再加 IX 锁。</li>
</ol>
<p>在具有意向锁的多粒度封锁方法中，任意事务 T 要对一个数据对象加锁，必须先对它的上层结点加意向锁。申请封锁时应该按自上而下的次序进行，释放封锁时则应该按自下而上的次序进行。</p>
<p><img src="https://i.loli.net/2020/05/11/WrXlch5Ly9KAwoS.png" alt="image-20200511123052840"></p>
<p>图 b 中，所谓锁的强度是指它对其他锁的排斥程度。一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然。</p>
<h4 id="其他并发控制机制"><a href="#其他并发控制机制" class="headerlink" title="其他并发控制机制"></a>其他并发控制机制</h4><p>并发控制的方法除了封锁技术外还有时间戳方法、乐观控制法和多版本并发控制等。</p>
<p>时间戳方法给每一个事务盖上一个时标，即事务开始执行的时间。每个事务具有唯一的时间戳，并按照这个时间戳来解决事务的冲突操作。</p>
<p>乐观控制阀认为书屋执行时很少发生冲突，不对事务进行特殊的管制，而是让它自由执行，事务提交前再进行正确性检查。如果发生冲突则回滚事务。</p>
<p>多版本并发控制是指数据库中通过维护数据对象的多个版本信息来实现高效并发控制的一种策略。</p>
<h3 id="恢复与备份"><a href="#恢复与备份" class="headerlink" title="恢复与备份"></a>恢复与备份</h3><h4 id="故障分类及恢复策略"><a href="#故障分类及恢复策略" class="headerlink" title="故障分类及恢复策略"></a>故障分类及恢复策略</h4><p>​    1）事务故障。事务未运行至正常终止点就夭折了。</p>
<p>​    2）系统故障。突发事件导致系统停止运行。</p>
<p>​    3）介质故障。硬件损坏。</p>
<p>​    4）其他故障。有人攻击。</p>
<h4 id="事务访问数据方式"><a href="#事务访问数据方式" class="headerlink" title="事务访问数据方式"></a>事务访问数据方式</h4><p>​    对于一个事务而言，它是通过 3 个地址空间同数据库进行交互：</p>
<p>​    1）保存数据库元素的磁盘块空间——物理数据库。</p>
<p>​    2）缓冲区管理器所管理的内存地址空间——数据缓冲区。</p>
<p>​    3）事务的局部地址空间——事务工作区。</p>
<p>​    当事务要读取数据库元素时，首先必须将该元素从物理数据库读取到数据缓冲区中，除非它已经在缓冲区中，然后再将缓冲区中的内容读到事务工作区中。</p>
<p><img src="https://i.loli.net/2020/04/06/GZAjXMbNu4z7apB.png" alt="image-20200406111338451"></p>
<p><img src="https://i.loli.net/2020/04/06/TcfswaB6NqoKzdp.png" alt="image-20200406111426865"></p>
<h4 id="基于日志的故障恢复策略"><a href="#基于日志的故障恢复策略" class="headerlink" title="基于日志的故障恢复策略"></a>基于日志的故障恢复策略</h4><p>​    日志是 DBMS 记录数据库全部更新操作的序列文件。通常一个数据库系统只有一个日志文件，为所有事务共享，其主要特点有：</p>
<p>​    1）日志文件记录了数据库的全部更新顺序。</p>
<p>​    2）每条日志都记录在日志的尾部，故日志文件是一个追加文件。</p>
<p>​    3）DBMS 允许事务的并发执行导致日志文件是“交错的”。</p>
<p>​    4）属于单个事务的日志顺序与该事务的更新操作顺序是一致的。</p>
<p>​    5）日志记录通常是先写到日志缓冲区中，然后写到稳定存储器中。</p>
<p>​    数据库中的日志记录有两种类型：</p>
<p>​    1）记录数据更新操作的日志记录，包括 update，insert 和 delete 操作。</p>
<p>​    2）记录事务操作的日志记录，包括start，commit 和 abort 操作。</p>
<p>​    它们的具体记录格式如下：</p>
<p>​    &lt; Ti, A, V1,V2 &gt; 表示 Ti 对数据元素 A 执行了更新操作，V1为 A 更新前的值，V2表示 A 更新后的值。</p>
<p>​    &lt; Ti, START &gt; 表示事务 Ti 已经开始。此时 DBMS 完成对事务的初始化工作，如分配事务工作区等。</p>
<p>​    &lt; Ti, COMMIT &gt; 表示事务 Ti 已经提交。</p>
<p>​    &lt; Ti, ABORT &gt; 表示事务已经终止，即事务执行失败。</p>
<p>​    为了保证数据库能运用日志进行恢复，要求日志文件必须放到稳定存储器上，并且要求每条日志记录必须在其所包含数据元素的更新值写到稳定存储器之前写到稳定存储器上，即<strong>先写日志</strong>规则。</p>
<h5 id="UNDO-操作"><a href="#UNDO-操作" class="headerlink" title="UNDO 操作"></a>UNDO 操作</h5><p>​    事务 T 执行过程中修改了数据库后，可能由于某种原因事务中止或系统崩溃，可使用 UNDO 恢复技术将 T 修改的全部数据对象值恢复到 T 开始前的状态。</p>
<p>​    对于要 UNDO 的事务 T ，日志中记录有 &lt;T, START&gt; 以及 T 对数据库的所有更新操作的日志记录。UNDO 过程为：从 T 的最后一条更新日志开始，从日志尾向日志头（反向）依次将 T 更新的数据元素恢复为旧值（V1）。</p>
<p>​    之所以需要 UNDO ，是因为故障发生时未提交事务的修改可能已写到磁盘上。</p>
<h5 id="REDO-操作"><a href="#REDO-操作" class="headerlink" title="REDO 操作"></a>REDO 操作</h5><p>​    REDO 操作时对已提交事务进行重做，将数据库状态恢复到事务结束后的状态。</p>
<p>​    对于要 REDO 的事务 T，日志中已经记录了 &lt;T, START&gt;  ，T 的所有更新操作日志以及 &lt;T, COMMIT&gt;。REDO 的过程为：从 T 的第一条更新日志记录来时，从日志头向日志尾（顺向）依次将 T 更新的数据元素值恢复为新值（V2）。</p>
<p>​    需要 REDO 的原因是，故障发生时可能有些已提交事务的更新数据还未写到磁盘上。</p>
<h5 id="并发执行事务的基本恢复过程"><a href="#并发执行事务的基本恢复过程" class="headerlink" title="并发执行事务的基本恢复过程"></a>并发执行事务的基本恢复过程</h5><p>​    1）分析阶段。从日志头开始顺向扫描日志，以确定重做事务集和撤销事务集。将既有  &lt;T, START&gt;又有 &lt;T, COMMIT&gt; 日志记录的事务 T 加入重做事务集。将只有  &lt;T, START&gt;没有 &lt;T, COMMIT&gt; 日志记录的事务 T 加入撤销事务集。</p>
<p>​    2）撤销阶段。从日志尾反向扫描日志，对每一条属于撤销事务集中的事务更新操作日志依次执行 UNDO 操作。</p>
<p>​    3）重做阶段。从日志头顺向扫描日志，对每一条属于重做事务集中的事务更新操作日志依次执行 REDO 操作。</p>
<h4 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h4><p>​    检查点是周期性地向日志中写一条检查点记录并记录所有当前活跃的事务，为恢复管理器提供信息，以决定从日志的何处开始恢复。在日志记录中使用 &lt; Checkpoint L &gt;来指定检查点 L 。</p>
<p>​    图10-19 是系统崩溃时的不同事务状态类型，其中 Tc 为完成最近检查点时刻，Tf 为故障发生时刻。 </p>
<p><img src="https://i.loli.net/2020/04/06/TgmJlz6Qevkprni.png" alt="image-20200406114406231"></p>
<h4 id="备份与介质故障恢复"><a href="#备份与介质故障恢复" class="headerlink" title="备份与介质故障恢复"></a>备份与介质故障恢复</h4><p>​    动态备份是指备份操作与用户事务的执行并发进行，备份期间允许对数据库进行存取或修改。静态备份则要等待用户事务结束然后备份。</p>
<p>​    具体进行数据备份时可以有两种方式，一种是全备份，一种是增量备份。</p>
<p>​    全备份是指每次备份全部数据库，而增量备份只备份上次备份后更新过的数据。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>二分查找 Hard</title>
    <url>/2020/04/29/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEHard/</url>
    <content><![CDATA[<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></h4><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。</p>
<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>

<p>先考虑一个有序数组中查找中位数的情况：当数组元素为奇数时，取最中间的一个元素；当数组元素为偶数时，取最中间的两个元素的平均值。</p>
<p>有两个有序数组时我们先计算出总数组的长度，在两个数组中间画一条分割线，当两条分割线左侧的元素个数为总数组长度的一半时，在分割线左右的四个元素则是构成中位数的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length &gt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="comment">//分割线左边的所有元素需要满足的个数(m + n + 1) / 2</span></span><br><span class="line">        <span class="keyword">int</span> totalLeft = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//在 nums1 的区间 [0, m]里查找恰当的分割线</span></span><br><span class="line">        <span class="comment">//使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="comment">//在较小长度的数组使用二分查找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//向上取整</span></span><br><span class="line">            <span class="keyword">int</span> i = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line">            <span class="comment">//搜索分割线位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] &gt; nums2[j])&#123;<span class="comment">//不满足交叉小于的情况</span></span><br><span class="line">                <span class="comment">//下一轮搜索区间 [left, i - 1]</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间 [i, right]</span></span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line">        <span class="keyword">int</span> nums1LeftMax = i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">        <span class="keyword">int</span> nums2LeftMax = j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> nums2RightMIn = j == n ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((m + n) % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums1LeftMax, nums2LeftMax);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)((Math.max(nums1LeftMax,nums2LeftMax) + Math.min(nums1RightMin, nums2RightMIn))) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 O( log( min(<em>m</em>,n) ) )，空间复杂度：O(1)。</p>
<h4 id="1095-山脉数组中查找目标值"><a href="#1095-山脉数组中查找目标值" class="headerlink" title="1095. 山脉数组中查找目标值"></a><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></h4><p>（这是一个 <strong>交互式问题</strong> ）</p>
<p>给你一个 <strong>山脉数组</strong> <code>mountainArr</code>，请你返回能够使得 <code>mountainArr.get(index)</code> <strong>等于</strong> <code>target</code> <strong>最小</strong> 的下标 <code>index</code> 值。</p>
<p>如果不存在这样的下标 <code>index</code>，就请返回 <code>-1</code>。</p>
<p>何为山脉数组？如果数组 <code>A</code> 是一个山脉数组的话，那它满足如下条件：</p>
<p><strong>首先</strong>，<code>A.length &gt;= 3</code></p>
<p><strong>其次</strong>，在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 <code>i</code> 使得：</p>
<ul>
<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>
<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>
</ul>
<p>你将 <strong>不能直接访问该山脉数组</strong>，必须通过 <code>MountainArray</code> 接口来获取数据：</p>
<ul>
<li><code>MountainArray.get(k)</code> - 会返回数组中索引为<code>k</code> 的元素（下标从 0 开始）</li>
<li><code>MountainArray.length()</code> - 会返回该数组的长度</li>
</ul>
<p><strong>注意：</strong></p>
<p>对 <code>MountainArray.get</code> 发起超过 <code>100</code> 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p>
<p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “<strong>答案</strong>”：<a href="https://leetcode-cn.com/playground/RKhe3ave，请注意这" target="_blank" rel="noopener">https://leetcode-cn.com/playground/RKhe3ave，请注意这</a> <strong>不是一个正确答案</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：array &#x3D; [1,2,3,4,5,3,1], target &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：array &#x3D; [0,1,2,4,2,1], target &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line">解释：3 在数组中没有出现，返回 -1。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li>
<li><code>0 &lt;= target &lt;= 10^9</code></li>
<li><code>0 &lt;= mountain_arr.get(index) &lt;= 10^9</code></li>
</ul>
<p>山脉数组表示数组中间存在一个最大的数，它左边的数都是单调递增，右边的数都是单调递减。如果是已经排序的数组我们可以想到二分查找，那么山脉数组能不能也使用二分查找呢？</p>
<p>答案是可以，只要我们找到最高点的下标，将山脉数组分成左边一个单调递增的数组，右边分为一个单调递减的数组，然后分别对这两个数组进行二分查找。</p>
<p>问题的关键是如何找到最高点的下标，常规的做法是直接遍历一遍数组找到最大值的下标。更巧妙的方法是使用类似二分查找的方法来找到最高点的下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">	<span class="comment">//计算中间点的下标</span></span><br><span class="line">	<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//mountainArr[mid] &lt; mountainArr[mid+1] </span></span><br><span class="line">	<span class="comment">//mountainArr[mid+1]比其左侧的值都大,其左侧的值不可能为最高点</span></span><br><span class="line">	<span class="keyword">if</span>(mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="number">1</span>))&#123;</span><br><span class="line">		<span class="comment">//下一轮搜索区间[mid+1, right]</span></span><br><span class="line">		left = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123; <span class="comment">//mountainArr[mid] &gt;= mountainArr[mid+1] </span></span><br><span class="line">		   <span class="comment">//mountainArr[mid]比其左侧的值都大,其右侧的值不可能为最高点</span></span><br><span class="line">		<span class="comment">//下一轮搜索区间[left, mid]</span></span><br><span class="line">		right = mid;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到了最高点后，先在左边递增的部分寻找目标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(mountainArr.get(mid) &lt; target)&#123;</span><br><span class="line">          <span class="comment">//target 比 mountainArr[mid+1]左侧的值都大,其左侧的值不可能为target</span></span><br><span class="line">          <span class="comment">//下一轮搜索区间[mid+1, right]</span></span><br><span class="line">          left = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//target 比 mountainArr[mid]右侧的值都小,其右侧的值不可能为target</span></span><br><span class="line">          <span class="comment">//下一轮搜索区间[left, mid]</span></span><br><span class="line">          right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没找到就在右边递减的部分寻找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(mountainArr.get(mid) &lt; target)&#123;</span><br><span class="line">          <span class="comment">//target 比 mountainArr[mid-1]右侧的值都大,其右侧的值不可能为target</span></span><br><span class="line">      	  <span class="comment">//下一轮搜索区间[left, mid - 1]</span></span><br><span class="line">      	  right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">//target 比 mountainArr[mid]左侧的值都小,其左侧的值不可能为target</span></span><br><span class="line">      	 <span class="comment">//下一轮搜索区间[mid, right]</span></span><br><span class="line">         <span class="comment">//[left(mid), right] --&gt; [left, right(mid)] 将下取整改为上取整</span></span><br><span class="line">         <span class="comment">//否则为死循环</span></span><br><span class="line">      left = mid;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将整合所有部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is MountainArray's API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * interface MountainArray &#123;</span></span><br><span class="line"><span class="comment"> *     public int get(int index) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     public int length() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = mountainArr.length();</span><br><span class="line">        <span class="keyword">int</span> peekIndex = findPeekIndex(mountainArr, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mountainArr.get(peekIndex) == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> peekIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = findSortedArray(target, mountainArr, <span class="number">0</span>, peekIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findReverseArray(target, mountainArr, peekIndex + <span class="number">1</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findPeekIndex</span><span class="params">(MountainArray mountainArr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[mid+1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[left, mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left == right</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSortedArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mountainArr.get(mid) &lt; target)&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[mid+1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[left, mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mountainArr.get(left) == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findReverseArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mountainArr.get(mid) &lt; target)&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[mid, right]</span></span><br><span class="line">                <span class="comment">//[left(mid), right] --&gt; [left, right(mid)] 将下取整改为上取整</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mountainArr.get(left) == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/2020/04/04/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h3 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h3><h4 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h4><p>　　传输层向它上面的应用层提供通信服务，属于面向通信部分的最高层，同时也是用户功能中的最底层。</p>
<p>　　<strong>传输层</strong>位于网络层上，它为运行在不同主机上的<strong>进程</strong>之间提供了逻辑通信，<strong>网络层</strong>提供<strong>主机</strong>之间的逻辑通信。即使网络层协议不可靠（网络层协议使分组丢失、混乱或重复），传输层同样能为应用程序提供可靠的服务。</p>
<p>　　传输层的功能如下：</p>
<p>　　1）提供应用进程之间的通信（端到端的通信）。与网络层的区别是，网络层提供的是主机之间的逻辑通信。</p>
<p>　　2）复用和分用。复用是指发送方不同的应用进程都可以使用同一个传输层协议传输数据；分用指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的进程。</p>
<p>　　注意：传输层的复用和分用与网络层复用分用功能不同。网络层的复用是指发送方不同协议的数据都可以封装成IP数据报发送出去，分用是指接收方的网络层在剥去首部后把数据交付给相应的协议。</p>
<p>　　3）传输层还要对收到的报文进行差错检测（首部和数据部分）。而网络层只检测 IP 数据报的首部，不检验数据部分是否出错。</p>
<p>　　4）提供两种不同的传输协议，即面向连接的 TCP 和面向无连接的 UDP。网络层无法同时实现两种协议（在网络层要么只提供面向连接的服务，如虚电路；要么只提供无连接服务，如数据报，不可能在网络层同时存在这两种方式）。</p>
<p>　　当传输层采用 TCP 时尽管下面的网络是不可靠的，但这种逻辑通信通道就相当于一条全双工的可靠信道。当传输层采用 UDP 时，这种逻辑信道仍是一条不可靠信道。</p>
<p><img src="https://i.loli.net/2020/04/04/3FQL42bwSgD95yh.png" alt="img"></p>
<h4 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h4><h5 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h5><p>　　端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道将其报文段中的数据向上交付给应用层相应的进程。端口是传输层服务访问点（TSAP），它在传输层的作用类似于 IP 地址在网络层的作用，或MAC地址在数据链路层的作用，只不过IP地址和MAC地址标识的是主机，而端口标识的是主机中的应用进程。</p>
<p>　　数据链路层的SAP 是MAC地址，网络层的SAP是IP地址，传输层的SAP 是端口。</p>
<h5 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h5><p>　　应用进程通过端口号进行标识，端口号长16个比特，能够表示65536 个不同的端口号。</p>
<p>　　端口号只具有本地意义，即端口号只标识本计算机应用层中的各进程，在因特网中不同计算机的相同端口号是没有联系的。根据端口号范围可将端口分为两类：</p>
<p>　　1）服务端使用的端口号。这里分为两类，最重要的一类是<strong>熟知端口号</strong>，数值为<strong>0~1023</strong>，IANA（互联网地址指派机构）把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有用户都知道。另一类为登记端口号，数值为 1024~49151。它是供没有熟知端口的应用程序使用的，使用这类端口必须在IANA登记。</p>
<p><img src="https://i.loli.net/2020/04/04/wcfgOCdMm4XUkRv.png" alt="img"></p>
<p> 　2）客户端使用的端口号，数值为 49152~65535 ，这类端口号仅在客户进程运行时才动态地选择，因此又称短暂端口号（也称临时端口）。</p>
<h5 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h5><p>　　在网络中通过IP地址来区别不同地主机，通过端口号来标识和区分一台主机中不同应用进程。在网络中采用发送方和接收方地套接字（Socket）组合来识别端点。</p>
<p>　　套接字 = （主机IP地址，端口号）</p>
<p>　　它唯一地标识网络中的一台主机和其上的一个应用。</p>
<p>　　</p>
<h4 id="无连接服务与面向连接服务"><a href="#无连接服务与面向连接服务" class="headerlink" title="无连接服务与面向连接服务"></a>无连接服务与面向连接服务</h4><p>　　面向连接服务就是在通信双方进行通信之前，必须先建立连接，在通信过程中，整个连接的情况一直被实时地监控和管理。通信结束后，应该释放这个连接。</p>
<p>　　无连接服务是指两个实体之间地通信不需要先建立好连接，需要通信时，直接将信息发送到“网络”中，让该信息地传递在网上尽力而为地往目的地传送。</p>
<p>　　TCP/IP 协议族 在 IP 上使用了两个传输协议：一个是面向连接的传输控制协议（Transmission Control Protocol，TCP），采用TCP时，传输层向上提供的是一条全双工的可靠逻辑信道；另一个是无连接的用户数据报协议（User Datagram Protocol，UDP），采用UDP时，传输层向上提供的是一条不可靠的逻辑信道。</p>
<p>　　TCP 在传送数据之前必须先建立连接，数据传送后要释放连接。TCP 不提供广播或组播服务。由于TCP提供面向连接的可靠传输服务，不可避免地增加了许多开销，如确认、流量控制、计时器及连接管理等。TCP 更适合可靠性更重要地场合，如 FTP，HTTP，TELNET等。</p>
<p>　　UDP 是一个无连接地非可靠传输层协议。它在IP之上仅提供两个附加服务：多路复用和对数据地错误检查。UDP 比较简单，执行速度快、实时性好。使用 UDP 的应用主要包括小文件传送协议（TFTP）、DNS、SMTP和实时传输协议（RTP）。</p>
<h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><h4 id="UDP-数据报"><a href="#UDP-数据报" class="headerlink" title="UDP 数据报"></a>UDP 数据报</h4><h5 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h5><p>　　UDP 具有如下优点：1) UDP 无须建立连接。2）无连接状态。3）分组首部开销小，TCP 有20B的首部开销，UDP 仅有8B的开销。4）应用层能更好地控制要发送的数据和发送时间。</p>
<p>　　UDP 常用于一次性传输较少数据的网络应用如 DNS等。UDP 提供尽最大努力交付，不保证可靠交付。UDP 是面向报文的。报文不可分割，是UDP数据报处理的最小单位。</p>
<p>　　</p>
<h5 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h5><p><img src="https://i.loli.net/2020/04/04/f6CQvHwS4l57PYu.png" alt="img"></p>
<p>　　1）源端口。源端口号。在需要对方回信时选用，不用可为全0.</p>
<p>　　2）目的端口。目的端口号。交付报文时必须使用到。</p>
<p>　　3）长度。UDP 数据报的长度（包括首部和数据），其最小值是 8B。</p>
<p>　　4）校验和。检测UDP数据报在传输中是否有错。有错就丢弃。</p>
<p>　　当传输 层从IP 层收到 UDP 数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口上交给应用进程。如果接收方UDP发现收到的报文中目的端口号不正确，丢弃报文，并由ICMP发送“端口不可达”差错报文给发送方。</p>
<p>　　</p>
<h4 id="UDP-校验"><a href="#UDP-校验" class="headerlink" title="UDP 校验"></a>UDP 校验</h4><p>　　在计算校验和时要在UDP数据报之前增加12B的伪首部，仅仅是为了计算校验和。</p>
<p>　　<strong>IP 数据报的校验和只检验IP数据报的首部，UDP的校验和则检查首部和数据部分。</strong></p>
<h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><h4 id="TCP-协议的特点"><a href="#TCP-协议的特点" class="headerlink" title="TCP 协议的特点"></a>TCP 协议的特点</h4><p>　　TCP 是在不可靠的 IP 层上实现的可靠数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。</p>
<p>　　TCP 协议的特点：</p>
<p>　　1）TCP 是面向连接的传输层协议。</p>
<p>　　2）每条TCP 连接只能有两个端点，每条TCP 连接只能是点对点的。</p>
<p>　　3）TCP 提供可靠的交付服务，保证传输的数据无差错、不丢失、不重复且有序。</p>
<p>　　4）TCP 提供全双工通信，允许双方的应用进程在任何时候都能发送数据，为此 TCP 连接的两端都设有发送缓存和接收缓存。</p>
<p>　　5）TCP 是面向字节流的。</p>
<p>　　</p>
<h4 id="TCP-报文段"><a href="#TCP-报文段" class="headerlink" title="TCP 报文段"></a>TCP 报文段</h4><p>　　TCP 传送的数据单元称为报文段。一个TCP 报文段分为 TCP 首部和TCP 数据两部分。整个TCP 报文作为 IP 数据报的数据部分封装在 IP 数据报中。其首部的前20B是固定的。TCP 报文段首部最短为20B，后面有4N字节是根据需要而增加的选项，通常长度是4B的整数倍。</p>
<p>　　TCP 报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答。</p>
<p><img src="https://i.loli.net/2020/04/04/ZrPKCWlDYTie6Mj.png" alt="img"></p>
<p> 　1）源端口和目的端口 各占2B。端口是传输层和应用层的服务接口，运输层的复用和分用功能都通过端口实现。</p>
<p>　　2）序号字段 占4B。TCP 是面向字节流的（TCP 传送时是逐个字节传送的），所以<strong>TCP连接传送得数据流中得每个字节都编上一个序号。序号字段得值指的是本报文段所发送的数据的第一个字节的序号</strong>。</p>
<p>　　3）确认号字段，占4B。<strong>是期望收到对方下一个报文段的数据的第一个字节的序号。若确认号为 N，则表明到序号 N-1 为止的所有数据都已正确收到。</strong></p>
<p>　　4）数据偏移（首部长度）占4位。表示首部的长度 以4B为单位。</p>
<p>　　5）保留字段。占6位。</p>
<p>　　6）紧急位URG。URG=1时，表明紧急指针字段有效。告诉系统报文段中有紧急数据。URG 要配合紧急指针使用，即数据从第一个字节到紧急指针所指字节就是紧急数据。</p>
<p>　　7）确认位ACK。只有当ACK=1时确认号字段才有效。当ACK=0时确认号无效。<strong>TCP 规定，在连接建立后所有传送的报文段必须把ACK置1。</strong></p>
<p>　　8）推送位PSH。接收TCP 收到PSH=1的报文段，就尽快地交付给应用进程。</p>
<p>　　9）复位位RST。当RST=1时表明TCP连接中出现严重错误，必须释放连接再重新建立运输连接。</p>
<p>　　10）同步位SYN。同步SYN=1表示这是一个连接请求或连接接收报文。当SYN=1，ACK=0时表示这是一个连接请求报文，若对方同意建立连接，则在相应报文中使用SYN=1，ACK=1。</p>
<p>　　11）终止位FIN。用来释放一个连接。FIN表明此报文段的额发送方的数据已发送完毕。</p>
<p>　　12）窗口字段。占2B它指出现在允许对方发送的数据量。</p>
<p>　　13）校验和。占2B。校验和字段检验的范围包括首部和数据两部分。计算校验和也要在TCP报文段前面加上12B的伪首部。</p>
<p>　　14）紧急指针字段。占16位，指出本报文段中紧急数据有多少字节。</p>
<p>　　15）选项字段。长度可变。TCP 只规定了一种窜巷，即最大报文长度MSS。MSS是TCP报文段中数据字段的最大长度。</p>
<p>　　16）填充字段。使整个首部长度是4B的整数倍。</p>
<h4 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h4><p>　　TCP 是面向连接的协议，因此每个TCP 连接都有三个阶段：<strong>连接建立、数据传送和连接释放</strong>。</p>
<p>　　TCP 连接建立过程中，要解决以下三个问题：</p>
<p>　　1）要使每一方都能够确知对方的存在。</p>
<p>　　2）要允许双方协商一些参数</p>
<p>　　3）能够运输实体资源。</p>
<p>　　TCP 把连接作为最基本的抽象，每条TCP连接有两个端点，TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口。TCP连接的端口称为套接字。端口拼接到IP地址即构成套接字。</p>
<p>　　1、TCP 连接的建立：三次握手。</p>
<p><img src="https://i.loli.net/2020/04/04/blFim8spoScZdGB.png" alt="img"></p>
<p> 　服务端的资源是在第二次握手时分配的，客户端的资源是在第三次握手时分配的，使得服务器易收到SYN洪泛攻击。</p>
<h5 id="为什么不采用“两次握手”建立连接？"><a href="#为什么不采用“两次握手”建立连接？" class="headerlink" title="为什么不采用“两次握手”建立连接？"></a><strong>为什么不采用“两次握手”建立连接？</strong></h5><p>　　防止两次握手情况下将已经失效的连接请求报文突然又传到服务器而产生错误。以客户 A 向服务器 B 建立连接为例。A 向 B 先发送连接请求 ，但是网络拥堵没有及时到达，还没有到达 B ，A的就超时重传了，再次发送了一个连接请求。等第一个请求报文到达服务器时服务器给出确认报文。收到第二个报文服务器认为又要请求连接，又给出确认报文。在网络拥堵时就会浪费服务器资源。</p>
<p>　　如果是三次握手，第二次的请求报文不是服务器想要的报文，连接建立失败。</p>
<p>　　2、TCP 连接的释放：四次挥手。</p>
<p><img src="https://i.loli.net/2020/04/04/5wOiGbaTICBSJ4j.png" alt="img"></p>
<h5 id="为什么不采用“三次挥手”释放连接，且发送最后一次挥手报文要等待2MSL时间呢？"><a href="#为什么不采用“三次挥手”释放连接，且发送最后一次挥手报文要等待2MSL时间呢？" class="headerlink" title="为什么不采用“三次挥手”释放连接，且发送最后一次挥手报文要等待2MSL时间呢？"></a><strong>为什么不采用“三次挥手”释放连接，且发送最后一次挥手报文要等待2MSL时间呢？</strong></h5><p>　　1）确保A发送的 最后一个确认报文能够到达B，如果 A 不等待 2MSL， 若A返回的最后一个确认报文段丢失，B不能正常关闭，而此时A已经关闭，不可能再重传。</p>
<p>　　2)防止出现“已失效的连接请求报文段”。A 在发送最后一个确认报文段之后，再经过2MSL可保证本连接持续的时间内产生的所有报文段从网络中消失。</p>
<p>　　</p>
<h4 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h4><p>　　TCP 使用了校验、序号、确认和重传等机制来达到这一目的。</p>
<h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><p>　　TCP 首部的序号字段用来保证数据能有序提交给应用层，TCP 把数据视为一个无结构但有序的字节流，序号建立在传送的字节流上，而不建立在报文段上。</p>
<p>　　TCP 连接传送的数据流中的每个字节都编上一个序号。</p>
<p><img src="https://i.loli.net/2020/04/04/frq8gsQlw239Y1h.png" alt="img"></p>
<p>　　上图中第一个报文段序号为0，第二个为3。</p>
<h5 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h5><p>　　<strong>TCP 首部的确认号是期望收到对方的下一个报文段的第一个字节的序号。</strong></p>
<p>　　<strong>TCP 默认使用累计确认，即TCP 只确认数据流中至第一个丢失字节为止的字节。</strong></p>
<h5 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h5><p>　　有两种事件会导致TCP 对报文段进行重传，超时和冗余 ACK。</p>
<p>　　1）超时</p>
<p>　　TCP 每发送一个报文段，就对这个报文段设置一次计时器。重传时间到期未收到确认则重传。</p>
<p>　　2）冗余ACK（冗余确认）</p>
<p>　　TCP 规定每当比期望序号大的失序报文到达时，就发送一个冗余ACK，指明下一个期望字节的序号。</p>
<h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><p>　　TCP 提供流量控制服务来消除发送方使接收方缓冲区溢出的可能性，流量控制是一个速度匹配服务。</p>
<p>　　TCP 提供一种基于滑动窗口协议的流量控制机制，这里介绍TCP如何使用窗口机制来实现流量控制。</p>
<p>　　在通信过程中，接收方根据自己的接收缓存的大小，动态地调整发送方地发送窗口大小，这称为<strong>接收窗口 rwnd</strong>，即调整TCP首部中“窗口”字段值，来限制发送方向向网络注入报文地速率。同时发送方根据其对当前网络拥塞程序的估计而确定的窗口值，这称为<strong>拥塞窗口 cwnd</strong>。</p>
<p>　　例如，在通信中，有效数据只从A发往B，而B仅向A发送确认报文，这时B可通过设置确认报文段首部的窗口字段来将rwnd通知给A。<strong>rwnd即接收方允许连续接收的最大能力，单位是字节。</strong></p>
<p> 　传输层和数据链路层的流量控制的区别是：传输层定义端到端用户之间的流量控制、数据链路层定义两个中间结点的流量控制。另外，数据链路层的滑动窗口协议的大小不能动态变化，传输层的可以动态变化。</p>
<p><img src="https://i.loli.net/2020/04/04/Dodg3HIf7sBjJbW.png" alt="img"></p>
<h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a><strong>TCP 拥塞控制</strong></h4><p>　　所谓拥塞控制，是为了防止过多的数据注入网络，保证网络中的路由器或链路不致过载。</p>
<p>　　拥塞控制与流量控制的区别：拥塞控制是网络能够承受现有的网络复合，是一个全局性的过程，涉及所有主机、所有的路由器，以及与降低网络传输性能有关的所有因素。流量控制往往是指点对点 的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率。</p>
<p>　　发送方在确定发送报文段的速率时，既要根据接收方的接收能力，又要从全局考虑不要使网络发生拥塞。因此，TCP 协议要求发送方维护以下两个窗口：　　</p>
<p>　　1）接收窗口cwnd，接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量。由接收方根据其放在TCP报文首部的窗口值通知发送方。</p>
<p>　　2）拥塞窗口cwnd，发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络的当前容量。</p>
<p>　　<strong>发送窗口的上限值应取接收窗口 rwnd 和拥塞窗口 cwnd 中较小的一个。</strong></p>
<p>　　<strong><img src="https://i.loli.net/2020/04/04/2wIRxO9r1jsymtp.png" alt="img"></strong></p>
<p> 　接收窗口的大小可根据TCP报文的窗口字段通知发送方，发送方如何维护拥塞窗口呢？下面讲慢开始和拥塞避免算法。</p>
<h5 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h5><h6 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h6><p>　　在TCP 刚连接好并开始发送TCP 报文时，先令拥塞窗口 cwnd=1，即一个最大报文段长度MSS，每收到一个对新报文的确认后将 cwnd加1，即增大一个MSS。逐步加大发送方的拥塞窗口。</p>
<p>　　例如，A 向 B 发送数据，发送时 A 的拥塞窗口为 2，那么 A 一次可以发送两个 TCP 报文段，经过一个 RTT 后，A 收到 B 对刚才两个报文的确认，于是把拥塞窗口调整为 4，下一次发送时就可以一次发送4个报文段。</p>
<p>　　<strong>使用慢开始算法后，每经过一个传输轮次（一个RTT），拥塞窗口 cwnd 就会加倍，即cwnd 的大小指数式增长。这样慢开始一直把拥塞窗口 cwnd 增大到一个规定的慢开始门限 ssthresh（阈值），然后改用拥塞避免算法。</strong></p>
<h6 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h6><p>　　<strong>发送端的拥塞窗口 cwnd 每经过一个 RTT 就增加一个MSS的大小，而不是加倍，时cwnd按线性规律缓慢增长，当出现一次超时（网络拥塞）时，令慢开始门限 ssthresh 等于当前cwnd 的一半。</strong></p>
<h6 id="网络拥塞的处理"><a href="#网络拥塞的处理" class="headerlink" title="网络拥塞的处理"></a>网络拥塞的处理</h6><p>　　网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段，只要对方检测到超时事件的发生，就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方 cwnd 值得一般 （但不能小于2）.然后把拥塞窗口cwnd 重新设置为1，执行慢开始算法。这样做得目的是迅速减少主机发送到网络中得分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。</p>
<p>　　拥塞避免并不能完全避免拥塞。</p>
<p>　<img src="https://i.loli.net/2020/04/04/vD9GEh5pFyoHwIq.png" alt="img"></p>
<h5 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h5><p>　　 快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</p>
<h6 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h6><p>　　快重传技术采用了冗余ACK来检测丢包的发生。同样，冗余 ACK 也用于网络拥塞的检测（丢了包意味着网络出现了拥塞）。快重传并非取消重传计时器，而是在某些情况下更早地重传丢失地报文段。</p>
<p>　　<strong>当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。</strong></p>
<h6 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h6><p>　　发送端收到连续的三个冗余 ACK（即重复确认）时，执行“乘法减小”算法，把慢开始门限 ssthresh 设置为出现拥塞时发送方cwnd的一半。与满开始（慢开始算法将拥塞窗口cwnd设置为 1）的不同之处是，它把cwnd 的值设置为慢开始门限ssthresh 改变之后的值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>
<p>　　由于跳过了 cwnd 从1起始的慢开始过程，所以称为快恢复。快恢复算法实现的过程如下图。虚线为慢开始的处理过程。</p>
<p><img src="https://i.loli.net/2020/04/04/RQCNmEf41ZLnPO8.png" alt="img"></p>
<p> 　在流量控制中，发送方发送数据的量由接收方决定，在拥塞控制中，则由发送方自己通过检测 网络状况来决定。实际上，慢开始、拥塞避免、快重传和快恢复几种算法应是同时应用在拥塞控制机制中，<strong>当发送方检测到超时的时候，就开始慢开始和拥塞避免，当发送方接收发到冗余 ACK 时就采用快重传和快恢复。</strong></p>
<p> <img src="https://i.loli.net/2020/04/04/kHdKev7JVR15yna.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/05/07/UvJc6VCxe7fIGim.png" alt="image-20200507213947478"></p>
<h3 id="知识结构图"><a href="#知识结构图" class="headerlink" title="知识结构图"></a>知识结构图</h3><p><img src="https://i.loli.net/2020/04/11/p1mQsEuLAqKbizO.png" alt="image-20200411154708823"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树 Hard</title>
    <url>/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91Hard/</url>
    <content><![CDATA[<h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></h4><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 后序遍历 “左右根”。需要一个栈来保存根结点，</span></span><br><span class="line"><span class="comment">    * 还需要一个指针来记录上一个访问的结点来判断是否访问过根结点的右子结点。</span></span><br><span class="line"><span class="comment">    * 当访问过树的最右叶子结点后，弹出根结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode lastPrintNode = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">while</span>(root != <span class="keyword">null</span> || ! s.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//根结点入栈</span></span><br><span class="line">               s.push(root);</span><br><span class="line">               <span class="comment">//继续入栈根结点的左子结点</span></span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//无左子结点，将根结点复制一份</span></span><br><span class="line">               root = s.peek();</span><br><span class="line">               <span class="comment">//查看右子结点是否为空或右子结点已经访问过</span></span><br><span class="line">               <span class="keyword">if</span>(root.right == <span class="keyword">null</span> || root.right == lastPrintNode)&#123;</span><br><span class="line">                   <span class="comment">//根结点出栈</span></span><br><span class="line">                    s.pop(); </span><br><span class="line">                   <span class="comment">//访问根结点</span></span><br><span class="line">                    res.add(root.val); </span><br><span class="line">                   <span class="comment">//更新上一个访问过的结点</span></span><br><span class="line">                    lastPrintNode = root; </span><br><span class="line">                   <span class="comment">//取根结点的根节点访问</span></span><br><span class="line">                    root = <span class="keyword">null</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">//右子结点不为空，访问右子结点</span></span><br><span class="line">                   root = root.right;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>借助Spring Boot 简化 Spring 开发</title>
    <url>/2020/04/04/%E5%80%9F%E5%8A%A9Spring%20Boot%20%E7%AE%80%E5%8C%96%20Spring%20%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="借助Spring-Boot-简化-Spring-开发"><a href="#借助Spring-Boot-简化-Spring-开发" class="headerlink" title="借助Spring Boot 简化 Spring 开发"></a>借助Spring Boot 简化 Spring 开发</h1><p>Spring Boot 是令人兴奋的新项目，它提供了四个主要的特性，能够改变开发Spring应用程序的方式。</p>
<p>1、Spring Boot Starter： 他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中。</p>
<p>2、自动配置： Spring Boot 的自动配置特性利用了Spring 4对条件化配置的支持，合理地推测应用所需的bean 并自动化配置它们。</p>
<p>3、命令行接口： Spring 的 CLI 发挥了Groovy 编程语言的优势，并结合自动配置进一步简化 Spring 应用的开发。</p>
<p>4、Actuator： 它为Spring Boot 应用添加了一定的管理特性。</p>
<p>我们要从头开始编写一个新的 Spring 应用。这是一个 Web 项目，所以需要 Spring MVC 。同时还要有 REST API 将资源暴露为 JSON ，所以在构建中需要包含Jackson JSON 库</p>
<p>首先让我们从添加依赖开始，新建一个 Gradle 项目，在 build.gradle dependency 添加以下内容：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile(<span class="string">"org.springframework.boot:spring-boot-starter-web:1.1.4.RELEASE"</span>)</span><br><span class="line">compile(<span class="string">"org.springframework.boot:spring-boot-starter-jdbc:1.1.4.RELEASE"</span>)</span><br><span class="line">compile(<span class="string">"org.thymeleaf:thymeleaf-spring4:2.1.2.RELEASE"</span>)</span><br><span class="line">compile(<span class="string">"com.h2database:h2:1.3.174"</span>)</span><br></pre></td></tr></table></figure>

<p>Spring Boot 的 Starter 减少了构建中的依赖列表的长度，而 Spring Boot 的自动配置功能则缩减了 Spring 配置的数量。它在实现时，会考虑应用中的其他因素并推断你所需要的 Spring 配置。</p>
<p>Spring Boot Starter 也会触发自动配置。例如在 Spring Boot 应用中，如果我们想使用 Spring MVC 的话，所需要做的仅仅是将 Web Starter 作为依赖放入到构建中。将 Web Starter 放入到构建中以后，它会自动添加 Spring MVC 依赖。如果 Spring Boot 的 Web 自动配置探测到 Spring MVC 位于类路径下，它将会自动配置支持 Spring MVC 的多个 bean，包括视图解析器、资源处理器、以及消息转换器等等。</p>
<p>Spring Boot CLI 充分利用了Spring Boot Starter 和自动配置的魔力，并添加了一些 Groovy 的功能，它简化了 Spring 的开发流程，通过 CLI ，我们能够运行一个或多个 Groovy 脚本，并查看它是如何运行的。在应用的运行过程中，CLI 能够自动导入 Spring 类型并解析依赖。</p>
<p>Spring Boot Actuator 为 Spring Boot 项目带来了很多有用的特性，包括：</p>
<p>1、管理端点；</p>
<p>2、合理的异常处理以及默认的“/error”映射端点；</p>
<p>3、获取应用信息的“Info”端点；</p>
<p>4、当启用Spring Security 时，会有一个审计事件框架。</p>
<p>这里我们开发一个 Contacts 应用。</p>
<p>ContactController 为 Contacts 应用处理基本的 Web 请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> contacts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ContactRepository contactRepo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContactController</span><span class="params">(ContactRepository contactRepo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contactRepo = contactRepo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">(Map&lt;String,Object&gt; model)</span></span>&#123;</span><br><span class="line">        List&lt;Contact&gt; contacts = contactRepo.findAll();</span><br><span class="line">        model.put(<span class="string">"contacts"</span>,contacts);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"home"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">submit</span><span class="params">(Contact contact)</span></span>&#123;</span><br><span class="line">        contactRepo.save(contact);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>home()方法使用注入的 ContactRepository 来获取所有 Contact 对象的列表，并将它们放到模型当中，然后把请求转交给home视图。这个视图将会展现联系人的列表以及添加新的Contact 表单。submit()方法将会处理表单提交的POST请求，保存Contact，并重定向到首页。</p>
<p>Contact 是一个简单的POJO</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> contacts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line">    <span class="keyword">private</span> String emailAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhoneNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhoneNumber</span><span class="params">(String phoneNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phoneNumber = phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmailAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmailAddress</span><span class="params">(String emailAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.emailAddress = emailAddress;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>按照传统的方式，Java Web 应用会使用JSP作为视图层的技术。但是，Thymeleaf 的原生模板比 JSP 更加便于使用，而且它能够让我们以 HTML 的形式编写模板。鉴于此，我们会使用Thymeleaf 来定义 Contacts 应用的home视图。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spring Boot Contacts<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/style.css&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Spring Boot Contacts<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"firstName"</span>&gt;</span>First Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"firstName"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"lastName"</span>&gt;</span>Last Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"phoneNumber"</span>&gt;</span>Phone #:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"phoneNumber"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"emailAddress"</span>&gt;</span>Email:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"emailAddress"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">th:each</span>=<span class="string">"contact : $&#123;contacts&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;contact.firstName&#125;"</span>&gt;</span>First<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;contact.lastName&#125;"</span>&gt;</span>Last<span class="tag">&lt;/<span class="name">span</span>&gt;</span> :</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;contact.phoneNumber&#125;"</span>&gt;</span>phoneNumber<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;contact.emailAddress&#125;"</span>&gt;</span>emailAddress<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>只要我们将 Thymeleaf 添加到项目的类路径下，就启用了 Spring Boot 的自动配置。当应用运行时，Spring Boot 将会探测到类路径中的Thymeleaf，然后会自动配置视图解析器，模板解析器以及模板引擎，这些都是在 Spring MVC 中使用 Thymeleaf所需要的。因此，在我们的应用中，不需要使用显示 Spring 配置的方式来定义 Thymeleaf。</p>
<p>ContactController 中 home() 方法返回的逻辑视图名为 home ，因此模板文件名为 home.html，自动配置的模板解析器会在指定的目录下查找Thymeleaf模板，这个目录也就是相对根类目录下的templates目录下 ，所以在Maven或Gradle项目中，我们需要将home.html放到“src / main / resources / templates” 中。这个模板中使用了style.css文件，我们倾向于将静态资源放入“src / main / resources / public”目录下。</p>
<p>style.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#eeeeee</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>持久化数据</p>
<p>ContactRepository 能够从数据库中存取 Contact</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> contacts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContactRepository</span><span class="params">(JdbcTemplate jdbc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbc = jdbc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Contact&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbc.query(<span class="string">"select id, firstName, lastName, phoneNumber, emailAddress from contacts order by lastName"</span>,</span><br><span class="line">                <span class="keyword">new</span> RowMapper&lt;Contact&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Contact <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                        Contact c = <span class="keyword">new</span> Contact();</span><br><span class="line">                        c.setId(rs.getLong(<span class="number">1</span>));</span><br><span class="line">                        c.setFirstName(rs.getString(<span class="number">2</span>));</span><br><span class="line">                        c.setLastName(rs.getString(<span class="number">3</span>));</span><br><span class="line">                        c.setPhoneNumber(rs.getString(<span class="number">4</span>));</span><br><span class="line">                        c.setEmailAddress(rs.getString(<span class="number">5</span>));</span><br><span class="line">                        <span class="keyword">return</span> c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Contact contact)</span></span>&#123;</span><br><span class="line">        jdbc.update(<span class="string">"insert into contacts(firstName,lastName,phoneNumber,emailAddress) values(?,?,?,?)"</span>,</span><br><span class="line">                contact.getFirstName(),contact.getLastName(),contact.getPhoneNumber(),contact.getEmailAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ContactRepository使用了@Repository注解，在组件扫描的时候他会被发现并创建为 Spring 应用上下文中的 bean。</p>
<p>JdbcTemplate 呢？我们难道不用再Spring应用上下文中声明JdbcTemplate bean 吗？为了声明它， 我们是不是需要声明一个H2 DataSource？</p>
<p>一切都不需要！！当 Spring Boot 嗅探到 Spring 的 JDBC 模块和H2 在类路径下的时候，自动配置就会发挥作用，将会自动配置 JdbcTemplate bean 和 H2 DataSource bean。</p>
<p>我们需要自己创建contacts表的模式，Spring Boot 可不会知道 contacts 表会是什么样子。</p>
<p>我们将一个名为schema.sql的脚本文件放入类路径根下，也就是Maven或Gradle项目目录下的”src/main/resources“目录下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">create table <span class="title">contacts</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    id identity,</span></span></span><br><span class="line"><span class="function"><span class="params">    firstName varchar(<span class="number">30</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">    lastName <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">    phoneNumber <span class="title">varchar</span><span class="params">(<span class="number">13</span>)</span>,</span></span><br><span class="line"><span class="function">    emailAddress <span class="title">varchar</span><span class="params">(<span class="number">30</span>)</span></span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure>



<p>我们需要一个特定的类来启动Spring Boot 项目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> contacts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击运行，打开浏览器输入localhost:8080就能进入Contacts应用。</p>
<p> <img src="https://i.loli.net/2020/04/04/jOsdNFPVnmoxHiL.png" alt="img"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>使用对象-关系映射持久化数据</title>
    <url>/2020/04/04/%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1-%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="使用对象-关系映射持久化数据"><a href="#使用对象-关系映射持久化数据" class="headerlink" title="使用对象-关系映射持久化数据"></a>使用对象-关系映射持久化数据</h1><p>在数据持久化的世界中，JDBC就像自行车，对于份内的工作它能完成的很好。随着应用程序越来越复杂，对持久化的要求也越来越复杂。我们需要将对象的属性映射到数据库的列上，并且需要自动生成语句和查询，这样我们就能从无休止的问号字符串中解脱出来。</p>
<p><strong>一、Hibernate</strong></p>
<p>还是以Spittr应用为例来具体阐述Hibernate的使用。</p>
<p>我们定义Spitter、Spittle两个实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spitter</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Spitter</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue</span>(strategy=GenerationType.IDENTITY)</span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Column</span>(name=<span class="string">"username"</span>)</span><br><span class="line">   <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Column</span>(name=<span class="string">"password"</span>)</span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Column</span>(name=<span class="string">"fullname"</span>)</span><br><span class="line">   <span class="keyword">private</span> String fullName;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Column</span>(name=<span class="string">"email"</span>)</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Column</span>(name=<span class="string">"updateByEmail"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> updateByEmail;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Spitter</span><span class="params">(Long id, String username, String password, String fullName,</span></span></span><br><span class="line"><span class="function"><span class="params">         String email, <span class="keyword">boolean</span> updateByEmail)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">      <span class="keyword">this</span>.username = username;</span><br><span class="line">      <span class="keyword">this</span>.password = password;</span><br><span class="line">      <span class="keyword">this</span>.fullName = fullName;</span><br><span class="line">      <span class="keyword">this</span>.email = email;</span><br><span class="line">      <span class="keyword">this</span>.updateByEmail = updateByEmail;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> username;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> password;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFullName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fullName;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> email;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUpdateByEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> updateByEmail;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.JoinColumn;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.ManyToOne;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spittle</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Spittle</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue</span>(strategy=GenerationType.IDENTITY)</span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@ManyToOne</span></span><br><span class="line">   <span class="meta">@JoinColumn</span>(name=<span class="string">"spitter"</span>)</span><br><span class="line">   <span class="keyword">private</span> Spitter spitter;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Column</span></span><br><span class="line">   <span class="keyword">private</span> String message;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Column</span></span><br><span class="line">   <span class="keyword">private</span> Date postedTime;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Spittle</span><span class="params">(Long id, Spitter spitter, String message, Date postedTime)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">      <span class="keyword">this</span>.spitter = spitter;</span><br><span class="line">      <span class="keyword">this</span>.message = message;</span><br><span class="line">      <span class="keyword">this</span>.postedTime = postedTime;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Date <span class="title">getPostedTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.postedTime;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">getSpitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.spitter;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Entity注解表示这是一个实体类，@Id注解代表这是数据表的primary key ,@GeneratedValue代表这是自动生成的列，</p>
<p>@Column注解将数据表的一列与类的属性绑定，不指定name属性则代表和变量名相同，@ManyToOne注解代表会有多个Spittle参照同一个Spitter， @JoinColumn注解代表参考spitter列。</p>
<p>这样就实现了类属性和数据表项的绑定。</p>
<p>同样我们定义SpitterRepository、SpittleRepository接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Spitter <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Spitter <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Spitter&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> spitterId)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们先看看如何配置Hibernate 下面是RepositoryTestConfig.java。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.hibernate4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabase;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.hibernate4.HibernateTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.hibernate4.LocalSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.TransactionManagementConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryTestConfig</span> <span class="keyword">implements</span> <span class="title">TransactionManagementConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmbeddedDatabaseBuilder edb = <span class="keyword">new</span> EmbeddedDatabaseBuilder();</span><br><span class="line">    edb.setType(EmbeddedDatabaseType.H2);</span><br><span class="line">    edb.addScript(<span class="string">"spittr/db/hibernate4/schema.sql"</span>);</span><br><span class="line">    edb.addScript(<span class="string">"spittr/db/hibernate4/test-data.sql"</span>);</span><br><span class="line">    EmbeddedDatabase embeddedDatabase = edb.build();</span><br><span class="line">    <span class="keyword">return</span> embeddedDatabase;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">annotationDrivenTransactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(sessionFactory);</span><br><span class="line">    HibernateTransactionManager transactionManager = <span class="keyword">new</span> HibernateTransactionManager();</span><br><span class="line">    transactionManager.setSessionFactory(sessionFactory);</span><br><span class="line">    <span class="keyword">return</span> transactionManager;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SessionFactory <span class="title">sessionFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      LocalSessionFactoryBean lsfb = <span class="keyword">new</span> LocalSessionFactoryBean();</span><br><span class="line">      lsfb.setDataSource(dataSource());</span><br><span class="line">      lsfb.setPackagesToScan(<span class="string">"spittr.domain"</span>);</span><br><span class="line">      Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">      props.setProperty(<span class="string">"dialect"</span>, <span class="string">"org.hibernate.dialect.H2Dialect"</span>);</span><br><span class="line">      lsfb.setHibernateProperties(props);</span><br><span class="line">      lsfb.afterPropertiesSet();</span><br><span class="line">      SessionFactory object = lsfb.getObject();</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里我们声明它是一个配置类并且启用了组件扫描和事务管理。</p>
<p>@Inject和@Autowired基本相同，同样dataBase bean为数据源配置，annotationDrivenTransactionManager bean 为事务处理，</p>
<p>使用Hibernate所需要的主要接口时org.hibernate.Session。Session接口提供了基本的数据访问功能，如保存、更新、删除以及从数据库加载对象的功能。通过Hibernate的Session接口，应用程序的Repository能够满足所有的持久化需求。</p>
<p>SessionFactory主要负责Hibernate Session的打开，关闭以及管理。</p>
<p>dataSource和hibernateProperties属性声明了从哪里获取数据库连接以及要使用哪一种数据库。这里不再列出Hibernate配置文件，使用packageToScan属性告诉Spring扫描一个或多个包以查找域类，这些类表明要使用Hibernate进行持久化，这些类可以使用的注解包括JPA的@Entity或@MappedSuperclass以及Hibernate的Entity。</p>
<p>了解完Hibernate的配置之后我们开始编写HibernateSpitterRepository和HibernateSpittleRepository他们分别实现SpitterRepository接口和SpittleRepository接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.hibernate4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.criterion.Restrictions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.SpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateSpitterRepository</span> <span class="keyword">implements</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Inject</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HibernateSpitterRepository</span><span class="params">(SessionFactory sessionFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sessionFactory = sessionFactory;      <span class="comment">//&lt;co id="co_InjectSessionFactory"/&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> Session <span class="title">currentSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sessionFactory.getCurrentSession();<span class="comment">//&lt;co id="co_RetrieveCurrentSession"/&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> findAll().size();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span> </span>&#123;</span><br><span class="line">      Serializable id = currentSession().save(spitter);  <span class="comment">//&lt;co id="co_UseCurrentSession"/&gt;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Spitter((Long) id, </span><br><span class="line">            spitter.getUsername(), </span><br><span class="line">            spitter.getPassword(), </span><br><span class="line">            spitter.getFullName(), </span><br><span class="line">            spitter.getEmail(), </span><br><span class="line">            spitter.isUpdateByEmail());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (Spitter) currentSession().get(Spitter<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;      </span><br><span class="line">      <span class="keyword">return</span> (Spitter) currentSession() </span><br><span class="line">            .createCriteria(Spitter<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line">            .add(Restrictions.eq("username", username))</span><br><span class="line">            .list().get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spitter&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (List&lt;Spitter&gt;) currentSession() </span><br><span class="line">            .createCriteria(Spitter<span class="class">.<span class="keyword">class</span>).<span class="title">list</span>()</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> spittr.db.hibernate4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Criteria;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.criterion.Order;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.criterion.Restrictions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.SpittleRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateSpittleRepository</span> <span class="keyword">implements</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Inject</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HibernateSpittleRepository</span><span class="params">(SessionFactory sessionFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sessionFactory = sessionFactory;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> Session <span class="title">currentSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sessionFactory.getCurrentSession();<span class="comment">//&lt;co id="co_RetrieveCurrentSession"/&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> findAll().size(); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> findRecent(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (List&lt;Spittle&gt;) spittleCriteria()</span><br><span class="line">            .setMaxResults(count)</span><br><span class="line">            .list();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (Spittle) currentSession().get(Spittle<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">      Serializable id = currentSession().save(spittle);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Spittle(</span><br><span class="line">         (Long) id, </span><br><span class="line">         spittle.getSpitter(), </span><br><span class="line">         spittle.getMessage(), </span><br><span class="line">         spittle.getPostedTime());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> spitterId)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> spittleCriteria()</span><br><span class="line">            .add(Restrictions.eq(<span class="string">"spitter.id"</span>, spitterId))</span><br><span class="line">            .list();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">      currentSession().delete(findOne(id));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (List&lt;Spittle&gt;) spittleCriteria().list(); </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> Criteria <span class="title">spittleCriteria</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> currentSession() </span><br><span class="line">            .createCriteria(Spittle<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">            .addOrder(Order.desc("postedTime"));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们将一个SessionFactory注入到HibernateSpitterRepository和HibernateSpittleRepository的sessionFactory属性中，在currentSession()方法中我们使用这个sessionFactory来获取当前事务的Session。</p>
<p>我们使用了@Repository注解，它能够被组件扫描扫描到，不必显示声明，它还会捕获平台相关的异常，然后使用Spring统一非检查型异常重新抛出。</p>
<p>数据类同数据库的表存在对应关系，使用Hibernate操作数据类时，Hibernate会将之转换为对数据库中对应表的操作。</p>
<p>org.hibernate.Criteria接口表示特定持久类的一个查询。Session是 Criteria实例的工厂。currentSession()</p>
<p>.createCriteria(Spittle.class)表示Spittle类的一个查询。参见：<a href="http://www.baike.com/wiki/criteria&prd=jinshan" target="_blank" rel="noopener">http://www.baike.com/wiki/criteria</a></p>
<p>session.save()方法返回一个生成的id，该id为Serializable类型。</p>
<p>下面是测试的一部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.hibernate4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.SpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= RepositoryTestConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpitterRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  SpitterRepository spitterRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">4</span>, spitterRepository.count());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Spitter&gt; spitters = spitterRepository.findAll();</span><br><span class="line">    assertEquals(<span class="number">4</span>, spitters.size());</span><br><span class="line">    assertSpitter(<span class="number">0</span>, spitters.get(<span class="number">0</span>));</span><br><span class="line">    assertSpitter(<span class="number">1</span>, spitters.get(<span class="number">1</span>));</span><br><span class="line">    assertSpitter(<span class="number">2</span>, spitters.get(<span class="number">2</span>));</span><br><span class="line">    assertSpitter(<span class="number">3</span>, spitters.get(<span class="number">3</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>二、JPA-Hibernate</strong></p>
<p>我们尝试开发基于JPA的Repository。Java持久化API（Java Persistence API，JPA）诞生在EJB2实体Bean的废墟之上，并成为下一代Java持久化标准。JPA是基于POJO的持久化机制。</p>
<p>以Spittr应用为例，我们首先看看JpaConfig类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jpa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabase;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.JpaTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.JpaVendorAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.vendor.Database;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.TransactionManagementConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmbeddedDatabaseBuilder edb = <span class="keyword">new</span> EmbeddedDatabaseBuilder();</span><br><span class="line">    edb.setType(EmbeddedDatabaseType.H2);</span><br><span class="line">    edb.addScript(<span class="string">"spittr/db/jpa/schema.sql"</span>);</span><br><span class="line">    edb.addScript(<span class="string">"spittr/db/jpa/test-data.sql"</span>);</span><br><span class="line">    EmbeddedDatabase embeddedDatabase = edb.build();</span><br><span class="line">    <span class="keyword">return</span> embeddedDatabase;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">emf</span><span class="params">(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter)</span> </span>&#123;</span><br><span class="line">    LocalContainerEntityManagerFactoryBean emf = <span class="keyword">new</span> LocalContainerEntityManagerFactoryBean();</span><br><span class="line">    emf.setDataSource(dataSource);</span><br><span class="line">    emf.setPersistenceUnitName(<span class="string">"spittr"</span>);</span><br><span class="line">    emf.setJpaVendorAdapter(jpaVendorAdapter);</span><br><span class="line">    emf.setPackagesToScan(<span class="string">"spittr.domain"</span>);</span><br><span class="line">    <span class="keyword">return</span> emf;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaVendorAdapter <span class="title">jpaVendorAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HibernateJpaVendorAdapter adapter = <span class="keyword">new</span> HibernateJpaVendorAdapter();</span><br><span class="line">    adapter.setDatabase(Database.H2);</span><br><span class="line">    adapter.setShowSql(<span class="keyword">true</span>);</span><br><span class="line">    adapter.setGenerateDdl(<span class="keyword">false</span>);</span><br><span class="line">    adapter.setDatabasePlatform(<span class="string">"org.hibernate.dialect.H2Dialect"</span>);</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration</span></span><br><span class="line">  <span class="meta">@EnableTransactionManagement</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConfig</span> <span class="keyword">implements</span> <span class="title">TransactionManagementConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> EntityManagerFactory emf;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">annotationDrivenTransactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      JpaTransactionManager transactionManager = <span class="keyword">new</span> JpaTransactionManager();</span><br><span class="line">      transactionManager.setEntityManagerFactory(emf);</span><br><span class="line">      <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>基于JPA的应用程序需要使用EntityManagerFactory的实现类来获得EntityManager实例。JPA定义了应用程序管理类型和容器管理类型的实体管理器，这两种实体管理器实现了同一个EntityManager接口。关键的区别不在于EntityManager本身，而是在于EntityManager的创建和管理方式。顾名思义，前者由应用程序创建和管理，后者由Java EE创建和管理。</p>
<p>JpaVendorAdapter 属性用于指明所使用的是哪一个厂商的JPA实现。</p>
<p>使用LocalContainerEntityManagerFactoryBean来配置容器管理类型的JPA。</p>
<p>接下来编写基于JPA的Repository：JpaSpitterRepository、JpaSpittleRepository</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jpa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PersistenceContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.SpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaSpitterRepository</span> <span class="keyword">implements</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@PersistenceContext</span></span><br><span class="line">   <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> findAll().size();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span> </span>&#123;</span><br><span class="line">      entityManager.persist(spitter);</span><br><span class="line">      <span class="keyword">return</span> spitter;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> entityManager.find(Spitter<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;      </span><br><span class="line">      <span class="keyword">return</span> (Spitter) entityManager.createQuery(<span class="string">"select s from Spitter s where s.username=?"</span>).setParameter(<span class="number">1</span>, username).getSingleResult();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spitter&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (List&lt;Spitter&gt;) entityManager.createQuery(<span class="string">"select s from Spitter s"</span>).getResultList();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jpa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PersistenceContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.SpittleRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaSpittleRepository</span> <span class="keyword">implements</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PersistenceContext</span></span><br><span class="line">  <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findAll().size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findRecent(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List&lt;Spittle&gt;) entityManager.createQuery(<span class="string">"select s from Spittle s order by s.postedTime desc"</span>)</span><br><span class="line">        .setMaxResults(count)</span><br><span class="line">        .getResultList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> entityManager.find(Spittle<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">    entityManager.persist(spittle);</span><br><span class="line">    <span class="keyword">return</span> spittle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> spitterId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List&lt;Spittle&gt;) entityManager.createQuery(<span class="string">"select s from Spittle s, Spitter sp where s.spitter = sp and sp.id=? order by s.postedTime desc"</span>)</span><br><span class="line">        .setParameter(<span class="number">1</span>, spitterId)</span><br><span class="line">        .getResultList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    entityManager.remove(findOne(id));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List&lt;Spittle&gt;) entityManager.createQuery(<span class="string">"select s from Spittle s"</span>).getResultList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于EntityManager并不是线程安全的，一般并不适合注入到Repository这样共享的单例Bean中，我们使用@PersistanceContext注解解决这个问题。@PersistanceContext并没有注入一个真正的EntityManager，而是给了它一个EntityManager的代理。真正的EntityManager是与当前事务相关联的那一个，如果不存在，就会创建一个新的。@Transactional表明这个Repository中的持久化方法是在事务上下文中执行的。</p>
<p>以下是测试类部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jpa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.Ignore;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.SpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span></span>=JpaConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpitterRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   SpitterRepository spitterRepository;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      assertEquals(<span class="number">4</span>, spitterRepository.count());</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;Spitter&gt; spitters = spitterRepository.findAll();</span><br><span class="line">      assertEquals(<span class="number">4</span>, spitters.size());</span><br><span class="line">      assertSpitter(<span class="number">0</span>, spitters.get(<span class="number">0</span>));</span><br><span class="line">      assertSpitter(<span class="number">1</span>, spitters.get(<span class="number">1</span>));</span><br><span class="line">      assertSpitter(<span class="number">2</span>, spitters.get(<span class="number">2</span>));</span><br><span class="line">      assertSpitter(<span class="number">3</span>, spitters.get(<span class="number">3</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>三、借助Spring Data实现自动化的JPA Repository</strong></p>
<p>尽管JPA-Hibernate代码已经很简单，但依然会有直接与EntityManager交互来查询数据库。我们借助Spring Data，以接口定义的方式创建Repository。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpitterRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Spitter</span>, <span class="title">Long</span>&gt;, <span class="title">SpitterSweeper</span> </span>&#123;</span><br><span class="line">   <span class="function">Spitter <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">   <span class="function">List&lt;Spitter&gt; <span class="title">findByUsernameOrFullNameLike</span><span class="params">(String username, String fullName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpittleRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Spittle</span>, <span class="title">Long</span>&gt;, <span class="title">SpittleRepositoryCustom</span> </span>&#123;</span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> spitterId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里我们并不需要实现findBySpittleId方法，findByUsername方法，findByUsernameOrFullNameLike方法，方法签名已经告诉Spring Data JPA足够的信息来创建这个方法的实现了。</p>
<p>编写Spring Data JPA Repository 的关键在于要从一组接口中选一个进行扩展，这里SpittleRepository扩展了Spring Data JPA 的JpaRepository。通过这种方式，JpaRepository进行了参数化，所以它就能知道这是一个用来持久化Spitter对象的Repository，并且Spitter对象的ID类型为Long。</p>
<p>接下来我们看看自定义查询方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpitterSweeper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">eliteSweep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PersistenceContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpitterRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">SpitterSweeper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@PersistenceContext</span></span><br><span class="line">   <span class="keyword">private</span> EntityManager em;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eliteSweep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     String update = </span><br><span class="line">         <span class="string">"UPDATE Spitter spitter "</span> +</span><br><span class="line">             <span class="string">"SET spitter.status = 'Elite' "</span> +</span><br><span class="line">             <span class="string">"WHERE spitter.status = 'Newbie' "</span> +</span><br><span class="line">             <span class="string">"AND spitter.id IN ("</span> +</span><br><span class="line">             <span class="string">"SELECT s FROM Spitter s WHERE ("</span> +</span><br><span class="line">             <span class="string">"  SELECT COUNT(spittles) FROM s.spittles spittles) &gt; 10000"</span> +</span><br><span class="line">             <span class="string">")"</span>;</span><br><span class="line">      <span class="keyword">return</span> em.createQuery(update).executeUpdate();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂查询可以自己编写。</p>
<p>配置Spring Data JPA</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.JpaTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.vendor.Database;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>(<span class="string">"spitter.db"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDataJpaConfig</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">        .addScript(<span class="string">"classpath:/com/habuma/spitter/db/jpa/schema.sql"</span>)</span><br><span class="line">        .addScript(<span class="string">"classpath:/com/habuma/spitter/db/jpa/test-data.sql"</span>)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(); <span class="comment">// does this need an emf???</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HibernateJpaVendorAdapter <span class="title">jpaVendorAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HibernateJpaVendorAdapter adapter = <span class="keyword">new</span> HibernateJpaVendorAdapter();</span><br><span class="line">    adapter.setDatabase(Database.H2);</span><br><span class="line">    adapter.setShowSql(<span class="keyword">false</span>);</span><br><span class="line">    adapter.setGenerateDdl(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">emf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalContainerEntityManagerFactoryBean emf = <span class="keyword">new</span> LocalContainerEntityManagerFactoryBean();</span><br><span class="line">    emf.setDataSource(dataSource());</span><br><span class="line">    emf.setPersistenceUnitName(<span class="string">"spitter"</span>);</span><br><span class="line">    emf.setJpaVendorAdapter(jpaVendorAdapter());</span><br><span class="line">    <span class="keyword">return</span> emf;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@EnableJpaRepositories(“spitter.db”)会扫描spittr.db包查找扩展自Spring Data JPA Repository接口的所有接口，如果发现了扩展自Repository的接口，他会自动（在应用启动的时候）生成这个接口的实现。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树 Medium</title>
    <url>/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91Medium/</url>
    <content><![CDATA[<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h4><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 中序遍历 “左根右”。需要一个栈来保存根结点。</span></span><br><span class="line"><span class="comment">    * 当访问过树的最左叶子结点后，弹出根结点，访问根结点，继续访问根节点的右子结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环条件：栈中元素不为空。树的根结点非空</span></span><br><span class="line">       <span class="keyword">while</span>(root != <span class="keyword">null</span> || ! s.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//根结点入栈</span></span><br><span class="line">               s.push(root);</span><br><span class="line">               <span class="comment">//继续入栈根结点的左子结点</span></span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//无左子结点，将根结点出栈</span></span><br><span class="line">               root = s.pop();</span><br><span class="line">               <span class="comment">//访问根结点</span></span><br><span class="line">               res.add(root.val);</span><br><span class="line">               <span class="comment">//继续访问根结点的右子结点</span></span><br><span class="line">               root = root.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h4><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>采用层次遍历，使用一个队列存储结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(! queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//获取当前层的结点数</span></span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">                <span class="comment">//取出队头结点，将其加入当前层的结果中</span></span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                level.add(t.val);</span><br><span class="line">                <span class="comment">//如果有左右子结点，将它们加入队尾</span></span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) queue.add(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) queue.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//保存每一层的结果</span></span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设树上有 n 个结点，时间复杂度 O(n)，空间复杂度O(n)。</p>
<h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h4><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>在数据结构课程中我们学过通过前序遍历序列和中序遍历序列构造二叉树的方法：</p>
<ol>
<li>从先序遍历序列中拿出一个结点 x 。</li>
<li>建立根结点，在中序遍历序列中找出结点 x 的位置，确定以结点 x 为根结点的左右子树结点数。</li>
<li>重复步骤 1 和步骤 2 递归建立结点 x 的左右子树。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用一个 HashMap 存储中序遍历结点的下标，在寻找结点下标时只用常数时间。</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = preorder.length;</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="comment">//建立 HashMap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//递归建立二叉树</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, inorder, <span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preorder_left, <span class="keyword">int</span> preorder_right, <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder_left &gt; preorder_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//确定二叉树根结点（先序遍历最左结点）</span></span><br><span class="line">        <span class="keyword">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">//找到根结点在中序遍历序列中的下标</span></span><br><span class="line">        <span class="keyword">int</span> inorder_root = indexMap.get(preorder[preorder_root]);</span><br><span class="line">		<span class="comment">//建立根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preorder_root]);</span><br><span class="line">		<span class="comment">//确定根结点左子树结点的个数</span></span><br><span class="line">        <span class="keyword">int</span> leftSubTreeSize = inorder_root - inorder_left;</span><br><span class="line">		<span class="comment">//递归建立左子树</span></span><br><span class="line">        root.left = buildTree(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + leftSubTreeSize, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//递归建立右子树</span></span><br><span class="line">        root.right = buildTree(preorder, inorder, preorder_left + leftSubTreeSize + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度O(n)。</p>
<h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></h4><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p>
<p> <strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 前序遍历 “根左右”。需要一个栈来保存已经访问过的根结点。</span></span><br><span class="line"><span class="comment">    * 当已经访问过树的最左叶子结点后，弹出根结点，继续访问根结点的右子结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="comment">//循环条件：栈中元素不为空。树的根节点非空</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || ! s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//访问根节点</span></span><br><span class="line">                ans.add(root.val);</span><br><span class="line">                <span class="comment">//保存根节点</span></span><br><span class="line">                s.push(root);</span><br><span class="line">                <span class="comment">//访问根结点的左子结点</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无左子结点，弹出根结点</span></span><br><span class="line">                root = s.pop();</span><br><span class="line">                <span class="comment">//继续访问右子结点</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></h4><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>

<p>第一感觉就是用层次遍历，保存每一层的最后一个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">		<span class="comment">//层次遍历使用的队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(! queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// len 为层次遍历时每一层的结点个数</span></span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                <span class="comment">// 是否为最后一个结点</span></span><br><span class="line">                <span class="keyword">if</span>(i == len-<span class="number">1</span>)&#123;</span><br><span class="line">                res.add(t.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将左右子结点加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) queue.add(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) queue.add(t.right);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以模仿二叉树遍历，只是先遍历右子结点然后遍历左子结点。同时在遍历的过程中保存每一层的第一个结点值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            假设二叉树深度为 i ，res 数组的大小为 i。</span></span><br><span class="line"><span class="comment">            当 res.size() 小于当前访问的层数时就代表这是最右侧结点。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt; level)&#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先遍历右子结点</span></span><br><span class="line">            helper(root.right, level+<span class="number">1</span>, res);</span><br><span class="line">            <span class="comment">//后遍历左子结点</span></span><br><span class="line">            helper(root.left, level+<span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<p>思路一</p>
<p>我们可以遍历所有结点，并判断 p 或 q 是否在它的左右子树上，或者这个结点就是 p 或 q 。定义 fx表示 x 结点的子树中是否包含 p 节点或 q节点。fl 代表 x 结点的左子树上是否有 p 或 q 结点，fr 代表 x 结点的右子树上是否有 p 或 q 结点。我们有两种情况：</p>
<ul>
<li>p 和 q 分别在 x 结点的左右子树上，即 fl &amp;&amp; fr == true</li>
<li>结点 x 就是 p 或 q，此时 x== p || x==q 为true，若在 x 结点的左子树或右子树上找到另一个结点，则 x 就是最近公共祖先。</li>
</ul>
<p>总结判断条件：(f1 &amp;&amp; fr) || [ (x==p || x==q) &amp;&amp; ( fl || fr) ] 。由于是自底向上判断的，在所有满足条件的公共祖先中一定是深度最大的祖先被访问到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode res;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//先判断左右子树，再判断当前结点情况</span></span><br><span class="line">        <span class="keyword">boolean</span> left = dfs(root.left, p, q);</span><br><span class="line">        <span class="keyword">boolean</span> right = dfs(root.right, p, q);</span><br><span class="line">        <span class="comment">//判断条件</span></span><br><span class="line">        <span class="keyword">if</span>((left &amp;&amp; right) || (root.val == p.val || root.val == q.val) &amp;&amp; (left || right))&#123;</span><br><span class="line">            res = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回 x 结点的左右子树 是否包含 p 或 q 结点</span></span><br><span class="line">        <span class="keyword">return</span> left || right || root.val == p.val || root.val == q.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>使用NoSQL数据库</title>
    <url>/2020/04/04/%E4%BD%BF%E7%94%A8NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="使用NoSQL数据库"><a href="#使用NoSQL数据库" class="headerlink" title="使用NoSQL数据库"></a>使用NoSQL数据库</h1><p><strong>一、使用MongoDB持久化文档数据</strong>  </p>
<p>  有一些数据的最佳表现形式是文档，也就是说，不要把这些数据分散到多个表、节点或实体中，将这些信息收集到一个非规范化（也就是文档）的结构中更有意义。如果数据之间有明显的关联关系，文档数据库就不太适合了。</p>
<p>我们在一个购物订单系统中学习MongoDB。接下来我们要配置Spring Data MongoDB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mongodb.Mongo;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.config.AbstractMongoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.config.EnableMongoRepositories;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories</span>(basePackages = <span class="string">"orders.db"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoConfig</span> <span class="keyword">extends</span> <span class="title">AbstractMongoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mongo <span class="title">mongo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDatabaseName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OrdersDB"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过@EnableMongoRepository注解启用Spring Data 的自动化MongoDB repository生成功能，我们让配置类扩展AbstractMongoConfiguration并重载mongo()方法，getDatabaseName()方法，mongo()方法会直接返回一个MongoClient实例而不是声明MongoFactory bean 和MongoTemplate bean。使用MongoClient更加简单。这里需要一个运行在本地的MongoDB 服务器，MongoClient监听的默认的端口27017，如果需要更改端口在MongoClient构造方法中指定端口即可。</p>
<p>下面是Order类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"customer"</span>)</span><br><span class="line">    <span class="keyword">private</span> String customer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;Item&gt; items = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(String customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customer = customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Item&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItems</span><span class="params">(Collection&lt;Item&gt; items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们可以看到Order类使用了@Document注解，这样它就能借助MongoTemplate或自动生成的Repository进行持久化，其id属性上使用了@Id注解用来指定它作为文档的ID，除此之外，customer属性上使用了@Field注解，这样在文档持久化的时候customer属性会映射为customer的域。同时items属性它指的是订单中具体条目的集合，在传统的关系型数据库中，这些条目会在另一个数据表中，通过外键进行引用，items域上可能还会有使用JPA的@OneToMany注解。</p>
<p>下面是Item类，Item类本身没有任何注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String product;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQuantity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.product = product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuantity</span><span class="params">(<span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义OrderRepository扩展MongoRepository,它和Spring Data JPA一样，扩展了Repository的接口将会在运行时自动生成实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> orders.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.MongoRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.Query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">Order</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">findByCustomer</span><span class="params">(String customer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">findByCustomerLike</span><span class="params">(String customer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">findByCustomerAndType</span><span class="params">(String customer,String type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">getByType</span><span class="params">(String type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"&#123;customer:'Chuck Wagon'&#125;"</span>)</span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">findChucksOrders</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">下面是测试类</span><br><span class="line"><span class="keyword">package</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> orders.config.MongoConfig;</span><br><span class="line"><span class="keyword">import</span> orders.db.OrderRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.MongoOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes=MongoConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">RunWith</span>(<span class="title">SpringJUnit4ClassRunner</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MongoDbTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span> MongoOperations mongoOps;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Before</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Deleting all orders (just in case something is left over from a previous failed run)</span></span><br><span class="line">      orderRepository.deleteAll();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMongoRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      assertEquals(<span class="number">0</span>, orderRepository.count());</span><br><span class="line">      Order order = createAnOrder();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Saving an order</span></span><br><span class="line">      Order savedOrder = orderRepository.save(order);       </span><br><span class="line">      assertEquals(<span class="number">1</span>, orderRepository.count());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Finding an order by ID</span></span><br><span class="line">      Order foundOrder = orderRepository.findOne(savedOrder.getId());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, foundOrder.getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, foundOrder.getItems().size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by a single field value</span></span><br><span class="line">      List&lt;Order&gt; chucksOrders = orderRepository.findByCustomer(<span class="string">"Chuck Wagon"</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, chucksOrders.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chucksOrders.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chucksOrders.get(<span class="number">0</span>).getItems().size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by a single field value like</span></span><br><span class="line">      List&lt;Order&gt; chuckLikeOrders = orderRepository.findByCustomerLike(<span class="string">"Chuck"</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, chuckLikeOrders.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chuckLikeOrders.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chuckLikeOrders.get(<span class="number">0</span>).getItems().size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by multiple field values</span></span><br><span class="line">      List&lt;Order&gt; chucksWebOrders = orderRepository.findByCustomerAndType(<span class="string">"Chuck Wagon"</span>, <span class="string">"WEB"</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, chucksWebOrders.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chucksWebOrders.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chucksWebOrders.get(<span class="number">0</span>).getItems().size());</span><br><span class="line"></span><br><span class="line">      List&lt;Order&gt; chucksPhoneOrders = orderRepository.findByCustomerAndType(<span class="string">"Chuck Wagon"</span>, <span class="string">"PHONE"</span>);</span><br><span class="line">      assertEquals(<span class="number">0</span>, chucksPhoneOrders.size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by a custom query method</span></span><br><span class="line">      List&lt;Order&gt; chucksOrders2 = orderRepository.findChucksOrders();</span><br><span class="line">      assertEquals(<span class="number">1</span>, chucksOrders2.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chucksOrders2.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chucksOrders2.get(<span class="number">0</span>).getItems().size());</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Deleting an order</span></span><br><span class="line">      orderRepository.delete(savedOrder.getId());</span><br><span class="line">      assertEquals(<span class="number">0</span>, orderRepository.count());     </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Order <span class="title">createAnOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Order order = <span class="keyword">new</span> Order();</span><br><span class="line">      order.setCustomer(<span class="string">"Chuck Wagon"</span>);</span><br><span class="line">      order.setType(<span class="string">"WEB"</span>);</span><br><span class="line">      Item item1 = <span class="keyword">new</span> Item();</span><br><span class="line">      item1.setProduct(<span class="string">"Spring in Action"</span>);</span><br><span class="line">      item1.setQuantity(<span class="number">2</span>);</span><br><span class="line">      item1.setPrice(<span class="number">29.99</span>);</span><br><span class="line">      Item item2 = <span class="keyword">new</span> Item();</span><br><span class="line">      item2.setProduct(<span class="string">"Module Java"</span>);</span><br><span class="line">      item2.setQuantity(<span class="number">31</span>);</span><br><span class="line">      item2.setPrice(<span class="number">29.95</span>);</span><br><span class="line">      order.setItems(Arrays.asList(item1, item2));</span><br><span class="line">      <span class="keyword">return</span> order;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二、使用Neo4j操作位图数据</strong></p>
<p>  文档型数据库会将数据存储到粗粒度的文档中，图数据库会将数据存储到多个细粒度的节点中，这些节点之间通过关系建立关联。Spring Data Neo4j提供了将Java对象映射到节点和关联关系的注解、面向模板的Neo4j访问方式以及Repository’实现的自动化生成功能。</p>
<p>配置Spring Data Neo4j的关键在于声明GraphDatabaseService bean 和启用Neo4j Repository自动生成功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.neo4j.graphdb.GraphDatabaseService;</span><br><span class="line"><span class="keyword">import</span> org.neo4j.graphdb.factory.GraphDatabaseFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.config.EnableNeo4jRepositories;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.config.Neo4jConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableNeo</span>4jRepositories(basePackages = <span class="string">"orders.db"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Neo4jConfig</span> <span class="keyword">extends</span> <span class="title">Neo4jConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Neo4jConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      setBasePackage(<span class="string">"orders"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span>(destroyMethod=<span class="string">"shutdown"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> GraphDatabaseService <span class="title">graphDatabaseService</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> GraphDatabaseFactory()</span><br><span class="line">            .newEmbeddedDatabase(<span class="string">"/tmp/graphdb"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@EnableNeo4jRepositories注解能够让Spring Data Neo4j自动生成 Neo4j的Repository实现。定义GraphDatabaseService bean使用GraphDatabaseFactory 来创建嵌入式的Neo4j数据库。</p>
<p>Neo4j定义了两种类型的实体：节点和关联关系。节点反映了应用中的事物，而关联关系定义了这些事物是如何联系在一起的。</p>
<p>Order、Item是两个节点他们之间的关系是Order has items </p>
<p>下面我们为Order添加注解，使其成为图数据库中的一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.annotation.GraphId;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.annotation.NodeEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.annotation.RelatedTo;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NodeEntity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@GraphId</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String customer;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String type;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@RelatedTo</span>(type=<span class="string">"HAS_ITEMS"</span>)</span><br><span class="line">   <span class="keyword">private</span> Set&lt;Item&gt; items = <span class="keyword">new</span> LinkedHashSet&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> customer;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(String customer)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.customer = customer;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> type;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.type = type;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Collection&lt;Item&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> items;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItems</span><span class="params">(Set&lt;Item&gt; items)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.items = items;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> @NodeEntity注解代表这是一个节点，@GraphId注解代表这是一个图Id，@RelatedTo(type=”HAS_ITEMS”)注解代表Order与一个Item的Set存在关系。</p>
<p>Item也是图数据库中的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.annotation.GraphId;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.annotation.NodeEntity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NodeEntity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@GraphId</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String product;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Order <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> order;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> product;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.product = product;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> price;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.price = price;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQuantity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> quantity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuantity</span><span class="params">(<span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 同样我们需要创建自动化的Neo4j Repository</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> orders.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.repository.GraphRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">GraphRepository</span>&lt;<span class="title">Order</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function">List&lt;Order&gt; <span class="title">findByCustomer</span><span class="params">(String customer)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function">List&lt;Order&gt; <span class="title">findByCustomerLike</span><span class="params">(String customer)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">List&lt;Order&gt; <span class="title">findByCustomerAndType</span><span class="params">(String customer, String type)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">List&lt;Order&gt; <span class="title">getByType</span><span class="params">(String type)</span></span>;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// @Query("&#123;customer:'Chuck Wagon'&#125;")</span></span><br><span class="line"><span class="comment">// List&lt;Order&gt; findChucksOrders();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">下面是测试类</span><br><span class="line"><span class="keyword">package</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> orders.config.Neo4jConfig;</span><br><span class="line"><span class="keyword">import</span> orders.db.OrderRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes=Neo4jConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">RunWith</span>(<span class="title">SpringJUnit4ClassRunner</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Neo4jTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Before</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Deleting all orders (just in case something is left over from a previous failed run)</span></span><br><span class="line">      orderRepository.deleteAll();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNeo4jRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      assertEquals(<span class="number">0</span>, orderRepository.count());</span><br><span class="line">      Order order = createAnOrder();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Saving an order</span></span><br><span class="line">      Order savedOrder = orderRepository.save(order);       </span><br><span class="line">      assertEquals(<span class="number">1</span>, orderRepository.count());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Finding an order by ID</span></span><br><span class="line">      Order foundOrder = orderRepository.findOne(savedOrder.getId());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, foundOrder.getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, foundOrder.getItems().size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by a single field value</span></span><br><span class="line">      List&lt;Order&gt; chucksOrders = orderRepository.findByCustomer(<span class="string">"Chuck Wagon"</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, chucksOrders.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chucksOrders.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chucksOrders.get(<span class="number">0</span>).getItems().size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by a single field value like</span></span><br><span class="line">      List&lt;Order&gt; chuckLikeOrders = orderRepository.findByCustomerLike(<span class="string">"Chuck.*"</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, chuckLikeOrders.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chuckLikeOrders.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chuckLikeOrders.get(<span class="number">0</span>).getItems().size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by multiple field values</span></span><br><span class="line">      List&lt;Order&gt; chucksWebOrders = orderRepository.findByCustomerAndType(<span class="string">"Chuck Wagon"</span>, <span class="string">"WEB"</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, chucksWebOrders.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chucksWebOrders.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chucksWebOrders.get(<span class="number">0</span>).getItems().size());</span><br><span class="line"></span><br><span class="line">      List&lt;Order&gt; chucksPhoneOrders = orderRepository.findByCustomerAndType(<span class="string">"Chuck Wagon"</span>, <span class="string">"PHONE"</span>);</span><br><span class="line">      assertEquals(<span class="number">0</span>, chucksPhoneOrders.size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by a custom query method</span></span><br><span class="line"><span class="comment">//    List&lt;Order&gt; chucksOrders2 = orderRepository.findChucksOrders();</span></span><br><span class="line"><span class="comment">//    assertEquals(1, chucksOrders2.size());</span></span><br><span class="line"><span class="comment">//    assertEquals("Chuck Wagon", chucksOrders2.get(0).getCustomer());</span></span><br><span class="line"><span class="comment">//    assertEquals(2, chucksOrders2.get(0).getItems().size());</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Deleting an order</span></span><br><span class="line">      orderRepository.delete(savedOrder.getId());</span><br><span class="line">      assertEquals(<span class="number">0</span>, orderRepository.count());     </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Order <span class="title">createAnOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Order order = <span class="keyword">new</span> Order();</span><br><span class="line">      order.setCustomer(<span class="string">"Chuck Wagon"</span>);</span><br><span class="line">      order.setType(<span class="string">"WEB"</span>);</span><br><span class="line">      Item item1 = <span class="keyword">new</span> Item();</span><br><span class="line">      item1.setProduct(<span class="string">"Spring in Action"</span>);</span><br><span class="line">      item1.setQuantity(<span class="number">2</span>);</span><br><span class="line">      item1.setPrice(<span class="number">29.99</span>);</span><br><span class="line">      Item item2 = <span class="keyword">new</span> Item();</span><br><span class="line">      item2.setProduct(<span class="string">"Module Java"</span>);</span><br><span class="line">      item2.setQuantity(<span class="number">31</span>);</span><br><span class="line">      item2.setPrice(<span class="number">29.95</span>);</span><br><span class="line">      order.setItems(<span class="keyword">new</span> HashSet&lt;Item&gt;(Arrays.asList(item1, item2)));</span><br><span class="line">      <span class="keyword">return</span> order;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 三、使用Redis操作键值对数据</p>
<p>Redis是一种特殊类型的数据库，它被称之为key-value存储，key-value存储与哈希Map有很大的相似性，可以把它理解为持久化的哈希Map。<br>连接Redis</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RedisConnectionFactory <span class="title">redisCF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Product&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory cf)</span> </span>&#123;</span><br><span class="line">      RedisTemplate&lt;String, Product&gt; redis = <span class="keyword">new</span> RedisTemplate&lt;String, Product&gt;();</span><br><span class="line">      redis.setConnectionFactory(cf);</span><br><span class="line">      <span class="keyword">return</span> redis;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们配置RedisConnectionFactory bean 通过默认构造器创建的连接工厂会向localhost上的6379端口创建连接。顾名思义，Redis连接工厂会生成到Redis key-value存储的连接，我们使用RedisTemplate简化数据访问，能够让我们持久化各种类型的key和value。<br>将RedisConnectionFactory bean 注入到 RedisTemlate中，RedisTemplate使用两个类型进行参数化，第一个是key的类型，第二个是value的类型。</p>
<p>下面是Product类，实现了Serializable接口，因为Redis存储对象时需要将其序列化，取出时需要反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String sku;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getSku</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sku;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSku</span><span class="params">(String sku)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sku = sku;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> price;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.price = price;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是测试类的一部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.BoundListOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span></span>=RedisConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CartTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * IMPORTANT: This test class requires that a Redis server be running on </span></span><br><span class="line"><span class="comment">    *            localhost and listening on port 6379 (the default port).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisConnectionFactory cf;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate&lt;String, Product&gt; redis;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@After</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      redis.delete(<span class="string">"9781617291203"</span>);</span><br><span class="line">      redis.delete(<span class="string">"cart"</span>);</span><br><span class="line">      redis.delete(<span class="string">"cart1"</span>);</span><br><span class="line">      redis.delete(<span class="string">"cart2"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">workingWithSimpleValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Product product = <span class="keyword">new</span> Product();</span><br><span class="line">      product.setSku(<span class="string">"9781617291203"</span>);</span><br><span class="line">      product.setName(<span class="string">"Spring in Action"</span>);</span><br><span class="line">      product.setPrice(<span class="number">39.99f</span>);</span><br><span class="line">      </span><br><span class="line">      redis.opsForValue().set(product.getSku(), product);</span><br><span class="line">      </span><br><span class="line">      Product found = redis.opsForValue().get(product.getSku());</span><br><span class="line">      assertEquals(product.getSku(), found.getSku());</span><br><span class="line">      assertEquals(product.getName(), found.getName());</span><br><span class="line">      assertEquals(product.getPrice(), found.getPrice(), <span class="number">0.005</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>关系数据理论</title>
    <url>/2020/04/04/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="数据冗余导致的问题"><a href="#数据冗余导致的问题" class="headerlink" title="数据冗余导致的问题"></a>数据冗余导致的问题</h3><p>　　1）冗余存储：信息被重复存储，导致浪费大量存储空间。</p>
<p>　　2）更新异常：当重复的信息的一个副本被修改，所有副本都必须进行同样的修改。因此当更新数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的风险。</p>
<p>　　3）插入异常：只有当一些信息事先已经存放在数据库中时，另外一些信息才能存入数据库中。</p>
<p>　　4）删除异常：删除某些信息时可能丢失其他信息。</p>
<h3 id="函数依赖定义"><a href="#函数依赖定义" class="headerlink" title="函数依赖定义"></a>函数依赖定义</h3><h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><p>　　在关系R中，若属性或者属性集 A 中 两个元组的值相等，如果这两个元祖中对应的属性或者属性集B中的值也相同，则记作A—&gt;B。 A函数决定B； 或者 B函数依赖于A。</p>
<p><img src="https://i.loli.net/2020/04/04/E4hlWZPTntAf6KX.png" alt=""></p>
<h4 id="平凡与非平凡函数依赖"><a href="#平凡与非平凡函数依赖" class="headerlink" title="平凡与非平凡函数依赖"></a>平凡与非平凡函数依赖</h4><p>　　对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。若不特别声明，总是讨论非平凡函数依赖。</p>
<p><img src="https://i.loli.net/2020/04/04/Yrj2GxN84q5mglZ.png" alt=""></p>
<h4 id="完全函数依赖和部分函数依赖"><a href="#完全函数依赖和部分函数依赖" class="headerlink" title="完全函数依赖和部分函数依赖"></a>完全函数依赖和部分函数依赖</h4><p>　　完全函数依赖：（学号,课号）——&gt;成绩;   单独一个学号，不能决定成绩，单独一个课程，也不能决定成绩；只有二者同时，才能决定；</p>
<p>　　部分函数依赖：（学号,课号）——&gt;姓名；学号和课号能决定姓名, 单独一个 学号 也能决定 姓名；</p>
<p><img src="https://i.loli.net/2020/04/04/W4s5Xqyj9JPelo1.png" alt=""></p>
<h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><p>　　学号—&gt;系号，系号—&gt;系主任;       系主任   传递依赖于  学号</p>
<p><img src="https://i.loli.net/2020/04/04/8MYz1S5RQP7LhxO.png" alt=""></p>
<h3 id="函数依赖理论"><a href="#函数依赖理论" class="headerlink" title="函数依赖理论"></a>函数依赖理论</h3><h4 id="码、超码、候选码和主码"><a href="#码、超码、候选码和主码" class="headerlink" title="码、超码、候选码和主码"></a>码、超码、候选码和主码</h4><p>　　码是一个或多个属性的集合。</p>
<p>　　超码是一个或多个属性的集合，超码中的这些属性可以让我们在一个实体集中唯一地标识一个实体。</p>
<p>　　候选码是极小的超码集，也就是它的任意真子集都不是超码，而他本身是超码。</p>
<p>　　主码是被选中用来在一个关系中区分不同元组的候选码。</p>
<p>　　<strong>候选码的确定：</strong></p>
<p>　　设关系模式R中U=ABC…….等N个属性，U中的属性在FD中有四种范围：</p>
<p>　　(1)左右出现;<br>　　(2)只在左部出现;<br>　　(3)只在右部出现;<br>　　(4)不在左右出现;</p>
<p>　　算法：按以下步骤求候选键：<br>　　1.只在FD右部出现的属性，不属于候选码;<br>　　2.只在FD左部出现的属性，一定存在于某候选码当中;<br>　　3.外部属性一定存在于任何候选码当中;  (左右都不出现)</p>
<p>　　4.其他属性逐个与2,3的属性组合，求属性闭包，直至X的闭包等于U,若等于U,则X为候选码。</p>
<p>　　例1：R&lt;U,F&gt;,U=(A,B,C,D,E,G),F={AB–&gt;C,CD–&gt;E,E–&gt;A.A–&gt;G},求候选码以及主属性。</p>
<p>　　因为：G只在右边出现，所以候选码肯定不包含G，BD只出现在左边，所以，候选码中肯定有BD，而BD的闭包还是BD，则对BD进行组合,除了G以外,BD可以跟A,C,E进行组合。</p>
<p>  　　<strong>先看ABD</strong><br>  　　ABD本身自包ABD,而AB–&gt;C,CD–&gt;E,A–&gt;G,所以ABD的闭包为ABDCEG=U<br> 　 　<strong>再看BDC</strong><br>　　  CD–&gt;E,E–&gt;A,A–&gt;G,BDC本身自包,所以BDC的闭包为BDCEAG=U<br> 　　 <strong>最后看BDE</strong><br>　　  E–&gt;A,A–&gt;G,AB–&gt;C,BDE本身自包,所以BDE的闭包为BDEAGC=U</p>
<p>  　　因为(ABD)、(BCD)、(BDE)的闭包都是ABCDEG所以本问题的候选码有3个分别是ABC、BCD和BDE</p>
<p> 　　候选码：ABC，BCD，BDE；</p>
<p>　　主属性（主要的属性，能决定其他属性的)：ABCDE;</p>
<p>　　非主属性：G；  
　　</p>
<h4 id="Armstrong-公理系统"><a href="#Armstrong-公理系统" class="headerlink" title="Armstrong 公理系统"></a>Armstrong 公理系统</h4><p>　　设关系模式R&lt;U,F&gt;，其中U为属性集，F是U上的一组函数依赖，那么有如下推理规则</p>
<p>　　① A1自反律：若Y⊆X⊆U，则X→Y为F所蕴含；                    即：ABC→AB；   AB——&gt;A (平凡依赖函数)；<br>　　② A2增广律：若X→Y为F所蕴含，且Z⊆U，则XZ→YZ为F所蕴含；<br>　　③ A3传递律：若X→Y，Y→Z为F所蕴含，则X→Z为F所蕴含。<br>　　根据上面三条推理规则，又可推出下面三条推理规则：<br>　　④ 合并规则：若X→Y，X→Z，则X→YZ为F所蕴含；<br>　　⑤ 伪传递规则：若X→Y，WY→Z，则XW→Z为F所蕴含；  即：A→B，AC→BC；BC→D ；得出AC→D；<br>　　⑥ 分解规则：若X→Y，Z⊆Y，则X→Z为F所蕴含。      即：A→BC;  能得出：  A→B，A→C；  </p>
<h4 id="属性集闭包"><a href="#属性集闭包" class="headerlink" title="属性集闭包"></a>属性集闭包</h4><p>　　闭包就是由一个属性直接或间接推导出的所有属性的集合。</p>
<p>　　例如：f={a-&gt;b，b-&gt;c，a-&gt;d，e-&gt;f}；由a可直接得到b和d，间接得到c，则a的闭包就是{a，b，c，d}；</p>
<p>　　已知关系R(A1，A2，A3，A4，A5，A6)，函数依赖集F为{ (A2，A3)——&gt;A4，A3——&gt;A6，(A2，A5)——&gt;A1 }， 问(A2，A3)关于F的属性闭包为：{A2，A3,A4,A6}；  因为：A2，A3能带到A4，A3能得到A6；</p>
<p>　　已知关系R(A，B，C，D，E，F，G)，函数依赖集F为{ A ——&gt;B，B——&gt;D，AD——&gt;EF，AG——&gt;C}， 问：A关于F的属性闭包为:{A,B,D,E,F}；     因为：A能得到B，B能得到D，AD能得到EF;  </p>
<h4 id="最小函数依赖集（正则覆盖）"><a href="#最小函数依赖集（正则覆盖）" class="headerlink" title="最小函数依赖集（正则覆盖）"></a><strong>最小函数依赖集（正则覆盖）</strong></h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>　　如果函数依赖集F满足以下条件，则称F为一个极小函数依赖集。也称为最小依赖集或最小覆盖。</p>
<p>　　(1)F中任一函数依赖的右部仅含有一个属性。</p>
<p>　　(2)F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价。</p>
<p>　　(3)F中不存在这样的函数依赖X→A，X有真子集Z使得F-{X→A}U{Z→A}与F等价。</p>
<h5 id="最小依赖集通用算法"><a href="#最小依赖集通用算法" class="headerlink" title="最小依赖集通用算法"></a><strong>最小依赖集通用算法</strong></h5><p>　　① 用分解的法则，使F中的任何一个函数依赖的右部仅含有一个属性；</p>
<p>　　② 去掉多余的函数依赖：从第一个函数依赖X→Y开始将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，看X+是否包含Y，若是，则去掉X→Y；否则不能去掉，依次做下去。直到找不到冗余的函数依赖；</p>
<p>　　③ 去掉各依赖左部多余的属性。一个一个地检查函数依赖左部非单个属性的依赖。<strong>例如XY→A，若要判 X 为多余的，则以X→A代替XY→A，若 A 属于(Y)+，则 X 是多余属性（A 不通过 XY→A，通过 Y 就可以得到 A ，证明 X 是冗余的。），若 X 为多余的则用 Y→A 替代 XY→A。</strong></p>
<h5 id="最小依赖集案例"><a href="#最小依赖集案例" class="headerlink" title="最小依赖集案例"></a>最小依赖集案例</h5><p>　　例1：关系模式R(U，F)中，U=ABCDEG，F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;BC}；求F的最小函数依赖集</p>
<p>　　步骤：</p>
<p>　　（1）用分解的法则，使F中的任何一个函数依赖的右部仅含有一个属性；得到：F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;B，ADG-&gt;C}；</p>
<p>　　（2）去掉多余的函数依赖：从第一个函数依赖X→Y开始将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，依次做下去。直到找不到冗余的函数依赖；</p>
<p>　　　　① 去掉B-&gt;D，此时F={DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;B，ADG-&gt;C}，此条件下得出B的闭包 B+ = B；B+不包含D，所以B-&gt;D保留。</p>
<p>　　　　②去掉DG-&gt;C，此时F={B-&gt;D,BD-&gt;E,AG-&gt;B,ADG-&gt;B，ADG-&gt;C}，此时DG闭包DG+ = DG，不包含C,所以不能去掉DG-&gt;C.</p>
<p>　　　　③ 去掉BD-&gt;E，此时F={B-&gt;D，DG-&gt;C,AG-&gt;B,ADG-&gt;B，ADG-&gt;C}，此时闭包BD+ = BD,不包含E，所以不能去掉BD-&gt;E，继续保留。</p>
<p>　　　　④去掉AG-&gt;B，此时F={B-&gt;D，DG-&gt;C,BD-&gt;E,ADG-&gt;B，ADG-&gt;C}；此时AG+ = AG，不包含B，所以不能去掉AG-&gt;B，继续保留。</p>
<p>　　　　⑤去掉ADG-&gt;B，此时F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;C}，此时ADG+ = ADGCBE,包含了B，所以删除ADG-&gt;B，不保留。</p>
<p>　　　　⑥去掉ADG-&gt;C，此时F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B}，此时ADG+ = ADGCBD,包含了C，所以删除ADG-&gt;C，不保留。</p>
<p>　　　　综上所得，此时得到F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B}；</p>
<p>　　（3）去掉各依赖左部多余的属性。一个一个地检查函数依赖左部非单个属性的依赖。</p>
<p>　　此时函数依赖左边非单个属性有：DG-&gt;C,BD-&gt;E,AG-&gt;B；所以做如下操作：</p>
<p>　　　　①先来看DG-&gt;C，<strong>判断 D 是否多余，用 D-&gt;C 代替 DG-&gt;C 并求 DG - D = G 的闭包</strong>，此时G的闭包G+ = G，不包含C，保留D。判断 G 是否多余，求 DG - G = D 的闭包，此时D+ = D，不包含C，所以G也不能去掉；</p>
<p>　　　　②再来看BD-&gt;E，判断 B 是否多余，求 BD - B = D 的闭包，此时D的闭包D+ = D，不含E，保留B。判断 D 是否多余，求 BD - D = B 的闭包，此时B+ = BDE，包含了E，所以<strong>去掉D。</strong></p>
<p>　　　　③最后再来看 AG-&gt;B，判断 A 是否多余，求 AG - A = G 的闭包，G+ = G，不包含B，不能去掉A。判断 G 是否多余，求 AG - G = A 的闭包，A的闭包A+ =A，不含B，不能去掉G，还是AG-&gt;B ；</p>
<p>　　所以最后得出：F的最小函数依赖集是：F={B-&gt;D，DG-&gt;C,B-&gt;E,AG-&gt;B}；</p>
<h4 id="无损连接分解判定"><a href="#无损连接分解判定" class="headerlink" title="无损连接分解判定"></a>无损连接分解判定</h4><h5 id="判断表法"><a href="#判断表法" class="headerlink" title="判断表法"></a>判断表法</h5><p><img src="https://i.loli.net/2020/04/04/lHaYsVfUW1kOC69.png" alt=""></p>
<p> <img src="https://i.loli.net/2020/04/04/JAR2xnFpjH6qCoD.png" alt=""></p>
<p> <img src="https://i.loli.net/2020/04/04/vg6JaYUop15BFlO.png" alt=""></p>
<h5 id="无损连接定理"><a href="#无损连接定理" class="headerlink" title="无损连接定理"></a>无损连接定理</h5><p>　　<img src="https://i.loli.net/2020/04/04/5qiw86uL2yGmSPZ.png" alt=""></p>
<p>　　案例（1）：关系模式R（SAIP），F={S—&gt;A,SI—&gt;P};  ρ={R1(SA),R2(SIP)}检测分解是否为无损连接？</p>
<p>　　因为：R1∩R2 = S ；R1—R2 = A； R2—R1 = IP；所以得出：S —&gt;A；或者S —&gt;IP； 而 S —&gt;A 在F={S—&gt;A,SI—&gt;P}中，所以此分解是无损连接。</p>
<p>　　举例（2）：已知R&lt;U,F&gt;，U={A,B,C}，F={A→B}，如下的两个分解：<br>　　① ρ1={AB,BC}；</p>
<p>　　② ρ2={AB,AC}；</p>
<p>　　因为：AB∩BC = B；AB—BC = A；BC—AB = C；得出；B→A，或者 B→A，两个都不包含在F={A→B}中，所以 ρ1 分解是有损的。</p>
<p>　　因为：AB∩AC = A；AB—AC = B；AC—AB = C；得出：A→B，或者A→C，而A→B包含在F={A→B}中，所以 ρ2 分解是无损的。</p>
<h4 id="保持依赖分解判定"><a href="#保持依赖分解判定" class="headerlink" title="保持依赖分解判定"></a>保持依赖分解判定</h4><p><img src="https://i.loli.net/2020/04/04/rZvdit19IXUeu46.png" alt=""></p>
<p>　　</p>
<p>​        案例（1）：关系模式R&lt;U, F&gt;，U=｛A, B, C, D, E｝，F＝{B→A，D→A，A→E，AC→B｝则分解ρ={R1（ABCE），R2（CD）｝是否满足保持函数依赖。</p>
<p>　　因为：B→A，A→E，AC→B在R1上成立，D→A在R1和R2上都不成立，因此需做进一步判断。</p>
<p>　　由于B→A，A→E，AC→B都是被保持的（因为它们的元素都在R1中），因此我们要进一步判断的是D→A是不是也被保持。</p>
<p>　　①先看R1：因为：result = D；result ∩R1 = ф (空集)；所以：t=ф，result=D；</p>
<p>　　②再看R2：因为：result = D；result ∩R2 = D；D+ = DA; D+ ∩ R2 = D; 所以：t=D，result=D；</p>
<p>　　一个循环后result未发生变化，因此最后result=D，并未包含A，所以D→A未被保持，该分解不是保持依赖的。</p>
<p>　　案例（2）：关系R&lt;U,F&gt;，U={A,B,C,D,E}，F={A→C,B→C,C→D,DE→C,CE→A}，R的一个分解为R1(AD)，R2(AB)，R3(BE)，R4(CDE)，R5(AE)，判断这个分解是否具有函数依赖性。</p>
<p>　　因为：,C→D,DE→C均在R4(CDE)中被保持，而A→C,B→C，CE→A，在R1….R5上都不成立，需要进一步判断。</p>
<p>　　（1）A→C；</p>
<p>　　①先看R1：因为：result = A；result ∩R1 = A ； A+ = ACD ； A+ ∩ R1 = AD；所以：t=AD，result=AD； 此时，result改变，则，进入R2；</p>
<p>　　②再看R2：因为：result = AD；result ∩R2 = ф，最后还是result = AD；</p>
<p>　　③再看R3：因为：result = AD；result ∩R3 = ф，最后还是result = AD；</p>
<p>　　④再看R4：因为：result = AD；result ∩R4 = D，D+ = D; D+ ∩ R4= D；最后还是result = AD；</p>
<p>　　⑤再看R5：因为：result = AD；result ∩R5 = A，最后还是result = AD；</p>
<p>　　最后result = AD 并未包含C；所以，所以D→A未被保持，该分解不是保持依赖的；</p>
<p><img src="https://i.loli.net/2020/04/13/9ndTFcB2j7MrzIP.png" alt="image-20200413172034818"></p>
<p><img src="https://i.loli.net/2020/04/13/svSjHaFopgIeTwL.png" alt="image-20200413172105632"></p>
<p><img src="https://i.loli.net/2020/04/13/XU2MsqG8edf6HIh.png" alt="image-20200413172128282"></p>
<h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p>　　（1）：1NF：每个分量都是不可再分的数据项（值、原子）。即：属性中，不能存在复合属性 或者 多值属性。</p>
<p>　　（2）：2NF：每一个非主属性 完全函数依赖 于 候选键（码）。注意：这里是码（不是主属性）；即：不能存在 非主属性部分函数依赖于码。</p>
<p>　　（3）：3NF：每一个非主属性 都不传递依赖于 码。 即：不能存在非主属性对于码的传递函数依赖。</p>
<p>　　（4）：BCNF：不存在 主属性 对于 码 的 部分函数依赖 与 传递函数依赖。判断方法：箭头左边的必须是候选码（不能只是一个属性，部分码）。</p>
<p><img src="https://i.loli.net/2020/04/04/f8IdKbFRrWoZPw3.png" alt=""></p>
<p>　　<strong>判断范式的方法：</strong></p>
<p>　　<img src="https://i.loli.net/2020/04/04/RcqhALHKwyl9GUX.png" alt=""></p>
<p> 　　例1：R（A，B，C），F={A-&gt;B, B-&gt;A, A-&gt;C}</p>
<p>　　　　L ：No，R：C，LR：A，B</p>
<p>　　　　计算A+ = ABC ，A 是候选码</p>
<p>　　　　计算B+ = ABC，B 是候选码</p>
<p>　　　　主属性： A，B ；非主属性： C</p>
<p>　　　　1）看非主属性是否部分依赖于主属性，发现没有部分依赖。</p>
<p>　　　　2）看非主属性是否传递依赖于主属性，发现 B -&gt; A -&gt; C ，C 传递依赖于 B，<strong>但这个传递依赖成立的条件是 A -&gt; B 不成立，否则A -&gt; C 推不出来。</strong>故没有部分传递依赖。</p>
<p>　　　　3）看所有依赖左边是否全部为候选码，所有依赖左边依次是 A，B，A 全部为 候选码 故为 BCNF 范式。</p>
<p>　　　　例2：R（A，B，C，D），F={B-&gt;D, D-&gt;B, AB-&gt;C}</p>
<p>　　　　L：A， R：C，LR：B，D</p>
<p>　　　　L 一定为主属性，将 L 和 LR 组合为 AB，AD</p>
<p>　　　　主属性： A，B，D ；非主属性： C</p>
<p>　　　　AB+ = ABCD；AD+ = ABCD；故 AB，AD为候选码。</p>
<p>　　　　1）查看部分依赖。 C 完全依赖于 AB，没有部分依赖。</p>
<p>　　　　2）查看传递依赖。C直接完全依赖于候选码 AB，没有传递依赖。</p>
<p>　　　　3）查看是否全为候选码。所有依赖左边依次是 B，D，AB ，B，D不为 候选码 故为 3NF 范式。</p>
<h4 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h4><h5 id="3NF-分解"><a href="#3NF-分解" class="headerlink" title="3NF 分解"></a><strong>3NF 分解</strong></h5><p>　　1）计算最小函数依赖</p>
<p>　　2）将最小函数依赖依次分解，得到 3NF 保持函数依赖分解。</p>
<p>　　3）将保持依赖分解添加一个候选码到结果中，得到 3NF 无损连接分解。</p>
<h5 id="BCNF-分解"><a href="#BCNF-分解" class="headerlink" title="BCNF 分解"></a><strong>BCNF 分解</strong></h5><p>　　R(A，B，C，D)，F={A-&gt;B，C-&gt;D}一直找不是候选码的函数依赖项 A-&gt;B，将依赖集分解为两部分：</p>
<p>　　1）AB</p>
<p>　　2）ACD (B 可由A 推出)</p>
<p>　　继续分解 ACD。</p>
<p>　　<img src="https://i.loli.net/2020/04/04/yL3SnojMe8WakFN.png" alt=""></p>
<p>　　例： R（A，B，C，D，E，F），F={AE-&gt;F，A-&gt;B, BC-&gt;D, CD-&gt;A, CE-&gt;F}</p>
<h5 id="3NF-分解例子"><a href="#3NF-分解例子" class="headerlink" title="3NF 分解例子"></a><strong>3NF 分解</strong>例子</h5><p>　　<strong>1）计算最小函数依赖集</strong>，这里省略，可以看到 F 的最小函数依赖集就是它本身。</p>
<p>　　<strong>2）计算候选码</strong></p>
<p>　　L：C，E</p>
<p>　　R：F</p>
<p>　　LR：A，B，D</p>
<p>　　L 一定为主属性，将 L 和 LR 组合为 ACE，BCE，CDE。</p>
<p>　　主属性： A，B，C，D ，E；非主属性： F</p>
<p>　　ACE+ = ABCDEF；BCE+ = ABCDEF；CDE+ = ABCDEF；故ACE，BCE，CDE为候选码。</p>
<p> 　　<strong>3）分解</strong></p>
<p>　　将上面的函数依赖依次分解得到：AEF，AB，BCD，CDA，CEF。</p>
<p>　　得到 3NF 保持函数依赖分解 : AEF，AB，BCD，CDA，CEF</p>
<p>　　任意添加一个候选码进去(这里选 ACE)。</p>
<p>　　得到 3NF 无损连接依赖分解 : AEF，AB，BCD，CDA，CEF，ACE</p>
<h5 id="BCNF-分解例子"><a href="#BCNF-分解例子" class="headerlink" title="BCNF 分解例子"></a><strong>BCNF 分解例子</strong></h5><p>　　<strong>依次分解左边不是候选码的依赖项</strong></p>
<p>　　AE-&gt;F，A-&gt;B, BC-&gt;D, CD-&gt;A, CE-&gt;F 左边全部都不是候选码，都需要分解。</p>
<p>　　第一次分解 AE-&gt;F：</p>
<p>　　AEF， 剩下 R=（ABCDE），F={A-&gt;B, BC-&gt;D, CD-&gt;A} （F可以被导出，若 F 在依赖的左边需要使用其他依赖代替）</p>
<p>　　第二次分解 A-&gt;B：</p>
<p>　　AB，剩下 R=（ACDE）， F={AC-&gt;D, CD-&gt;A} （B可以被导出，<strong>丢失BC-&gt; D</strong>）</p>
<p>　　第三次分解 CD-&gt;A：</p>
<p>　　CDA，剩下 R=（CDE）， F={} （A可以被导出）</p>
<p>　　CDE为候选码分解停止。</p>
<p>　　故 BCNF 分解为 AEF，AB，CDA，CDE</p>
<p>参考：</p>
<p>　　<a href="https://blog.csdn.net/prdslf001001/article/details/80336835" target="_blank" rel="noopener">https://blog.csdn.net/prdslf001001/article/details/80336835</a></p>
<p>　　<a href="https://www.bilibili.com/video/av73467859/" target="_blank" rel="noopener">https://www.bilibili.com/video/av73467859/</a></p>
<p>　　<a href="https://www.bilibili.com/video/BV1eE411a79r/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1eE411a79r/</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/04/04/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建型模式–单例模式"><a href="#创建型模式–单例模式" class="headerlink" title="创建型模式–单例模式"></a>创建型模式–单例模式</h1><p>　　单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>　　注意：1）单例类中只能有一个实例</p>
<p>　　　　　2）单例类必须自己创建自己的唯一实例</p>
<p>　　　　　3）单例类必须给所有其他对象提供这一实例</p>
<p><strong>介绍</strong></p>
<p>　　意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>　　主要解决：一个全局使用的类频繁地创建与销毁。</p>
<p>　　何时使用：当您想控制实例数目，节省系统资源的时候。</p>
<p>　　如何解决：判断系统是否已经有这个单例，如果有则返回，没有则创建。</p>
<p>　　关键代码：构造函数是私有的。</p>
<p>　　应用实例：一个班级只有一个班主任。</p>
<p>　　优点：1）在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。2）避免对资源的多重占用（比如写文件操作）。</p>
<p>　　缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>　　应用场景：1）要求生产唯一序列号。2）WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。3）创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>
<p><strong>实现</strong></p>
<p>　　我们将创建一个 <em>SingleObject</em> 类。<em>SingleObject</em> 类有它的私有构造函数和本身的一个静态实例。<em>SingleObject</em> 类提供了一个静态方法，供外界获取它的静态实例。<em>SingletonPatternDemo*，我们的演示类使用 *SingleObject</em> 类来获取 <em>SingleObject</em> 对象。</p>
<p><img src="https://i.loli.net/2020/04/04/Px9WFvJVqliNUpw.png" alt="img"></p>
<p> 　1、创建一个Singleton 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、从 Singleton 类获取唯一的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不合法，构造函数不可见</span></span><br><span class="line">        <span class="comment">//SingleObject so = new SingleObject();</span></span><br><span class="line"></span><br><span class="line">        SingleObject so = SingleObject.getInstance();</span><br><span class="line">        so.showMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　输出：hello world！</p>
<p><strong>单例模式的几种实现方式</strong></p>
<p>　　1、<strong>懒汉式不加锁</strong>，线程不安全。可能会有多个进程进入到 if 语句内，创建多个实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 懒加载，线程不安全。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLazyUnlocked</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazyUnlocked instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazyUnlocked</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazyUnlocked <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazyUnlocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、<strong>懒汉式加锁</strong>，线程安全。加synchronized影响效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 懒加载，线程安全。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLazyLocked</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazyLocked instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazyLocked</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonLazyLocked <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazyLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、<strong>饿汉式</strong>，线程安全。类加载时创建实例，容易产生垃圾对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 非懒加载，线程安全。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHungry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonHungry instance = <span class="keyword">new</span> SingletonHungry();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonHungry</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonHungry <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　4、<strong>双重校验锁</strong>（Double-Checked Locking）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 懒加载，线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonDCL instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDCL</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDCL <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDCL<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　第一次校验：如果创建了实例再去执行getInstance()方法不会去竞争锁，直接返回实例。</p>
<p>　　第二次校验：防止二次创建实例。如果没有第二个判空语句，在实例还没有创建的情况下，A 和 B 两个线程都要获得单例的对象。A ，B 都进入了第一个判空语句内，然后争夺锁，A获得了锁，实例化了一个对象，然后释放了锁，B获得了锁，由于没有第二个判空语句B 又创建了一次对象。</p>
<p>　　volatile 关键字的作用：防止指令重排优化。保证变量在多线程运行时的可见性，无法保证原子性。</p>
<p>　　5、<strong>静态内部类</strong></p>
<p>　　对静态域使用延迟初始化利用类加载机制来保证初始化 instance 时只有一个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 静态内部类懒加载</span></span><br><span class="line"><span class="comment">* 懒加载，线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonRegister</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonRegister INSTANCE = <span class="keyword">new</span> SingletonRegister();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonRegister</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonRegister <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>　　6、<strong>枚举</strong></p>
<p>　　实现单例的最佳方法。更简洁，自动支持序列化机制防止多次实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考：<a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/singleton-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>关系模型与关系代数</title>
    <url>/2020/04/04/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>　　1）关系模型的数据结构为二维表，亦称关系，每个表（关系）有唯一的名字。</p>
<p>　　2）关系数据库是表的集合，即关系的集合。 </p>
<h4 id="关系数据结构的形式化定义"><a href="#关系数据结构的形式化定义" class="headerlink" title="关系数据结构的形式化定义"></a>关系数据结构的形式化定义</h4><p>　　1）域。域是一组具有相同数据类型的值的集合。如{‘男’，‘女’}。</p>
<p>　　2）笛卡儿积。</p>
<p><img src="https://i.loli.net/2020/04/04/c3YP65x9nMUm7EK.png" alt="img"></p>
<p> 　3）码。</p>
<p>　　　　超码：属性集 A 可以唯一标识关系 r 总中的一个元组，则称属性集 A 为关系 r 的一个超码。</p>
<p>　　　　候选码：对于关系 r 的一个或多个属性的集合 A ，如果属性集 A 的任何真子集都不能成为关系的超码，则称属性集 A 为候选码。</p>
<p>　　　　主码：若一个关系有多个候选码，可以选定其中一个候选码作为该关系的主码。</p>
<p>　　　　总结：主码 属于 候选码 属于 超码。</p>
<h4 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h4><p>　　关系完整性的约束条件：</p>
<p>　　1）实体完整性。主码不能为空。</p>
<p>　　2）参照完整性。外码要么为空要么能等于被参照关系的某个元组的主码。</p>
<p>　　3）用户自定义完整性。限制关系中某些属性的值符合业务语义要求。如限制性别为男或女。</p>
<p>　　</p>
<h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><p>　　关系操作有查询操作和更新操作两大类。查询操作又可分为选择、投影、连接、除、并、交、差、笛卡儿积等。其中<strong>选择、投影、集合并、集合差和笛卡儿积是 5 种基本关系操作</strong>。</p>
<p>​        关系代数</p>
<p><img src="https://i.loli.net/2020/04/04/wNd74x2S3sOeajV.png" alt="img"></p>
<p> 　在连接中把不能连接的元组丢弃称为<strong>自然连接</strong>，把左关系中不能连接的元组保留到结果关系称为<strong>左外连接</strong>，把右关系中不能连接的元组保留到结果关系中称为<strong>右外连接</strong>，把左右关系中不能连接的元组都保留到结果关系中称为<strong>全外连接</strong>。</p>
<p><img src="https://i.loli.net/2020/04/04/6kVrK947GniRo5f.png" alt="img"></p>
<p>　　关系代数例题</p>
<p><img src="https://i.loli.net/2020/04/04/qnDoKAmvJxYUhdk.png" alt="img"></p>
<p>　　1）查找选修了 08-09 学年第一学期（08091）开出的全部课程的学生学号和姓名。</p>
<p>　　解析：先找出所有08-09 学年第一学期的课程号，然后用选课关系表除这些课程号得到选修了08-09 学年第一学期全部课程学生的学号，再和学生表连接然后投影出学号和姓名。</p>
<p><img src="https://i.loli.net/2020/04/04/M8QDBnxT6GNHA4r.png" alt="img"></p>
<p>　　2）查找至少选修了一门其直接先修课编号为 CS012 的课程的学生学号和姓名。</p>
<p>　　解析：先找出先修课编号为 CS012 的课程然后依次连接选修关系和学生关系，最后投影出学生学号（没选过先修课编号为 CS012 的课程的同学会连接失败，如果选了多门先修课编号为 CS012 的课程的同学，投影会将学生学号和姓名去重）。</p>
<p><img src="https://i.loli.net/2020/04/04/CJ1dBG6NVYhOEtn.png" alt="img"></p>
<p>　　3）查找至少选修了学号为0703010 的学生所选课程的学号和姓名。</p>
<p>　　解析：先找出学号为0703010的学生所选的课程号，然后用选修关系除这些课程号，得到至少选修了学号为0703010 的学生所选课程的学号，再和学生表连接，投影出学号和姓名。</p>
<p><img src="https://i.loli.net/2020/04/04/mOjbEfyIU97XVFH.png" alt="img"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2020/04/04/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建型模式–工厂模式"><a href="#创建型模式–工厂模式" class="headerlink" title="创建型模式–工厂模式"></a>创建型模式–工厂模式</h1><p>　　工厂模式（Factory Pattern）是Java 中最常用的设计模式之一。提供了一种创建对象大的最佳方式。我们在创建对象时不会对客户端暴露创建逻辑，通过一个共同的接口来指向新创建的对象。</p>
<p>　</p>
<p><strong>介绍</strong></p>
<p>　　<strong>意图</strong>：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p>　　<strong>主要解决</strong>：接口选择的问题。</p>
<p>　　<strong>何时使用</strong>：不同条件下创建不同实例时。</p>
<p>　　<strong>如何解决</strong>：让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
<p>　　应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p>
<p>　　优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p>　　缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<p>　　使用场景<strong>：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p>
<p>　　<strong>注意事项</strong>：复杂对象生成适合使用工厂模式，简单对象直接new。</p>
<p><strong>实现</strong></p>
<p>　　我们将创建一个 <em>Shape</em> 接口和实现 <em>Shape</em> 接口的实体类。下一步是定义工厂类 <em>ShapeFactory<em>。</em>FactoryPatternDemo*，我们的演示类使用 *ShapeFactory</em> 来获取 <em>Shape</em> 对象。它将向 <em>ShapeFactory</em> 传递信息（<em>CIRCLE / RECTANGLE / SQUARE</em>），以便获取它所需对象的类型。</p>
<p><img src="https://i.loli.net/2020/04/04/gtuCzOImlK4UyG8.png" alt="img"></p>
<p> 　1、创建一个Shape接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、创建 Rectangle、Circle和Square 实体类实现Shape接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rectangle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、创建一个工厂，生成基于给定信息的实体类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用getShape方法获取形状对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"circle"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"square"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"rectangle"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　4、使用该工厂，通过传递类型信息来获取实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeFactory sf = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line"></span><br><span class="line">        Shape s1 = sf.getShape(<span class="string">"circle"</span>);</span><br><span class="line">        <span class="keyword">if</span>(s1 != <span class="keyword">null</span>)s1.draw();</span><br><span class="line"></span><br><span class="line">        Shape s2 = sf.getShape(<span class="string">"rectangle"</span>);</span><br><span class="line">        <span class="keyword">if</span>(s2 != <span class="keyword">null</span>)s2.draw();</span><br><span class="line"></span><br><span class="line">        Shape s3 = sf.getShape(<span class="string">"square"</span>);</span><br><span class="line">        <span class="keyword">if</span>(s3 != <span class="keyword">null</span>)s3.draw();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　输出：</p>
<p>　　Circle::draw()<br>　　Rectangle::draw()<br>　　Square::draw()</p>
<p>　　在已知获取对象的类型下，我们可以将Shape 对象强制转换为 Circle、Rectangle和Square对象，来使用特定实体类的特有方法。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/factory-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2020/04/04/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建型模式–原型模式"><a href="#创建型模式–原型模式" class="headerlink" title="创建型模式–原型模式"></a>创建型模式–原型模式</h1><p>　　原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种模式实现了一个原型接口，该接口用于创建当前对象的克隆。当创建对象的代价比较大时，则采用这种模式。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　　<strong>意图</strong>：用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p>　　<strong>主要解决</strong>：在运行期建立和删除原型。</p>
<p>　　何时使用：1、当一个系统应独立于它的产品创建，构成和表示时。2、当要实例化的类是在运行时刻指定时，例如，通过动态加载。3、为了避免创建一个与产品类层次平行的工厂类层次时。4、当一个类的实例只能有几个不同状态中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便。</p>
<p>　　如何解决：利用已有的一个原型对象，快速地生成和原型对象一样地实例。</p>
<p>　　<strong>关键代码</strong>：1、实现克隆操作，在JAVA 中继承 Cloneable ，重写Clone()。2、原型模式同样用于隔离类对象地使用者和具体类型（易变类）之间地耦合关系，它同样要求这些“易变类”拥有稳定的接口。</p>
<p>　　应用实例：1、细胞分裂。2、JAVA 中的Object clone() 方法。</p>
<p>　　优点：1、性能提高。2、逃避构造函数的约束。</p>
<p>　　缺点：1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</p>
<p>　　使用场景<strong>：</strong> 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p>
<p>　　注意事项<strong>：</strong>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>
<p>　　</p>
<p>实现</p>
<p>　　我们将创建一个抽象类 <em>Shape</em> 和扩展了 <em>Shape</em> 类的实体类。下一步是定义类 <em>ShapeCache*，该类把 shape 对象存储在一个 *Hashtable</em> 中，并在请求的时候返回它们的克隆。</p>
<p><em>PrototypePatternDemo*，我们的演示类使用 *ShapeCache</em> 类来获取 <em>Shape</em> 对象。</p>
<p><img src="https://i.loli.net/2020/04/04/pRkV14JYWSr6F9g.png" alt="img"></p>
<p> 　1、创建一个实现了 Cloneable 接口的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">protected</span> String type;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object cloned = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cloned = <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、创建继承了上面抽象类的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">()</span></span>&#123;</span><br><span class="line">        type = <span class="string">"Square"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        type = <span class="string">"Rectangle"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rectangle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        type = <span class="string">"Circle"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、创建一个类，从数据库中获取实体类，并把它们存储在一个 ConcurrentHashMap 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String,Shape&gt; shapeMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String shapeId)</span></span>&#123;</span><br><span class="line">        Shape cachedShape = shapeMap.get(shapeId);</span><br><span class="line">        <span class="keyword">return</span> (Shape)cachedShape.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每种形状进行数据库查询，并创建该形状。</span></span><br><span class="line">    <span class="comment">//假设创建三种形状。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">loadCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        circle.setId(<span class="string">"1"</span>);</span><br><span class="line">        shapeMap.put(circle.getId(),circle);</span><br><span class="line"></span><br><span class="line">        Rectangle rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        rectangle.setId(<span class="string">"2"</span>);</span><br><span class="line">        shapeMap.put(rectangle.getId(),rectangle);</span><br><span class="line"></span><br><span class="line">        Square square = <span class="keyword">new</span> Square();</span><br><span class="line">        square.setId(<span class="string">"3"</span>);</span><br><span class="line">        shapeMap.put(square.getId(),square);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　4、PrototypePatternDemo 使用 ShapeCache 类来获取存储在 ConcurrentHashMap 中的形状的克隆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypePatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeCache.loadCache();</span><br><span class="line"></span><br><span class="line">        Shape clonedShape = (Shape)ShapeCache.getShape(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Shape: "</span>+clonedShape.getType());</span><br><span class="line"></span><br><span class="line">        Shape clonedShape2 = (Shape)ShapeCache.getShape(<span class="string">"2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Shape: "</span>+clonedShape2.getType());</span><br><span class="line"></span><br><span class="line">        Shape clonedShape3 = (Shape)ShapeCache.getShape(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Shape: "</span>+clonedShape3.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　输出：</p>
<p><img src="https://i.loli.net/2020/04/04/u2HNXvUfjw5n3Pb.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/prototype-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/prototype-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2020/04/04/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建型模式–建造者模式"><a href="#创建型模式–建造者模式" class="headerlink" title="创建型模式–建造者模式"></a>创建型模式–建造者模式</h1><p>　　建造者模式（Builder Pattern）使用多个简单的对一步一步构成一个复杂的对象，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>　　一个Builder 类会一步一步的构造最终的对象。该Builder 对象是独立于其他对象的。</p>
<p><strong>介绍</strong></p>
<p>　　<strong>意图</strong>：将一个复杂的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>　　主要解决：在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p>　　<strong>何时使用</strong>：一些基本部件不会变，而其组合经常变化的时候。</p>
<p>　　如何解决：将变与不变分离开。</p>
<p>　　关键代码：建造者：创建与提供实例，导演：管理建造出来的实例的依赖关系。</p>
<p>　　<strong>应用实例</strong>：1、去肯德基，汉堡，可乐，薯条，炸鸡等是不变的，而其组合是经常变化的，生成出所谓的“套餐”。2、Java 中的StringBuilder。</p>
<p>　　优点：1、建造者独立、易扩展。2、便于控制细节风险。</p>
<p>　　缺点：1、产品必须有共同点，范围有限制。2、如内部变化复杂，会有很多的建造类。</p>
<p>　　使用场景：1、需要生成的对象具有复杂的内部结构。2、需要生成的对象内部属性本身相互依赖。</p>
<p>　　<strong>注意事项</strong>：与工厂模式的区别是：建造者模式更加关注零件装配的顺序。</p>
<p><strong>实现</strong></p>
<p>　　我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p>
<p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 <em>Item</em> 接口和实现 <em>Item</em> 接口的实体类，以及一个表示食物包装的 <em>Packing</em> 接口和实现 <em>Packing</em> 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p>
<p>然后我们创建一个 <em>Meal</em> 类，带有 <em>Item</em> 的 <em>ArrayList</em> 和一个通过结合 <em>Item</em> 来创建不同类型的 <em>Meal</em> 对象的 <em>MealBuilder<em>。</em>BuilderPatternDemo*，我们的演示类使用 *MealBuilder</em> 来创建一个 <em>Meal。</em></p>
<p><em><img src="https://i.loli.net/2020/04/04/rHiuG6QpIcWTmYN.png" alt="img"></em></p>
<p> 　1、创建一个表示食物条目和食物包装的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span></span>; <span class="comment">//返回包装的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、创建实现 Packing 接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 包装纸类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wrapper"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 杯子类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bottle</span> <span class="keyword">implements</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Bottle"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、创建实现 Item 接口的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 汉堡抽象类</span></span><br><span class="line"><span class="comment">* 汉堡都是用包装纸包装，价格不同。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Burger</span> <span class="keyword">implements</span> <span class="title">Item</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 冷饮抽象类，所有冷饮都是用杯子装，价格不同。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ColdDrink</span> <span class="keyword">implements</span> <span class="title">Item</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bottle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　4、创建扩展了 Burger 和 ColdDrink 的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">25.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Veg Burger"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChickenBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Chicken Burger"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coke</span> <span class="keyword">extends</span> <span class="title">ColdDrink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Coke"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pepsi</span> <span class="keyword">extends</span> <span class="title">ColdDrink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">35.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Pepsi"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　5、创建一个 Meal 类，带有上面定义的 Item 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Item&gt; items = <span class="keyword">new</span> ArrayList&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> cost = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">            cost += item.price();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showItems</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">            System.out.print(<span class="string">"Item: "</span>+item.name());</span><br><span class="line">            System.out.print(<span class="string">" Packing: "</span>+item.packing().pack());</span><br><span class="line">            System.out.println(<span class="string">" Price: "</span>+item.price());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　6、创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MealBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareVegMeal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> VegBurger());</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> Coke());</span><br><span class="line">        <span class="keyword">return</span> meal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareNonVegMeal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> Pepsi());</span><br><span class="line">        <span class="keyword">return</span> meal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　7、BuilderPatternDemo 使用 MealBuilder 来演示建造者模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderPatterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MealBuilder mealBuilder = <span class="keyword">new</span> MealBuilder();</span><br><span class="line"></span><br><span class="line">        Meal vegMeal = mealBuilder.prepareVegMeal();</span><br><span class="line">        System.out.println(<span class="string">"Veg Meal"</span>);</span><br><span class="line">        vegMeal.showItems();</span><br><span class="line">        System.out.println(<span class="string">"Total Cost: "</span>+vegMeal.getCost());</span><br><span class="line"></span><br><span class="line">        Meal nonVegMeal = mealBuilder.prepareNonVegMeal();</span><br><span class="line">        System.out.println(<span class="string">"Non-Veg meal"</span>);</span><br><span class="line">        nonVegMeal.showItems();</span><br><span class="line">        System.out.println(<span class="string">"Total Cost: "</span>+nonVegMeal.getCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　输出：</p>
<p><img src="https://i.loli.net/2020/04/04/vbdoVCnrMFiI69s.png" alt="img"></p>
<p>参考：<a href="https://www.runoob.com/design-pattern/builder-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/builder-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2020/04/04/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建型模式–抽象工厂模式"><a href="#创建型模式–抽象工厂模式" class="headerlink" title="创建型模式–抽象工厂模式"></a>创建型模式–抽象工厂模式</h1><p>　　抽象工厂模式（Abstract Factory Pattrn）是围绕一个超级工厂创建其他工厂。该超级工厂称为其他工厂的工厂。提供了一种创建对象的最佳方式。</p>
<p>　　在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>　</p>
<p><strong>介绍</strong></p>
<p>　　<strong>意图</strong>：提供一个创建一系列相关或相互依赖对象的接口，无需指定它们具体的类。</p>
<p>　　<strong>主要解决</strong>：主要解决接口选择的问题。</p>
<p>　　<strong>何时使用</strong>：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
<p>　　<strong>如何解决</strong>：在一个产品族里面定义多个产品。</p>
<p>　　<strong>关键代码</strong>：在一个工厂里聚合多个同类产品。</p>
<p>　　应用实例<strong>：</strong>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
<p>　　优点<strong>：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p>　　缺点<strong>：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<p>　　使用场景<strong>：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
<p>　　<strong>注意事项：</strong>产品族难扩展，产品等级易扩展。</p>
<p><strong>实现</strong></p>
<p>　　我们将创建 <em>Shape</em> 和 <em>Color</em> 接口和实现这些接口的实体类。下一步是创建抽象工厂类 <em>AbstractFactory*。接着定义工厂类 *ShapeFactory</em> 和 <em>ColorFactory<em>，这两个工厂类都是扩展了 *AbstractFactory</em>。然后创建一个工厂创造器/生成器类 <em>FactoryProducer*</em>AbstractFactoryPatternDemo*，我们的演示类使用 *FactoryProducer</em> 来获取 <em>AbstractFactory</em> 对象。它将向 <em>AbstractFactory</em> 传递形状信息 <em>Shape<em>（</em>CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。同时它还向 *AbstractFactory</em> 传递颜色信息 <em>Color</em>（<em>RED / GREEN / BLUE</em>），以便获取它所需对象的类型。</p>
<p><img src="https://i.loli.net/2020/04/04/moT4EKUNQRlXwOc.png" alt="img"></p>
<p> 　1、新建Shape，Color两个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、为这两个接口分别添加几个实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rectangle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blue::fill()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Green::fill()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Red::fill()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　4、创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用getShape方法获取形状对象。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shape == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(shape.equalsIgnoreCase(<span class="string">"circle"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shape.equalsIgnoreCase(<span class="string">"square"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shape.equalsIgnoreCase(<span class="string">"rectangle"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(color == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"RED"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Red();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"GREEN"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Green();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"BLUE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　5、创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂（工厂的工厂）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"color"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"shape"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　6、使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状工厂</span></span><br><span class="line">        AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">"shape"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(shapeFactory != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Shape s1 = shapeFactory.getShape(<span class="string">"circle"</span>);</span><br><span class="line">            <span class="keyword">if</span>(s1 != <span class="keyword">null</span>)s1.draw();</span><br><span class="line"></span><br><span class="line">            Shape s2 = shapeFactory.getShape(<span class="string">"rectangle"</span>);</span><br><span class="line">            <span class="keyword">if</span>(s2 != <span class="keyword">null</span>)s2.draw();</span><br><span class="line"></span><br><span class="line">            Shape s3 = shapeFactory.getShape(<span class="string">"square"</span>);</span><br><span class="line">            <span class="keyword">if</span>(s3 != <span class="keyword">null</span>)s3.draw();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色工厂</span></span><br><span class="line">        AbstractFactory colorFactory = FactoryProducer.getFactory(<span class="string">"color"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(colorFactory != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Color c1 = colorFactory.getColor(<span class="string">"red"</span>);</span><br><span class="line">            <span class="keyword">if</span>(c1 != <span class="keyword">null</span>)c1.fill();</span><br><span class="line"></span><br><span class="line">            Color c2 = colorFactory.getColor(<span class="string">"blue"</span>);</span><br><span class="line">            <span class="keyword">if</span>(c2 != <span class="keyword">null</span>)c2.fill();</span><br><span class="line"></span><br><span class="line">            Color c3 = colorFactory.getColor(<span class="string">"green"</span>);</span><br><span class="line">            <span class="keyword">if</span>(c3 != <span class="keyword">null</span>)c3.fill();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　 输出：　</p>
<p>　　Circle::draw()<br>　　Rectangle::draw()<br>　　Square::draw()<br>　　Red::fill()<br>　　Blue::fill()<br>　　Green::fill()</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/abstract-factory-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/abstract-factory-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划 Easy</title>
    <url>/2020/04/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92Easy/</url>
    <content><![CDATA[<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h4><p>难度简单1831收藏分享切换为英文关注反馈</p>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<p><strong>设f(k) 表示连续以下标为 k 的元素结尾的连续子数组的和，f(k) = max( nums[k], nums[k] + f(k-1) ),如果f(k) &lt; 0 ，从当前元素开始求和。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化连续子数组的最大和，当前子数组的最大和。</span></span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">    	<span class="comment">//尝试向当前子数组后加入 nums[i]，如果当前子数组和为负，</span></span><br><span class="line">        <span class="comment">//则以当前元素作为第一个元素开始重新计算连续子数组。</span></span><br><span class="line">        sum = Math.max(nums[i],sum+nums[i]);</span><br><span class="line">        <span class="comment">//取最大值。</span></span><br><span class="line">        max = Math.max(max,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h4><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<ol>
<li>有一个台阶只有一种选择；</li>
<li>有两个台阶有 2 阶、1阶 + 1阶两种选择；</li>
<li>有三个台阶有也有两种选择：从第二个台阶爬一阶，从第一个台阶一次爬两阶。爬上第二个台阶有两种方法，故通过第二个台阶到第三个台阶有两种方法，加上从第一个台阶到第三个台阶有一种方法故有三种方法。</li>
</ol>
<p>设 f(n) 为爬上第 n 个台阶的方法总数，则有 f(n) = f(n-1) + f(n-2)；第 n 个台阶的方法数由第 n-1 个台阶和第 n-2 个台阶的方法数组成，即可以从 n-1 个台阶爬一个台阶到第 n 阶和从第 n-2 个台阶爬两个台阶到第 n 个台阶。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ;i &lt; n ; ++i)&#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h4><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p>假设我们在第 i 天之前买一张股票，想要在第 i 天卖掉它，我们肯定在前 i-1 天中选择一天价格最低的时候买入，在股票价格最高的时候卖出。但是如果在前 i-1 天中的某一天可以获得比第 i 天获得的更大利润就不能选择第 i 天卖出而要选择前 i-1 天中的最大利润。第 i 天能获得的最大利润 = max( 前 i-1 天的最大利润，第 i 天的股票价格 - 前 i-1 天股票的最低价格)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>,min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;prices.length;++i)&#123;</span><br><span class="line">        max=Math.max(max,prices[i]-min);</span><br><span class="line">        min=Math.min(prices[i],min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<p>以示例 2 为例：</p>
<ol>
<li>当只有一个数 2 时我们只能偷2；</li>
<li>当有两个数 2，7 时我们选择偷 7 ；</li>
<li>当有2，7，9 时，我们比较 2+9 和7 谁大就取谁，偷 2+9 =11；</li>
<li>当有2，7，9，3 时我们有 11 和（3+7）比较 选择 11 ；</li>
<li>当2，7，9，3，1 时 11 和 11 +1 我们选择 12。</li>
</ol>
<p>设 f(n) 为偷盗前 n 个房屋的最高金额，则 f(n) = max( f(n-1), f(n-2) + num)。即偷盗前 n 个房屋可以有偷第 n 个房屋和不偷第 n 个房屋两种选择，取其中金额最大的一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preMax = <span class="number">0</span>, curMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = curMax;</span><br><span class="line">        curMax = Math.max(preMax + x , curMax);</span><br><span class="line">        preMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></h4><p>数组的每个索引做为一个阶梯，第 <code>i</code>个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>(索引从0开始)。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: cost &#x3D; [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li><code>cost</code> 的长度将会在 <code>[2, 1000]</code>。</li>
<li>每一个 <code>cost[i]</code> 将会是一个Integer类型，范围为 <code>[0, 999]</code>。</li>
</ol>
<p>如果我们需要到达第 i 个台阶，我们有两种选择：</p>
<ol>
<li>从第 i-2 个台阶到达第 i 个台阶，花费为到达第 i-2 个台阶的最小花费 + cost[i]；</li>
<li>从第 i-1 个台阶到达第 i 个台阶，花费为到达第 i-2 个台阶的最小花费 + cost[i]；</li>
</ol>
<p>到达第 i 个台阶的最小代价为这两种花费的最小值。</p>
<p>即 <code>cost[i] = min( minPrice[i-1], minPrice[i-2] ) + cost[i]</code>。由于只要使用到前两个台阶的最小代价，所以只用维护两个变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//pre 为前 1 个台阶的最小花费，pre2 为前 2 个台阶的最小花费。</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, pre2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cost.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = cost[i] + Math.min(pre,pre2);</span><br><span class="line">            pre2 = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(pre,pre2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层</title>
    <url>/2020/04/04/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><h4 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户/服务器模型"></a>客户/服务器模型</h4><p>　　在客户/服务器模型（Client/Server，C/S）模型中，有一个总是打开的主机称为服务器，它服务于许多来自其他称为客户机的主机请求。</p>
<p>　　其工作流程如下：</p>
<p>　　1）服务器处于接收请求的状态。</p>
<p>　　2）客户机发出服务请求，并等待接收结果。</p>
<p>　　3）服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机。</p>
<p>　　客户程序必须知道服务器程序的地址。常见的使用客户/服务器模型的应用包括 Web、文件传输协议（FTP）、远程登录和电子邮件等。</p>
<p>　　客户/服务器模型的主要特点还有：</p>
<p>　　1）网络中各计算机的地位不平等，服务器可以通过对用户权限的控制来达到管理客户机的目的。整个网络的管理工作由少数服务器担当。</p>
<p>　　2）客户机之间不直接通信。</p>
<p>　　3）可扩展性不佳，受服务器硬件和带宽的限制，服务器支持的客户机有限。</p>
<p>　　</p>
<h4 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h4><p>　　在C/S 模型中，服务器性能的好坏决定了整个系统的性能。当大量的用户请求服务时，服务器必然成为系统的瓶颈。P2P 模型的思想是整个网络中的传输内容不再被保留在中心服务器上，每个结点都同时具有下载、上传的功能，其权利和义务都是大体对等的。</p>
<p><img src="https://i.loli.net/2020/04/04/YfH16xOIqM4p5SB.png" alt="img"></p>
<p> 　与C/S 模型相比，P2P 模型的优点主要体现在：</p>
<p>　　1）减轻服务器的计算压力，消除了对某个服务器的完全依赖。</p>
<p>　　2）多个客户机之间可以直接共享文档。</p>
<p>　　3）可扩展性好。</p>
<p>　　4）网络健壮性强。</p>
<h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><h4 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h4><p>　　因特网采用层次树状结构的命名方法。采用这种命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即域名（Domain Name）。域（Domain）是名字空间中一个可被管理的划分。域可以划分为子域，子域也能划分。这样就形成了顶级域、二级域、三级域等。每个域名都由标号序列组成，各标号之间用（“.”）隔开。</p>
<p><img src="https://i.loli.net/2020/04/04/jiIY6to5ZTGnhbB.png" alt="img"></p>
<p> 　域名中标号要注意：</p>
<p>　　1）标号中的英文不区分大小写。</p>
<p>　　2）标号中除连字符（-）外不允许使用其他的标点符号。</p>
<p>　　3）每个标号不超过 63 个字符，多标号组成的完整域名最长不超过 255 个字符。</p>
<p>　　4）级别最低的域名写在最左边，级别最高的域名写在最右边。</p>
<p>　　</p>
<p>　　顶级域名（Top Level Domain）分为如下三大类：</p>
<p>　　1）国家顶级域名。国家和某些地区的域名，“.cn”表示中国。</p>
<p>　　2）通用顶级域名。常见的“.com”（公司）、“.net”（网络服务机构）、“.org”（非盈利性组织）</p>
<p>　　3）基础结构域名。 arpa 用于反向域名解析。</p>
<p><img src="https://i.loli.net/2020/04/04/MYlKHhTdcOXG1yo.png" alt="img"></p>
<h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><p>　　域名到 IP 地址的解析是由运行在域名服务器上的程序完成的，一个服务器所管辖的范围称为区。每个域名服务器不但能够进行一些域名到 IP 地址的解析，而且还必须具有连向其他域名服务器的信息。当自己不能进行域名到 IP 地址的转换时，能够知道到什么地方去找其他域名服务器。</p>
<p>　　DNS 使用了大量的域名服务器，它们以层次方式组织。采用分布式设计的 DNS，是一个在因特网上实现分布式数据库的精彩范例。</p>
<p>　　主要有 4 种类型的域名服务器：</p>
<p>　　1）根域名服务器。根域名服务器是最高层次的服务器，所有根域名服务器都知道所有顶级域名服务器的 IP 地址。根域名服务器也是最重要的域名服务器。<strong>根域名服务器用来管理顶级域（如.com），通常它并不直接把待查询的域名直接转换为 IP 地址，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。</strong></p>
<p>　　2）顶级域名服务器。负责管理在该顶级域名服务器注册的所有二级域名。收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当查找的域名服务器的 IP 地址）。</p>
<p>　　3）授权域名服务器（权限域名服务器）。授权域名服务器总能将其管辖的主机名转换为该主机的IP 地址。</p>
<p>　　4）本地域名服务器。当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给该主机的本地域名服务器。我们在 Windows 系统中配置“本地连接” 时，就需要填写 DNS 地址，这个地址就是本地 DNS 的地址。</p>
<p><img src="https://i.loli.net/2020/04/04/TWcnYbumtrf46jG.png" alt="img"></p>
<h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><p>　　域名解析是指把<strong>域名映射成为 IP 地址</strong>或把 IP 地址映射成域名的过程。前者称为<strong>正向解析</strong>，后者称为反向解析。当客户端需要域名解析时，通过本机的额DNS 客户端构造一个 DNS 的请求报文， 以 <strong>UDP 数据报</strong>方式发往本地域名服务器。域名解析有两种方式：递归查询和递归与迭代相结合的查询。<strong>递归查询给根服务器造成的负载过大，在实际中几乎不使用。</strong></p>
<p>　　常用递归与迭代相结合的查询方式如下图所示。 </p>
<p><img src="https://i.loli.net/2020/04/04/mL9shJUbPAdkfYS.png" alt="img"></p>
<p> 　假定客户机想获知域名为 y.abc.com主机地 IP 地址，域名解析地过程（用使用 8 个UDP 报文）如下：</p>
<p>　　1）客户机向本地域名服务器发出 DNS 请求报文。</p>
<p>　　2）本地域名服务器收到后查询本地缓存，若有记录直接返回。若没有记录，以 DNS 客户的身份向根域名服务器发起解析请求。</p>
<p>　　3)根域名服务器收到请求后，判断该域名属于 .com 域，将对应的顶级域名服务器 dns.com 的 IP 地址返回给本地域名服务器。</p>
<p>　　4）本地域名服务器向 顶级域名服务器 dns.com 发出解析请求报文。</p>
<p>　　5）顶级域名服务器 dns.com 接收到请求后，判断该域名属于 abc.com域，因此将对应的授权域名服务器 dns.abc.com 的 IP 地址返回给本地域名服务器。</p>
<p>　　6）本地域名服务器向 dns.abc.com 发起解析请求报文。</p>
<p>　　7）授权域名服务器 dns.abc.com 收到请求后将 查询结果返回给本地域名服务器。</p>
<p>　　8）本地域名服务器将查询结果保存到本地缓存，同时返回给客户机。</p>
<p>　　为了提高 DNS 的查询效率，并减少互联网上的 DNS 查询报文数量，在域名服务器中广泛地使用了高速缓存。当一个 DNS 服务器接收到 DNS 查询结果时，它能将该 DNS 信息缓存在高速缓存中。</p>
<p>　　</p>
<h3 id="文件传输协议（FTP）"><a href="#文件传输协议（FTP）" class="headerlink" title="文件传输协议（FTP）"></a>文件传输协议（FTP）</h3><h4 id="FTP-的工作原理"><a href="#FTP-的工作原理" class="headerlink" title="FTP 的工作原理"></a>FTP 的工作原理</h4><p>　　文件传输协议（File Transfer Protocol，FTP）是因特网上使用的最广泛的文件传输协议。FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。它屏蔽了各计算机系统的细节，适合于在异构网络中的任意计算机之间传送文件。</p>
<p>　　FTP 提供以下功能：</p>
<p>　　1）提供不同种类主机系统之间的文件传输能力。</p>
<p>　　2）以用户权限管理的方式提供用户对远程 FTP 服务器上的文件管理能力。</p>
<p>　　3）以匿名 FTP 的方式提供公用文件共享的能力。</p>
<p>　　FTP 采用 客户/服务器的工作方式，它使用 TCP 可靠的传输服务。一个 FTP 服务器可同时为多个客户机进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接收新的请求；另外由若干从属进程，负责处理单个请求。</p>
<p>　　其工作步骤如下：</p>
<p>　　1）打开熟知端口21（控制端口），使客户进程能够连接上。</p>
<p>　　2）等待客户进程发连接请求。</p>
<p>　　3）启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程处理完客户的请求后终止。</p>
<p>　　4）回到等待状态。</p>
<p>　　</p>
<h4 id="控制连接与数据连接"><a href="#控制连接与数据连接" class="headerlink" title="控制连接与数据连接"></a>控制连接与数据连接</h4><p>　　FTP 在工作时使用两个并行的 TCP 连接：<strong>一个控制连接（端口号21），一个是数据连接（端口号20）</strong>。</p>
<p>　　1）控制连接。服务器监听21端口，等待客户连接，控制连接用来传递控制信息 以7位 ASCII 格式传送。</p>
<p>　　2）数据连接。服务器端接收到客户端发来的文件传输请求后，创建数据传送进程和数据连接。数据连接用来连接客户端和服务器端的数据传送进程，数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</p>
<h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><h4 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h4><p>　　一个电子邮件系统应具有三个最主要的组成构件，用户代理（User Agent）、邮件服务器和电子邮件使用的协议，如 SMTP、POP3（或 IMAP）等。</p>
<p><img src="https://i.loli.net/2020/04/04/GkUHhObCvaygi7Z.png" alt="img"></p>
<p>​        用户代理（UA）：用户与电子邮件系统的接口。通常情况下，就是一个运行在PC上的程序。</p>
<p>　　邮件服务器：组成电子邮件系统的核心。邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件的传送情况。邮件服务器采用C/S方式工作，但是它能够同时充当客户和服务器。</p>
<p>　　邮件发送协议和读取协议：邮件发送协议用于在用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，通常使用 SMTP；邮件读取协议用于用户代理从邮件服务器读取邮件，如 POP3；SMTP 主动将邮件推到服务器，POP3 向邮件服务器发出请求拉取用户邮箱的邮件。</p>
<p><img src="https://i.loli.net/2020/04/04/3iuyE4KN7TogBsz.png" alt="img"></p>
<h4 id="电子邮件格式与MIME"><a href="#电子邮件格式与MIME" class="headerlink" title="电子邮件格式与MIME"></a>电子邮件格式与MIME</h4><p>　　1、电子邮件格式</p>
<p>​        一个电子邮件分为信封和内容两大部分，邮件内容又分为首部和主体两部分。To：为收件人，Subject：为主题。</p>
<p>　　2、多用途网络邮件扩充 MIME</p>
<p>　　SMTP 只能传送一定长度的 ASCII 码且无法传送可执行文件及其他二进制对象，因此提出了多用途网络邮件扩充（Multipurpose Internet Mail Extensions）。MIME 增加了邮件主体的结构，并定义了传送非ASCII 码的编码规则。并未改动SMTP 或取代它。</p>
<p>　　MIME 主要包括以下三部分内容：</p>
<p>　　1）5 个新的邮件首部字段，包括 MIME 版本、内容描述、内容标识、内容传送编码和内容类型。</p>
<p>　　2）定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</p>
<p>　　3）定义了传送编码，可对任何内容格式进行格式转换。</p>
<p>　　</p>
<h4 id="SMTP-和-POP3"><a href="#SMTP-和-POP3" class="headerlink" title="SMTP 和 POP3"></a>SMTP 和 POP3</h4><h5 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h5><p>　　简单邮件传输协议（Simple Mail Transfer Protocol）是一种提供可靠且有效的电子邮件传输的协议，它控制两个相互通信的 SMTP 进程交换信息。<strong>SMTP 使用 C/S 方式。使用 TCP 连接，端口号为25</strong>。SMTP 通信有以下三个阶段：</p>
<p>　　1）连接建立</p>
<p>​        发件人的邮件到达邮件服务器缓存之后，邮件服务器每隔一段时间对邮件缓存扫描一次。如果有邮件使用 SMTP 熟知端口（25）与接收方服务器 SMTP 服务器建立 TCP 连接。连接成功后接收方发出 220 Service ready 。发送方服务器向接收方发出 HELLO 命令，附上发送方的主机名。SMTP 不使用中间邮件服务器，TCP 总是在发送方和接收方这两个邮件服务器之间建立。</p>
<p>　　2）邮件传送</p>
<p>　　连接建立后，邮件的传送从 MAIL 命令开始，MAIL命令后面有发件人的地址。若接收方SMTP已经准备好接收 则回复 250 OK。接着发送一个或多个 RCPT命令给接收方服务器，每发送一个RCPT 命令都有相应的信息返回 250 OK 或 550 No such user here。RCPT的作用是检测接收方是否做好了接收邮件的准备。获取 OK 的答复之后客户端使用 DATA 命令，表示开始传输邮件的内容。</p>
<p>　　3）连接释放</p>
<p>　　邮件发送完后，SMTP 客户发送 QUIT 命令SMTP 服务器返回211（服务关闭）。</p>
<p>　　</p>
<h5 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h5><p>　　邮局协议（Post Office Protocol，POP）是一个非常简单但功能有限的邮件读取协议。POP 也使用C/S 工作方式，在传输层使用 TCP，端口号为 110。POP 有两种工作方式：下载并保留，下载并删除。这里的保留和删除指是否保留服务器上的邮件。</p>
<p>　　另一个邮件接收协议是因特网报文存取协议（IMAP），它比POP复杂得多，IMAP 为用户提供了创建文件夹等命令。</p>
<p>　　</p>
<h3 id="万维网（WWW）"><a href="#万维网（WWW）" class="headerlink" title="万维网（WWW）"></a>万维网（WWW）</h3><h4 id="WWW-的概念与组成结构"><a href="#WWW-的概念与组成结构" class="headerlink" title="WWW 的概念与组成结构"></a>WWW 的概念与组成结构</h4><p>　　万维网（Word Wide Web，WWW）是一个资料空间，在这个空间中：一样有用的事务称为一样资源，并由一个“全域统一资源定位符（URL）”标识。这些资源通过超文本传输协议（HTTP）传送给使用者。</p>
<p>　　万维网的内核部分是由三个标准构成的：</p>
<p>　　1）统一资源定位符（URL）。负责标识万维网上的各种文档。</p>
<p>　　2）超文本传输协议（HTTP）。应用层协议，使用TCP连接进行可靠的传输。</p>
<p>　　3）超文本标记语言（HTML）。一种文档结构的标记语言。</p>
<p>　　URL 的一般形式是：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p>
<p>　　常见的协议有 http、ftp 等。</p>
<p>　　万维网以C/S方式工作，浏览器是用户计算机上的万维网客户程序。</p>
<p>　　</p>
<h4 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h4><p>　　HTTP 是面向事务的应用层协议，它规定了在浏览器和服务器之间的请求和响应的格式与规则，是万维网上能够可靠地交换文件的重要基础。</p>
<h5 id="HTTP-的操作过程"><a href="#HTTP-的操作过程" class="headerlink" title="HTTP 的操作过程"></a>HTTP 的操作过程</h5><p>　　浏览器要访问 WWW 服务器时，首先要完成对 WWW 服务器的域名解析。一旦获得了服务器的 IP 地址，浏览器就通过TCP向服务器发送连接建立请求。</p>
<p>　　每个万维网站点都有一个服务器进程，它不断地监听 TCP 的端口80（默认），当监听到连接请求后就向浏览器建立连接。TCP 连接建立后，浏览器就向服务器发送请求获取某个页面的 HTTP 请求。服务器收到 HTTP 请求后，将构件所请求 Web 页的必需信息，通过 HTTP 的响应返回给浏览器。浏览器再将信息进行解释，然后将Web 页显示给用户，最后TCP 连接释放。</p>
<p>　　访问一个网站发生的事件，以访问清华网站为例。</p>
<p>　　1）浏览器分析链接指向页面的 URL （<a href="http://www.tsinghua.edu.cn/chn/index.htm）。" target="_blank" rel="noopener">http://www.tsinghua.edu.cn/chn/index.htm）。</a></p>
<p>　　2）浏览器向 DNS 请求解析 <a href="http://www.tsinghua.edu.cn" target="_blank" rel="noopener">www.tsinghua.edu.cn</a> 的 IP 地址。</p>
<p>　　3）域名系统 DNS 解析出清华大学服务器的 IP 地址。</p>
<p>　　4）浏览器与该服务器建立 TCP 连接（默认端口号为 80）</p>
<p>　　5）浏览器发出 HTTP 请求：GET/chn/index.htm。</p>
<p>　　6）服务器通过 HTTP 响应把文件 index.htm 发送给浏览器。</p>
<p>　　7）TCP 连接释放。</p>
<p>　　8）浏览器解释文件 index.htm，并将Web 页显示给用户。</p>
<p>　　总结：DNS 解析 IP 地址，建立 TCP 连接，客户端发送 HTTP 请求，服务端响应 HTTP，TCP 连接释放，浏览器渲染页面。</p>
<h5 id="HTTP-的特点"><a href="#HTTP-的特点" class="headerlink" title="HTTP 的特点"></a>HTTP 的特点</h5><p>　　HTTP 是无状态的，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问的相同。因为服务器并不记得曾经访问过的这个用户，也不记得为该客户曾经服务过多少次。</p>
<p>　　HTTP 的无状态设计使服务器更容易支持大量并发的 HTTP 请求。在实际应用中，通常使用 Cookie 加数据库的方式来跟踪用户的活动。Cookie 是一个存储在用户主机中的文本文件，里面有一串识别码，用于Web 服务识别用户。</p>
<p>　　HTTP 既可以使用非持久连接，也可以使用持久连接（HTTP/1.1支持）。</p>
<p>　　对于非持久连接，每个网页元素的传输都需要单独建立一个TCP连接（5 张图片 5 个 TCP 连接），请求一个万维网文档所需要的事件是该文档的传输时间加上两倍往返时间 RTT。（一个 RTT 用于 TCP 连接，另一个RTT 用于请求和接收文档。三次握手的第三次可以发送HTTP请求）。</p>
<p>　　所谓持久连接，指万维网服务器在发送响应后仍然保持这条连接，使同一个客户和服务器可以继续在这条连接上传送后续的 HTTP 请求与响应报文。</p>
<p><img src="https://i.loli.net/2020/04/04/ChsAGEzXFHxfRVk.png" alt="img"></p>
<p> 　持久连接又分为非流水线和流水线两种方式。对于非流水线方式，客户收到前一个响应后才能发出下一个请求。HTTP/1.1 默认方式是使用流水线的持久连接。</p>
<h5 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h5><p>　　HTTP 是面向文本的，因此报文中的每个字段都是一些 ASCII 码串，并且每个字段的长度都是不确定的。</p>
<p>　　有两类 HTTP 报文：请求报文和响应报文。</p>
<p><img src="https://i.loli.net/2020/04/04/nib94M5QDNgkAy3.png" alt="img"></p>
<p> <img src="https://i.loli.net/2020/04/04/HqsRhgfN4BPynmj.png" alt="img"></p>
<h3 id="知识结构图"><a href="#知识结构图" class="headerlink" title="知识结构图"></a>知识结构图</h3><p><img src="https://i.loli.net/2020/05/07/mN2ThOy3YQ47BdH.png" alt="image-20200507171655791"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划 Medium</title>
    <url>/2020/04/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92Medium/</url>
    <content><![CDATA[<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p>在看这个问题之前我们首先来看看如何判断回文字符串，我们很容易写出下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=s.length()-<span class="number">1</span>; i&lt;j; ++i,--j)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，回文字符串是关于一个字符或者最中心的两个字符左右对称的。</p>
<ul>
<li>当字符串中字符数为奇数时关于最中心的字符对称，例如 abcba 关于字符 c 对称。</li>
<li>当字符串中字符数为偶数时关于最中心的两个字符之间的空格对称，例如 abba 关于 bb 对称。</li>
</ul>
<p>一个字符数为 n 的字符串可以关于 n 个单字符对称，关于 n-1 个两个字符对称。我们只需遍历 2n - 1 次即可得到所有回文字符串，在遍历时记录最长回文字符串的位置即可找出最长回文子串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length()&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, end=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); ++i)&#123;</span><br><span class="line">        <span class="comment">//关于单个字符对称</span></span><br><span class="line">       <span class="keyword">int</span> len1 = expandAround(s,i,i);</span><br><span class="line">        <span class="comment">//关于中心两个字符对称</span></span><br><span class="line">       <span class="keyword">int</span> len2 = expandAround(s,i,i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//取最大长度</span></span><br><span class="line">       <span class="keyword">int</span> len = Math.max(len1,len2);</span><br><span class="line">        <span class="comment">//记录最长回文子串的起始位置</span></span><br><span class="line">       <span class="keyword">if</span>(len &gt; end-start)&#123;</span><br><span class="line">       start = i - (len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        end = i + len/<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回子串</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 求字符串 s 中，left right 开始的对称点的回文字符串长度。</span></span><br><span class="line"><span class="comment">* 当 left == right 时，关于单个字符对称，当 left + 1 == right 时关于s[left],s[right]这两个中心字* 符对称。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAround</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left &gt;=<span class="number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">        left--;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> right-left-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n^2)，空间复杂度O(1)。</p>
<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="https://i.loli.net/2020/04/27/ymcKdA4V1LXFkaP.png" alt="img"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= m, n &lt;= 100</code></p>
</li>
<li><p>题目数据保证答案小于等于 <code>2 * 10 ^ 9</code></p>
</li>
</ul>
<p>我们使用 <code>dp[i][j]</code> 来存储到达 <code>(i,j)</code> 的最多路径，由于机器人只能向下或向右，则 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code> 。对于第一行 <code>dp[0][]</code> 和第一列 <code>dp[][0]</code> 只能有一条路径到达，所以它们的值全部为 1 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] counts = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="comment">//第一行和第一列全为 1 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)counts[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)counts[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;m; j++)&#123;</span><br><span class="line">                <span class="comment">//dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line">                counts[i][j] = counts[i-<span class="number">1</span>][j] + counts[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(mn)，空间复杂度为 O(mn)。</p>
<p>优化空间复杂度 为 O(n)</p>
<p>由于只需要<code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code> ，我们只用使用一个一维数组存储上一行的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="comment">//cur[j] 为 dp[i-1][j]，cur[j-1] 为 dp[i][j-1]。</span></span><br><span class="line">                cur[j] += cur[j-<span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(mn)，空间复杂度为 O(n)。</p>
<h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></h4><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="https://i.loli.net/2020/04/27/ymcKdA4V1LXFkaP.png" alt="img"></p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>说明：</strong>m 和 <em>n</em> 的值均不超过 100。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p>此题相比 <a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a> 多了一个障碍物判断。第一行第一列中只要有一个障碍物，后面的路径数全部为 0 。如果位置 <code>(i,j)</code>  上有障碍物，则路径数直接为 0 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] counts = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="comment">//初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                counts[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                counts[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;m; j++)&#123;</span><br><span class="line">                <span class="comment">//有障碍物直接为 0 </span></span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    counts[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//dp</span></span><br><span class="line">                    counts[i][j] = counts[i-<span class="number">1</span>][j]+counts[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(mn)，空间复杂度为 O(mn)。</p>
<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a></h4><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
<p>动态转移方程为：<code>dp[i] = MIN(dp[i], dp[i - j * j] + 1)</code>，<code>i</code>表示当前数字，<code>j*j</code>表示平方数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure>
<p>使用 dp 数组来保存以当前下标为和的完全平方数的个数。依次对每个数判断是否可以使用之前的dp数组中的值加一个较大的完全平方数得到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="comment">//最坏的情况，全部由 1 相加得到</span></span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; i-j*j&gt;=<span class="number">0</span>; ++j)&#123;</span><br><span class="line">                <span class="comment">//尝试由 i-1, i-4, i-9 ...得到 i </span></span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n*sqrt(n))，空间复杂度为 O(n)。</p>
<h4 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. 摆动序列</a></h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为<strong>摆动序列。</strong>第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反, <code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong><br>你能否用 O(<em>n</em>) 时间复杂度完成此题?</p>
<p>每当我们选择一个元素作为摆动序列的一部分时，这个元素要么是上升的，要么是下降的，这取决于前一个元素的大小。</p>
<p>我们使用两个数组来 dp，up[i] 存的是目前为止的以第 i 个元素结尾的上升摆动序列的长度。</p>
<p>类似的，down[i] 存的是目前为止以第 i 个元素结尾的下降摆动序列的长度。</p>
<p>数组中的任何元素都对应下面三种可能状态中的一种：</p>
<ol>
<li>上升的位置，意味着 nums[i] &gt; nums[i - 1]</li>
<li>下降的位置，意味着 nums[i] &lt; nums[i - 1]</li>
<li>相同的位置，意味着 nums[i] == nums[i - 1]</li>
</ol>
<p>如果为情况 1 ，意味着在这里摆动上升，前一个数字肯定处于下降的位置。所以 up[i] = down[i-1]+1, down[i] = down[i-1]。</p>
<p>如果为情况 2， 意味着在这里摆动下降，前一个数字肯定处在上升的位置。所以 down[i] = up[i-1]+1, up[i] = up[i-1]。</p>
<p>如果为情况 3，up[i] = up[i-1], down[i] = down[i-1]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        up[<span class="number">0</span>] = down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="comment">//情况1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                up[i] = down[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>])&#123; <span class="comment">//情况 2</span></span><br><span class="line">                down[i] = up[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//情况 3</span></span><br><span class="line">                down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">                up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up[nums.length-<span class="number">1</span>], down[nums.length-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为 O(n)。</p>
<p>优化：我们只需要 up[i-1] 和 down[i-1] ，只需要两个变量来保存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                up = down + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                down = up + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为 O(1)。</p>
<h4 id="837-新21点"><a href="#837-新21点" class="headerlink" title="837. 新21点"></a><a href="https://leetcode-cn.com/problems/new-21-game/" target="_blank" rel="noopener">837. 新21点</a></h4><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p>
<p>爱丽丝以 <code>0</code> 分开始，并在她的得分少于 <code>K</code> 分时抽取数字。 抽取时，她从 <code>[1, W]</code> 的范围中随机获得一个整数作为分数进行累计，其中 <code>W</code> 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p>
<p>当爱丽丝获得不少于 <code>K</code> 分时，她就停止抽取数字。 爱丽丝的分数不超过 <code>N</code> 的概率是多少？</p>
<p><strong>示例</strong> <strong>1**</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：1.00000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong> <strong>2</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：0.60000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br><span class="line">在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong> <strong>3</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10</span><br><span class="line">输出：0.73278</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= K &lt;= N &lt;= 10000</code></li>
<li><code>1 &lt;= W &lt;= 10000</code></li>
<li>如果答案与正确答案的误差不超过 <code>10^-5</code>，则该答案将被视为正确答案通过。</li>
<li>此问题的判断限制时间已经减少。</li>
</ol>
<p>爱丽丝获胜的概率只和下一轮开始前的得分有关，因此根据得分计算概率。令 dp[x] 表示从得分为 x 的情况开始游戏并且获胜的概率，目标是求 dp[0] 的值。</p>
<p>根据游戏规则，当分数大于等于 K 时，游戏结束，游戏结束时，如果分数不超过 N 则获胜，分数超过 N 则失败。</p>
<p>对于示例  3 ，我们可以列出以下表格</p>
<table>
<thead>
<tr>
<th>0</th>
<th>…</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
<th>21</th>
<th>22</th>
<th>23</th>
<th>24</th>
<th>25</th>
<th>26</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td>0.5</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>抽到的最大数字为 16 + 10，当最后结果为 17 ~ 21 时获胜概率为 1 （结果小于等于 N），当最后结果为 22 ~ 26 时获胜概率为 0 （结果大于N）。</p>
<p>则 dp[16] = ( dp[16+1] + dp[16+2] + … +dp[16+10] ) / 10，结果为 0.5。</p>
<p>dp[15] = ( dp[15+1] + dp[15+2] + … +dp[15+10] ) / 10，结果为 0.55。</p>
<p>得到公式</p>
<p>dp[x] = ( dp[x+1] + dp[x+2] + … +dp[x+W] ) / 10。</p>
<p>我们可以使用两层循环来求解，但会超出时间限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化 dp 数组最后 W 个元素</span></span><br><span class="line">        <span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[K + W];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = K; i &lt;= N &amp;&amp; i &lt; K + W; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从后往前按照公式依次计算 dp 数组中的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = K - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= W; j++)&#123;</span><br><span class="line">                dp[i] += dp[i + j] / W;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 O(N+KW) ，空间复杂度 O(n)。</p>
<p>上述dp[15] 和 dp[16]公式相减得到：</p>
<p>dp[15] = dp[16] - dp[16 + 10] / 10 + dp[16] / 10;</p>
<p>更一般地得到：</p>
<p>dp[x] =dp[x+1] - dp[x+1+W] / W +dp[x+1] / W。其中 x 取值范围为 [0, K-1)。</p>
<p>只有当 x 在[N, min(K + W + 1)] 范围内时才有 dp[x] = 1,因此可以在 O(1) 时间复杂度求出 dp[K - 1]。</p>
<p>dp[k - 1] = (min(N, K + W - 1) - K + 1) / W  = ( min(N - K + 1, W) )  / W。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[K + W];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = K; i &lt;= N &amp;&amp; i &lt; K + W; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算 dp[K - 1]</span></span><br><span class="line">        dp[K - <span class="number">1</span>] = <span class="number">1.0</span> * Math.min(N - K + <span class="number">1</span>, W) / W;</span><br><span class="line">        <span class="comment">//利用公式计算 dp 数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = K - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i] = dp[i + <span class="number">1</span>] - (dp[i + W + <span class="number">1</span>] - dp[i + <span class="number">1</span>]) / W;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <em>O</em>(min(<em>N</em>,<em>K</em>+<em>W</em>))，空间复杂度 O(K+W)。</p>
<h4 id="面试题-08-11-硬币N"><a href="#面试题-08-11-硬币N" class="headerlink" title="面试题 08.11. 硬币N"></a><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币N</a></h4><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入: n &#x3D; 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure>

<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入: n &#x3D; 10</span><br><span class="line"> 输出：4</span><br><span class="line"> 解释: 有四种方式可以凑成总金额:</span><br><span class="line">10&#x3D;10</span><br><span class="line">10&#x3D;5+5</span><br><span class="line">10&#x3D;5+1+1+1+1+1</span><br><span class="line">10&#x3D;1+1+1+1+1+1+1+1+1+1</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>注意:</p>
<p>你可以假设：</p>
<ul>
<li>0 &lt;= n (总金额) &lt;= 1000000</li>
</ul>
<p>完全背包问题即不限定硬币的个数去组合硬币达到指定的值。</p>
<p>这道题为求组合成指定数额有几种情况，我们设置 dp 数组：dp[k]  为组成 k 面额的硬币情况数。</p>
<p>设置基本情况：dp[0] = 1，这里 dp[0] 的含义不是 组成 0 的硬币种类为 0，二是作为完美能被一个硬币表示的情况为 1。即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while k - coin &#x3D;&#x3D; 0 :</span><br><span class="line">	dp[k] +&#x3D; dp[k - coin];</span><br><span class="line">	&#x3D;&gt;</span><br><span class="line">	dp[k] +&#x3D; dp[0];</span><br></pre></td></tr></table></figure>

<p>我们可以得到 dp 方程 dp[k] += dp[k-coin]；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">25</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//刚好可以用一个硬币凑成的情况</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;<span class="number">4</span>; ++c)&#123;</span><br><span class="line">            <span class="keyword">int</span> coin = coins[c];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=coin; i&lt;=n; ++i)&#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - coin]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为 O(n)。</p>
<p>coins 数组中的硬币顺序必须是由大到小。</p>
<p>如果硬币由小到大，我们求6的硬币情况数时，我们观察一下流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前面5种情况数：dp[1,5] &#x3D; [1,1,1,1,2];</span><br><span class="line"></span><br><span class="line">coin &#x3D; 1:</span><br><span class="line">dp[6] +&#x3D; (dp[6 - coin] &#x3D;&gt; dp[5] &#x3D;&gt; 2);</span><br><span class="line">即拿到coin(1)的情况有两种 :</span><br><span class="line">	coin(1,1,1,1,1) + coin(1);</span><br><span class="line">	coin(5) + coin(1);</span><br><span class="line">	</span><br><span class="line">coin &#x3D; 5:</span><br><span class="line">dp[6] +&#x3D; (dp[6 - coin] &#x3D;&gt; dp[1] &#x3D;&gt; 1);</span><br><span class="line">即拿到coin（5）的情况有一种:</span><br><span class="line">	coin(1) + coin(5);</span><br><span class="line">但是事实却是6的情况只有两种，（1，1，1，1，1，1）和（1，5）。这里是把（1，5）和（5，1）前后顺序不同的情况重复算了1次。因此我们应该去考虑硬币顺序带来的影响。</span><br></pre></td></tr></table></figure>
<p>正确答案：<br>于是我们先遍历硬币，保证在考虑一枚硬币的情况时，没有较大的硬币影响，这样，我们最终每种组合情况，都是以硬币的面额大小非递减组合。保证了同样的情况，调换顺序后重复计算的情况。</p>
<p>这时候，我们求6的硬币情况数时，我们观察一下流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">coin &#x3D; 1:</span><br><span class="line">前面5种情况数：dp[1,5] &#x3D; [1,1,1,1,1];</span><br><span class="line"></span><br><span class="line">dp[6] +&#x3D; (dp[6 - coin] &#x3D;&gt; dp[5] &#x3D;&gt; 1);</span><br><span class="line">即拿到coin(1)的情况有一种 :</span><br><span class="line">	coin(1,1,1,1,1) + coin(1);</span><br><span class="line">	</span><br><span class="line">coin &#x3D; 5:</span><br><span class="line">前面5种情况数：dp[1,5] &#x3D; [1,1,1,1,2];</span><br><span class="line"></span><br><span class="line">dp[6] +&#x3D; (dp[6 - coin] &#x3D;&gt; dp[1] &#x3D;&gt; 1);</span><br><span class="line">即拿到coin（5）的情况有一种:</span><br><span class="line">	coin(1) + coin(5);</span><br><span class="line">此时，硬币组合情况，的确为正确的情况。</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://leetcode-cn.com/problems/coin-lcci/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-eddiev/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-lcci/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-eddiev/</a></p>
<h4 id="面试题46-把数字翻译成字符串"><a href="#面试题46-把数字翻译成字符串" class="headerlink" title="面试题46. 把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题46. 把数字翻译成字符串</a></h4><p>难度中等57收藏分享切换为英文关注反馈</p>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p> <strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= num &lt; 231</code></li>
</ul>
<p>将 12258 的每一位翻译为一个字母得到 “bccfi”；</p>
<p>将 12258 中的 22 翻译为 “w” ，其他的每一位翻译为一个字母得到 “bwfi”；</p>
<p>可以总结出翻译的规则，字符串的 i 位置：</p>
<ul>
<li>可以单独作为一位来翻译</li>
<li>如果第 i - 1 位和第 i 位组成的数字在 10 到 25 之间，可以把这两位连起来翻译</li>
</ul>
<p>用 f(i) 表示以第 i 位结尾的前缀串翻译的方案数，考虑每一位单独翻译和前一位连起来再翻译的贡献。单独翻译对 f(i) 的贡献为 f(i - 1)；如果第 i - 1 位存在，第 i - 1位和第 i 位连起来的数字 x 满足 10 &lt;= x &lt;= 25，那么可以连起来翻译，对 f(i) 的贡献为 f(i - 2)，否则为 0。</p>
<p>我们可以列出下面的动态规划转移方程：</p>
<p>f(i) = f(i - 1) + f(i - 2) ( i - 1 &gt;= 0，10 &lt;= x &lt;= 25)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String src = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.length(); i++)&#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String pre = src.substring(i - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(pre.compareTo(<span class="string">"25"</span>) &lt;= <span class="number">0</span> &amp;&amp; pre.compareTo(<span class="string">"10"</span>) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                r += p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(log n)，空间复杂度O(logn)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>微机原理复习</title>
    <url>/2020/05/09/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="计算机工作原理"><a href="#计算机工作原理" class="headerlink" title="计算机工作原理"></a>计算机工作原理</h3><p>冯诺依曼计算机体系结构：输入设备、输出设备、存储器、运算器和控制器。</p>
<h3 id="8086"><a href="#8086" class="headerlink" title="8086"></a>8086</h3><p>共 20 根地址线，16根数据线。地址线 20 根代表可寻址的空间为 1MB，数据线为 16 根代表处理器字长为 16位。</p>
<h4 id="地址线和数据线"><a href="#地址线和数据线" class="headerlink" title="地址线和数据线"></a>地址线和数据线</h4><ul>
<li>AD0 — AD7 低 8 位地址和低 8 位数据信号分时复用，传递地址信号位单向，传送数据信号时为双向。</li>
<li>A16 — A19 高 4 位地址信号，与状态信号分时复用。</li>
<li>A8 — A15  8 位地址信号。</li>
</ul>
<h4 id="控制信号和状态信号"><a href="#控制信号和状态信号" class="headerlink" title="控制信号和状态信号"></a>控制信号和状态信号</h4><p><img src="https://i.loli.net/2020/05/09/SEzlOaAqhcmHfRM.png" alt="image-20200509141827458"></p>
<h4 id="内部寄存器"><a href="#内部寄存器" class="headerlink" title="内部寄存器"></a>内部寄存器</h4><p>含 14 个 16 位寄存器，按功能可分为三类：8 个通用寄存器、4 个段寄存器和 2 个控制寄存器。</p>
<h5 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h5><ul>
<li><p>数据寄存器：AX、BX、CX、DX。</p>
</li>
<li><p>地址指针寄存器：SP、BP。</p>
</li>
<li><p>变址寄存器：SI、DI。</p>
</li>
</ul>
<p>AX：累加器。所有 I/O 指令都通过 AX 与接口传送信息，中间运算结果也多放于 AX 中。</p>
<p>BX：基址寄存器。在间接寻址中用于存放基地址。</p>
<p>CX：计数寄存器。用于在循环或串操作指令中存放计数值。</p>
<p>DX：数据寄存器。在间接寻址的 I/O 指令中存放 I/O 端口地址，在 32 位乘除法运算时，存放高 16 位数。</p>
<p>SP：堆栈指针寄存器，其内容为栈顶的偏移地址。</p>
<p>BP：基址指针寄存器，常用于在访问内存时存放内存单元的偏移地址。</p>
<p>BX 用于数据段，BP 用于堆栈段。</p>
<p>SI：源变址寄存器</p>
<p>DI：目标变址寄存器</p>
<h5 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h5><ul>
<li>CF 进位标志位；</li>
<li>PF 奇偶标志位；</li>
<li>AF 辅助进位位；</li>
<li>ZF 零标志位，当运算结果为零时置 1 ；</li>
<li>SF 符号标志位，运算结果最高位为 1 时，SF = 1；</li>
<li>OF 溢出标志位。</li>
<li></li>
</ul>
<h5 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h5><ul>
<li>CS 代码段寄存器，存放代码段的段基地址。</li>
<li>DS 数据段寄存器，存放数据段的段基地址。</li>
<li>ES 附加段寄存器，存放数据段的段基地址。</li>
<li>SS 堆栈段寄存器，存放堆栈段的段基地址。</li>
</ul>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><p>例如 MOV AX，1200H。仅适合于源操作数。</p>
<h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>例如 MOV AX，BX。参加操作的操作数在 CPU 的通用寄存器中。</p>
<h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>例如 MOV AX，[1200H]。指令中直接给出操作数的偏移地址。</p>
<h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>例如 MOV AX，[BX]。参加操作的操作数放在内存中，其偏移地址为指令中寄存器的内容。</p>
<p>存放偏移地址的寄存器称为间址寄存器，它们分别是 BX，BP，SI，DI。</p>
<p>操作数的段地址取决于选择哪一个间址寄存器。当选择 BX，SI，DI 时默认在数据段。当选择 BP 时默认在堆栈段。</p>
<h4 id="寄存器相对寻址"><a href="#寄存器相对寻址" class="headerlink" title="寄存器相对寻址"></a>寄存器相对寻址</h4><p>例如 MOV AX，[BX+DATA]。操作数的偏移地址为寄存器的内容加上一个位移量。</p>
<p>基址寄存器为 BX 时默认在数据段；基址寄存器为 BP 时，默认在堆栈段。</p>
<h4 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h4><p>例如 MOV AX，[BP+DI+DATA]。操作数的偏移地址为基址寄存器内容+变址寄存器内容+位移量。操作数的段地址由选择的基址寄存器决定。</p>
<h3 id="8086-指令系统"><a href="#8086-指令系统" class="headerlink" title="8086 指令系统"></a>8086 指令系统</h3><p>从功能上包括六大类：</p>
<p>数据传送、算术运算、逻辑运算和移位、串操作、程序控制和处理器控制。</p>
<h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><p>包括通用数据传送、输入输出、地址传送和标志位操作。</p>
<h5 id="通用数据传送"><a href="#通用数据传送" class="headerlink" title="通用数据传送"></a>通用数据传送</h5><p><strong>该类指令的执行对标志位不产生影响。</strong></p>
<p>mov 指令</p>
<p>MOV dest,   src</p>
<p>两操作数 字长必须相同，两操作数<strong>不允许同时为存储器操作数</strong>、不允许同时为段寄存器，在源操作数是立即数时，目标操作数不能是段寄存器。</p>
<p>入栈/出栈指令</p>
<p>PUSH oprd </p>
<p>POP oprd</p>
<p>oprd 为 16 位寄存器或存储器两单元，不能为立即数。</p>
<p>交换指令</p>
<p>XCHG REG, MEM/REG</p>
<p>两个操作数必须有一个是寄存器操作数，不允许使用段寄存器。</p>
<p>查表指令</p>
<p>XLAT</p>
<p>用 BX 的内容代表表格首地址，AL 内容为表内位移量，BX+AL得到要查找元素的偏移地址。将 BX+AL 所指单元的内容送 AL。</p>
<h5 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h5><p>输入指令：IN acc，PORT</p>
<p>输出指令：OUT PORT，acc</p>
<p>根据端口地址码的长度，指令有两种不同的端口地址表现形式。</p>
<ul>
<li>直接寻址。端口地址为 8 位时，指令中直接给出 8 位端口地址，寻址 256 个端口。</li>
<li>间接寻址。端口地址为 16 位时，指令中的端口地址必须由 DX 指定；可寻址 64K 个端口。</li>
</ul>
<h5 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h5><p>取偏移地址指令 LEA。计算 MEM 相对于 REG 的偏移地址。</p>
<p>LEA REG,   MEM</p>
<p>将变量的 16 位偏移地址取出送目标寄存器。源操作数必须是一个存储器操作数，目标操作数通常是间址寄存器。</p>
<h4 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h4><p>算术运算指令的执行大多对状态标志位会产生影响。</p>
<h5 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h5><p>普通加法指令 </p>
<p>ADD oprd1,oprd2 </p>
<p>oprd1 = oprd1 + oprd2</p>
<p>带进位的加法指令 </p>
<p>ADC oprd1,oprd2 </p>
<p>oprd1 = oprd1+oprd2+CF</p>
<p>自增指令</p>
<p>INC oprd</p>
<p>oprd += 1</p>
<h5 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h5><p>普通减法指令</p>
<p>SUB oprd1, oprd2</p>
<p>oprd1 = oprd1 - oprd2</p>
<p>考虑借位的减法指令</p>
<p>SBB oprd1, oprd2</p>
<p>oprd1 = oprd1 - oprd2 - CF</p>
<p>自减指令</p>
<p>DEC oprd</p>
<p>oprd -= 1</p>
<p>取反指令</p>
<p>NEG oprd</p>
<p>oprd = 0-oprd</p>
<p>比较指令</p>
<p>CMP oprd1, oprd2</p>
<p>oprd1 - oprd2</p>
<p><strong>影响标志位</strong> 如果 oprd1 &gt; oprd2 则 CF = 0 </p>
<h5 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h5><p>无符号乘法指令 MUL</p>
<p>MUL oprd</p>
<p>oprd 为字节数   AX = AL * oprd</p>
<p>oprd 为 16 位数 DX AX = AX * oprd</p>
<h5 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h5><p>DIV oprd</p>
<p>若 oprd 是字节数 执行 AL / oprd。结果 AL 为商， AH 为余数</p>
<p>若 oprd 是双字节数执行 DX AX / oprd。结果 AX 为商，DX 为余数。</p>
<h4 id="逻辑运算和移位指令"><a href="#逻辑运算和移位指令" class="headerlink" title="逻辑运算和移位指令"></a>逻辑运算和移位指令</h4><h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p>AND oprd1, oprd2</p>
<p>OR oprd1, oprd2</p>
<p>NOT oprd 操作数按位取反再送回原地址，操作数不能为立即数，指令的执行对标志位无影响。</p>
<p>XOR oprd1, oprd2 两操作数异或，结果送目标地址</p>
<p>TEST oprd1, oprd2 将执行 “与” 操作，但运算的结果不送回目标地址。</p>
<h5 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h5><p>逻辑左移 SHL 、逻辑右移 SHR：将移动的位补 0 ，移除的位到 CF。</p>
<p>算术左移SAL、算术右移SAR：符号位不动，移动的位补 0 ，移除的位到 CF 。</p>
<p>不带进位循环左移ROL、不带进位循环右移ROR：将移除的位同时加到 CF 和被移动的位。</p>
<p>带进位循环左移 RCL、带进位循环右移 RCR：CF 参与循环移位，向左循环移位则 CF 在最左边（向右循环则 CF 在最右边）。</p>
<h4 id="程序控制指令"><a href="#程序控制指令" class="headerlink" title="程序控制指令"></a>程序控制指令</h4><h5 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h5><p>无条件转移指令 JMP oprd 。oprd 是 16 位偏移地址。</p>
<p>条件转移指令</p>
<p>JC/JNC、JZ/JNZ、JO/JNO、JP/JPE分别判断 CF、ZF、OF、PF 是否为 1 /为 0 。</p>
<h5 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h5><p>LOOP 循环次数由 CX 决定。用法 LOOP Label</p>
<h5 id="过程调用和返回"><a href="#过程调用和返回" class="headerlink" title="过程调用和返回"></a>过程调用和返回</h5><p>调用 CALL PROC</p>
<p>返回 RET，一般位于子程序的最后</p>
]]></content>
      <categories>
        <category>复试</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>利用线结构光测距</title>
    <url>/2020/04/04/%E5%88%A9%E7%94%A8%E7%BA%BF%E7%BB%93%E6%9E%84%E5%85%89%E8%BF%9B%E8%A1%8C%E4%B8%89%E7%BB%B4%E9%87%8D%E6%9E%84%EF%BC%88%E6%B5%8B%E8%B7%9D%EF%BC%89/</url>
    <content><![CDATA[<h1 id="利用线结构光测距"><a href="#利用线结构光测距" class="headerlink" title="利用线结构光测距"></a>利用线结构光测距</h1><p>通过线激光器扫描物体，同时用摄像机对其拍照得到带有结构光的图片，提取结构光上的点的三维坐标，激光器扫描整个物体就可求出所有点的三维坐标实现物体表面的三维重构，即可测量物体表面任意两点距离。</p>
<p>准备知识：</p>
<h6 id="四个坐标系的转换"><a href="#四个坐标系的转换" class="headerlink" title="四个坐标系的转换"></a><strong>四个坐标系的转换</strong></h6><p> <img src="https://i.loli.net/2020/04/04/p89aGLJcBtxC2Ue.png" alt="img"></p>
<p>世界坐标系–摄像机坐标系</p>
<p>将摄像机光心定位摄像机坐标原点Oc，摄像机的光轴定位摄像机坐标系的Zc轴，Xc轴，Yc轴分别与图像坐标系的x轴y轴平行。</p>
<p> <img src="https://i.loli.net/2020/04/04/P2C6DvWYxsRJT5V.png" alt="img"></p>
<p>R为3阶正交单位矩阵，t为平移向量，均为相机外参数</p>
<p>物理坐标系–像素坐标系</p>
<p>图像的x，y轴分别和像素的u，v轴平行</p>
<p> u=x/dx+u0, v=y/dy+v0</p>
<p><img src="https://i.loli.net/2020/04/04/Ilu6D3qhcsMX4UO.png" alt="img"></p>
<p> <img src="https://i.loli.net/2020/04/04/VlbA4hwG7qt2ROo.png" alt="img"></p>
<p>物理坐标系–摄像机坐标系</p>
<p> <img src="https://i.loli.net/2020/04/04/mgvBA8ErOCYePVJ.png" alt="img"></p>
<p>像素坐标系–世界坐标系</p>
<p>fx，fy，u0，v0为摄像机内部参数，R，t，为外部参数</p>
<p> <img src="https://i.loli.net/2020/04/04/TiGvFomXtY936S5.png" alt="img"></p>
<h6 id="系统测量模型"><a href="#系统测量模型" class="headerlink" title="系统测量模型"></a><strong>系统测量模型</strong></h6><p> <img src="https://i.loli.net/2020/04/04/HVvfTClZKQSAtcG.png" alt="img"></p>
<p>P点既在OP’直线上又在光平面上（由结构光投射器与物体表面结构光构成的平面），摄像机和结构光投射器相对位置不变，光平面方程不变，设摄像机下光平面方程为</p>
<p> <img src="https://i.loli.net/2020/04/04/45ZKk7HxFvrwQPf.png" alt="img"></p>
<p>设点P’在摄像机坐标系下的图像坐标（x，y，1）P点坐标为（Xc，Yc，Zc）则直线OcP直线方程为</p>
<p> <img src="https://i.loli.net/2020/04/04/R2ev3rwy9G1KZIO.png" alt="img"></p>
<p>联立可得</p>
<p> <img src="https://i.loli.net/2020/04/04/CIZWnvPmlJoe4kb.png" alt="img"></p>
<p>求空间点在摄像机坐标系下的空间三维坐标需要光平面方程，P’点的图像坐标，求解P’的坐标需要摄像机内参数，所以需要摄像机标定和光平面标定。</p>
<h6 id="系统实现方案"><a href="#系统实现方案" class="headerlink" title="系统实现方案"></a><strong>系统实现方案</strong></h6><p>固定摄像机和激光器，移动器棋盘格拍摄带有结构光和不带结构光的图片，需要不同角度拍摄。</p>
<p>通过harris角点提取图片中角点像素坐标</p>
<p>运用张正友标定思想完成相机标定</p>
<p>提取线结构光方程，与图像角点直线方程结合，求角点直线和结构光的交点坐标</p>
<p>通过角点的像素坐标和角点与结构光的交点坐标运用交比不变性得到结构光上一系列交点的摄像机坐标，通过最小二乘拟合得到摄像机坐标系下的光平面方程</p>
<p>运用光平面方程，可得到结构光上任意一点的相机坐标</p>
<h6 id="相机标定和光平面实现"><a href="#相机标定和光平面实现" class="headerlink" title="相机标定和光平面实现"></a><strong>相机标定和光平面实现</strong></h6><p>Qt+openCV</p>
<p>cameraCalibrate函数原型</p>
<p>calibrateCamera(InputArrayOfArrays objectPoints,</p>
<p>InputArrayOfArrays imagePoints,</p>
<p> Size imageSize,</p>
<p>InputOutputArray cameraMatrix,</p>
<p>InputOutputArray distCoeffs,</p>
<p> OutputArrayOfArrays rvecs,</p>
<p> OutputArrayOfArrays tvecs,</p>
<p> int flags=0 );</p>
<p>参数 ：</p>
<p>objectPoints  初始化世界坐标系的所有角点的三维坐标点</p>
<p>应输入  vector&lt;vector<Point3f>&gt; objectPoints</p>
<p> imagePoints 与其对应的像素坐标系的所有角点的二维坐标点</p>
<p>应输入 vector&lt; vector&lt; Point2f&gt;&gt; imagePoints</p>
<p> imageSize   图像大小</p>
<p>   cameraMatrix  相机内参数矩阵  </p>
<p> 输入一个cv::Mat cameraMatrix即可。</p>
<p>​     distCoeffs  为畸变矩阵。输入一个cv::Mat distCoeffs即可</p>
<p>rvecs  为旋转向量 应输入一个vector<a href="cv::Mat">cv::Mat</a></p>
<p>tvecs  为平移向量 应输入一个vector<a href="cv::Mat">cv::Mat</a></p>
<p>​     flags为标定是所采用的算法。可如下某个或者某几个参数：</p>
<p>CV_CALIB_USE_INTRINSIC_GUESS：使用该参数时，在cameraMatrix矩阵中应该有fx,fy,cx,cy的估计值。否则的话，将初始化(cx,cy）图像的中心点，使用最小二乘估算出fx，fy。如果内参数矩阵和畸变居中已知的时候，应该标定模块中的solvePnP()函数计算外参数矩阵。</p>
<p>CV_CALIB_FIX_PRINCIPAL_POINT：在进行优化时会固定光轴点。当CV_CALIB_USE_INTRINSIC_GUESS参数被设置，光轴点将保持在中心或者某个输入的值。</p>
<p>CV_CALIB_FIX_ASPECT_RATIO：固定fx/fy的比值，只将fy作为可变量，进行优化计算。当CV_CALIB_USE_INTRINSIC_GUESS没有被设置，fx和fy将会被忽略。只有fx/fy的比值在计算中会被用到。</p>
<p>CV_CALIB_ZERO_TANGENT_DIST：设定切向畸变参数（p1,p2）为零。</p>
<p>CV_CALIB_FIX_K1,…,CV_CALIB_FIX_K6：对应的径向畸变在优化中保持不变。如果设置了CV_CALIB_USE_INTRINSIC_GUESS参数，</p>
<p>CV_CALIB_RATIONAL_MODEL：计算k4，k5，k6三个畸变参数。如果没有设置，则只计算其它5个畸变参数。</p>
<p>摄像机标定需要角点的世界坐标棋盘格表面为x-y轴，所以棋盘格角点z坐标全为0，已知两角点的实际距离就可求出所有角点的世界坐标</p>
<p>摄像机标定还需角点的像素坐标</p>
<p>利用openCV库函数findChessboardCorners()可以提取到。</p>
<p>带入这两个参数到cameraCalibrate函数即可求出相机内参数和每幅图对应的外参数</p>
<h6 id="光平面标定"><a href="#光平面标定" class="headerlink" title="光平面标定"></a><strong>光平面标定</strong></h6><p>1、提取线结构光中心线方程，结构光处像素值为255利用二值化原理提取只含结构光的图像，利用goodFeaturesToTrack()取得结构光上的点，将这些点代入fitline()，拟合得到线结构光方程。</p>
<p>2、拟合角点直线方程，结合线结构光中心线方程，求两直线交点可得一系列光条上的点的像素坐标。</p>
<p>3、通过角点世界坐标，结合相机所求每一幅图的相机外参数，求出每幅图的角点摄像机坐标</p>
<p>4、通过摄像机内参数，将角点图像坐标转换为角点物理坐标</p>
<p> <img src="https://i.loli.net/2020/04/04/C72pjYhcAKlILbJ.png" alt="img"></p>
<p>5、已知A B C 角点 D 为角点直线与结构光角点直线的交点，A’ B ‘ C’ D’为成像点,</p>
<p>  已知A’ B ‘ C’ D’四点物理坐标或像素坐标，A B C三点相机坐标可求出D的相机坐标。</p>
<p> <img src="https://i.loli.net/2020/04/04/FOMiBtnzeWGHqT6.png" alt="img"></p>
<p>6、对于多幅图求出物体表面结构光与角点直线的交点坐标运用最小二乘拟合得到光平面方程</p>
<h6 id="运用光平面方程求距离"><a href="#运用光平面方程求距离" class="headerlink" title="运用光平面方程求距离"></a><strong>运用光平面方程求距离</strong></h6><p>鼠标点击结构光上任意两点获取两点的像素坐标通过公式</p>
<p> <img src="https://i.loli.net/2020/04/04/SegV9TcBWxjmXoP.png" alt="img"></p>
<p>其中1/dx=fx，1/dy=fy，fx，fy均为摄像机内参数</p>
<p>然后物理坐标转为摄像机坐标</p>
<p> <img src="https://i.loli.net/2020/04/04/NQ5HjtidSL7exXu.png" alt="img"></p>
<p>运用两点间距离公式可求出结构光上两点实际距离。</p>
<p> <img src="https://i.loli.net/2020/04/04/AbThzSE4KXNVe8M.png" alt="img"></p>
<p>附：</p>
<p>最小二乘拟合平面</p>
<p>CvMat*points_mat = cvCreateMat(X_vector.size(), 3, CV_32FC1);</p>
<p>//定义用来存储需要拟合点的矩阵大小N*3； </p>
<p>for (int i=0;i &lt; X_vector.size(); ++i)</p>
<p>{</p>
<p>points_mat-&gt;data.fl[i*3+0] = X_vector[i];</p>
<p>//矩阵的值进行初始化  X的坐标值</p>
<p>points_mat-&gt;data.fl[i * 3 + 1] = Y_vector[i];</p>
<p>// Y的坐标值</p>
<p>points_mat-&gt;data.fl[i * 3 + 2] = Z_vector[i];</p>
<p>//<span style="font-family: Arial, Helvetica, sans-serif;"></p>
<p>// Z的坐标值</span></p>
<p>}</p>
<p>float plane12[4] = { 0 };//定义用来储存平面参数的数组 </p>
<p>cvFitPlane(points_mat, plane12);//调用方程 </p>
<p>​    </p>
<p>// 其中 Plane12[4]   数组中对应ABCD；</p>
<p> //Ax+by+cz=D</p>
<p>​    void cvFitPlane(const CvMat* points, float* plane){</p>
<p>​      // Estimate geometric centroid.</p>
<p>​      int nrows = points-&gt;rows;</p>
<p>​      int ncols = points-&gt;cols;</p>
<p>​      int type = points-&gt;type;</p>
<p>​      CvMat* centroid = cvCreateMat(1, ncols, type);</p>
<p>​      cvSet(centroid, cvScalar(0));</p>
<p>​      for (int c = 0; c&lt;ncols; c++){</p>
<p>​        for (int r = 0; r &lt; nrows; r++)</p>
<p>​        {</p>
<p>​        centroid-&gt;data.fl[c] += points-&gt;data.fl[ncols*r + c];</p>
<p>​        }</p>
<p>​        centroid-&gt;data.fl[c] /= nrows;</p>
<p>​      }</p>
<p>​      // Subtract geometric centroid from each point.</p>
<p>​      CvMat* points2 = cvCreateMat(nrows, ncols, type);</p>
<p>​      for (int r = 0; r&lt;nrows; r++)</p>
<p>​        for (int c = 0; c&lt;ncols; c++)</p>
<p>​          points2-&gt;data.fl[ncols<em>r + c] = points-&gt;data.fl[ncols</em>r + c] - centroid-&gt;data.fl[c];</p>
<p>​      // Evaluate SVD of covariance matrix.</p>
<p>​      CvMat* A = cvCreateMat(ncols, ncols, type);</p>
<p>​      CvMat* W = cvCreateMat(ncols, ncols, type);</p>
<p>​      CvMat* V = cvCreateMat(ncols, ncols, type);</p>
<p>​      cvGEMM(points2, points, 1, NULL, 0, A, CV_GEMM_A_T);</p>
<p>​      cvSVD(A, W, NULL, V, CV_SVD_V_T);</p>
<p>​      // Assign plane coefficients by singular vector corresponding to smallest singular value.</p>
<p>​      plane[ncols] = 0;</p>
<p>​      for (int c = 0; c&lt;ncols; c++){</p>
<p>​        plane[c] = V-&gt;data.fl[ncols*(ncols - 1) + c];</p>
<p>​        plane[ncols] += plane[c] * centroid-&gt;data.fl[c];</p>
<p>​      }</p>
<p>​      // Release allocated resources.</p>
<p>​      //cvReleaseMat(¢roid);</p>
<p>​      cvReleaseMat(&amp;points2);</p>
<p>​      cvReleaseMat(&amp;A);</p>
<p>​      cvReleaseMat(&amp;W);</p>
<p>​      cvReleaseMat(&amp;V);</p>
<p>​    }</p>
<p>最小二乘拟合线：</p>
<p>函数原型如下：</p>
<p>void fitLine( InputArray points,</p>
<p>  OutputArray line,</p>
<p>  int distType,</p>
<p>  double param,</p>
<p>  double reps,</p>
<p>double aeps );</p>
<p>distType 指定拟合函数的类型，可以取 CV_DIST_L2</p>
<p>param 就是 CV_DIST_FAIR、CV_DIST_WELSCH、CV_DIST_HUBER 公式中的C。如果取 0，则程序自动选取合适的值。</p>
<p>reps 表示直线到原点距离的精度，建议取 0.01。<br>aeps 表示直线角度的精度，建议取 0.01。</p>
<p>计算出的直线信息存放在 line 中，为 cv::Vec4f 类型。line[0]、line[1] 存放的是直线的方向向量。line[2]、line[3] 存放的是直线上一个点的坐标。</p>
<p>如果直线用 y=kx+by=kx+b 来表示，那么 k = line[1]/line[0]，b = line[3] - k * line[2]</p>
<p>附部分源码</p>
<p>其中部分为ui设计和对特定图片写的去结构光的算法不可生搬硬套！</p>
<p>#ifndef MAINWINDOW_H</p>
<p>#define MAINWINDOW_H</p>
<p>#include <QMainWindow></p>
<p>#include <iostream></p>
<p>#include <fstream></p>
<p>#include<QFileDialog></p>
<p>#include<QString></p>
<p>#include<QImage></p>
<p>#include<QPixmap></p>
<p>#include <QWidget></p>
<p>#include<QMouseEvent></p>
<p>#include<QEvent></p>
<p>#include<QDebug></p>
<p>#include<QMessageBox></p>
<p>#include “opencv2/core/core.hpp”</p>
<p>#include “opencv2/imgproc/imgproc.hpp”</p>
<p>#include “opencv2/calib3d/calib3d.hpp”</p>
<p>#include “opencv2/highgui/highgui.hpp”</p>
<p>#include &lt;opencv2\imgproc\types_c.h&gt;</p>
<p>using namespace cv;</p>
<p>using namespace std;</p>
<p>#define IMGCOUNT 14</p>
<p>namespace Ui {</p>
<p>class MainWindow;</p>
<p>}</p>
<p>class MainWindow : public QMainWindow</p>
<p>{</p>
<p>  Q_OBJECT</p>
<p>public:</p>
<p>  explicit MainWindow(QWidget *parent = 0);</p>
<p>  ~<strong><em>MainWindow\</em></strong>();</p>
<p>private slots:</p>
<p>  void <strong>cameraCalibrate</strong>();//无结构光摄像机标定</p>
<p>  void <strong>squareCalibrate</strong>();//有结构光摄像机标定和光平面标定</p>
<p>  Point2f <strong>getcrosspoint</strong>(Vec4f lineA,Vec4f lineB);//找出两条直线的交点</p>
<p>  void <strong>GetCrossPointAll</strong>();//找出所有图片的结构光交点</p>
<p>  void <strong>calMatrix_M</strong>();//计算世界坐标系与摄像机坐标系的关系矩阵M</p>
<p>  void <strong>calCameraCornerPoints</strong>();//计算摄像机坐标系下的角点坐标</p>
<p>  void <strong>calCameraCrossPoints</strong>();//计算摄像机坐标下的结构光交点坐标</p>
<p>  void <strong>calCornersInCamera</strong>(Point2f A,Point2f B,Point2f C,Point2f D,Mat A_,Mat B_,Mat C_);</p>
<p>  void <strong>fitting_light_surface</strong>();</p>
<p>  void <strong>cvFitPlane</strong>(const CvMat* points, float* plane);</p>
<p>  void <strong>calDistance</strong>();</p>
<p>  void <strong>pushbutton1</strong>();</p>
<p>public slots:</p>
<p>  void <strong>open</strong>();</p>
<p>protected:</p>
<p>  void <strong><em>mousePressEvent\</em></strong>(QMouseEvent *m);//重载mousePressEvent函数</p>
<p>private:</p>
<p>  double zoom=1;</p>
<p>  vector<Point2f> mousePoint;</p>
<p>  QString path;</p>
<p>private:</p>
<p>  Ui::MainWindow *ui;</p>
<p>  int imageCount;</p>
<p>  string file;</p>
<p>  Size image_size;//图像的尺寸</p>
<p>  Size board_size;   //标定板上每列，行的角点数7 size.width 代表列数 size.height 代表 行数</p>
<p>  vector<Point2f> image_points_buf; //缓存每幅图像上检测到的角点</p>
<p>  vector&lt;vector<Point3f>&gt; object_points; //保存标定板上角点的三维坐标,为标定函数的第一个参数</p>
<p>  vector&lt;vector<Point2f>&gt; image_points_seq; //保存检测到的所有角点</p>
<p>  Size square_size;//实际测量得到的标定板上每个棋盘格的大小，这里其实没测，就假定了一个值，</p>
<p>  Mat cameraMatrix;//摄像机内参数</p>
<p>  Mat distCoeffs;//畸变系数</p>
<p>  vector<Mat> tvecsMat;//每幅图像的旋转向量</p>
<p>  vector<Mat> R_matrix;//每幅图的旋转矩阵</p>
<p>  vector<Mat> rvecsMat;//每幅图像的平移向量</p>
<p>  vector<Point2f>corners;//结构光上的点</p>
<p>  Vec4f line_para; //输出的直线</p>
<p>  vector<Mat> M;//摄像机坐标 世界坐标 转换系数</p>
<p>  vector&lt;vector<Mat>&gt;corners_in_camera;//角点在相机坐标系下的坐标</p>
<p>  vector&lt;vector<Point2f>&gt;crossPointAll;//所有图像的结构光与角点直线的坐标</p>
<p>  //拟合点的三维坐标</p>
<p>  vector<double>X_vector;</p>
<p>  vector<double>Y_vector;</p>
<p>  vector<double>Z_vector;</p>
<p>  float plane12[4] = { 0 };//定义用来储存平面参数的数组</p>
<p>};</p>
<p>#endif // MAINWINDOW_H</p>
<p>#include “mainwindow.h”</p>
<p>#include “ui_mainwindow.h”</p>
<p>MainWindow::<strong>MainWindow</strong>(QWidget *parent) :</p>
<p>  QMainWindow(parent),</p>
<p>  ui(new Ui::MainWindow)</p>
<p>{</p>
<p>  ui-&gt;setupUi(this);</p>
<p>   connect(ui-&gt;actioncalibrateCamera,SIGNAL(triggered()),this,SLOT(cameraCalibrate()));</p>
<p>   connect(ui-&gt;pushButton,SIGNAL(clicked()),this,SLOT(pushbutton1()));</p>
<p>   connect(ui-&gt;pushButton_2,SIGNAL(clicked()),this,SLOT(open()));</p>
<p>   ui-&gt;rows-&gt;setValue(7);ui-&gt;cols-&gt;setValue(7);</p>
<p>   ui-&gt;filename-&gt;setText(“D:\QT projects\PIC\struct_image_copy”);</p>
<p>   ui-&gt;dis-&gt;setValue(10);</p>
<p>   ui-&gt;pic-&gt;setValue(11);</p>
<p>}</p>
<p>MainWindow::~<strong><em>MainWindow\</em></strong>()</p>
<p>{</p>
<p>  delete ui;</p>
<p>}</p>
<p>void MainWindow::<strong>cameraCalibrate</strong>()</p>
<p>{</p>
<p>​      board_size.width=ui-&gt;cols-&gt;value();board_size.height=ui-&gt;rows-&gt;value();</p>
<p>​      QString f=”D:\QT projects\PIC\cal_image_copy”;</p>
<p>​      for (int image_num = 1; image_num &lt;= IMGCOUNT; image_num++)</p>
<p>​      {</p>
<p>​        QString n(“\%1.bmp”);n=n.arg(image_num);</p>
<p>​        QString m=f+n;</p>
<p>​        string file=string((const char *)m.toLocal8Bit());</p>
<p>​        Mat imageInput = imread(file);</p>
<p>​        if (!findChessboardCorners(imageInput, board_size, image_points_buf))</p>
<p>​           {</p>
<p>​             cout &lt;&lt; “can not find chessboard corners!\n”;//找不到角点</p>
<p>​             return;</p>
<p>​           }</p>
<p>​           else</p>
<p>​           {</p>
<p>​             Mat view_gray;//灰度图</p>
<p>​             cvtColor(imageInput, view_gray, CV_RGB2GRAY);</p>
<p>​             /<em>亚像素精确化</em>/</p>
<p>​             find4QuadCornerSubpix(view_gray, image_points_buf, Size(5, 5));//对粗提取的角点进行精确化</p>
<p>​             drawChessboardCorners(view_gray, board_size, image_points_buf, true);//用于在图片中标记角点</p>
<p>​             image_points_seq.push_back(image_points_buf);//保存亚像素角点</p>
<p>​             imshow(“Camera Calibration”, view_gray);//显示图片</p>
<p>​             waitKey(500);//停半秒</p>
<p>​           }</p>
<p>​           image_size.width = imageInput.cols;</p>
<p>​           image_size.height = imageInput.rows;</p>
<p>​           imageInput.release();</p>
<p>​      }</p>
<p>/<em>相机标定</em>/</p>
<p>​           for (int t = 0; t&lt;IMGCOUNT; t++)</p>
<p>​             {</p>
<p>​                 vector<Point3f> tempPointSet; //世界坐标点</p>
<p>​               for (int i = 0; i&lt;board_size.width; i++)//每列 size.width代表图像的宽度 即列数</p>
<p>​               {</p>
<p>​                 for (int j = 0; j&lt;board_size.height; j++)//每行</p>
<p>​                 {</p>
<p>​                   Point3f realPoint;</p>
<p>​                   //假设标定板放在世界坐标系中z=0的平面上</p>
<p>​                   realPoint.x = j*square_size.width;</p>
<p>​                   realPoint.y = i*square_size.height;</p>
<p>​                   realPoint.z = 0;</p>
<p>​                   tempPointSet.push_back(realPoint);</p>
<p>​                 }</p>
<p>​               }</p>
<p>​               object_points.push_back(tempPointSet);</p>
<p>​             }</p>
<p>​           //内外参数对象</p>
<p>​             cameraMatrix = Mat(3, 3,CV_32FC1, Scalar::all(0));//摄像机内参数矩阵</p>
<p>​            // vector<int> point_counts;// 每幅图像中角点的数量</p>
<p>​             distCoeffs = Mat(1, 5, CV_64F, Scalar::all(0));//摄像机的5个畸变系数：k1,k2,p1,p2,k3</p>
<p>​             calibrateCamera(object_points, image_points_seq, image_size, cameraMatrix, distCoeffs, rvecsMat, tvecsMat, 0);//相机标定</p>
<p>/<em>保存内外参数</em>/</p>
<p>​               ofstream fout(“caliberation_result.txt”);//保存标定结果的文件</p>
<p>​               fout &lt;&lt; “相机内参数矩阵：” &lt;&lt; endl;</p>
<p>​               fout &lt;&lt; cameraMatrix &lt;&lt; endl &lt;&lt; endl;</p>
<p>​               fout &lt;&lt; “畸变系数：\n”;</p>
<p>​               fout &lt;&lt; distCoeffs &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;</p>
<p>​               waitKey(0);//停半秒</p>
<p>}</p>
<p>void MainWindow::<strong>squareCalibrate</strong>()</p>
<p>{</p>
<p>  object_points.clear();image_points_seq.clear();</p>
<p> for (int image_num = 1; image_num &lt;= imageCount; image_num++)</p>
<p> {</p>
<p>   QString n(“\%1.bmp”);n=n.arg(image_num);</p>
<p>   QString m=path+n;</p>
<p>​    file=string((const char *)m.toLocal8Bit());</p>
<p>   //sprintf(filenames, “D:\QT projects\PIC\struct_image_copy\%d.bmp”, image_num);</p>
<p>​    Mat origin_image = imread(file);</p>
<p>​      Mat grey_image;</p>
<p>​      cvtColor(origin_image, grey_image, CV_RGB2GRAY);</p>
<p>​      CV_Assert(grey_image.depth() != sizeof(uchar));</p>
<p>​      int row=grey_image.rows;</p>
<p>​      int col=grey_image.cols;</p>
<p>​      uchar*p;</p>
<p>/<em>阶段去除高亮部分</em>/</p>
<p>​      for(int i=0;i&lt;row;i++)</p>
<p>​      {</p>
<p>​        p=grey_image.ptr<uchar>(i);</p>
<p>​        for(int j=0;j&lt;col;j++)</p>
<p>​        {</p>
<p>​          if(p[j]&gt;250)p[j]-=100;</p>
<p>​          if(p[j]&gt;220)p[j]-=70;</p>
<p>​          if(p[j]&gt;190)p[j]-=30;</p>
<p>​          if(p[j]&gt;170)p[j]-=10;</p>
<p>​        }</p>
<p>​      }</p>
<p>/<em>去除黑方格上的亮点</em>/</p>
<p>​      for(int i=0;i&lt;row;i++)</p>
<p>​      {</p>
<p>​        p=grey_image.ptr<uchar>(i);</p>
<p>​        for(int j=0;j&lt;col;j++)</p>
<p>​        {</p>
<p>​          if(p[j]&gt;140){</p>
<p>​            if(j&lt;15&amp;&amp;p[j+15]&lt;100)</p>
<p>​            p[j]=p[j+15];</p>
<p>​            if((j&gt;15)&amp;&amp;(j&lt;col-15))</p>
<p>​            {if(p[j+15]&lt;100)p[j]=p[j+15];</p>
<p>​            if(p[j+15]&lt;100)p[j]=p[j-15];</p>
<p>​            }</p>
<p>​            if(j&gt;col-15&amp;&amp;p[j+15]&lt;100)</p>
<p>​              p[j]=p[j-15];</p>
<p>​          }</p>
<p>​        }</p>
<p>​      }</p>
<p>/<em>腐蚀进一步消除</em>/</p>
<p>​      Mat ele = getStructuringElement(MORPH_RECT,Size(4,4));</p>
<p>​      Mat ele2 = getStructuringElement(MORPH_RECT,Size(2,2));</p>
<p>​       erode(grey_image,grey_image,ele);//erode函数直接进行腐蚀操作</p>
<p>​       dilate(grey_image,grey_image,ele2);//膨胀增加精确度</p>
<p>​       // imshow(“after erode operation”,grey_image);</p>
<p>​       Mat imageInput=grey_image.clone();</p>
<p>​       if (!findChessboardCorners(imageInput, board_size, image_points_buf,CV_CALIB_CB_FILTER_QUADS))</p>
<p>​           {</p>
<p>​             cout &lt;&lt; “can not find chessboard corners!\n”;//找不到角点</p>
<p>​             return;</p>
<p>​           }</p>
<p>​           else</p>
<p>​           {</p>
<p>​             Mat view_gray=grey_image.clone();</p>
<p>​             /<em>亚像素精确化</em>/</p>
<p>​             find4QuadCornerSubpix(view_gray, image_points_buf, Size(5, 5));//对粗提取的角点进行精确化</p>
<p>​             drawChessboardCorners(view_gray, board_size, image_points_buf, true);//用于在图片中标记角点</p>
<p>​             image_points_seq.push_back(image_points_buf);//保存亚像素角点</p>
<p>​            // imshow(“Camera Calibration”, view_gray);//显示图片</p>
<p>​             waitKey(100);</p>
<p>​           }</p>
<p>​           image_size.width = imageInput.cols;</p>
<p>​           image_size.height = imageInput.rows;</p>
<p>​           imageInput.release();</p>
<p> }</p>
<p>/<em>相机标定</em>/</p>
<p>​          for (int t = 0; t&lt;imageCount; t++)</p>
<p>​            {</p>
<p>​             vector<Point3f> tempPointSet;</p>
<p>​              for (int i = 0; i&lt;board_size.width; i++)//每列</p>
<p>​              {</p>
<p>​                for (int j = 0; j&lt;board_size.height; j++)//每行</p>
<p>​                {</p>
<p>​                  Point3f realPoint;</p>
<p>​                  //假设标定板放在世界坐标系中z=0的平面上</p>
<p>​                  realPoint.x = j*square_size.width;//小方格的宽度</p>
<p>​                  realPoint.y = i*square_size.height;</p>
<p>​                  realPoint.z = 0;</p>
<p>​                  tempPointSet.push_back(realPoint);</p>
<p>​                }</p>
<p>​              }</p>
<p>​              object_points.push_back(tempPointSet);</p>
<p>​            }</p>
<p>​           //内外参数对象</p>
<p>​            cameraMatrix = Mat(3, 3, CV_32FC1, Scalar::all(0));//摄像机内参数矩阵</p>
<p>​            //int point_counts;// 每幅图像中角点的数量</p>
<p>​            distCoeffs = Mat(1, 5, CV_32FC1, Scalar::all(0));//摄像机的5个畸变系数：k1,k2,p1,p2,k3</p>
<p>​            calibrateCamera(object_points, image_points_seq, image_size, cameraMatrix, distCoeffs, rvecsMat, tvecsMat, 0);//相机标定</p>
<p>/<em>二值化</em>/</p>
<p>​                   Mat origin_image=imread(file);//</p>
<p>​                   Mat grey_image;</p>
<p>​                   cvtColor(origin_image, grey_image, CV_RGB2GRAY);</p>
<p>​                   // imshow(“origin”,origin_image);</p>
<p>​                   // imshow(“grey”,grey_image);</p>
<p>​                   //waitKey(100);</p>
<p>​                   Mat binary_image;</p>
<p>​                   threshold(grey_image,binary_image,240, 255, CV_THRESH_BINARY);</p>
<p>​                   //imshow(“binary”,binary_image);</p>
<p>​                   //寻找二值化图像上的角点并保存</p>
<p>​                   goodFeaturesToTrack(binary_image,corners,18,0.01,10,Mat());</p>
<p>​                   for(unsigned int i=0;i&lt;corners.size();i++)</p>
<p>​                     {</p>
<p>​                       circle(origin_image,corners[i],2,Scalar(255,0,0),2);</p>
<p>​                     }</p>
<p>​                   // imshow(“binary points”,origin_image);</p>
<p>/<em>直线拟合</em>/</p>
<p>​                     fitLine(corners, line_para, cv::DIST_L2, 0, 1e-2, 1e-2);</p>
<p>​                     cv::Point point0;</p>
<p>​                     point0.x = line_para[2];</p>
<p>​                     point0.y = line_para[3];</p>
<p>​                     double k = line_para[1] / line_para[0];</p>
<p>​                     //计算直线的端点(y = k(x - x0) + y0)</p>
<p>​                     Point point1, point2;</p>
<p>​                     point1.x = 0;</p>
<p>​                     point1.y = k * (0 - point0.x) + point0.y;</p>
<p>​                     point2.x = origin_image.cols;</p>
<p>​                     point2.y = k * (origin_image.cols - point0.x) + point0.y;</p>
<p>​                     cv::line(origin_image, point1, point2, cv::Scalar(255, 255, 0), 2, 8, 0);</p>
<p>​                    // cv::imshow(“image”, origin_image);</p>
<p>/<em>获取结构光与角点直线坐标</em>/</p>
<p>​                     GetCrossPointAll();</p>
<p>/<em>将旋转向量转换成旋转矩阵</em>/         for(int i=0;i&lt;imageCount;i++)</p>
<p>​                     {  Mat temp;</p>
<p>​                       Rodrigues(rvecsMat[i],temp );</p>
<p>​                       R_matrix.push_back(temp);</p>
<p>​                     }</p>
<p>/<em>求M矩阵</em>/</p>
<p>​                     calMatrix_M();</p>
<p>/<em>求角点的摄像机坐标</em>/</p>
<p>​                     calCameraCornerPoints();</p>
<p>/<em>交比不变求结构光与角点直线的摄像机坐标</em>/</p>
<p>​                     calCameraCrossPoints();</p>
<p>/<em>拟合光平面</em>/</p>
<p>​                     fitting_light_surface();</p>
<p>/<em>保存内外参数</em>/</p>
<p>​              ofstream fout(“struct_caliberation_result.txt”);//保存标定结果的文件</p>
<p>​              fout &lt;&lt; “相机内参数矩阵：” &lt;&lt; endl;</p>
<p>​              fout &lt;&lt; cameraMatrix &lt;&lt; endl &lt;&lt; endl;</p>
<p>​              fout &lt;&lt; “畸变系数：\n”;</p>
<p>​              fout&lt;&lt;distCoeffs&lt;&lt;endl;</p>
<p>​              fout&lt;&lt;”第一幅图角点像素坐标”&lt;&lt;endl&lt;&lt;image_points_seq[0]&lt;&lt;endl;</p>
<p>​              fout&lt;&lt;”第一幅图角点世界坐标”&lt;&lt;endl&lt;&lt;object_points[0]&lt;&lt;endl;</p>
<p>​              fout&lt;&lt;”第一幅图交点像素坐标”&lt;&lt;endl&lt;&lt;crossPointAll[0]&lt;&lt;endl;</p>
<p>​              fout&lt;&lt;”a b c d”&lt;&lt;image_points_seq[10][0]&lt;&lt;endl&lt;&lt;image_points_seq[10][3]&lt;&lt;endl&lt;&lt;image_points_seq[10][6]&lt;&lt;endl&lt;&lt;crossPointAll[1][0]&lt;&lt;endl;</p>
<p>​              fout&lt;&lt;”camera”&lt;&lt;endl&lt;&lt;corners_in_camera[6][0]&lt;&lt;endl&lt;&lt;corners_in_camera[6][3]&lt;&lt;endl&lt;&lt;corners_in_camera[6][6]&lt;&lt;endl;</p>
<p>​              fout&lt;&lt;plane12[0]&lt;&lt;”  “&lt;&lt;plane12[1]&lt;&lt;”  “&lt;&lt;plane12[2]&lt;&lt;”  “&lt;&lt;plane12[3]&lt;&lt;endl;</p>
<p>​              for(int i=0;i&lt;50;i++)</p>
<p>​              fout&lt;&lt;”X_vector”&lt;&lt;” “&lt;&lt;X_vector[i]&lt;&lt;”  “&lt;&lt;”Y_vector”&lt;&lt;” “&lt;&lt;Y_vector[i]&lt;&lt;”  “&lt;&lt;”Z_vector”&lt;&lt;” “&lt;&lt;Z_vector[i]&lt;&lt;endl;</p>
<p>​               waitKey(0);//停半秒</p>
<p>}</p>
<p>Point2f MainWindow:: <strong>getcrosspoint</strong>(Vec4f lineA,Vec4f lineB)</p>
<p>  { //求两条直线角点</p>
<p>​    double ka=lineA[1]/lineA[0];</p>
<p>​    double kb=lineB[1]/lineB[0];</p>
<p>​    Point2f cross_point;</p>
<p>​    cross_point.x=(lineB[3]-lineA[3]+ka<em>lineA[2]-kb</em>lineB[2])/(ka-kb);</p>
<p>​    cross_point.y=ka*(cross_point.x-lineA[2])+lineA[3];</p>
<p>​    return cross_point;</p>
<p>  }</p>
<p>void MainWindow:: <strong>GetCrossPointAll</strong>()</p>
<p> {</p>
<p>   for(int i=0;i&lt;imageCount;i++)//11幅图</p>
<p>   {</p>
<p>​     vector<Point2f>crossPointPerPic;</p>
<p>​     for(int j=0;j&lt;board_size.height;j++)//遍历每行</p>
<p>​     {</p>
<p>​       vector<Point2f>temp;//取每行角点</p>
<p>​       for(int m=0;m&lt;board_size.width;m++)</p>
<p>​         temp.push_back(image_points_seq[i][j*7+m]);</p>
<p>​       Vec4f para;</p>
<p>​       fitLine(temp,para,DIST_L2,0,1e-2,1e-2);//拟合每行角点直线</p>
<p>​       Point2f temp_point=getcrosspoint(para,line_para);//得出角点直线与结构光交点</p>
<p>​       crossPointPerPic.push_back(temp_point);</p>
<p>​     }</p>
<p>​     crossPointAll.push_back(crossPointPerPic);</p>
<p>   }</p>
<p> }</p>
<p>void MainWindow::<strong>calMatrix_M</strong>()</p>
<p>{</p>
<p>//利用旋转矩阵和平移向量求得摄像机坐标系和世界坐标系之间的关系矩阵M</p>
<p>  for(int k=0;k&lt;imageCount;k++)</p>
<p>  { Mat temp(4,4,CV_32F);</p>
<p>​    for(int i=0;i&lt;3;i++)</p>
<p>​     for(int j=0;j&lt;3;j++)</p>
<p>​     {temp.at<float>(i,j)=R_matrix[k].at<double>(i,j);</p>
<p>​     temp.at<float>(0,3)=tvecsMat[k].at<double>(0);</p>
<p>​     temp.at<float>(1,3)=tvecsMat[k].at<double>(1);</p>
<p>​     temp.at<float>(2,3)=tvecsMat[k].at<double>(2);</p>
<p>​     temp.at<float>(3,0)=0;temp.at<float>(3,1)=0;temp.at<float>(3,2)=0;temp.at<float>(3,3)=1;</p>
<p>​     }</p>
<p>   M.push_back(temp);</p>
<p>  }</p>
<p>}</p>
<p>void MainWindow::<strong>calCameraCornerPoints</strong>()</p>
<p>{//求出摄像机坐标系下的角点</p>
<p>for(int i=0;i&lt;imageCount;i++)</p>
<p>{</p>
<p>  vector<Mat>temp;</p>
<p>  for(int j=0;j&lt;board_size.height;j++)</p>
<p>​    for(int k=0;k&lt;board_size.width;k++)</p>
<p>​    { Mat temp2(4,1,CV_32F);</p>
<p>​      Mat world(4,1,CV_32F);world.at<float>(0)=object_points[i][j*7+k].x;//取出世界坐标系下的角点</p>
<p>​      world.at<float>(1)=object_points[i][j<em>7+k].y;world.at<float>(2)=object_points[i][j</em>7+k].z;</p>
<p>​      world.at<float>(3)=1;</p>
<p>​      temp2=M[i]*world;//转换为摄像机坐标系</p>
<p>​      temp.push_back(temp2);</p>
<p>​    }</p>
<p>  corners_in_camera.push_back(temp);</p>
<p>}</p>
<p>}</p>
<p>void MainWindow::<strong>calCameraCrossPoints</strong>()</p>
<p>{</p>
<p>  for(int i=0;i&lt;imageCount;i++)</p>
<p>  {</p>
<p>​    for(int j=0;j&lt;board_size.height;j++)</p>
<p>​    {   //每行取三个角点</p>
<p>​        Point2f A=image_points_seq[i][j*7];//找到每行的第1，4，7个角点</p>
<p>​        Point2f B=image_points_seq[i][j*7+3];</p>
<p>​        Point2f C=image_points_seq[i][j*7+6];</p>
<p>​        Point2f D=crossPointAll[i][j];//每行的结构光交点</p>
<p>​        Mat A_=corners_in_camera[i][j*7];//找到对应角点在摄像机坐标下的坐标</p>
<p>​        Mat B_=corners_in_camera[i][j*7+3];</p>
<p>​        Mat C_=corners_in_camera[i][j*7+6];</p>
<p>​        calCornersInCamera(A,B,C,D,A_,B_,C_);//将角点坐标转换为摄像机坐标</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p> void MainWindow::<strong>calCornersInCamera</strong>(Point2f A,Point2f B,Point2f C,Point2f D,Mat A_,Mat B_,Mat C_)</p>
<p> {</p>
<p>​    double CR=(D.x-B.x)<em>(A.x-C.x)/((A.x-B.x)</em>(D.x-C.x));//求出交比</p>
<p>​    //利用像素坐标系下求得的交比，利用交比不变性求出结构光点在摄像机下的坐标，已知，A，B,C,D像素坐标和A_,B_,C_,摄像机坐标可求D_坐标</p>
<p>​    //由于像素坐标系与物理坐标系是线性关系，可省略像素坐标系转图像坐标系这一步，在像素坐标系下求得的交比与在图像坐标系下求得的交比一样</p>
<p>​    double m=CR*(A_.at<float>(0)-B_.at<float>(0))/(A_.at<float>(0)-C_.at<float>(0));</p>
<p>​    double x=(B_.at<float>(0)-m*C_.at<float>(0))/(1-m);</p>
<p>​    double y=(B_.at<float>(1)-m*C_.at<float>(1))/(1-m);</p>
<p>​    double z=(B_.at<float>(2)-m*C_.at<float>(2))/(1-m);</p>
<p>​    X_vector.push_back(x); Y_vector.push_back(y); Z_vector.push_back(z);</p>
<p> }</p>
<p> void MainWindow::<strong>fitting_light_surface</strong>()</p>
<p> {</p>
<p>   CvMat*points_mat = cvCreateMat(X_vector.size(), 3, CV_32FC1);</p>
<p>   //定义用来存储需要拟合点的矩阵大小N*3；</p>
<p>   for (unsigned int i=0;i &lt; X_vector.size(); ++i)</p>
<p>​       {</p>
<p>​       points_mat-&gt;data.fl[i*3+0] = X_vector[i];</p>
<p>​        //矩阵的值进行初始化  X的坐标值</p>
<p>​       points_mat-&gt;data.fl[i * 3 + 1] = Y_vector[i];</p>
<p>​       // Y的坐标值</p>
<p>​       points_mat-&gt;data.fl[i * 3 + 2] = Z_vector[i];</p>
<p>​       //<span style="font-family: Arial, Helvetica, sans-serif;"></p>
<p>​       // Z的坐标值</span></p>
<p>   }</p>
<p>​       cvFitPlane(points_mat, plane12);//调用方程</p>
<p> }</p>
<p> void MainWindow::<strong>cvFitPlane</strong>(const CvMat* points, float* plane)</p>
<p> {</p>
<p>   int nrows = points-&gt;rows;</p>
<p>   int ncols = points-&gt;cols;</p>
<p>   int type = points-&gt;type;</p>
<p>   CvMat* centroid = cvCreateMat(1, ncols, type);</p>
<p>   cvSet(centroid, cvScalar(0));</p>
<p>   for (int c = 0; c&lt;ncols; c++)</p>
<p>   {</p>
<p>   for (int r = 0; r &lt; nrows; r++)</p>
<p>​     {</p>
<p>​      centroid-&gt;data.fl[c] += points-&gt;data.fl[ncols*r + c];</p>
<p>​     }</p>
<p>   centroid-&gt;data.fl[c] /= nrows;</p>
<p>   }</p>
<p>   // Subtract geometric centroid from each point.</p>
<p>   CvMat* points2 = cvCreateMat(nrows, ncols, type);</p>
<p>   for (int r = 0; r&lt;nrows; r++)</p>
<p>​     for (int c = 0; c&lt;ncols; c++)</p>
<p>​       points2-&gt;data.fl[ncols<em>r + c] = points-&gt;data.fl[ncols</em>r + c] - centroid-&gt;data.fl[c];</p>
<p>  // Evaluate SVD of covariance matrix.</p>
<p>  CvMat* A = cvCreateMat(ncols, ncols, type);</p>
<p>  CvMat* W = cvCreateMat(ncols, ncols, type);</p>
<p>  CvMat* V = cvCreateMat(ncols, ncols, type);</p>
<p>  cvGEMM(points2, points, 1, NULL, 0, A, CV_GEMM_A_T);</p>
<p>  cvSVD(A, W, NULL, V, CV_SVD_V_T);</p>
<p>  // Assign plane coefficients by singular vector corresponding to smallest singular value.</p>
<p>  plane[ncols] = 0;</p>
<p>  for (int c = 0; c&lt;ncols; c++){</p>
<p>  plane[c] = V-&gt;data.fl[ncols*(ncols - 1) + c];</p>
<p>  plane[ncols] += plane[c] * centroid-&gt;data.fl[c];</p>
<p>  }</p>
<p>  // Release allocated resources.</p>
<p>  //cvReleaseMat(¢roid);</p>
<p>  cvReleaseMat(&amp;points2);</p>
<p>  cvReleaseMat(&amp;A);</p>
<p>  cvReleaseMat(&amp;W);</p>
<p>  cvReleaseMat(&amp;V);</p>
<p> }</p>
<p> void MainWindow::<strong><em>mousePressEvent\</em></strong>(QMouseEvent *e)</p>
<p> {</p>
<p>​    static int i=0;</p>
<p>   if(i&lt;2)</p>
<p>   {</p>
<p>​     if(i==0){ui-&gt;x1-&gt;setText(QString::number(0));ui-&gt;y1-&gt;setText(QString::number(0));</p>
<p>​          ui-&gt;x2-&gt;setText(QString::number(0));ui-&gt;y2-&gt;setText(QString::number(0));</p>
<p>​          ui-&gt;realdis-&gt;setText(QString::number(0));}</p>
<p>​     Point2f temp;</p>
<p>​     temp.x = e-&gt;x();</p>
<p>​     temp.y = e-&gt;y()-34;//纵坐标应减去MainWindow上方空白的长度</p>
<p>​     if(i==0){ui-&gt;x1-&gt;setText(QString::number(temp.x));ui-&gt;y1-&gt;setText(QString::number(temp.y));}</p>
<p>​     if(i==1){ui-&gt;x2-&gt;setText(QString::number(temp.x));ui-&gt;y2-&gt;setText(QString::number(temp.y));}</p>
<p>​     mousePoint.push_back(temp);</p>
<p>​     ++i;</p>
<p>   }</p>
<p>   else</p>
<p>   {   //收集到两个点之后再次点击鼠标计算距离并清空mousePoint</p>
<p>​     if(image_points_seq.size()!=0)</p>
<p>​     {      calDistance();</p>
<p>​       i-=2;mousePoint.pop_back();mousePoint.pop_back();</p>
<p>​     }</p>
<p>​     else</p>
<p>​     QMessageBox::warning( this, tr(“warning”),</p>
<p>​              tr(“未标定摄像机和光平面”</p>
<p>​                  “”)</p>
<p>​                 );</p>
<p>   }</p>
<p> }</p>
<p> void::MainWindow::<strong>open</strong>()</p>
<p> {</p>
<p>   QString path = QFileDialog::getOpenFileName(</p>
<p>​             this,</p>
<p>​             “文件对话框”,</p>
<p>​             “../“,//上一级路径</p>
<p>​             “Image(*.bmp *.jpg *.png)”</p>
<p>​            );</p>
<p>  QImage* image=new QImage(path);</p>
<p>   if(image-&gt;width()&gt;1500)zoom=(double)image-&gt;width()/1500;//宽度大于1500像素进行缩放 zoom为缩放比</p>
<p>   int width = image-&gt;width()/zoom;//缩放后的宽度</p>
<p>   int height = image-&gt;height()/zoom;//缩放后的高度</p>
<p>   //QPixmap fitpixmap = pixmap.scaled(width, height,Qt::KeepAspectRatio Qt::IgnoreAspectRatio, Qt::SmoothTransformation); // 饱满填充</p>
<p>  QPixmap pixmap = QPixmap::fromImage(*image);</p>
<p>  QPixmap fitpixmap = pixmap.scaled(width, height, Qt::IgnoreAspectRatio, Qt::SmoothTransformation); // 按比例缩放</p>
<p>   //重新设置label的面积使图片充满整个label区域</p>
<p>   ui-&gt;label-&gt;resize(width,height);</p>
<p>   ui-&gt;label-&gt;setPixmap(fitpixmap);</p>
<p> }</p>
<p>void MainWindow::<strong>calDistance</strong>()</p>
<p>{</p>
<p>  //获取需要的数据</p>
<p>  //double fx=7079.108034043226;  double fy=7138.477799905151;</p>
<p>  //double u0=1385.469717666468; double v0=1009.67646851548;</p>
<p>  //double a=0.999773;double b=-0.0105343;double c= 0.0185257;double d= -19.9609;</p>
<p>  double fx= cameraMatrix.at<double>(0,0);</p>
<p>  double fy= cameraMatrix.at<double>(1,1);</p>
<p>  double u0=cameraMatrix.at<double>(0,2);</p>
<p>  double v0=cameraMatrix.at<double>(1,2);</p>
<p>  double a=(double)plane12[0];double b=(double)plane12[1];double c=(double)plane12[2];double d=(double)plane12[3];</p>
<p>  Mat physic_to_pixel(3,3,CV_32F);//归一化坐标和像素坐标之间的关系矩阵</p>
<p>  physic_to_pixel.at<float>(0,0)=(double)fx;physic_to_pixel.at<float>(0,1)=0;physic_to_pixel.at<float>(0,2)=u0;</p>
<p>  physic_to_pixel.at<float>(1,0)=0;physic_to_pixel.at<float>(1,1)=(double)fy;physic_to_pixel.at<float>(1,2)=v0;</p>
<p>  physic_to_pixel.at<float>(2,0)=0;physic_to_pixel.at<float>(2,1)=0;physic_to_pixel.at<float>(2,2)=1;</p>
<p>  //两个点的像素，摄像机，归一化物理坐标</p>
<p>  Mat pixel1(3,1,CV_32F);Mat pixel2(3,1,CV_32F);</p>
<p>  Mat camera1(3,1,CV_32F);Mat camera2(3,1,CV_32F);</p>
<p>  Mat physic1(3,1,CV_32F);Mat physic2(3,1,CV_32F);</p>
<p>  //赋值 计算</p>
<p>  pixel1.at<float>(0)=mousePoint[0].x<em>zoom;pixel1.at<float>(1)=mousePoint[0].y</em>zoom;pixel1.at<float>(2)=1;</p>
<p>  pixel2.at<float>(0)=mousePoint[1].x<em>zoom;pixel2.at<float>(1)=mousePoint[1].y</em>zoom;pixel2.at<float>(2)=1;</p>
<p>  physic1=physic_to_pixel.inv()<em>pixel1;physic2=physic_to_pixel.inv()</em>pixel2;</p>
<p>  camera1.at<float>(0)=(d/(a<em>physic1.at<float>(0)+b</em>physic1.at<float>(1)+c))<em>physic1.at<float>(0); camera1.at<float>(1)=(d/(a</em>physic1.at<float>(0)+b<em>physic1.at<float>(1)+c))</em>physic1.at<float>(1); camera1.at<float>(2)=(d/(a<em>physic1.at<float>(0)+b</em>physic1.at<float>(1)+c))*physic1.at<float>(2);</p>
<p>  camera2.at<float>(0)=(d/(a<em>physic2.at<float>(0)+b</em>physic2.at<float>(1)+c))<em>physic2.at<float>(0);camera2.at<float>(1)=(d/(a</em>physic2.at<float>(0)+b<em>physic2.at<float>(1)+c))</em>physic2.at<float>(1);camera2.at<float>(2)=(d/(a<em>physic2.at<float>(0)+b</em>physic2.at<float>(1)+c))*physic2.at<float>(2);</p>
<p>  //得到两点在摄像机坐标下得距离</p>
<p>  double dis=sqrt((camera1.at<float>(0)-camera2.at<float>(0))<em>(camera1.at<float>(0)-camera2.at<float>(0))+(camera1.at<float>(1)-camera2.at<float>(1))</em>(camera1.at<float>(1)-camera2.at<float>(1))+(camera1.at<float>(2)-camera2.at<float>(2))*(camera1.at<float>(2)-camera2.at<float>(2)));</p>
<p>   ui-&gt;realdis-&gt;setText(QString::number(dis));</p>
<p>}</p>
<p>void MainWindow::<strong>pushbutton1</strong>()</p>
<p>{</p>
<p>  path=ui-&gt;filename-&gt;toPlainText();</p>
<p>  board_size.width=ui-&gt;cols-&gt;value();board_size.height=ui-&gt;rows-&gt;value();</p>
<p>  square_size.width=square_size.height=ui-&gt;dis-&gt;value();</p>
<p>  imageCount=ui-&gt;pic-&gt;value();</p>
<p>  squareCalibrate();</p>
<p>  QString text(“%1x+%2y+%3z\n=%4”);text=text.arg(plane12[0]).arg(plane12[1]).arg(plane12[2]).arg(plane12[3]);</p>
<p>  ui-&gt;surface-&gt;setText(text);</p>
<p>}</p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/04/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。每次遍历一次都使一个元素归位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">		<span class="comment">//外层循环 N-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">//内层循环 N-i-1 次。第 i 次遍历整个数组需要交换 N-i-1 次。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;N-i; j++)&#123;</span><br><span class="line">                <span class="comment">//比较和交换</span></span><br><span class="line">                <span class="keyword">if</span>(a[j].compareTo(a[j-<span class="number">1</span>]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    Comparable temp = a[j];</span><br><span class="line">                    a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">                    a[j-<span class="number">1</span>] =temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h3><p>选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小元素，存放到排序序列的前部分，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="comment">// 找出未排序序列中的最小元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[min].compareTo(a[j]) &gt; <span class="number">0</span>) min = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使未排序序列中的最小值归位</span></span><br><span class="line">            Comparable temp = a[min];</span><br><span class="line">            a[min] = a[i];</span><br><span class="line">            a[i] = temp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将第 i 个元素与前面的 0 ~ i-1 个元素比较,若比其中的元素小则依次交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span> &amp;&amp; a[j].compareTo(a[j-<span class="number">1</span>])&lt;<span class="number">0</span> ;j--)&#123;</span><br><span class="line">               Comparable temp = a[j];</span><br><span class="line">               a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">               a[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h +<span class="number">1</span>;  <span class="comment">//h = 1,4,13,40 ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将数组变为 h 有序，即相隔 h 个元素 的元素构成一组，组内有序，</span></span><br><span class="line"><span class="comment">        将 h 的值逐渐缩小则数组有序。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h; i&lt;N; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=h &amp;&amp; a[j].compareTo(a[j-h])&lt;<span class="number">0</span>; j-=h)&#123;</span><br><span class="line">                    Comparable temp = a[j];</span><br><span class="line">                    a[j] = a[j-h];</span><br><span class="line">                    a[j-h] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组a[lo...hi]排序</span></span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a,lo,mid);</span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);</span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//将a[lo..mid] 和a[mid+1..hi]归并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//将a[lo..hi] 复制到aux[lo..hi]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo; k&lt;=hi; ++k)</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">int</span> i = lo, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo; k&lt;=hi; ++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++]; <span class="comment">//左半边用尽</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];<span class="comment">//右半边用尽</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(aux[i].compareTo(aux[j]) &lt; <span class="number">0</span>) a[k] = aux[i++];</span><br><span class="line">                      <span class="keyword">else</span> a[k] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//将左半部分排序</span></span><br><span class="line">        sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将右半部分排序</span></span><br><span class="line">        sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[]a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组切分为a[lo..i-1], a[i], a[i+1..hi]</span></span><br><span class="line">        <span class="keyword">int</span> i=lo,j=hi;</span><br><span class="line">        <span class="comment">//选取第一个元素为基准点</span></span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i，j 相遇停止</span></span><br><span class="line">        <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//先从左边开始，不能保证你最后和基准点交换的那个数，是小于等于左边的。例如 2，1，4，9</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//找出右边比基准点小的元素的下标</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; i &amp;&amp; a[j].compareTo(v) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找出左边比基准点大的元素的下标</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i].compareTo(v) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="comment">//交换a[i] 和 a[j]</span></span><br><span class="line">                Comparable temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] =temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i，j 相遇，基准点的位置已经找到，将a[v] 与 a[i] 交换。</span></span><br><span class="line">        Comparable temp = a[lo];</span><br><span class="line">        a[lo] = a[j];</span><br><span class="line">        a[j] =temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回基准点的下标</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点开始，从下至上，从右至左向下调整。</span></span><br><span class="line">            adjustDown(a,i,a.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换堆顶元素与最后一个元素，最大的元素归位。由于破坏了大根堆的特性需要重新调整堆顶元素。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a.length-<span class="number">1</span>; j&gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="comment">//交换元素</span></span><br><span class="line">            Comparable temp = a[<span class="number">0</span>];</span><br><span class="line">            a[<span class="number">0</span>] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向下调整大根堆</span></span><br><span class="line">            adjustDown(a,<span class="number">0</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(Comparable[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>*i+<span class="number">1</span>; k&lt;length; k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到两个子结点中较大的一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; a[k].compareTo(a[k+<span class="number">1</span>])&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果子结点的值大于父结点的值，将父结点向下调整，继续向下调整</span></span><br><span class="line">            <span class="keyword">if</span>(a[k].compareTo(temp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//父结点的值设置为子结点的值</span></span><br><span class="line">                a[i] = a[k];</span><br><span class="line">                <span class="comment">//对当前结点继续向下调整</span></span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将 temp 值放到最终的位置</span></span><br><span class="line">        a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库完整性与安全性</title>
    <url>/2020/04/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h3 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h3><h4 id="SQL-存取控制机制"><a href="#SQL-存取控制机制" class="headerlink" title="SQL 存取控制机制"></a>SQL 存取控制机制</h4><p>​    SQL 支持受控的存取保护，即在自主存取控制中，用户对于不同的数据对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户。因此自主存取控制非常灵活。</p>
<p>​    自主存取控制通过 SQL 的 grant 和 revoke 语句实现。</p>
<p>​    用户权限是由两个要素组成的：数据对象和操作对象。</p>
<p>​    用户的存取权限：该用户可以在哪些数据对象上进行哪些类型的操作。定义存取权限称为授权。</p>
<p>​    自主存取控制能够通过授权机制有效地控制其他用户对敏感数据的存取。</p>
<h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><p>​    创建用户语句 create user 的语法如下：</p>
<p><img src="https://i.loli.net/2020/04/05/PMcSmGxa3O7JzBb.png" alt="image-20200405154743908"></p>
<p>​    只有系统的超级用户才有权创建一个新的数据库用户。新创建的数据库用户有 3 种权限 connect、resource 和 dba。默认为 connect 权限，拥有 connect 权限的用户不能创建新用户、模式和基本表，只能登录数据库。然后由 dba 或其他用户给他转授权限。拥有 resource 权限的用户可以创建基本表和视图，并称为所创建对象的属主，但不能创建模式和新用户。数据库对象的属主可以使用 grant 语句把该对象上的存取权限授予其他用户。拥有 dba 权限的用户是系统中的超级用户，可以创建新用户、模式、基本表和视图等；dba 拥有所有数据库对象的存取权限，还可以将这些权限授予给一般用户。</p>
<h5 id="权限的授予与收回"><a href="#权限的授予与收回" class="headerlink" title="权限的授予与收回"></a>权限的授予与收回</h5><p>​    grant 和 revoke 有两种权限：目标权限和命令权限。</p>
<h6 id="命令权限的授予与收回"><a href="#命令权限的授予与收回" class="headerlink" title="命令权限的授予与收回"></a>命令权限的授予与收回</h6><p>​    命令级权限主要指 DDL 操作权限。命令权限的授予语句 grant 和 收回语句 revoke 的语法分别为：</p>
<p><img src="https://i.loli.net/2020/04/05/jWhtYLXsdeT6iAE.png" alt="image-20200405155559635"></p>
<p>​    其中 &lt; command_list &gt; 可以是 create database、create default、create function、create procedure、create rule、create table、create view、create index、backup database 和 backup log 等。</p>
<p>​    一次可以授予多种权限，授予多种权限时，权限之间用逗号分隔。</p>
<p>​    all：表示上述所有权限。</p>
<p>​    public：表示所有用户。</p>
<p>​    &lt; username_list &gt;：指定的用户名列表。如果将某组权限同时授予多个用户，则用户名之间用逗号分隔。</p>
<h6 id="目标权限的授予与收回"><a href="#目标权限的授予与收回" class="headerlink" title="目标权限的授予与收回"></a>目标权限的授予与收回</h6><p>​    目标权限主要指对对象的 DML 操作权限。对象权限的授予语句 grant 和收回语句 revoke 的语法分别为：</p>
<p><img src="https://i.loli.net/2020/04/05/iEl5Mm3Tw8tWVQ6.png" alt="image-20200405160348795"></p>
<p>​    其中 &lt; command_list &gt; 可以是 update、select、insert、delete、execute 和 all 。execute 针对存储过程授予执行权限，update、select、insert、delete 针对基本表和视图授权， all 指全部的权限。</p>
<p>​    cascade ：级联收回。</p>
<p>​    restrict：默认值，若转赋了权限，则不能收回。</p>
<p>​    with grant option：将指定对象上的目标权限授予其他安全账户的能力，但是不允许循环授权。即不允许将其得到的权限授予其祖先。</p>
<h3 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h3><h4 id="完整性约束条件"><a href="#完整性约束条件" class="headerlink" title="完整性约束条件"></a>完整性约束条件</h4><p>​    完整性约束条件作用的对象可以是关系、元组、列 3 种。列约束主要是列的类型、取值范围、精度、是否允许空值等的约束条件。元组约束是元组中属性间的联系的约束。关系约束是若干元组间、关系集合上以及关系之间的约束。</p>
<p>​    完整性约束条件涉及的这 3 类对象，其状态可以是静态的，也可以是动态的。</p>
<p>​    静态约束是指数据库每一确定状态时的数据对象所应满足的约束条件，它反映数据库状态合理性的约束，这是最重要的一类完整性约束。</p>
<p>​    静态约束主要表现在：</p>
<p>​    1）静态列级约束：对一个列的取值域的说明。对数据类型（类型，长度、单位、精度等）、数据格式、对取值范围或取值集合的约束、对空值的约束和其他约束。</p>
<p>​    2）静态元组约束：规定元组的各个列之间的约束关系。</p>
<p>​    3）静态关系约束：在一个关系的各个元组之间或若干关系之间存在各种联系或约束。常见的静态关系约束有：<strong>实体完整性约束、参照完整性约束和函数依赖约束</strong>。</p>
<p>​    </p>
<p>​    动态约束是指数据库从一种状态转变为另一种状态时的新、旧值之间所应满足的约束条件，它是反映数据库状态变迁的约束。</p>
<p>​    动态约束主要表现在：</p>
<p>​    1）动态列级约束。修改列定义或列值时应满足的约束条件。<strong>包括修改列定义时的约束</strong>（将允许空值的列修改为不允许空值，记录中有一列为空值，拒绝修改）<strong>修改列值时的约束</strong>（修改列值有时需要参照其旧值）。</p>
<p>​    2）动态元组约束：指需改元组的值时元组中各个字段间需要满足某种约束条件。</p>
<p>​    3）动态关系约束：动态关系约束是加在关系变化前后状态上的限制条件。例如，事物一致性、原子性等约束条件。</p>
<p>​    </p>
<p>​    完整性约束又可以分为立即执行的约束和延迟执行的约束。</p>
<p>​    立即执行约束：检查是否违背完整性约束的时机是在一条语句执行完后立即检查。</p>
<p>​    延迟执行约束：需要延迟到整个事务执行结束后再进行检查。</p>
<p>​    </p>
<h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>​    实体完整性要求基本表的主码值唯一且不允许为空值。primary key 指定</p>
<p>​    实体完整性的检查和违约处理：</p>
<p>​    1）检查主码是否唯一。如果不唯一则拒绝插入或修改。（索引或顺序查找）</p>
<p>​    2）检查主码的各个属性是否为空，只要有一个为空则拒绝插入或修改。</p>
<h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><p>​    参照完整性为若干个表中的相应元组建立联系。参照完整性定义是使用 create table 语句中的 foreign key 和 references 短语来实现，或通过 alter table 语句中的 add foreign key 来实现。</p>
<p>​    参照完整性的检查和违约处理：</p>
<p>​    1）拒绝执行。如果发生了违约，阻止操作。</p>
<p>​    2）级联操作。当删除或修改被参照关系的某个元组造成了与参照关系的不一致时，则删除或修改参照表中所有不一致的元组。级联操作必须在定义外码时给出定义（在外码定义最后追加 on delete/update cascade）。</p>
<p>​    3）设置为空值。如果外码可以为空，发生了违约则将外码置空。</p>
<p>​    4）置空值删除。删除被参照关系的元组，并将被参照关系中相应元组的外码置空值。</p>
<h4 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h4><h5 id="属性上的约束"><a href="#属性上的约束" class="headerlink" title="属性上的约束"></a>属性上的约束</h5><p>​    包括：列值非空、列值唯一、设置默认值和满足 check 定义。如果不满足则拒绝相应的操作。</p>
<p>​    以上约束分别通过 not null、unique、default+默认值、check 实现。</p>
<h5 id="元组上的约束"><a href="#元组上的约束" class="headerlink" title="元组上的约束"></a>元组上的约束</h5><p>​    元组上的约束可以设置不同属性之间的取值相互约束条件，也是用 check 实现。插入元组或修改属性的值时，RDBMS 检查元组上的约束条件是否满足，否则拒绝操作。</p>
<p><img src="https://i.loli.net/2020/04/05/fNQagDl4ZItoTWi.png" alt="image-20200405164250636"></p>
<p>​    第一个 check 为属性上的约束，放在属性定义后，第二个 check 为元组上的约束。    </p>
<h4 id="完整性约束的修改"><a href="#完整性约束的修改" class="headerlink" title="完整性约束的修改"></a>完整性约束的修改</h4><p>​    要修改约束必须先删除约束，然后加入新的约束。</p>
<p><img src="https://i.loli.net/2020/04/05/n9JVSWwL5aC14o8.png" alt="image-20200405164505007"></p>
<h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>​    若要对 select 语句返回的结果值进行逐行处理，必须使用游标。可对游标的当前位置进行更新、查询和删除，使用游标必须经历 5 个步骤：</p>
<p>​    1）定义游标：declare；</p>
<p>​    2）打开游标：open；</p>
<p>​    3）逐行提取游标集中的行：fetch；</p>
<p>​    4）关闭游标：close；</p>
<p>​    5）释放游标：deallocate；</p>
<h4 id="游标的使用"><a href="#游标的使用" class="headerlink" title="游标的使用"></a>游标的使用</h4><h5 id="定义游标"><a href="#定义游标" class="headerlink" title="定义游标"></a>定义游标</h5><p><img src="https://i.loli.net/2020/04/05/vcoWwbID6UaBy2i.png" alt="image-20200405165033658"></p>
<p>​    read only 表示当前游标集中的元组仅可以查询，不可以修改。update表示可以对当前游标集中的元组进行更新操作，如果有 of &lt; columnName_list &gt;，表示仅可以对游标集中指定的属性列进行更新操作。</p>
<h5 id="打开游标"><a href="#打开游标" class="headerlink" title="打开游标"></a>打开游标</h5><p>​    系统按照游标的定义从数据库中将数据检索出来，放在内存的游标集中，并为游标集指定一个游标，该游标指向游标集中的第一个元组。</p>
<p>​    打开游标的语法：open &lt; cursorName &gt;</p>
<h5 id="获取当前游标值"><a href="#获取当前游标值" class="headerlink" title="获取当前游标值"></a>获取当前游标值</h5><p>​    要对当前游标所指向的元组进行操作，必须获取当前游标所指向的元组，其语法是</p>
<p>​    fetch &lt; cursorName &gt; into &lt; @variableName_list &gt;</p>
<p>​    <strong>获取当前游标的值，必须将当前游标所指向的元组的各个属性值分别用变量接收，其变量个数、数据类型必须与定义游标中的 select 子句所定义的属性（或表达式）个数数据类型相一致。</strong></p>
<p>​    SQL Server 中，变量名前面必须使用 @ 符号，使用一个 @ 符号位局部变量，使用两个 @ 为全局变量。</p>
<p>​    执行一次该语句，系统将当前游标所指向的元组属性放到变量中，然后游标自动下移一个元组。当游标移至尾部，则不可以再读取游标，必须关闭游标再重新打开游标。可以通过检查全局变量 @@FETCH_STATUS 来判断是否已经读完游标集中所有行。</p>
<p>​    @@FETCH_STATUS 的值有：</p>
<p>​    0 ：fetch 语句成功，表示已经从游标集中获取了元组值。</p>
<p>​    1：fetch 语句失败或此行不在结果集中。</p>
<p>​    2：被提取的行不存在。</p>
<h5 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h5><p>​    close  &lt; cursorName &gt;</p>
<h5 id="释放游标所占用的存储空间"><a href="#释放游标所占用的存储空间" class="headerlink" title="释放游标所占用的存储空间"></a>释放游标所占用的存储空间</h5><p>deallocate  &lt; cursorName &gt;</p>
<h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><p><img src="https://i.loli.net/2020/04/05/NUanJEF7lpHYyhA.png" alt="image-20200405195554371"></p>
<h4 id="对当前游标集的修改"><a href="#对当前游标集的修改" class="headerlink" title="对当前游标集的修改"></a>对当前游标集的修改</h4><p>​    可以对当前游标集中的元组执行删除和更新操作。</p>
<h5 id="删除游标集中的当前行"><a href="#删除游标集中的当前行" class="headerlink" title="删除游标集中的当前行"></a>删除游标集中的当前行</h5><p>​    delete from &lt; tableName &gt; where current of &lt; cursorName  &gt;</p>
<h5 id="更新游标集中的当前行"><a href="#更新游标集中的当前行" class="headerlink" title="更新游标集中的当前行"></a>更新游标集中的当前行</h5><p>​    update &lt; tableName &gt;</p>
<p>​    set &lt; columnName &gt;=&lt; expr &gt;[,&lt; columnName &gt;=&lt; expr &gt;…]</p>
<p>​    where current of &lt; cursorName &gt;</p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>​    存储过程是为了完成特定功能汇集而成的一组命名了的 SQL 语句集合，该集合编译后存放在数据库中，可按实际情况重新编译。</p>
<p>​    使用存储过程的优点：将业务操作封装、便于事务管理、实现一定程度的安全性保护、特别适合统计和查询操作、减少网络通信量。</p>
<h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><p><img src="https://i.loli.net/2020/04/05/vXtEcyQObCRpxT6.png" alt="image-20200405200322658"></p>
<p>​    output：输出参数，被调用者获取使用。</p>
<h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><p>​    存储过程创建后存放在数据库中，当要使用存储过程时，必须执行命令 execute。</p>
<p><img src="https://i.loli.net/2020/04/05/GlUWZ8rtMVhSO5y.png" alt="image-20200405200618013"></p>
<h4 id="修改和删除存储过程"><a href="#修改和删除存储过程" class="headerlink" title="修改和删除存储过程"></a>修改和删除存储过程</h4><h5 id="修改存储过程"><a href="#修改存储过程" class="headerlink" title="修改存储过程"></a>修改存储过程</h5><p><img src="https://i.loli.net/2020/04/05/z1no7G8baR5Yp9t.png" alt="image-20200405200745811"></p>
<p><img src="https://i.loli.net/2020/04/05/s79bqRDMnWKrEvm.png" alt="image-20200405200755212"></p>
<h5 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h5><p>​    drop procedure &lt; procedureName &gt;</p>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>​    触发器是用户定义在关系表上的一类由事件驱动的存储过程，由服务器自动激活。触发器可以进行更为复杂的检查和操作，具有更精细和强大的数据控制能力。</p>
<p>​    有两个特殊的表用在触发器语句中，不同的数据库其名称不一样。以SQL Server 为例介绍触发器。</p>
<p>​    1）deleted 表。存储 delete 和 update 语句执行时所影响的行的拷贝，在 delete 和 update 语句执行前被作用的行转移到 deleted 表中，即将被删除的元组或修改前的元组值存入该表中。</p>
<p>​    2）inserted 表。存储 insert 和 update 语句执行时所映像的行的拷贝，在 insert 和 update 语句执行期间，新行被同时加到 inserted 表和触发器中，即将被插入的元组或修改后的元组存入该表中，同时也更新基本表。</p>
<h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><p><img src="https://i.loli.net/2020/04/05/KzmCBDclWnp6hxR.png" alt="image-20200405201801494"></p>
<p>​    &lt;insert|update|delete&gt; ：触发器事件。</p>
<h4 id="修改和删除触发器"><a href="#修改和删除触发器" class="headerlink" title="修改和删除触发器"></a>修改和删除触发器</h4><p>​    修改触发器：</p>
<p><img src="https://i.loli.net/2020/04/05/rSV8gNdlaT6vQwx.png" alt="image-20200405202018722"></p>
<p>​    删除触发器：</p>
<p>​    drop trigger &lt; triggerName &gt;</p>
<h4 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h4><p>​    触发器常用于保证完整性，并在一定程度上实现安全性，如用触发器来进行审计。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><h3 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h3><p>操作系统特征：<strong>并发</strong>和<strong>共享</strong>。</p>
<h3 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h3><ul>
<li>资源管理：处理机管理、存储器管理、文件管理、设备管理。</li>
<li>用户与硬件的接口：命令接口、程序接口（系统调用）。</li>
</ul>
<h3 id="操作系统的分类和发展"><a href="#操作系统的分类和发展" class="headerlink" title="操作系统的分类和发展"></a>操作系统的分类和发展</h3><ol>
<li>手工操作阶段（无操作系统）</li>
<li>批处理阶段（操作系统开始阶段）解决人机矛盾和CPU和I/O速度不匹配的问题。分为单道批处理和多道批处理系统（内存中只能保持一道作业和能保持多道作业）。</li>
<li>分时操作系统。将 CPU 时间分为许多时间片，采用时间片轮转法，支持多道程序设计的系统。</li>
<li>实时操作系统。</li>
<li>网络操作系统和分布式操作系统。</li>
</ol>
<h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>中断也称为外中断，指来自 CPU 执行指令以外的事情发生，如 I/O 中断。时钟中断表示固定的时间片已到。</p>
<p>异常也称为内中断，指源自CPU执行指令或内存内部的时间，如程序的非法操作码、地址越界、算术溢出、缺页等引起的事件。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用可视为特殊的公共子程序。凡是与资源有关的操作（如存储分配、进行 I/O 传输及管理文件等），都必须通过系统调用方式向操作系统提出服务请求。</p>
<h3 id="核心态与用户态"><a href="#核心态与用户态" class="headerlink" title="核心态与用户态"></a>核心态与用户态</h3><p>系统调用需要使用某些特权指令才能完成，需要由操作系统内核程序负责完成。用户程序通过执行访管指令来发起系统调用，请求操作系统提供服务。执行操作系统内核应用程序时，CPU 会在核心态，执行用户程序时在用户态。</p>
<p>用户态转向核心态：系统调用、发生中断和异常、执行特权指令、进程状态变换。</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程的特征：动态性、并发性、独立性、异步性、结构性。进程实体都是由程序段、数据段和进程控制块三部分组成的。</p>
<h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><p>运行态：单处理机环境下，每个时刻最多只能有一个进程处于运行态。</p>
<p>就绪态：进程已经准备运行，等待 CPU 调度。</p>
<p>阻塞态：进程正在等待某一事件而暂停运行。</p>
<p>进程三大状态之间的转换忽略。</p>
<h3 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h3><p>引入线程的目的是为了更好地使用多道程序并发执行，提高资源利用率和系统吞吐率。引进线程地目的则是为了减少程序在并发执行时所付出地时空开销，提高操作系统地并发性能。</p>
<h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><ol>
<li>作业调度。又称高级调度，从外存上处于后备状态地作业中挑选一个或多个作业，给他们分配内存、输入/输出等必要的资源，并建立相应的进程。</li>
<li>内存调度。又称中级调度，其作用是提高内存利用率和系统吞吐量。将暂时不能运行的进程调至外存等待，当运行条件已经具备，再将就绪进程重新调入内存。</li>
<li>进程调度。又称低级调度，按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</li>
</ol>
<h3 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h3><h4 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h4><p>FCFS 调度算法既可以用于作业调度，又可以用于进程调度。算法简单，效率较低。<strong>对长作业比较有利，对短作业不利；有利于 CPU 繁忙型作业，不利于 I/O繁忙型作业</strong>。</p>
<h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><p>短作业优先算法从后备队列中选择一个或若干估计运行时间最短作业，将它们调入内存运行。对长作业不利，会导致“饥饿”现象，SJF 调度算法的平均等待时间、平均周转时间最少。</p>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p>既可用于作业调度，又可用于进程调度，优先级描述作业运行的紧迫程度。按高优先级进程能否抢占正在执行的进程分为剥夺式优先级调度算法和非剥夺优先级调度算法。根据优先级是否改变分为动态优先级和静态优先级。</p>
<h4 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h4><p>用于作业调度，是对FCFS调度算法和SJF调度算法的一种综合平衡，同时还考虑了每个作业的等待时间和估计运行时间。<br>$$<br>响应比R_p=\frac{等待时间+要求服务时间}{要求服务时间}<br>$$</p>
<h4 id="时间片轮转法"><a href="#时间片轮转法" class="headerlink" title="时间片轮转法"></a>时间片轮转法</h4><p>主要适用于分时系统，系统将所搜就绪进程按时间的先后顺序排成一个队列，进程调度程序选择就绪进程依次执行一个时间片。时间片很大时退化为 FCFS 算法，时间片很小时导致进程切换开销过大。</p>
<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p>时间片轮转法和优先级调度算法的综合与发展。通过动态调整进程优先级和时间片大小，多级反馈队列可以兼顾多方面的系统目标。设置多个就绪队列，并为每个队列赋予不同的优先级，在优先级越高的队列中，每个进程运行的时间片越小。</p>
<h3 id="进程的同步"><a href="#进程的同步" class="headerlink" title="进程的同步"></a>进程的同步</h3><h4 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h4><p>临界资源：一次只允许一个进程使用的资源称为临界资源。</p>
<p>临界区：访问临界资源的那段代码。</p>
<p>同步：直接制约关系，为完成某任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程之间的直接制约关系源于它们之间的合作。</p>
<p>互斥：间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界区资源的进程退出临界区后，另一个进程才允许访问此临界资源。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个进程因竞争资源而造成的一种相互等待的情况，若无外力作用，这些进程都将无法向前推进。</p>
<h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><ul>
<li>互斥条件</li>
<li>不可抢占条件</li>
<li>请求并保持条件</li>
<li>循环等待条件</li>
</ul>
<h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><ol>
<li>死锁预防，破环产生死锁 4 个条件中的一个或几个。</li>
<li>死锁避免，在动态分配资源过程中，用某种方法防止系统进入不安全状态。<strong>银行家算法</strong></li>
<li>死锁的检测及解除，通过系统检查出死锁的发生，采取某种措施解除死锁。</li>
</ol>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h3><h4 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h4><ol>
<li>内存空间的分配与回收，由操作系统完成主存储器空间的分配与管理。</li>
<li>地址转换，在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，存储器管理须提供地址变换功能，将逻辑地址转换为响应的物理地址。</li>
<li>内存空间的扩充，利用虚拟存储技术</li>
<li>存储保护，保证各道作业在各自的存储空间内运行，互不干扰。</li>
</ol>
<h4 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h4><p>将源程序变为可在内存中执行的程序，一般需要以下几个步骤：</p>
<ul>
<li>编译，将用户源代码编译成若干目标模块，形成<strong>逻辑地址</strong>。</li>
<li>链接，将编译后的目标模块及所需要的库函数链接在一起，形成整个完整的装入模块。</li>
<li>装入，将完整的装入模块装入内存。</li>
</ul>
<p>链接分为三种：</p>
<ol>
<li>静态链接，在程序运行前，链接库函数。</li>
<li>装入时动态链接，在程序装入内存时，将库函数链接。</li>
<li>运行时动态链接，在程序执行时，将库函数链接。</li>
</ol>
<p>装入分三种：</p>
<ol>
<li>绝对装入，逻辑地址和物理地址完全相同。</li>
<li>可重定位装入。将装入模块装入内存适当的位置，装入时对指令和数据的修改过程称为重定位。地址变化通常是在装入时一次完成。</li>
<li>动态运行时装入，装入程序把装入模块装入内存后，并不立即把模块中的相对地址转换为绝对地址，在程序运行的过程中才进行地址的转换。</li>
</ol>
<h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><ol>
<li>单一连续分配。在内存中永远只有一道程序，不会产生越界访问。</li>
<li>固定分区分配。将内存划分为若干固定大小的区域，每个分区只装入一道作业。</li>
<li>动态分区分配。在进程装入内存时，根据进程的大小动态地建立分区。</li>
</ol>
<p>动态分区的分配策略：</p>
<ul>
<li>首次适应算法，空闲分区按<strong>地址递增</strong>的次序链接，分配时按顺序查找，找到大小能满足要求的第一个空闲分区。</li>
<li>最佳适应算法，空闲分区按<strong>分区大小递增</strong>的次序链接，找到第一个能满足要求的分区。</li>
<li>最坏适应算法，空闲分区按<strong>分区大小递减</strong>的次序链接，找到第一个能满足要求的分区。</li>
<li>临近适应算法，分配内存时从上一次查找结束的位置开始继续查找。</li>
</ul>
<h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><p>非连续分配允许将一个程序分散地装入不相邻的内存分区。</p>
<p>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存块中的空间。</p>
<h5 id="1-分页"><a href="#1-分页" class="headerlink" title="1. 分页"></a>1. 分页</h5><p><strong>进程中的块称为页(Page)，内存中的块称为页框(Page Frame，或页帧)</strong>。外存也以同样的单位进行划分，直接称为块(Block)。进程在执行时需要申请主存空间，即为每个页面分配主存中的可用页框。</p>
<p>&emsp;&emsp;页面大小应该是2的整数幂。页面太小会使进程的页面过多，页表过长，占用大量的内存，增加硬件地址转换的开销，降低页面换人/换出的效率；页面过大会使内部碎片增多，降低内存利用率。</p>
<p>&emsp;&emsp;为了便于内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，它记录页面在内存中对应的物理块号，<strong>页表一般存放在内存中</strong>。页表由页表项组成，<strong>页表项 = 页号 + 页框号</strong>。<strong>物理地址 = 页内地址 + 页框号 &times; 页面大小</strong></p>
<h5 id="2-分段"><a href="#2-分段" class="headerlink" title="2. 分段"></a>2. 分段</h5><p>段式管理按照用户进程中的自然段划分逻辑空间。在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，这个工作由编译程序完成。</p>
<h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><h4 id="虚拟内存基本概念"><a href="#虚拟内存基本概念" class="headerlink" title="虚拟内存基本概念"></a>虚拟内存基本概念</h4><h5 id="传统存储管理方式的特征"><a href="#传统存储管理方式的特征" class="headerlink" title="传统存储管理方式的特征"></a>传统存储管理方式的特征</h5><p>1）一次性。作业必须一次性全部装入内存，才开始运行。</p>
<p>2）驻留性。作业被装入内存后，就一直驻留在内存中，可能造成进程长时间阻塞。</p>
<h5 id="局部性原则"><a href="#局部性原则" class="headerlink" title="局部性原则"></a>局部性原则</h5><p>1）时间局部性。程序中某条指令一旦执行，不久后该指令可能再次执行。</p>
<p>2）空间局部性。一旦程序访问了某个存储单元，不久后，其附近的存储单元也被访问。</p>
<h5 id="虚拟存储器的主要特性"><a href="#虚拟存储器的主要特性" class="headerlink" title="虚拟存储器的主要特性"></a>虚拟存储器的主要特性</h5><p>1）多次性。作业可分多次调入内存执行。</p>
<p>2）对换性。在作业运行过程中允许进行换入和换出。</p>
<p>3）虚拟性。从逻辑上扩充内存的容量。</p>
<h5 id="虚拟存储技术的实现"><a href="#虚拟存储技术的实现" class="headerlink" title="虚拟存储技术的实现"></a>虚拟存储技术的实现</h5><p>虚拟存储系统<strong>只能基于非连续分配技术</strong>，连续分配方式时，会使相当一部分内存空间处于暂时或者“永久”空闲的状态，严重造成内存资源的浪费。</p>
<p>1）请求分页存储管理</p>
<p>2）请求分段存储管理</p>
<p>3）请求段页式存储管理</p>
<p>不管哪种方式，都需要一定的<strong>硬件的支持</strong>，一般需要的支持有以下几个方面：</p>
<ul>
<li>一定容量的<strong>内存</strong>和<strong>外存</strong></li>
<li><strong>页表机制(或段表机制)</strong>，作为主要的数据结构</li>
<li><strong>中断机制</strong>，当用户程序要访问的部分尚未调入内存时，则产生中断</li>
<li><strong>地址变换机制</strong>，逻辑地址和物理地址的转换。</li>
</ul>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><h5 id="最佳-OPT-置换算法"><a href="#最佳-OPT-置换算法" class="headerlink" title="最佳(OPT)置换算法"></a>最佳(OPT)置换算法</h5><p>淘汰以后永久不使用的页面或者在最长时间内不再被访问的页面，以便保证获得最低的缺页率。由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因此该算法无法实现。</p>
<h5 id="先进先出-FIFO-页面置换算法"><a href="#先进先出-FIFO-页面置换算法" class="headerlink" title="先进先出(FIFO)页面置换算法"></a>先进先出(FIFO)页面置换算法</h5><p>优先淘汰最早进入内存的页面，即在内存中驻留时间最久的页面。</p>
<h5 id="最近最久未使用-LRU-置换算法"><a href="#最近最久未使用-LRU-置换算法" class="headerlink" title="最近最久未使用(LRU)置换算法"></a>最近最久未使用(LRU)置换算法</h5><p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近将来可能也不会被访问。</p>
<h5 id="时钟-CLOCK-置换算法"><a href="#时钟-CLOCK-置换算法" class="headerlink" title="时钟(CLOCK)置换算法"></a>时钟(CLOCK)置换算法</h5><p>简单的CLOCK算法给每帧关联一个附加位，称为<strong>使用位</strong>。当某页首次装入主存时，将该帧的使用位置为1。</p>
<h4 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h4><p>在页面置换算法中，<strong>刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存</strong>，这种频繁的页面调度行为称为<strong>抖动</strong>。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件三种分配方式比较"><a href="#文件三种分配方式比较" class="headerlink" title="文件三种分配方式比较"></a>文件三种分配方式比较</h3><table>
<thead>
<tr>
<th></th>
<th>访问第 n 条记录</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>连续分配</td>
<td>访问磁盘 1 次</td>
<td>顺序存取速度快，文件定长时可按文件起始地址及记录长度进行随机访问。</td>
<td>文件存储需要连续 的存储空间，会产生碎片，不利于文件的动态扩充</td>
</tr>
<tr>
<td>链式分配</td>
<td>访问磁盘 n 次</td>
<td>可解决外存的随便化问题，提高外存空间的利用率，动态增长较方便</td>
<td>只能按照文件的指针链顺序访问，查找效率低，指针信息存放消耗外存空间</td>
</tr>
<tr>
<td>索引分配</td>
<td>m 级需访问磁盘 m+1 次</td>
<td>可以随机访问，文件易于增删</td>
<td>索引表增加存储空间的开销，索引表的查找策略对文件系统效率影响较大</td>
</tr>
</tbody></table>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><table>
<thead>
<tr>
<th></th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务(FCFS)算法</td>
<td>按磁盘请求队列中的磁道号依次移动</td>
<td>公平、简单</td>
<td>平均寻道距离大，仅应用在磁盘I/O较少的 场合</td>
</tr>
<tr>
<td>最短寻找时间优先(SSTF)算法</td>
<td>选择离当前磁头距离最近的磁道</td>
<td>性能比“先来先服务”好</td>
<td>不能保证平均寻道时间最短，可能导致“饥饿”现象</td>
</tr>
<tr>
<td>扫描(SCAN)算法</td>
<td>按磁头移动方向移动到最边缘的磁道，然后反向</td>
<td>寻道性能较好，可避免“饥饿”现象</td>
<td>不利于远离磁头一端的访问请求</td>
</tr>
<tr>
<td>循环扫描(C-SCAN)算法</td>
<td>按磁头移动方向移动到最边缘的磁道，然后从另一端开始重新扫描</td>
<td>消除了对两端磁道请求的不公平</td>
<td>—</td>
</tr>
</tbody></table>
<h2 id="I-O-管理"><a href="#I-O-管理" class="headerlink" title="I/O 管理"></a>I/O 管理</h2><h3 id="I-O-控制方式"><a href="#I-O-控制方式" class="headerlink" title="I/O 控制方式"></a>I/O 控制方式</h3><ul>
<li>程序直接控制方式，每读一个字，CPU 对外设状态进行循环检查。CPU和I/O设备只能串行工作，CPU的利用率相对低。</li>
<li>中断驱动方式，允许I/O设备主动打断CPU的运行并请求服务，使得其向I/O控制器发送读命令后 CPU 继续做其它有用的工作。比程序直接控制更有效，但由于<strong>数据中的每个字在存储器与I/O控制器之间的传输都必须经过CPU</strong>，这就导致了中断驱动方式仍然会耗很多CPU时间。</li>
<li>DMA 方式，<strong>I/O设备和内存之间开辟直接的数据通路</strong>。</li>
<li>通道控制方式，I/O通道是专门负责输入/输出的处理机。I/O通道方式是DMA方式的发展，它<strong>可以减少CPU的干预</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>复试</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统概论</title>
    <url>/2020/04/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="数据库系统的作用"><a href="#数据库系统的作用" class="headerlink" title="数据库系统的作用"></a>数据库系统的作用</h3><h4 id="数据与数据管理"><a href="#数据与数据管理" class="headerlink" title="数据与数据管理"></a>数据与数据管理</h4><p>　　1）数据。描述事物的符号记录称为数据。数据是数据库中存储的对象，也是数据库管理系统处理的对象。数据和关于数据的解释是不可分的。</p>
<p>　　2）数据管理。数据处理是指对各种数据进行采集、存储、检索、加工、传播和应用等一系列活动的总和。数据管理是对数据进行有效的分类、组织、编码、存储、检索、维护和应用，它是数据处理的中心问题。</p>
<h4 id="数据管理技术的产生与发展"><a href="#数据管理技术的产生与发展" class="headerlink" title="数据管理技术的产生与发展"></a>数据管理技术的产生与发展</h4><p>　　1）人工管理阶段。面向应用程序，一个数据集只能对应一个程序，没有相应的软件系统专门负责数据的管理工作。当多个应用程序涉及某些相同的数据时，必须由各自的应用程序分别定义和管理这些数据，无法共享利用，存在大量冗余。</p>
<p>　　2）文件系统阶段。利用文件系统管理数据就是由专门的软件对数据进行统一管理。对于一个特定的应用，数据被集中组织存放在多个数据文件组中，并针对该文件组来开发特定的应用程序。文件系统利用“按文件名访问，按记录进行存取”的管理技术，可以对文件进行修改、插入和删除。</p>
<p>　　文件系统的弊端：数据共享性差，数据冗余和不一致。数据独立性差。数据孤立。数据获取困难。完整性问题（也称为一致性约束）。原子性问题。并发访问异常。安全性问题。</p>
<p>　　3）数据库管理系统阶段。数据库管理系统是由一个相互关联的数据的集合和一组用以访问、管理和控制这些数据的程序组成。这个数据集合通常称为数据库。</p>
<p>　　数据库管理系统的优点：</p>
<p>　　a. 数据整体结构化。</p>
<p>　　b.数据的共享度高，冗余度低，易扩充。<strong>数据独立性</strong>高。</p>
<p>　　c.数据独立性是用来描述数据与应用程序之间的依赖程度，包括数据的物理独立性和数据的逻辑独立性。</p>
<p>　　<strong>物理独立性</strong>是指用户的应用程序与存储在磁盘上数据库中的数据是相互独立的。</p>
<p>　　<strong>逻辑独立性</strong>是指用户的应用程序与数据的逻辑结构是相互独立的。</p>
<p>　　d.数据由数据库管理系统统一管理和控制</p>
<p>　　DBMS 必须提供：<strong>数据的安全性保护。数据的完整性检查。并发控制。数据库恢复。</strong></p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>　　数据模型是一个描述数据语义、数据与数据之间联系、数据操作，以及一致性（完整性）约束的概念工具的集合。通过数据模型可以对现实世界的数据特征进行抽象。</p>
<h4 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h4><p>　　数据模型应满足三方面的要求：一是能比较真实地模拟现实世界；二是容易被人所理解；三是便于在计算机上实现。</p>
<p>　　1）<strong>概念模型</strong>。又称信息模型，它按用户的观点或认识对现实世界的数据和信息进行建模，主要用于数据库设计。常用的概念模型有 E-R 模型，OO 模型。</p>
<p>　　2）<strong>逻辑模型</strong>。逻辑层是数据抽象的中间层，用于描述数据库数据的整体逻辑结构。该层的数据抽象称为逻辑数据模型。它是用户通过数据库管理系统看到的现实世界，是按计算机系统的观点对数据建模，即数据的计算机实现形式，主要用于 DBMS 的实现。</p>
<p>　　3）<strong>物理模型</strong>。物理层是数据抽象的最低层，用来描述数据的物理存储结构和存取方法。它不但由 DBMS 的设计决定，而且与操作系统、计算机硬件密切相关。</p>
<h4 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h4><p>　　1）<strong>数据结构</strong>。数据结构描述数据库的组成对象（数据）以及对象之间的联系。</p>
<p>　　2）<strong>数据操作</strong>。数据操作指对数据库中各种对象的实例允许执行的操作集合，包括操作及有关的操作规则。</p>
<p>　　3）<strong>数据的完整性约束条件</strong>。完整性规则是给定数据模型中数据及其联系所具有的制约和依存规则，用以限定复合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。</p>
<p>　　数据模型有：层次模型、网状模型、关系模型、面向对象模型、XML模型。</p>
<h4 id="数据抽象与数据库三级模式"><a href="#数据抽象与数据库三级模式" class="headerlink" title="数据抽象与数据库三级模式"></a>数据抽象与数据库三级模式</h4><h5 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a><strong>数据抽象</strong></h5><p>　　1）物理层抽象。最低层次的抽象，描述数据实际上是怎样存储的。</p>
<p>　　2）逻辑层抽象。描述数据库中存储什么数据以及这些数据之间存在什么关系。</p>
<p>　　3）视图层抽象。最高层次的抽象，只描述整个数据库的某个部分。</p>
<h5 id="数据库的三级模式"><a href="#数据库的三级模式" class="headerlink" title="数据库的三级模式"></a><strong>数据库的三级模式</strong></h5><p>　　模式是数据库中全体数据的逻辑结构和特征的描述，它仅仅设计型的描述，不涉及具体的值。模式的一个具体值称为模式的一个实例。</p>
<p>　　数据库的三级模式结构是指数据库管理系统提供的外模式、模式和内模式 3 个不同的抽象级别观察数据库中数据的角度。</p>
<p>　　1）模式。也称为逻辑层数据抽象。是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。DBMS 提供 数据定义语言（DDL）来严格定义模式。模式对应于表。</p>
<p>　　2）外模式。对应于视图层数据抽象，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述。</p>
<p>　　3）内模式。也称存储模式，对应于物理层数据抽象，它是数据的物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p>
<h5 id="数据库的两层映像功能与数据独立性"><a href="#数据库的两层映像功能与数据独立性" class="headerlink" title="数据库的两层映像功能与数据独立性"></a><strong>数据库的两层映像功能与数据独立性</strong></h5><p>　　1）<strong>外模式/模式映像</strong>。定义了外模式与模式之间的对应关系。当模式改变时，由数据库管理员对各个外模式/模式的映像作相应的改变，可以保持外模式不变。<strong>保证了数据与程序的逻辑独立性，简称为数据的逻辑独立性。</strong></p>
<p>　　2）<strong>模式/内模式映像</strong>。当数据库的存储结构改变了，由数据库管理员对模式。内模式映像作相应的改变，可以使模式保持不变。<strong>保证了数据与程序的物理独立性，简称为数据的物理独立性。</strong></p>
<h3 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h3><h4 id="数据库系统组成"><a href="#数据库系统组成" class="headerlink" title="数据库系统组成"></a>数据库系统组成</h4><p>　　从DBMS角度来看：数据库系统结构是外模式/模式/内模式的三级模式；从用户角度看：数据库系统分为单用户结构、主从式结构、分布式结构、客户/服务器、浏览器/应用服务器/数据库服务器等结构。</p>
<p>　　数据库中包含 4 类数据：用户数据、元数据、索引和应用元数据。用户数据就是通过结构化的关系（二维表）组织的所有业务数据的集合；元数据是对关系数据库结构的描述数据和数据库的有关统计数据，也成为数据字典；索引是为了改进数据库的性能和可访问性而建立的附件数据；应用元数据是用户窗体、报表、查询和其他形式的应用组件。</p>
<h4 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h4><h5 id="DBMS-的功能"><a href="#DBMS-的功能" class="headerlink" title="DBMS 的功能"></a><strong>DBMS 的功能</strong></h5><p>　　1）数据定义。DBMS 提供数据定义语言（Data Definition Language，DDL），用户通过它可以方便的对数据库中的数据对象进行定义。</p>
<p>　　2）数据组织、存储和管理。DBMS 分类组织、存储和管理各种数据，包括数据字典、用户数据、数据的存取路径等。</p>
<p>　　3）数据操纵。DBMS 还提供数据操纵语言（Data Manipulation Language，DML）用户通过它实现增删改查。</p>
<p>　　4）数据库的事务管理和运行。数据库在建立、运行和维护时由 DBMS 统一管理、统一控制，以保证数据的安全性、完整性、多用户对数据的并发操作以及发生故障后的系统恢复。</p>
<p>　　5）数据库的建立和维护。数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。</p>
<h5 id="DBMS-的组成"><a href="#DBMS-的组成" class="headerlink" title="DBMS 的组成"></a><strong>DBMS 的组成</strong></h5><p>　　1）模式更新。对数据库中的逻辑结构进行修改。</p>
<p>　　2）查询。</p>
<p>　　3）更新。</p>
<p>　　4）查询处理器。对用户请求的 SQL 操作进行查询优化。</p>
<p>　　5）存储管理器。根据执行策略，从数据库中取数据或更新数据。</p>
<p>　　6）事务管理器。负责保证系统的完整性，保证多个同时运行的事务不发生冲突。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>数组 Easy</title>
    <url>/2020/04/09/%E6%95%B0%E7%BB%84Easy/</url>
    <content><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h4><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<p>以 num[i] 为 HashMap 的 key，i 为 HashMap 的 value。每遍历到一个新的 nums[i] 判断 HashMap 中是否包含值为 target - nums[i] 的 key，如果包含则取出 key 的 value ，返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; numMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(numMap.containsKey(target-nums[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,numMap.get(target-nums[i])&#125;;</span><br><span class="line"></span><br><span class="line">            numMap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h4><p>给定一个排序数组，你需要在<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地</a></strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>



<p>我们使用i，j两个二指针， j 在前面走。如果 j 指向的元素等于 i 指向的元素 j 直接向前移，如果 j 指向的元素不等于 i 指向的元素，i 向前移 ，将 j 指向的元素赋给 i ，j向前移。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;nums.length;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] != nums[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-i != <span class="number">1</span>)&#123;</span><br><span class="line">                nums[++i]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ++i; <span class="comment">//i，j相邻 直接 ++i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h4><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p>使用异或，2^2 = 0，0 ^ n = n。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h4><p>给定一个已按照<strong><em>升序排列\</em></strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p>
<p><strong>说明:</strong></p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br></pre></td></tr></table></figure>

<p>双指针左右向数组中间移动，直到它们的和为 target。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=numbers.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[j]+numbers[i] &gt;target)&#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[j]+numbers[i] &lt;target)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></h4><p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>由于多数元素出现的次数比其他元素出现次数的总和还要多，我们可以设置一个计数 count 和 返回结果 majority ，</p>
<p>当出现的元素和 majority 相同时 count 加一， 当出现的元素和 majority 不同时 count 减一， 当 count 为 0 时更换 majority 为当前遍历的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                majority = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[i] == majority)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">268. 缺失数字</a></h4><p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>



<p>利用 2 ^2 = 0 ， 0 ^ 2 = 2 异或运算的特性，我们可以在线性时间复杂度找出缺失的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        res=res^(i+<span class="number">1</span>)^nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303. 区域和检索 - 数组不可变</a></h4><p>给定一个整数数组  <em>nums*，求出数组从索引 *i</em> 到 <em>j</em> (<em>i</em> ≤ <em>j</em>) 范围内元素的总和，包含 <em>i, j</em> 两点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>你可以假设数组不可变。</li>
<li>会多次调用 <em>sumRange</em> 方法。</li>
</ol>
<p>注意到 “假设数组不可变” 这个条件，我们可以自然地想到直接将一些区域和存储起来，多次调用 <em>sumRange</em> 方法时只用 O(1) 时间复杂度就可以得到结果。</p>
<p>在数组初始化的时候生成一个前 n 项和的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">     <span class="comment">//sum[i] 代表前 i (i&gt;=1) 个元素的和      </span></span><br><span class="line">     sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第i+1个 到 j+1个元素的和</span></span><br><span class="line">     <span class="keyword">return</span> sum[j+<span class="number">1</span>] - sum[i];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">392. 判断子序列</a></h4><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>你可以认为 <strong>s</strong> 和 <strong>t</strong> 中仅包含英文小写字母。字符串 <strong>t</strong> 可能会很长（长度 ~= 500,000），而 <strong>s</strong> 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<p><strong>示例 1:</strong><br><strong>s</strong> = <code>&quot;abc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p>
<p>返回 <code>true</code>.</p>
<p><strong>示例 2:</strong><br><strong>s</strong> = <code>&quot;axc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p>
<p>返回 <code>false</code>.</p>
<p>最直观的办法就是维护两个指针，判断子序列中的所有字符是否在原始字符串中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;t.length() &amp;&amp; j&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子字符串被全部匹配</span></span><br><span class="line">        <span class="keyword">return</span> j == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></h4><p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为<em>O(n)</em>的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>

<p>将当前元素的值的绝对值作为下标，将以当前元素为下标的数组元素值置位为负，再遍历一次数组即可找出所有未出现的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = Math.abs(nums[i])-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="532-数组中的K-diff数对"><a href="#532-数组中的K-diff数对" class="headerlink" title="532. 数组中的K-diff数对"></a><a href="https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/" target="_blank" rel="noopener">532. 数组中的K-diff数对</a></h4><p>给定一个整数数组和一个整数 <strong>k</strong>, 你需要在数组里找到<strong>不同的</strong> k-diff 数对。这里将 <strong>k-diff</strong> 数对定义为一个整数对 (i, j), 其中 <strong>i</strong> 和 <strong>j</strong> 都是数组中的数字，且两数之差的绝对值是 <strong>k</strong>.</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 1, 4, 1, 5], k &#x3D; 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。</span><br><span class="line">尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:[1, 2, 3, 4, 5], k &#x3D; 1</span><br><span class="line">输出: 4</span><br><span class="line">解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 3, 1, 5, 4], k &#x3D; 0</span><br><span class="line">输出: 1</span><br><span class="line">解释: 数组中只有一个 0-diff 数对，(1, 1)。</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ol>
<li>数对 (i, j) 和数对 (j, i) 被算作同一数对。</li>
<li>数组的长度不超过10,000。</li>
<li>所有输入的整数的范围在 [-1e7, 1e7]。</li>
</ol>
<p>我们先将整数数组排序， 从第一个元素开始 向右寻找 diff 为 k 的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//去掉相同元素</span></span><br><span class="line">        <span class="keyword">for</span>(;i&gt;<span class="number">0</span>&amp;&amp;i&lt;nums.length&amp;&amp;nums[i]==nums[i-<span class="number">1</span>];i++);</span><br><span class="line">　　　　　　　<span class="comment">//向右寻找</span></span><br><span class="line">        j=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;nums.length&amp;&amp;nums[j]-nums[i]&lt;k;j++);</span><br><span class="line">        <span class="comment">//找到一对 j-i==k</span></span><br><span class="line">        <span class="keyword">if</span>(j&lt;nums.length&amp;&amp;nums[j]-nums[i]==k)</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="面试题29-顺时针打印矩阵"><a href="#面试题29-顺时针打印矩阵" class="headerlink" title="面试题29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">面试题29. 顺时针打印矩阵</a></h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code></li>
</ul>
<p>方法一：模拟</p>
<p>可以模拟打印矩阵的路径，初始位置是矩阵的左上角，初始方向是向右，当越界或者进入访问过的位置就顺时针旋转进入另一个方向。</p>
<p>判断是否访问过数组中的某一个元素需要一个 visited 数组，当元素被访问过时将其设置为 true。当路径的长度等于矩阵中元素数量时，结束循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span> total = rows * cols;</span><br><span class="line">        <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[total];</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//矩阵顺时针旋转遍历方向：右、下、左、上</span></span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++)&#123;</span><br><span class="line">            order[i] = matrix[row][col];</span><br><span class="line">            visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//获得下一行的横纵坐标</span></span><br><span class="line">            <span class="keyword">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>], nextCol = col + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//判断下一个坐标是否访问过或者越界</span></span><br><span class="line">            <span class="keyword">if</span>(nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextCol &lt; <span class="number">0</span> || nextCol &gt;= cols || visited[nextRow][nextCol])&#123;</span><br><span class="line">                <span class="comment">//顺时针旋转</span></span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新下一个需要访问的坐标</span></span><br><span class="line">            row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            col += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(mn)，空间复杂度O(mn)。</p>
<p>方法二：按层模拟</p>
<p>可以将矩阵看成若干层，首先打印最外层的元素，其次打印次外层的元素，直到打印最内层的元素。</p>
<p>对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于(top, left)，右下角位于(bottom, right)，按照如下顺序遍历当前层的元素。</p>
<ol>
<li><p>从左到右遍历上侧元素，依次为(top, left) 到 (top, right)</p>
</li>
<li><p>从上到下遍历右侧元素，依次为(top + 1, right) 到(bottom, right)。</p>
</li>
<li><p>如果 left &lt; right 且 top &lt; bottom ，则从右向左遍历下侧元素，依次为(bottom, right - 1) 到 (bottom, left + 1)，以及从下到上遍历左侧元素，依次为 (bottom, left) 到 (top + 1, left)。</p>
</li>
</ol>
<p>遍历完当前层的元素之后，将 left 和 top 分别增加 1 ，将 right 和 bottom 分别减少 1，进入下一层遍历。</p>
<p>下图来自 <a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shun-shi-zhen-da-yin-ju-zhen-by-leetcode-solution/" target="_blank" rel="noopener">Leetcode</a>。</p>
<p><img src="https://i.loli.net/2020/06/05/oznBqb5HX2FDQfP.png" alt="image-20200605105850949"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[rows * cols];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = cols - <span class="number">1</span>, top = <span class="number">0</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom)&#123;</span><br><span class="line">            <span class="comment">//遍历上侧元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = left; c &lt;= right; c++)&#123;</span><br><span class="line">                order[index++] = matrix[top][c];</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//遍历右侧元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r = top + <span class="number">1</span>; r &lt;= bottom; r++)&#123;</span><br><span class="line">                order[index++] = matrix[r][right];</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 不满足 left &lt; right &amp;&amp; top &lt; bottom 代表只有一行或者一列，遍历上侧和右侧元素即可。</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right &amp;&amp; top &lt; bottom)&#123;</span><br><span class="line">                <span class="comment">//遍历下侧元素</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = right - <span class="number">1</span>; c &gt; left; c--)&#123;</span><br><span class="line">                    order[index++] = matrix[bottom][c];</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//遍历左侧元素</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> r = bottom; r &gt; top; r--)&#123;</span><br><span class="line">                    order[index++] = matrix[r][left];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入下一层</span></span><br><span class="line">            left++ ;</span><br><span class="line">            right-- ;</span><br><span class="line">            top++ ;</span><br><span class="line">            bottom-- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(mn)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组 Medium</title>
    <url>/2020/04/17/%E6%95%B0%E7%BB%84Medium/</url>
    <content><![CDATA[<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h4><p>给你 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p>
<p><img src="https://i.loli.net/2020/04/21/23RAHzps9cYvGKC.jpg" alt="img"></p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>

<p>使用双指针。左指针为 i，右指针为 j 。水的容量为 (j - i) * min(i , j) 。我们需要维护一个容器的容量的最大值。我们需要找出最大的容量。此时需要向中间移动左右指针中比较小的那个值。证明：一般 i &lt; j ，容器的容量为  <code>min(height[i] , height[j])*(j-i)</code> , 如果我们将两个指针中的比较高的值向中间移动，那么得到的容量一定小于前面算出的容量（j 变小了，i 不变，两个边界最小值不变）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=height.length-<span class="number">1</span>; i&lt;=j ;)&#123;</span><br><span class="line">            <span class="comment">//维护最大容量</span></span><br><span class="line">            max = Math.max(max, (j-i) * Math.min(height[i], height[j]) );</span><br><span class="line">            <span class="comment">//移动高度较小的指针</span></span><br><span class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure>

<p>对于数组中任意一个位置 i，最远到达的位置为 i + nums[i] 。实时维护一个可到达的最远位置 rightmax，如果rightmax 大于数组最后一个位置的下标即可返回true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rightmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">                 <span class="comment">//最远可到达 rightmax </span></span><br><span class="line">            <span class="keyword">if</span>(i &lt;= rightmax)&#123;</span><br><span class="line">            	<span class="comment">//实时更新 rightmax 的值</span></span><br><span class="line">            rightmax = Math.max(rightmax , i+nums[i]);</span><br><span class="line">                <span class="comment">//大于最后一个位置的下标返回 true</span></span><br><span class="line">            <span class="keyword">if</span>(rightmax &gt;= n-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. 除自身以外数组的乘积</a></h4><p>给你一个长度为 <em>n</em> 的整数数组 <code>nums</code>，其中 <em>n</em> &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。</p>
<p> <strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong>题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p>
<p><strong>说明:</strong> 请<strong>不要使用除法，</strong>且在 O(<em>n</em>) 时间复杂度内完成此题。</p>
<p><strong>进阶：</strong><br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。）</p>
<p>一看到这个题，我们立刻想到求出数组中所有元素的乘积然后除以对应位置的元素，得到除自身以外的数组的乘积，但是很遗憾，我们并不能使用除法。</p>
<p>看到题目的提示中前缀和后缀，我们想到除自身以外数组的乘积就是数组中一个元素的前缀积乘后缀积，示例中元素 1 的前缀元素为 1 ，后缀元素为 2，3，4，最后得到结果 1 * 24 = 24。元素 3 的前缀元素为 1， 2，后缀元素为 4，最后得到结果 2 * 4 = 8。</p>
<p>我们可以先生成前缀积数组和后缀积数组，求两数组中对应位置元素的积就得到最后的答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] L = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] R = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成前缀数组</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            L[i] = L[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成后缀数组</span></span><br><span class="line">        R[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            R[i] = R[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++)&#123;</span><br><span class="line">            ans[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度O(n)。</p>
<p>我们可以直接使用 ans 数组来代替前缀数组，最后直接使用 ans 数组乘后缀数组得到结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] R = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成前缀数组</span></span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            ans[i] = ans[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成后缀数组</span></span><br><span class="line">        R[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            R[i] = R[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++)&#123;</span><br><span class="line">            ans[i] *= R[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度不变。</p>
<p>更进一步，我们可以使用一个元素 R 来代替 后缀数组，在每次遍历时更新 R 的值即可实现和后缀数组相同的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 生成前缀数组</span></span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            ans[i] = ans[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span> ; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            ans[i] *= R;</span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度O(1)。</p>
<h4 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/" target="_blank" rel="noopener">974. 和可被 K 整除的子数组</a></h4><p>给定一个整数数组 <code>A</code>，返回其中元素之和可被 <code>K</code> 整除的（连续、非空）子数组的数目。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [4,5,0,-2,-3,1], K &#x3D; 5</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">有 7 个子数组满足其元素之和可被 K &#x3D; 5 整除：</span><br><span class="line">[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>2 &lt;= K &lt;= 10000</code></li>
</ol>
<p>暴力解法：使用两个循环枚举子数组的起点和终点，统计子数组的和并判断是否整除 k 。时间复杂度 O(n^3) 空间复杂度 O(1)。</p>
<p>暴力解法优化：使用一个数组存储前缀和 p[i] 表示[0…i]的数字之和，p[j] - p[i] 表示一个子数组的和。时间复杂度 O(n^2) 空间复杂度 O(n)。</p>
<p>哈希表：使用哈希表存储，以前缀和模 K 的值为键，其值出现的次数为值。在遍历数组的同时更新。我们需要对哈希表初始化，即余数为 0 出现的次数为 1 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; record = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        record.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : A)&#123;</span><br><span class="line">            sum += e;</span><br><span class="line">            <span class="comment">//Java 负数取模产生负数，需要纠正</span></span><br><span class="line">            <span class="keyword">int</span> mod = (sum % K + K) % K;</span><br><span class="line">            <span class="comment">//得到前缀和模 K 的值出现的次数</span></span><br><span class="line">            <span class="keyword">int</span> times = record.getOrDefault(mod, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//更新结果和以 mod 为余数的前缀和出现的次数</span></span><br><span class="line">            ans += times;</span><br><span class="line">            record.put(mod, times + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n) 遍历一次数组，空间复杂度 O( min (n, k) ) 模 k 得到的余数最多有 k 个。</p>
<p>我们还可以先生成哈希表，得到前缀和模 k 的值出现的次数 n，对于这个值，和可被 k 整除的子数组的个数为 n(n-1)/2，类似于冒泡排序的两两比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; record = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        record.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : A)&#123;</span><br><span class="line">            sum += e;</span><br><span class="line">            <span class="comment">//Java 负数取模产生负数，需要纠正</span></span><br><span class="line">            <span class="keyword">int</span> mod = (sum % K + K) % K;</span><br><span class="line">            record.put(mod, record.getOrDefault(mod, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : record.entrySet())&#123;</span><br><span class="line">            ans += entry.getValue() * (entry.getValue() - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度同上。</p>
<h4 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。</p>
<p>如果某个 <strong>连续</strong> 子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p>
<p>请返回这个数组中「优美子数组」的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,1,1], k &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,4,6], k &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line">解释：数列中不包含任何奇数，所以不存在优美子数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,1,2,2,1,2,2,2], k &#x3D; 2</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<p>在这个题目中偶数是没有用的，我们可以建立一个 odd 数组来记录第 i 个奇数的下标，假设当前枚举到第 i 个，那么 <code>[odd[i], odd[i+k-1]]</code> 这个子数组恰好包含 k 个奇数。这个范围左侧的奇数下标为 odd[i-1], 右侧的奇数下标为 odd[i+k]。如果<code>[odd[i], odd[i+k-1]]</code> 这个包含 k 个奇数的子数组左右侧都右偶数，那么满足条件的包含 k 个奇数的子数组个数为  (<em>odd</em>[<em>i</em>]−<em>odd</em>[<em>i</em>−1])∗(<em>odd</em>[<em>i</em>+<em>k</em>]−<em>odd</em>[<em>i</em>+<em>k</em>−1]) 。我们只要遍历一遍 odd 数组即可求解答案。</p>
<p>边界处理：</p>
<ol>
<li>当 nums[0] 为奇数时，odd[1] = 0，此时左边没有偶数 odd[1] - odd[0] 应该为 1（只有 nums[0] 为子数组左侧边界）。此时 odd[0] = -1。</li>
<li>当记录最后一个奇数时（假设这是第 index 个奇数，对应 nums 数组中的下标为 x）， odd[index] = x, odd[index+1] = nums.length。odd 数组最后一个元素记录的是数组中所有元素的数量。</li>
</ol>
<p>以示例 3 来解释：我们生成的 odd 数组为 [-1, 3, 6, 10]，对其遍历一遍得到结果 (3 - (-1)) * (10-6) = 16。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] odd = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成 odd 数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>)odd[++index] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//边界处理</span></span><br><span class="line">        odd[<span class="number">0</span>] = -<span class="number">1</span>; odd[++index] = n;</span><br><span class="line">		<span class="comment">//计算结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+k &lt;= index; ++i)&#123;</span><br><span class="line">            ans += (odd[i] - odd[i-<span class="number">1</span>])*(odd[i+k] - odd[i+k-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="面试题56-I-数组中数字出现的次数"><a href="#面试题56-I-数组中数字出现的次数" class="headerlink" title="面试题56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56 - I. 数组中数字出现的次数</a></h4><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>2 &lt;= nums &lt;= 10000</code></li>
</ul>
<p>一个整型数组 <code>nums</code> 里除一个数字之外，其他数字都出现了两次。这个问题我们直接将 <code>nums</code> 数组中所有数字异或即可得到结果。现在只出现一次的数字有两个，我们再将所有数字进行异或即可得到两个只出现一次的数字的异或结果。</p>
<p>如果将这两个数字分别分成两组，一组里面含有一个出现一次的数字。我们直接将两组中的所有数字异或即可得到结果。</p>
<p>如何分组？我们从两个只出现一次的数字的异或结果入手，找出两个数字中不同的<strong>位</strong>（该位为 1 ）， 按照这个不同的位将所有数字分为两组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如 [4,1,4,6] 数组中所有数字异或的结果为 1 ^ 6 &#x3D; 7</span><br><span class="line">将 7 表示为二进制 0111（忽略前面的 28 个 0）</span><br><span class="line">我们可以将数字的最后三位中任选一位作为分组的判断。</span><br><span class="line">例如将倒数第一位为 0 分为第一组 得到[4,4,6]</span><br><span class="line">将倒数第一位为 1 分为第二组 得到[1]</span><br><span class="line">分别将这两组中的数字全部异或即可得到结果 1 和 6。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//计算两个只出现一次数字的异或结果</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ret ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出用来分组的那一位</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((idx &amp; ret) == <span class="number">0</span>)&#123;</span><br><span class="line">            idx = idx &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//分组异或计算结果</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; idx) == <span class="number">0</span>)&#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层</title>
    <url>/2020/04/04/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a><strong>通信基础</strong></h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="数据、信号与码元"><a href="#数据、信号与码元" class="headerlink" title="数据、信号与码元"></a>数据、信号与码元</h5><p>　　1）数据：传送信息的实体。</p>
<p>　　2）信号：数据的电气或电磁表现，是数据在传输过程中的存在形式。</p>
<p>　　3）码元：用一个固定时长的信号波形表示一位k进制数字。</p>
<p>　　</p>
<h5 id="信源、信道与信宿"><a href="#信源、信道与信宿" class="headerlink" title="信源、信道与信宿"></a>信源、信道与信宿</h5><p>　　1）信源：产生与发送数据的源头 。2）信道：信号的传输媒介。3）信宿：接收数据的终点。</p>
<p>　　</p>
<h5 id="速率、波特与带宽"><a href="#速率、波特与带宽" class="headerlink" title="速率、波特与带宽"></a>速率、波特与带宽</h5><p>　　速率：单位时间传输的数据量。可以用码元传输速率和信息传输速率表示。</p>
<p>　　1）码元传输速率：单位时间内传输的码元个数。单位为波特Baud。</p>
<p>　　2）信息传输率：单位时间内传输的比特数，单位 b/s。</p>
<p>　　</p>
<h4 id="奈奎斯特定理和香农定理"><a href="#奈奎斯特定理和香农定理" class="headerlink" title="奈奎斯特定理和香农定理"></a>奈奎斯特定理和香农定理</h4><p>　　1）奈奎斯特定理：<strong>在理想低通信道中极限码元传输率为2W波特，其中W是理想低通信道的带宽单位为Hz。</strong>若用V来表示每个码元离散电平的数目，比如有16种不同的码元，采用NRZ码传输，发送一位需要1个信号周期，一个码元含有4bit信息量，若采用Manchester码 ，发送一位需要2个信号周期，一个码元含有2bit信息量。如果只有两种码元，采用NRZ，每个码元含有1bit信息量；采用Manchester，每个码元含有0.5bit信息量。</p>
<p>　　<strong>极限数据传输率 = 2W*log2(V)</strong></p>
<p>　　2）香农定理：给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率</p>
<p>　　<strong>信道的极限数据传输率 = W*log2(1+S/N)</strong></p>
<p> 　</p>
<h4 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h4><p>　　<img src="https://i.loli.net/2020/04/04/TgmOEQv4BAeCZXt.png" alt="img"></p>
<p> 　   归零编码（RZ）：高电平为1，低电平为0，在每个时钟周期中间均跳变到低电平。</p>
<p>　　非归零编码（NRZ）：高电平为1，低电平为0，无法传递时钟信号难以同步。</p>
<p>　　反转非归零码（NRZI）：用信号的翻转代表0，信号保持不变代表1。</p>
<p>　　曼彻斯特码（Manchester）：10 表示高电平，01表示低电平。以太网使用。</p>
<p>　　差分曼彻斯特码：若下一个电平为低，在码元边界反转，若为高电平则保持不变。</p>
<h4 id="电路交换、报文交换与分组交换"><a href="#电路交换、报文交换与分组交换" class="headerlink" title="电路交换、报文交换与分组交换"></a>电路交换、报文交换与分组交换</h4><p>　　1）电路交换：在进行数据传输前，两个结点之间必须<strong>建立一条双方独占的物理通信路径</strong>。时延小，有序传输，无冲突，实时性强。建立连接时间长，线路独占，灵活性差，难以规格化。</p>
<p>　　2) 报文交换：<strong>数据交换的单位是报文</strong>，报文携带有目标地址、源地址等信息。报文交换在交换结点采用存储转发的传输方式。无须建立连接，动态分配线路，提高线路可靠性提高线路利用率，提供多目标服务。转发时延大，需要较大缓存空间。</p>
<p>　　3）分组交换：<strong>限制每次传送数据块大小上限，</strong>采用存储–转发方式。无建立时延，线路利用率高、简化存储管理，加速传输，减少出错概率和重发数据量。存在传输时延，需要传输额外的信息量，当分组交换使用数据报服务时会出现失序、丢失或者重复分组，需要重新排序分组。采用虚电路服务，无失序问题但有呼叫建立、数据传输和虚电路释放三个过程。</p>
<p><img src="https://i.loli.net/2020/04/04/2LT6fPzRjcS7sOm.png" alt="img"></p>
<h4 id="数据报和虚电路"><a href="#数据报和虚电路" class="headerlink" title="数据报和虚电路"></a>数据报和虚电路</h4><p>　　<strong>分组交换可分为面向连接的虚电路方式和无连接的数据报方式</strong>。这两种服务方式都由网络层提供。（IP分组）数据报方式和虚电路方式是分组交换的两种方式。</p>
<p>　　1）数据报：高层协议先将报文拆成若干个带序号的数据单元，在网络层加上控制信息形成数据报分组。<strong>不同的分组可以走不同的路径，也可以按不同的顺序到达目的结点。</strong></p>
<p>　　2）虚电路：在发送发和接收方建立一条逻辑上相连的虚电路，连接一旦确立就固定了虚电路所对应的物理路径。与电路交换类似，分为虚电路建立、数据传输和虚电路释放。端系统每次建立虚电路时，选择一个未使用过的虚电路号分配给该虚电路。<strong>每个数据分组不仅要有分组号、校验和控制信息还要有它要通过的虚电路号。</strong></p>
<p><img src="https://i.loli.net/2020/04/04/b4jrLfc7wiYvuMe.png" alt="img"></p>
<h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a><strong>传输介质</strong></h3><h4 id="双绞线、同轴电缆、光纤与无线传输介质"><a href="#双绞线、同轴电缆、光纤与无线传输介质" class="headerlink" title="双绞线、同轴电缆、光纤与无线传输介质"></a>双绞线、同轴电缆、光纤与无线传输介质</h4><p>　　传输介质是发送设备和接收设备之间的物理线路。</p>
<p>　　1）双绞线：由两根采用一定规则并排绞合的互相绝缘的铜导线组合而成，绞合可以减少对相邻导线的电磁干扰。模拟传输和数字传输都可使用。</p>
<p>　　2）同轴电缆：由内导体、绝缘层、网状编织层和塑料外层构成。</p>
<p>　　3）光纤：主要由纤心和包层构成，利用光的全反射。</p>
<p>　　4）无线传输介质：无线电波 微光、红外光和激光。</p>
<p>　　</p>
<h4 id="物理层接口的特性"><a href="#物理层接口的特性" class="headerlink" title="物理层接口的特性"></a>物理层接口的特性</h4><p>　　1）机械特性：规定物理连接时所采用的规格、引线的数目、引脚的数量和排列情况。</p>
<p>　　2）电气特性：规定传输二进制位时，线路上信号的电压高低、阻抗匹配、传输速率和距离限制等。</p>
<p>　　3）功能特性：指明某条线上出现的某一电平的电压表示何种意义，接口部件的信号线用途。</p>
<p>　　4）规程特性：定义各条物理线路的工作规程和时序关系。</p>
<h3 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a><strong>物理层设备</strong></h3><h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><p>　　中继器又称转发器，主要功能是将信号整形并放大再转发出去，消除衰减，<strong>其原理是信号再生</strong>。有两个端口输入和输出端口。使用中继器连接的几个网段仍是一个局域网，它不能连接两个具有不同速率的局域网，它没有存储转发功能。中继器两端的网络部分是网段，而不是子网。</p>
<h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>　　集线器实质上是一个多端口的中继器工作在物理层。当Hub工作时，一个端口收到数据信号后，将其整形放大，使之再生然后转发到其他所有端口，Hub在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，不具备信号的定向传输能力。Hub组成的网络是共享式网络，逻辑上仍是一个总线网，Hub只能在半双工状态下工作。集线器不能分割冲突域，例如一个带宽为10Mbps 的集线器上连接了8台计算机，8台计算机同时工作时，每台计算机真正拥有的带宽时1.25Mbps。</p>
<h3 id="本章小结及疑难点"><a href="#本章小结及疑难点" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="奈式准则和香农公式的主要区别是什么？这两个公式对数据通信的意义是什么？"><a href="#奈式准则和香农公式的主要区别是什么？这两个公式对数据通信的意义是什么？" class="headerlink" title="奈式准则和香农公式的主要区别是什么？这两个公式对数据通信的意义是什么？"></a>奈式准则和香农公式的主要区别是什么？这两个公式对数据通信的意义是什么？</h4><p>​        奈式准则指出了，码元传输的速率是受限的，不能任意提高，否则在接收端就无法正确判断码元是 1 还是 0（因为有码元之间的相互干扰）。</p>
<p>​        奈式准则是在理想条件下推导出的。在实际条件下，最高码元传输速率要比理想条件下得出的数值还要小些。奈式准则并没有对信息传输速率给出限制，要提高信息传输率就要提高每个码元所含的信息量。</p>
<p>​        香农公式给出了信息传输率的极限，即对于一定的传输带宽（Hz）和一定的信噪比，信息传输率的上限就确定了。要想提高信息的传输速率，必须设法提高传输线路的带宽或提高所传信号的信噪比。</p>
<h4 id="同步通信和异步通信的区别是什么？"><a href="#同步通信和异步通信的区别是什么？" class="headerlink" title="同步通信和异步通信的区别是什么？"></a>同步通信和异步通信的区别是什么？</h4><p>​        “异步通信”是一种很常用的通信方式。接收端必须时刻做好接收准备。发送端可以在任意时刻发送字符。异步通信可以用字符和帧作为发送单位，但必须注意字符或帧的开始和结束标识。</p>
<p>​        “同步通信”的通信双方必须先建立同步，即双方的时钟要调整到同一个频率。收发双方不停地接收连续的同步比特流。</p>
<h4 id="位同步和帧同步的区别是什么？"><a href="#位同步和帧同步的区别是什么？" class="headerlink" title="位同步和帧同步的区别是什么？"></a>位同步和帧同步的区别是什么？</h4><p>​        位同步是指接收端时钟已经调整到和发送端时钟完全一样，因此接收端收到比特流后，就能在每一位的中间位置进行判决。位同步的目的是为了将发送端发送的每一个比特都正确的接收下来。仅仅有位同步还不够，因为数据以帧为单位进行发送。一个帧必须有明确的界限，也就是有帧定界符。接收端在收到比特流后，必须能够正确地找出帧定界符，以便知道哪些比特构成一个帧。接收端确定了帧的准确位置就是完成了帧同步。</p>
<p><img src="https://i.loli.net/2020/04/27/MYGosKipFAkC62X.png" alt="image-20200427161642085"></p>
<p><img src="https://i.loli.net/2020/04/27/U3H9wYFLjGCya6D.png" alt="image-20200427161701168"></p>
<p><img src="https://i.loli.net/2020/04/10/CD5szARNdXO238P.png" alt="image-20200410102252708"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2020/04/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="结构型模式–享元模式"><a href="#结构型模式–享元模式" class="headerlink" title="结构型模式–享元模式"></a>结构型模式–享元模式</h1><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。它减少对象数量从而改善应用所需的对象结构的方式。享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建对象。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。</p>
<p><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p>
<p><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p>
<p><strong>关键代码：</strong>用 HashMap 存储这些对象。</p>
<p><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。</p>
<p><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。</p>
<p><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>
<p><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。</p>
<p><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 <em>Shape</em> 接口和实现了 <em>Shape</em> 接口的实体类 <em>Circle</em>。下一步是定义工厂类 <em>ShapeFactory</em>。</p>
<p><em>ShapeFactory</em> 有一个 <em>Circle</em> 的 <em>HashMap*，其中键名为 *Circle</em> 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。<em>ShapeFactory</em> 检查它的 <em>HashMap</em> 中的 circle 对象，如果找到 <em>Circle</em> 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。</p>
<p><em>FlyWeightPatternDemo*，我们的演示类使用 *ShapeFactory</em> 来获取 <em>Shape</em> 对象。它将向 <em>ShapeFactory</em> 传递信息（<em>red / green / blue/ black / white</em>），以便获取它所需对象的颜色。</p>
<p><img src="https://i.loli.net/2020/04/04/mkq83nVXFwSI6Kp.png" alt="img"></p>
<p> 1、创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">int</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"circle::draw() [color: "</span>+color+<span class="string">", x: "</span>+x+<span class="string">", y: "</span>+y+<span class="string">", radius: "</span>+radius+<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建一个工厂，生成基于给定信息的实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String,Shape&gt; circleMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String color)</span></span>&#123;</span><br><span class="line">        Circle circle = (Circle)circleMap.get(color);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(circle == <span class="keyword">null</span>)&#123;</span><br><span class="line">            circle = <span class="keyword">new</span> Circle(color);</span><br><span class="line">            circleMap.put(color,circle);</span><br><span class="line">            System.out.println(<span class="string">"Creating circle of color: "</span>+color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用该工厂，通过传递颜色信息来获取实体类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeightDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String colors[]=&#123;<span class="string">"Red"</span>,<span class="string">"Green"</span>,<span class="string">"Blue"</span>,<span class="string">"White"</span>,<span class="string">"Black"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Circle circle = (Circle)ShapeFactory.getShape(getRandomColor());</span><br><span class="line">            circle.setRadius(<span class="number">100</span>);</span><br><span class="line">            circle.setX(getRandomX());</span><br><span class="line">            circle.setY(getRandomY());</span><br><span class="line">            circle.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRandomColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> colors[(<span class="keyword">int</span>)Math.random()* colors.length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomY</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/E7unTaG5r1qLNU6.png" alt="img"></p>
<p> 我们重用了 key 为红色的圆。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>数据链路层</title>
    <url>/2020/04/04/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h3 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h3><h4 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h4><p>　　对网络层而言，数据链路层的基本任务是将源机器中来自网络层的数据传输到目标机器的网络层。</p>
<p>　　1）无确认的无连接服务。源机器发送数据帧时<strong>不需要先建立链路连接</strong>，目的机器收到数据帧时<strong>无需发回确认</strong>，对于<strong>丢失的帧交给上层处理</strong>。<strong>适用于实时通信或误码率较低的通信信道，如以太网</strong>。</p>
<p>　　2）有确认的无连接服务。源机器发送数据帧时<strong>不需要先建立链路连接</strong>，目的机器收到数据帧时<strong>必须发回确认。</strong>源机器在规定的时间内未收到确认信号时就<strong>重传丢失的帧</strong>。适用于误码率较高的通信信道，如无线通信。</p>
<p>​        3）有确认的面向连接服务。帧传输过程分为三个阶段：建立数据链路、传输帧、释放数据链路。目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧。适用于通信要求（可靠性、实时性）较高的场合。</p>
<p>　　</p>
<h4 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h4><p>　　数据链路层连接的建立、维持和释放过程称为链路管理，它主要用于面向连接的服务。链路两端的结点要通信必须首先确认对方已处于就绪状态，并交换一些必要的信息以对帧序号初始化，然后才能建立连接，在传输过程中能要维持连接，传输完成后要释放该连接。</p>
<p>　　</p>
<h4 id="帧定界、帧同步与透明传输"><a href="#帧定界、帧同步与透明传输" class="headerlink" title="帧定界、帧同步与透明传输"></a>帧定界、帧同步与透明传输</h4><p>　　两个工作站之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送。将一段数据的前后分别<strong>添加首部和尾部</strong>就构成了帧。首部和尾部含有很多控制信息，它们的一个重要作用是确定帧的边界，即<strong>帧定界</strong>。帧同步指的是接收方应能从收到的二进制比特流中区分帧的起始和终止。如在  <strong>HDLC 通信规程中用标识位F（01111110）来标识帧的开始和结束。</strong>检测到帧标识位 F 即认为是帧的开始，然后一旦检测到帧标识位 F 即表示帧的结束。</p>
<p><img src="https://i.loli.net/2020/04/04/sNDjvCmKV7gE1xI.png" alt="img"></p>
<p> 　如果在数据中刚好出现 01111110 的序列会误认为是帧的结束而抛弃后面的数据，要采取有效的措施解决这个问题，即透明传输。<strong>透明传输就是不管所传送数据是什么样的比特组合，都应当能在链路上传送。</strong></p>
<p> 　</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>　　由于收发双发各自的工作速率和缓存空间的差异可能发送方的发送能力大于接受方的接收能力的现象，流量控制实际上就是限制发送方的数据流量，使其发送速率不超过接收方的接收能力。</p>
<p>　　流量控制并不是数据链路层特有的功能，许多高层协议也提供此功能，只不过控制的对象不同而已。对于数据链路层来说，控制的是相邻两节点之间数据链路上的流量，对于传输层来说，控制的则是源端口到目的端口之间的流量。</p>
<p><img src="https://i.loli.net/2020/04/04/TcEumn3joNMX9Us.png" alt="img"></p>
<h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>　　由于信道噪声等原因，帧在传输过程中可能会出现错误。用以使发送方确定接收方是否正确收到由其发送的数据的方法称为差错控制。通常，这些错误可分为位错和帧错。</p>
<p>　　位错指帧中某些位出现了差错。通常采用<strong>循环冗余校验（CRC）方式发现位错</strong>，通过自动重传请求（Automatic Repeat reQuest<strong>，ARQ）方式来重传出错的帧</strong>。发送方将数据帧加CRC校验码一起发送，接收方根据检错码对数据帧进行错误检测，若发现错误则丢弃，发送方超时重传该数据帧。ARQ法只需返回很少的控制信息就可有效确认所发数据帧是否被正确接收。</p>
<p>　　帧错指帧的丢失、重复或失序等错误在数据链路层引入<strong>定时器和编号机制</strong>，能保证每一帧最终都能有且仅有一次正确地交付给目的结点。</p>
<h3 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h3><p>　　数据链路层之所以要把比特组合成帧为单位传输，是为了在出错时只重发出错地帧，而不必重发全部数据，从而提高数据。为了接收方能正确地接收并检查所传输地帧，发送方必须依据一定地规则把网络层递交地分组封装成帧（称为组帧）。组帧主要解决帧定界、帧同步、透明传输等问题。</p>
<p>　　组帧既要加首部又要加尾部。 接收方依靠帧中地定界符来区分帧地开始和结尾。分组（IP数据报）仅是包含在帧中的数据部分。</p>
<h4 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h4><p>　　字符计数法是指<strong>在帧的头部使用一个计数字段来标明帧内字符数</strong>。如果计数字段出错后面的全部出错。</p>
<p><img src="https://i.loli.net/2020/04/04/zWNs7ADgBUthZQF.png" alt="img"></p>
<p> 　</p>
<h4 id="字符填充法的首尾定界符法"><a href="#字符填充法的首尾定界符法" class="headerlink" title="字符填充法的首尾定界符法"></a>字符填充法的首尾定界符法</h4><p>　　字符填充法使用一些特定的字符来定界一帧的开始（DLE STX）与结束（DLE ETX）。为了使信息位中出现的特殊字符不误认为帧的首尾定界符，可以在<strong>特殊字符前面填充一个转义字符（DLE）来加以区分</strong>（转义字符使ASCII 码中的控制字符，是一个字符 DLE只是一个代号），以实现数据的透明传输。</p>
<p><img src="https://i.loli.net/2020/04/04/tBpYfKaSMN3vyCk.png" alt="img"></p>
<p> 上图中信息部分含有一个转义字符DLE，因此在传输过程中添加一个转义字符，接收方将其去掉。</p>
<p>　　</p>
<h4 id="零比特填充的首尾标志法"><a href="#零比特填充的首尾标志法" class="headerlink" title="零比特填充的首尾标志法"></a>零比特填充的首尾标志法</h4><p>　　使用 01111110 来标志一帧的开始和结束。在信息位中遇到连续的5个1则自动在后面添加一个0。性能优于字符填充法。</p>
<p><img src="https://i.loli.net/2020/04/04/QXAdYuFaspT4J9S.png" alt="img"></p>
<h4 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h4><p>　　在物理层进行比特编码时，通常采用违规编码。例如曼彻斯特码。可以借用违规编码序列来定界帧的起始和终止。</p>
<p>　　<strong>目前较常用的组帧方法是比特填充法和违规编码法。</strong></p>
<h3 id="差错控制-1"><a href="#差错控制-1" class="headerlink" title="差错控制"></a>差错控制</h3><p> 　比特传输是传输差错的一种，这里仅讨论比特差错。通常利用编码技术来进行差错控制，主要有两类：<strong>自动重传请求ARQ</strong>和<strong>前向纠错FEC</strong>。<strong>在ARQ方式中，接收端检测出差错时通知发送端重发</strong>，直到收到正确的码字。<strong>在FEC 方式中，接收端不但能发现差错还能确定出错位置纠错</strong>。差错控制可分为检错编码和纠错编码。</p>
<h4 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4><p>　　1）奇偶校验码。在信息位后添加一位校验，以传输11100101 为例，如果是奇校验码 信息位中有5个1 为奇数则信息位为0，11100101 0 。如果是偶校验码 校验位为1 11100101 1。“奇”（“偶”）代表加上信息位之后的 “1” 的个数为 奇（偶）。它分为垂直奇偶校验、水平奇偶校验和水平垂直奇偶校验。</p>
<p>　　2）循环冗余码。又称多项式码，任意一个由二进制数位串组成的代码都可以与一个只含有0和1两个系数的多项式建立一一对应关系。</p>
<p>　　给定一个 m bit 的帧或报文，发送器生成 r bit 的序列称为帧检验序列（FCS）。形成的帧将由m+r bit 组成。发送方和接收方事先商定一个多项式 G(x) （最高位和最低位必须为1），使这个带校验码的帧刚好能被预先确定的多项式 G(x) 整除。接收方用同样的多项式去除收到的帧，如果无余数，认为无差错。</p>
<p>　　假设一个帧有 m 位，对应的多项式为 M(x)，计算冗余码的步骤如下;</p>
<p>　　a. 加0。假设G(x)的阶为 r ，在帧的低位端加上 r 个0。</p>
<p>　　b. 模2除（不涉及借位，0-1=1） 用帧的数据串除G(x)的数据串得到的余数为冗余码（共 r 位，前面的 0 不可以省略）。</p>
<p><img src="https://i.loli.net/2020/04/04/tgyXjxhYJPOEvR2.jpg" alt="img"></p>
<h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><p>　　以下海明码编码原理与过程。</p>
<p><img src="https://i.loli.net/2020/04/04/poDZz6wILR4KMNE.jpg" alt="img"></p>
<p> 　</p>
<h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h3><h4 id="流量控制、可靠传输与滑动窗口机制"><a href="#流量控制、可靠传输与滑动窗口机制" class="headerlink" title="流量控制、可靠传输与滑动窗口机制"></a>流量控制、可靠传输与滑动窗口机制</h4><p>　　流量控制涉及对链路上的帧的发送速率的控制，以使接收方有足够的缓冲空间来接收每个帧。</p>
<p>　　流量控制的基本方法是由接收方控制发送方的速率，常见的方式有两种：<strong>停止-等待协议</strong>和<strong>滑动窗口协议</strong>。</p>
<h5 id="停止-等待流量控制基本原理"><a href="#停止-等待流量控制基本原理" class="headerlink" title="停止-等待流量控制基本原理"></a>停止-等待流量控制基本原理</h5><p>　　发送方每发送一帧，都要等待接收方的应答信号才能发送下一帧，效率很低。</p>
<h5 id="滑动窗口流量控制基本原理"><a href="#滑动窗口流量控制基本原理" class="headerlink" title="滑动窗口流量控制基本原理"></a>滑动窗口流量控制基本原理</h5><p>　　在任意时刻，发送发都维持一组连续的允许发送的帧的序号，称为发送窗口。同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。<strong>发送方每接收到一个确认帧，发送窗口就向前滑动一个帧的位置。</strong></p>
<p>　　<strong>滑动窗口特性：</strong></p>
<p>　　a.只有接收窗口向前滑动（同时接收方发送了确认帧时），发送窗口才有可能向前移动（发送发接收到了确认帧）。</p>
<p>　　b.从滑动窗口概念上看，停止-等待协议、后退 N 帧协议和选择重传协议只在发送窗口大小与接收窗口大小上有所差别：</p>
<p>　　停止-等待协议：发送窗口大小 = 1，接收窗口大小 = 1</p>
<p>　　后退 N 帧协议：发送窗口 &gt; 1，接收窗口大小 = 1</p>
<p>　　选择重传协议：发送窗口 &gt; 1，接收窗口大小 &gt; 1</p>
<p>　　c.接收窗口大小为 1 时，可保证帧的有序接收。</p>
<p>　　d.<strong>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的，传输层的滑动窗口会改变。</strong></p>
<h5 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h5><p>　　数据链路层的可靠传输通常使用确认和超时重传两种机制来完成。确认是一种无数据的控制帧，这种控制帧使得接收方知道哪些内容被正确接收。有时候为了提高传输效率，将确认捎带在一个回复帧中，称为捎带确认。超时重传是发送方在发送数据帧后一段时间内没有收到确认帧，重新发送该数据帧。</p>
<p>　　自动重传请求（ARQ）通过接收方请求发送方重传出错的数据帧来恢复出错的帧。传统的自动重传请求分三种，停止-等待 ARQ，后退N帧 ARQ ，选择性重传 ARQ。</p>
<p>　　停止等待 ARQ：发送一帧，确认一帧。超时重传。</p>
<p>　　后退 N 帧 ARQ：可以连续发送窗口内的帧，接收方接收窗口为 1 可以保证按序接收数据帧。如果采用 n 比特对帧编号， 则其发送窗口W的大小应满足 <strong>1 &lt;= W &lt;= 2^n-1</strong> 。如果发送方窗口大于上限就会造成无法分辨新帧和旧帧。</p>
<p><img src="https://i.loli.net/2020/04/04/opi2d3rDtv9aZu6.png" alt="img"></p>
<p> 　2 号帧出错，丢弃窗口内所有帧。</p>
<p>　    选择重传 ARQ：设法只重传出现差错的数据帧或计时器超时的帧，必须加大接收窗口，接收发送序号不连续但仍处在接收窗口中的那些数据帧。等到所缺失的帧后一起交给主机。若采用 n 比特对帧编号则满足发送窗口<strong>W1 + W2 &lt;= 2^n</strong> 。接收窗口不应超过发送窗口 。一般情况下 <strong>W1=W2 = 2^(n-1)</strong>。</p>
<p><img src="https://i.loli.net/2020/04/04/B9UL7qNWwoVFgKk.png" alt="img"></p>
<p> <strong>GBN 和选择重传 都使用累计确认 收到 3 号帧的确认说明 接收方已经收到 0 - 3 号帧。</strong>　</p>
<p>　　信道效率：发送方在一个发送周期的时间内，有效地发送数据所需要地时间占整个发送周期的比率。</p>
<p>　　例如，发送方从开始发送数据开始到收到第一个确认帧为止，称为一个发送周期，设为T，发送方在这个周期内共发送L比特的数据，发送方的数据传输率为C，则发送方用于发送有效数据的时间为L/C，在这种情况下 信道利用率为 (L/C)/T。</p>
<p>　　信道吞吐率 = 信道利用率 * 发送方的发送速率。</p>
<h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><p>　　介质访问控制所要完成的任务是，为使用介质的每个结点隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输。用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制（Medium Access Control， MAC）子层。</p>
<h4 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h4><p>　　信道划分介质访问控制将使用介质的每个设备与来自同一通信信道上的其他设备的通信隔开，把时域和频域资源合理地分配给网络上地设备。在一条介质上同时携带多个传输信号的方法来提高系统的利用率，这就是多路复用。</p>
<p>　　1）频分多路复用（FDM）：将多路基带信号调制到不同频率载波上，再叠加形成一个复合信号的多路服用技术。</p>
<p>　　2）时分多路复用（TDM）：将一条物理信道按时间分成若干时间片，轮流地分配给多个信号使用。每个时间片由复用的一个信号占用。</p>
<p>　　3）波分多路复用（WDM）：在一根光纤中传输多种不同波长的光信号。</p>
<p>　　4）码分多路复用（CDM）：采用不同的编码来区分各路原始信号。</p>
<p>　　码分多址（Code Division Multiple Access ，CDMA）是码分复用的一种方式。每比特时间分成 m 个更短的时间槽，称为码片。当两个或多个站点同时发送时，各路数据在信道中线性相加。为从信道中分离出各路信号，要求<strong>各个站点的码片序列相互正交</strong>。</p>
<p>　　可以把多个站点发送的数据看作多个向量，这些向量都是两两正交的。发送方和接收方都有相同的、独一无二的码片序列。在信道中多个向量线性相加，在接收端用码片序列和信道中多个向量的和做规格化内积（点乘后取平均值）我们知道正交的向量点乘的结果为0，其他的向量可以忽略掉。只有发送方的向量做规格化内积。结果为 1 则代表 发送1 ，结果为 -1 代表发送0.。</p>
<p>　　</p>
<h4 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h4><p>　　当有两个或多个用户同时发送信息时，就会产生帧的冲突。为了解决帧的碰撞，每个用户须按照一定的规则重传它的帧，知道该帧无碰撞地通过。常用的协议有 ALOHA 协议、CSMA 协议、CSMA/CD协议、CSMA/CA协议等，他们的核心思想是：胜利者争用获得信道，从而获得信息的发送权。<strong>随机介质访问控制机制实质上是将一种广播信道转化为点到点信道的行为。</strong></p>
<h5 id="ALOHA-协议"><a href="#ALOHA-协议" class="headerlink" title="ALOHA 协议"></a>ALOHA 协议</h5><p>　　a. 纯 ALOHA 协议 ：不检测信道状态 直接发送 ，一段时间没收到确认 <strong>等待一段随机的时间</strong>后再发送，直到成功。假设网络负载（T 时间内所有站点发送的所有帧数）为G,纯ALOHA吞吐量（T时间内发送成功的平均帧数）为 S = G<em>e^(-2</em>G) 。当G=0.5时。 S = 0.184</p>
<p><img src="https://i.loli.net/2020/04/04/SmI1ruGDC2xyXAQ.png" alt="img"></p>
<p>　　b.时隙 ALOHA 协议 ：把所有各站在时间上同步起来，并将时间划分为一段段等长的时隙，规定只能在每个时隙开始才能发送一个帧。在一个时隙内又两个或以上的帧到达时在下一个时隙产生碰撞碰撞后重传策略与纯 ALOHA 协议相似。网络吞吐量S与网络负载关系是 S = G*e^(-G) 。当G=0.5时。 S = 0.368</p>
<h5 id="CSMA-协议（Carrier-Sense-Multiple-Access，载波监听多路访问）"><a href="#CSMA-协议（Carrier-Sense-Multiple-Access，载波监听多路访问）" class="headerlink" title="CSMA 协议（Carrier Sense Multiple Access，载波监听多路访问）"></a>CSMA 协议（Carrier Sense Multiple Access，载波监听多路访问）</h5><p><img src="https://i.loli.net/2020/04/04/GN7rqSDIsl9ecpw.png" alt="img"></p>
<h5 id="CSMA-CD-协议-（Carrier-Sense-Multiple-Access-with-Collision-Detection，-载波监听多路访问-碰撞检测）有线局域网–以太网"><a href="#CSMA-CD-协议-（Carrier-Sense-Multiple-Access-with-Collision-Detection，-载波监听多路访问-碰撞检测）有线局域网–以太网" class="headerlink" title="CSMA/CD 协议 （Carrier Sense Multiple Access with Collision Detection， 载波监听多路访问/碰撞检测）有线局域网–以太网"></a>CSMA/CD 协议 （Carrier Sense Multiple Access with Collision Detection， 载波监听多路访问/碰撞检测）<strong>有线局域网–以太网</strong></h5><p>　　CSMA/CD 是 CDMA 的改进，CSMA/CD 适用于总线型网络或半双工网络。“载波监听”指发送前前检测总线上是否有其他站点在发送数据，若有则暂时不发送数据，等待信道变为空闲再发送。”碰撞检测“ 就是边发送边监听，即适配器边发送边监听信道上信号电压的变化情况，判断是否有其他站点是否也在发送数据。</p>
<p>　　<strong>CSMA/CD 的工作流程可概括为 “先听后发，边听边发，冲突停发，随机重发”。</strong></p>
<p>　　采用CSMA/CD 协议的以太网不可能进行全双工通信，只能进行半双工通信。</p>
<p> <img src="https://i.loli.net/2020/04/04/CvOhY84VSxdtLwj.png" alt="img"></p>
<p> 　为了确保发送站在发送数据的同时能检测到可能存在的冲突，需要在发送完帧之前就能收到自己发送出去的数据，<strong>帧的传输时延至少要两倍于信号在总线中的传播时延</strong>，所以CSMA/CD 总线网中所有数据帧必须要大于一个最小帧长。<strong>最小帧长 = 总线传播时延*数据传输率*2。以太网最小帧长64B 最大帧长1500B。</strong></p>
<p>　　</p>
<p>　　二进制退避算法：确定基本退避时间，一般取两倍的总线端到端传播时延 2r 。定义参数 k ，它等于重传次数 <strong>k=min(重传次数，10)</strong>。从离散的整数集合 0 ~ 2^k -1 中随机取出一个数n，重传所需要退避的时间就是n倍的基本退避时间 2nr。当重传16次仍不成功抛弃此帧，向上层报告。</p>
<h5 id="CSMA-CA-协议-（Carrier-Sense-Multiple-Access-with-Collision-Avoidence）无线局域网"><a href="#CSMA-CA-协议-（Carrier-Sense-Multiple-Access-with-Collision-Avoidence）无线局域网" class="headerlink" title="CSMA/CA 协议 （Carrier Sense Multiple Access with Collision Avoidence）无线局域网"></a>CSMA/CA 协议 （Carrier Sense Multiple Access with Collision Avoidence）无线局域网</h5><p>　　无线局域网环境下，不能简单地搬用CSMA/CD 协议，特别是碰撞检测部分。主要有两个原因 a.接收信号的强度会远小于发送信号地强度，无线介质上信号强度的动态变化范围很大，若要实现碰撞检测，硬件上的花费就会过大。b.在无线通信中，并非所有站点都能听见对方，即存在“隐蔽站”问题。　　</p>
<p>　　CSMA/CA 采用二进制指数退避算法。任何一个站要发送数据帧时，不仅要等待一个时间间隔，还要进入争用窗口，并计算随机退避时间以便再次试图接入信道。</p>
<p>　　CSMA/CA 还使用预约信道、ACK帧、RTS/CTS 帧等三种机制来实现碰撞避免：</p>
<p>　　预约信道：发送方在发送数据的同时向其他站点通知自己传输数据需要的时间长度，以便让其他站点在这段时间内不会发送数据，从而避免碰撞。</p>
<p>　　ACK帧：所有站点在正确接收到发给自己的帧（除广播帧和组播帧）后，都需要向发送方发回一个ACK帧。</p>
<p>　　RTS/CTS 帧：可选的碰撞避免机制，主要解决无线网中的 “屏蔽站”问题。</p>
<p>　　CSMA/CD 与 CSMA/CA 区别：</p>
<p>　　CSMA/CD 可以检测冲突但无法避免；CSMA/CA 发送包的同时不能检测信道上有无冲突，只能尽量避免。</p>
<p>　　CSMA/CD 用于总线形以太网， CSMA/CA用于无线局域网 802.11 a/b/g/n等。</p>
<p>　　CSMA/CD 通过电缆中的电压变化来检测；CSMA/CA 采用能能量检测、载波检测、和能量载波混合检测三种检测信道空闲的方式。</p>
<p>　　总结：CSMA/CA 在发送数据前广播告知其他结点，让其他结点不要发送数据。CSMA/CD 发送前侦听，边发送边侦听，一旦出现碰撞停止发送。</p>
<p>　　</p>
<h4 id="轮询访问介质访问控制：令牌传递协议"><a href="#轮询访问介质访问控制：令牌传递协议" class="headerlink" title="轮询访问介质访问控制：令牌传递协议"></a>轮询访问介质访问控制：令牌传递协议</h4><p>　　在轮询访问中，用户不能随机地发送消息，而是要通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道的分配。典型的轮询访问介质访问控制协议是令牌传递协议，主要用在令牌环局域网中。当环上一个站希望传送帧时，必须等待令牌。一旦收到令牌，站点便可启动发送帧。帧在环上传送时，不管该帧是否是发给本站点的，所有站点都进行转发，直到该帧回到它的始发站，并<strong>由始发站撤销该帧</strong>。帧的目的站除转发帧外，应针对该帧维持一个副本。当计算机都不需要发送数据时，<strong>令牌在环形网上游荡</strong>。数据链路层研究的是<strong>点到点</strong>之间的通信。</p>
<h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><h4 id="局域网的基本概念和体系结构"><a href="#局域网的基本概念和体系结构" class="headerlink" title="局域网的基本概念和体系结构"></a>局域网的基本概念和体系结构</h4><p>　　局域网（LAN）是指在一个较小的物理范围内，将各种设备通过双绞线等连接介质互相连接起来组成资源和信息共享的计算机互联网络。</p>
<p>　　局域网的特性主要由三个要素决定：拓扑结构、传输介质、介质访问控制方式，最重要的是介质访问控制方式，决定局域网的技术特性。</p>
<p>　　常见的局域网拓扑结构：星形、环形、总线形和星形总线形复合型结构。</p>
<p>　　局域网的介质访问控制方式有 CSMA/CD、令牌总线和令牌环，其中前两种方法主要用于总线形局域网，令牌环主要用于环形局域网。</p>
<p>　　三种特殊的局域网拓扑实现如下：</p>
<p>　　以太网：逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构。</p>
<p>　　令牌环：逻辑拓扑是环形结构，物理拓扑是星形结构。</p>
<p>　　FDDI（光纤分布数字接口）：逻辑拓扑是环形结构，物理拓扑是双环结构。</p>
<p>　　<strong>IEEE 802标准定义的局域网参考模型只对应于OSI参考模型的数据链路层和物理层，将数据链路层拆分成两个子层：逻辑链路控制（LLC）子层和媒体接入控制（MAC）子层。与接入传输媒体有关的内容都放在MAC子层，主要功能包括：组帧和拆帧、比特传输差错检测、透明传输。LLC子层与传输媒体无关，它向网络层提供无确认无连接、面向连接、带确认无连接、告诉传送4种不同的连接服务类型。</strong></p>
<h4 id="以太网与IEEE-802-3"><a href="#以太网与IEEE-802-3" class="headerlink" title="以太网与IEEE 802.3"></a>以太网与IEEE 802.3</h4><h5 id="以太网的传输介质与网卡"><a href="#以太网的传输介质与网卡" class="headerlink" title="以太网的传输介质与网卡"></a>以太网的传输介质与网卡</h5><p>　　IEEE 802.3 标准是一种基带总线形的局域网标准。</p>
<p><img src="https://i.loli.net/2020/04/04/L8FeJPwOCcDUB4x.png" alt="img"></p>
<p> 　网卡工作在数据链路层和物理层。出厂时自带MAC地址。</p>
<h5 id="以太网的MAC帧"><a href="#以太网的MAC帧" class="headerlink" title="以太网的MAC帧"></a>以太网的MAC帧</h5><p><img src="https://i.loli.net/2020/04/04/FWhknbH3deVaCMv.png" alt="img"></p>
<p> 　由于总线上使用的是广播通信，因此网卡从网络上每收到一个MAC帧，首先用硬件检查MAC帧中的MAC地址，如果是发往本站的帧就留下否则丢弃。</p>
<p>　　以太网帧结构：</p>
<p>　　前导码：使接收端与发送端时钟同步。第一个字段7B，是前同步码，用来快速实现MAC帧的比特同步。第二个字段是帧开始定界符，1B。</p>
<p>　　注意：MAC帧并不需要帧结束符，在以太网传输帧时，各帧之间必须有一定的间隙。但不要误以为以太网帧不需要尾部，<strong>在数据链路层上帧既要加首部又要加尾部。</strong></p>
<p>　　地址：通常使用MAC地址，6B。</p>
<p>　　类型：2B，指出数据域中携带的数据应交给哪个协议实体处理。</p>
<p>　　数据：46~1500B，包含高层的协议信息。由于CSMA/CD 限制，以太网帧必须满足最小长度64B</p>
<p>　　校验码（FCS）：4B，采用32位循环冗余校验码（CRC），<strong>不但需要校验MAC帧的数据部分还要校验目的地址、源地址和类型字段，但不校验前导码</strong>。</p>
<h5 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h5><p>　　a. 100BASE-T 以太网：100Mb/s 星形拓扑结构以太网，半双工使用 CSMA/CD，全双工不使用CSMA/CD。</p>
<p>　　b. 吉比特以太网：1Gb/s 半双工使用 CSMA/CD，全双工不使用CSMA/CD。</p>
<p>　　c.10吉比特网：10Gb/s 只使用光纤作为传输媒体，只工作在全双工方式，没有争用问题，不使用CSMA/CD。</p>
<p>　　</p>
<h4 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h4><p>　　IEEE 802.11 是无线局域网的一系列协议标准，包括 802.11a 和802.11b等。它们制定了MAC 层协议，运行在多个物理层标准上。</p>
<p>　　802.11 的MAC 层采用CSMA/CA 协议进行介质访问控制。</p>
<p>　　无线局域网可分为两大类：固定基础设施无线局域网和无固定基础设施无线局域网自组织网络。</p>
<p>　　a. 有固定基础设施无线局域网：802.11标准规定无线局域网的最小构件是基本服务集（BSS）。一个基本服务集包括一个基站和若干移动站。BSS内可直接通信，与BSS外的站点通信时要通过本BSS的基站。基本服务集中的基站也称接入点，其作用和网桥相似。</p>
<p>　　b. 无固定基础设施无线局域网自组织网络</p>
<p>　　自组织网络没有上述基本服务集的接入点，而是由一些平等状态移动站相互通信组成的临时网络。各站点之间地位平等，中间结点都为转发结点，这些结点都具有路由器功能。</p>
<h4 id="令牌环网的基本原理"><a href="#令牌环网的基本原理" class="headerlink" title="令牌环网的基本原理"></a>令牌环网的基本原理</h4><p>　　令牌环网的每一站通过电缆与环接口干线耦合器（TCU）相连。TCU 的主要作用是，传递所有经过的帧，为接入站发送和接收数据提供接口。TCU 的状态有收听和发送状态。在令牌环网中有一个令牌沿着环形总线在入网结点计算机间依次传递，令牌实际上是一个特殊格式的MAC控制帧，它本身不包含信息，仅控制信道的使用，确保在同一时刻只有一个结点能够独占信道。</p>
<p>　　令牌环网物理上采用星形拓扑结构，逻辑上仍是环形拓扑结构。</p>
<h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><h4 id="广域网基本概念"><a href="#广域网基本概念" class="headerlink" title="广域网基本概念"></a>广域网基本概念</h4><p>　　广域网通常指覆盖范围很广的长距离网络。广域网是因特网的核心部分，其任务是长距离运送主机所发送的数据。</p>
<p>　　广域网由一些结点交换机几连接这些交换机的链路组成。结点交换机的功能是将分组存储并转发。局域网使用的协议主要在数据链路层，而广域网使用的协议主要在网络层。</p>
<p><img src="https://i.loli.net/2020/04/04/lshEwS5eZCVgQk7.png" alt="img"></p>
<p> 　广域网一个重要问题是路由选择和分组转发。路由选择协议负责搜索分组从某个结点到目的结点的最佳传输路由，以便构造路由表，然后从路由表再构造出转发分组的转发表。分组通过转发表转发。PPP 协议和HDLC 协议是目前最常用的两种广域网数据链路层控制协议。</p>
<h4 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h4><p>　　PPP（Point-to-Point Protocol）是使用串行线路<strong>面向字节</strong>的协议，该协议应用再直接连接两个结点的链路上。设计的目的只要是用来通过拨号或专线方式建立点对点发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共同解决方案。</p>
<p>　　PPP协议有三个组成部分</p>
<p>　　1）链路控制协议（LCP）。一种扩展链路控制协议，用于建立、配置、测试和管理数据链路。</p>
<p>　　2）网络控制协议（NCP）。PPP协议采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</p>
<p>　　3）一个将IP数据报封装到串行链路的方法。IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传输单元（MTU）的限制。</p>
<p><img src="https://i.loli.net/2020/04/04/1b9RQXWtLTOj3Hn.png" alt="img"></p>
<p> 　标志字段F 仍为01111110 前后各占1B若它出现在信息字段中，必须做字节填充，使用的控制转义字符为 7D 。在PPP中，地址字段A占1B，规定为0xFF，控制字段C占1B，规定为0x03，两者的内容始终不变。<strong>PPP是面向字符的</strong>，因而所有PPP帧的长度都是整数个字节。协议字段占2B，说明信息段中运载的是什么种类的分组，以比特0开始的是诸如IP、IPX这样的网络层协议；以比特1开始的用来协商其他协议。信息段长度是可变的，大于等于0且小于等于1500B。FCS 检验地址字段、控制字段、协议字段和信息字段。</p>
<p>　　<strong>PPP提供差错检测但不提供纠错功能，只保证无差错接收。是不可靠的传输协议，也不使用序号和确认机制。仅支持点对点的链路通信。PPP只支持全双工链路。PPP的两端可以运行不同的网络协议。</strong></p>
<h4 id="HDLC-协议"><a href="#HDLC-协议" class="headerlink" title="HDLC 协议"></a>HDLC 协议</h4><p>　　高级数据链路控制（High-level Data Link Control）协议是ISO 制定的<strong>面向比特</strong>的数据链路层协议。</p>
<p>　　1）站。HDLC 有3种站类型：主站、从站和复合站。主站负责控制链路的操作，主站发出的帧成为<strong>命令帧</strong>。从站受控于主站，按主站的命令进行操作，发出的帧称为<strong>响应帧</strong>。有些站既有主站的功能又有从站的功能，称为复合站，可以发出两种帧。</p>
<p>　　2）数据操作方式</p>
<p>　　a. 正常相应方式。非平衡结构操作方式。主站向从站传输数据，从站响应传输，从站只有收到主站的许可后，才可进行响应。</p>
<p>　　b. 异步平衡方式。平衡结构操作方式。每个复合站都可以进行对另一站的数据传输。</p>
<p>　　c. 异步响应方式。非平衡结构操作方式。从站即使未收到主站的允许也可以传输。</p>
<p>　　3）HDLC 帧</p>
<p><img src="https://i.loli.net/2020/04/04/4gb1UdZuOLzao5e.png" alt="img"></p>
<p> 　标志段F：8 bit，01111110。采用比特填充的首尾标志法实现透明传输。地址字段A：8 bit 使用非平衡方式传送数据时，站地址写入从站的地址，使用平衡方式传送数据时，站地址写入应答站的地址。控制字段C：根据其第一位或第一第二位的取值可以将HDLC 帧分为三类：</p>
<p>　　1）信息帧，第一位为0，用来传输数据信息，或使用捎带技术对数据进行确认。</p>
<p>　　2）监督帧，第一二位为10，用于流量控制和差错控制，执行对信息帧的确认、请求重发和请求暂停发送等功能。　</p>
<p>　　3）无编号帧，低一二位为11，用于提供对链路的建立、拆除等多种控制功能。</p>
<p>　　 <strong>PPP与HDLC区别：</strong></p>
<p>　　1）PPP面向字节，HDLC 面向比特</p>
<p>　　2）PPP帧比HDLC帧多一个2B的协议字段，当协议字段为0x0021时，表示信息字段是IP数据报。</p>
<p>　　3）PPP不使用序号和确认机制，只保证无差错接收，端到端差错检测由高层负责。HDLC信息帧使用了编号和确认机制，能够提供可靠传输。</p>
<h3 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h3><h4 id="网桥的概念及其基本原理"><a href="#网桥的概念及其基本原理" class="headerlink" title="网桥的概念及其基本原理"></a>网桥的概念及其基本原理</h4><p>　　两个或多个以太网通过网桥连接后，就成为一个覆盖范围更大的以太网，原来的以太网称为一个网段。网桥工作在链路层的MAC子层，可以使以以太网各网段成为隔离开的碰撞域。网桥处理数据是帧它工作在数据链路层，中继器放大器处理的对象是信号，它工作在物理层。</p>
<p>　　网桥的基本特点：</p>
<p>　　1）具备寻址和路径选择的能力，以确定帧的传输方向</p>
<p>　　2）从源网络接收帧，以目的网络的介质访问控制协议向目的网络转发该帧</p>
<p>　　3）网桥在不同或相同类型的LAN之间存储并转发帧，必要时还进行链路层上的协议转换。</p>
<p>　　4）网桥对接收到的帧不做任何修改，或只对帧的封装格式做很少的修改。</p>
<p>　　5）网桥可以通过帧翻译互联不同类型的局域网，即把原协议的信息段内容作为另一种协议的信息部分封装在帧中。</p>
<p>　　6）网桥应有足够大的缓冲空间。</p>
<p>　　网桥的优点：</p>
<p>　　1）能过滤通信量；2）扩大了物理范围；3）可使用不同的物理层；4）可互联不同类型的局域网；5）提高了可靠性；6）性能得到改善</p>
<p>　　网桥的缺点：</p>
<p>　　1）增大了时延；2）MAC子层没有流量控制功能（流量控制在LLC子层）；3）不同MAC子层的网桥接在一起时，需要进行帧格式的转换；4）网桥只适合用户数不多和通信量不大的局域网，否则广播信息太多引起广播风暴。</p>
<p>　　网桥必须具有路径选择的功能，接收到帧后要决定正确的路径，将该帧转送到响应的目的局域网站点。根据路径算法的不同，可将网桥分为透明网桥和源路由网桥。</p>
<p>　　1.透明网桥（选择的不是最佳路由）</p>
<p>　　接收与之连接的所有LAN传送的每一帧，到达帧的路由选择取决于源LAN 和目的LAN 。1）如果源LAN和目的LAN相同则丢弃；2）如果源LAN和目的LAN不同则转发此帧；3）如果目的LAN未知，那么扩散此帧。（网桥自学习算法）</p>
<p>　　2.源路由网桥（选择的是最佳路由）</p>
<p>　　路由选择由发送数据帧的源站负责，网桥只根据真正的路由信息对帧进行接收和转发。为了找到最佳的路由，源站以广播方式向目的站发送一个发现帧作为探测用。目的站也将一一发送应答帧；每个应答帧将通过原路径返回，途径的网桥把自己的标志记录在应答帧中；源站选出最佳路由。</p>
<p>　　3.两种网桥的比较</p>
<p>　　使用源路由网桥可以利用最佳路由，若两个以太网之间使用并联的路由器还可以是通信量较平均的分配给每个网桥。采用透明网桥时，只能使用生成树，而生成树并不能保证所有路由是最佳的，也不能在不同的链路中进行负载均衡。</p>
<p>　　透明网桥和源路由网桥中提到的最佳路由并不是经过路由器最少的路由，而是可以发送帧往返时间最短的路由。</p>
<h4 id="局域网交换机及其工作原理"><a href="#局域网交换机及其工作原理" class="headerlink" title="局域网交换机及其工作原理"></a>局域网交换机及其工作原理</h4><h5 id="局域网交换机"><a href="#局域网交换机" class="headerlink" title="局域网交换机"></a>局域网交换机</h5><p>　　以太网交换机是一个多端口的网桥，它工作在数据链路层。交换机能将网络分成更小的冲突域，为每个工作站提供更高的带宽。利用交换机还可以实现虚拟局域网（VLAN）不仅可以隔离冲突域还能隔离广播域。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>　　以太网交换机的原理是，检测以太端口来的数据帧的源和目的地的MAC地址，然后与系统内部的动态查找表进行比较，若数据帧的MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给响应的目的端口。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>　　a.交换机的每个端口都直接与单台主机相连，工作在全双工方式。</p>
<p>　　b.以太网交换机能同时连通许多对端口，使每对相互通信的主机都能像独占通信媒体那样无碰撞地传输数据。</p>
<p>　　c.即插即用。</p>
<p>　　d.交换速率高。</p>
<p>　　e.独占传输媒体地带宽</p>
<h5 id="两种交换方式"><a href="#两种交换方式" class="headerlink" title="两种交换方式"></a>两种交换方式</h5><p>　　a.直通式交换机只检查帧地目的地址，帧在接收后几乎马上就能被传出去。</p>
<p>　　b.存储转法式交换机先将接收到地帧缓存到高速缓冲器中，检查并转发。</p>
<p><img src="https://i.loli.net/2020/04/04/I3H5PKNcn1RFGxh.png" alt="img"></p>
<h3 id="本章小结及疑难点"><a href="#本章小结及疑难点" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="“链路”-和-“数据链路”-有何区别？"><a href="#“链路”-和-“数据链路”-有何区别？" class="headerlink" title="“链路” 和 “数据链路” 有何区别？"></a>“链路” 和 “数据链路” 有何区别？</h4><p>​        链路指从一个结点到相邻结点的一段物理线路，其中间没有任何其他任何的交换结点。在进行数据通信时，两台计算机之间的通信路径往往要通过许多段这样的链路。</p>
<p>​        数据链路则是另一个概念，要在一条线路上传送数据，除了必须要有一条物理线路外，还必须有一些通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
<h4 id="为什么-PPP-协议不使用帧的编号和确认机制来实现可靠传输？"><a href="#为什么-PPP-协议不使用帧的编号和确认机制来实现可靠传输？" class="headerlink" title="为什么 PPP 协议不使用帧的编号和确认机制来实现可靠传输？"></a>为什么 PPP 协议不使用帧的编号和确认机制来实现可靠传输？</h4><p>​        PPP 不使用序号和确认机制出于以下考虑：</p>
<p>​        若使用能够实现可靠传输的数据链路层协议（如 HDLC ），开销就会增大。当数据链路层出现差错的概率不大时，使用简单的 PPP 较为合理。</p>
<p>​        在因特网环境下， PPP 的信息字段放入的数据是 IP 数据报。假定数据链路层实现了非常可靠的传输协议，但在上升到网络层后仍可能由于网络拥塞而被丢弃。数据链路层的可靠传输并不能保证网络层的传输也是可靠的。</p>
<p>​        PPP 在帧格式中有帧校验序列 FCS 字段。对于每个接收到的帧， PPP 都要使用硬件进行 CRC 校验若发现有差错，则丢弃该帧（只要是上交到上一层的帧都是无差错的）。端到端的差错控制由高层协议负责。</p>
<h4 id="交换机和网桥的不同之处。"><a href="#交换机和网桥的不同之处。" class="headerlink" title="交换机和网桥的不同之处。"></a>交换机和网桥的不同之处。</h4><p>​        1）网桥的端口一般连接局域网，而交换机的端口一般直接与局域网的主机相连。</p>
<p>​        2）交换机允许多对计算机同时通信，而网桥仅允许每个网段上的计算机同时通信。</p>
<p>​        3）网桥采用存储转发方式进行转发，而以太网交换机还可以采用直通方式进行转发，且以太网交换机采用了专用的交换结构芯片，转发速度比网桥快。</p>
<h4 id="局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？"><a href="#局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？" class="headerlink" title="局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？"></a>局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？</h4><p>​        局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数量有限。局域网的地理范围较小，且为一个单位所拥有，采用广播通信方式十分方便。但广域网的地理范围很大，如果采用广播通信方式势必造成通信资源的极大浪费。</p>
<p><img src="https://i.loli.net/2020/04/10/LtEuor7PDM3xKzb.png" alt="image-20200410134049382"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2020/04/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="结构型模式–代理模式"><a href="#结构型模式–代理模式" class="headerlink" title="结构型模式–代理模式"></a>结构型模式–代理模式</h1><p><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p><strong>何时使用：</strong>想在访问一个类时做一些控制。</p>
<p><strong>如何解决：</strong>增加中间层。</p>
<p><strong>关键代码：</strong>实现与被代理类组合。</p>
<p><strong>应用实例：</strong> 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。</p>
<p><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。</p>
<p><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>
<p><strong>使用场景：</strong>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p>
<p><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 <em>Image</em> 接口和实现了 <em>Image</em> 接口的实体类。<em>ProxyImage</em> 是一个代理类，减少 <em>RealImage</em> 对象加载的内存占用。</p>
<p><em>ProxyPatternDemo*，我们的演示类使用 *ProxyImage</em> 来获取要加载的 <em>Image</em> 对象，并按照需求进行显示。</p>
<p><img src="https://i.loli.net/2020/04/04/sFxj37SopKEcz5T.png" alt="img"></p>
<p> 1、创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现接口得实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String filename)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filename = filename;</span><br><span class="line">        loadFromDisk(filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying "</span>+filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String filename)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading "</span>+filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealImage realImage;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filename = filename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(realImage == <span class="keyword">null</span>)&#123;</span><br><span class="line">            realImage = <span class="keyword">new</span> RealImage(filename);</span><br><span class="line">        &#125;</span><br><span class="line">        realImage.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> ProxyImage(<span class="string">"test.jpg"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从磁盘加载</span></span><br><span class="line">        image.display();</span><br><span class="line">        <span class="comment">//不需要从磁盘加载</span></span><br><span class="line">        image.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://i.loli.net/2020/04/04/qnfFXHh23agZoIO.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/proxy-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/proxy-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>空对象模式</title>
    <url>/2020/04/04/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h1><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。在空对象模式中，我们创建要给指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个定义操作（在这里，是客户的名称）的 <em>AbstractCustomer</em> 抽象类，和扩展了 <em>AbstractCustomer</em> 类的实体类。工厂类 <em>CustomerFactory</em> 基于客户传递的名字来返回 <em>RealCustomer</em> 或 <em>NullCustomer</em> 对象。</p>
<p><em>NullPatternDemo*，我们的演示类使用 *CustomerFactory</em> 来演示空对象模式的用法。</p>
<p><img src="https://i.loli.net/2020/04/04/sAg4bQJ5LzBwMXi.png" alt="img"></p>
<p> 1、创建一个抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCustomer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isNil</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建扩展了上述类的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCustomer</span> <span class="keyword">extends</span> <span class="title">AbstractCustomer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealCustomer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullCustomer</span> <span class="keyword">extends</span> <span class="title">AbstractCustomer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Not Available in Customer Database"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建 CustomerFactory 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] names = &#123;<span class="string">"Rob"</span>, <span class="string">"Joe"</span>, <span class="string">"Julie"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractCustomer <span class="title">getCustomer</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(names[i].equalsIgnoreCase(name))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RealCustomer(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NullCustomer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用 CustomerFactory，基于客户传递的名字，来获取 RealCustomer 或 NullCustomer 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullObjectPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractCustomer customer1 = CustomerFactory.getCustomer(<span class="string">"Rob"</span>);</span><br><span class="line">        AbstractCustomer customer2 = CustomerFactory.getCustomer(<span class="string">"Bob"</span>);</span><br><span class="line">        AbstractCustomer customer3 = CustomerFactory.getCustomer(<span class="string">"Julie"</span>);</span><br><span class="line">        AbstractCustomer customer4 = CustomerFactory.getCustomer(<span class="string">"Laura"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Customers"</span>);</span><br><span class="line">        System.out.println(customer1.getName());</span><br><span class="line">        System.out.println(customer2.getName());</span><br><span class="line">        System.out.println(customer3.getName());</span><br><span class="line">        System.out.println(customer4.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/gk8WAMDECH7PczQ.png" alt="img"></p>
<p> 我们使用一个空对象代替了对象的判空处理。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/null-object-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/null-object-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2020/04/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="结构型模式–外观模式"><a href="#结构型模式–外观模式" class="headerlink" title="结构型模式–外观模式"></a>结构型模式–外观模式</h1><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。它向现有的系统添加一个接口，来隐藏系统的复杂性。该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</p>
<p><strong>何时使用：</strong> 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。</p>
<p><strong>如何解决：</strong>客户端不与系统耦合，外观类与系统耦合。</p>
<p><strong>关键代码：</strong>在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p>
<p><strong>应用实例：</strong> 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。</p>
<p><strong>优点：</strong> 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。</p>
<p><strong>缺点：</strong>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>
<p><strong>使用场景：</strong> 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。</p>
<p><strong>注意事项：</strong>在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 <em>Shape</em> 接口和实现了 <em>Shape</em> 接口的实体类。下一步是定义一个外观类 <em>ShapeMaker</em>。</p>
<p><em>ShapeMaker</em> 类使用实体类来代表用户对这些类的调用。<em>FacadePatternDemo*，我们的演示类使用 *ShapeMaker</em> 类来显示结果。</p>
<p><img src="https://i.loli.net/2020/04/04/DMayPn4GSoKTuwm.png" alt="img"></p>
<p> 1、创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cricle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rectangle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建一个外观类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeMaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Shape circle;</span><br><span class="line">    <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">    <span class="keyword">private</span> Shape square;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeMaker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        square = <span class="keyword">new</span> Square();</span><br><span class="line">        rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        circle.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSquare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        square.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用该外观类画出各种类型的形状</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeMaker shapeMaker = <span class="keyword">new</span> ShapeMaker();</span><br><span class="line"></span><br><span class="line">        shapeMaker.drawCircle();</span><br><span class="line">        shapeMaker.drawRectangle();</span><br><span class="line">        shapeMaker.drawSquare();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/9XTsfaW8yUxkgF3.png" alt="img"></p>
<p> 我们通过 ShapeMaker 类屏蔽了底层的类的实现，仅仅调用接口就可画出各种形状。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/facade-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/facade-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2020/04/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="结构型模式–桥接模式"><a href="#结构型模式–桥接模式" class="headerlink" title="结构型模式–桥接模式"></a>结构型模式–桥接模式</h1><p>桥接（Bridge）是用于<strong>把抽象化与实现化解耦，使二者可以独立变化</strong>。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
<p>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
<p><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
<p><strong>何时使用：</strong>实现系统可能有多个角度分类，每一种角度都可能变化。</p>
<p><strong>如何解决：</strong>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p>
<p><strong>关键代码：</strong>抽象类依赖实现类。</p>
<p><strong>应用实例：</strong> 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</p>
<p><strong>优点：</strong> 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。</p>
<p><strong>缺点：</strong>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p>
<p><strong>使用场景：</strong> 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p>
<p><strong>注意事项：</strong>对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们有一个作为桥接实现的 <em>DrawAPI</em> 接口和实现了 <em>DrawAPI</em> 接口的实体类 <em>RedCircle<em>、</em>GreenCircle<em>。</em>Shape</em> 是一个抽象类，将使用 <em>DrawAPI</em> 的对象。<em>BridgePatternDemo*，我们的演示类使用 *Shape</em> 类来画出不同颜色的圆。</p>
<p><img src="https://i.loli.net/2020/04/04/glISfaxoyCGMEwv.png" alt="img"></p>
<p>1、创建桥接接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现了 DrawAPI 接口的实体桥接实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlueCircle</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Drawing Circle[ color: blue, radius: "</span>+radius+<span class="string">", x: "</span>+x+<span class="string">", y: "</span>+y+<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedCircle</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Drawing Circle[ color: red, radius: "</span>+radius+<span class="string">", x: "</span>+x+<span class="string">", y: "</span>+y+<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用 DrawAPI 接口创建抽象类 Shape</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Shape</span><span class="params">(DrawAPI drawAPI)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、创建继承了 Shape 的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y, radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y, DrawAPI drawAPI)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drawAPI);</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        drawAPI.draw(radius,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、使用 Shape 和 DrawAPI 类画出不同的圆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgePatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape redCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>,<span class="number">10</span>,<span class="keyword">new</span> RedCircle());</span><br><span class="line">        Shape blueCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>,<span class="number">10</span>,<span class="keyword">new</span> BlueCircle());</span><br><span class="line"></span><br><span class="line">        redCircle.draw();</span><br><span class="line">        blueCircle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://i.loli.net/2020/04/04/qZgEOrWUYe3VmzN.png" alt="img"></p>
<p>我们将Circle的抽象和具体的实现分离开，DrawAPI 作为桥接接口，具体的实现类实现 DrawAPI 的接口，当需要画各种类型的圆时通过 DrawAPI 来实现。对比传统的 RedCircle 继承 Circle 类 的方法比较起来，当继承 Circle 类的实体类多起来之后更加容易维护。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/bridge-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/bridge-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2020/04/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="结构型模式–组合模式"><a href="#结构型模式–组合模式" class="headerlink" title="结构型模式–组合模式"></a>结构型模式–组合模式</h1><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似得对象当作一个单一得对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。它创建了对象组的树形结构。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<p><strong>何时使用：</strong> 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<p><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。</p>
<p><strong>关键代码：</strong>树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
<p><strong>应用实例：</strong> 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p>
<p><strong>优点：</strong> 1、高层模块调用简单。 2、节点自由增加。</p>
<p><strong>缺点：</strong>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p>
<p><strong>使用场景：</strong>部分、整体场景，如树形菜单，文件、文件夹的管理。</p>
<p><strong>注意事项：</strong>定义时为具体类。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们有一个类 <em>Employee<em>，该类被当作组合模型类。</em>CompositePatternDemo*，我们的演示类使用 *Employee</em> 类来添加部门层次结构，并打印所有员工。</p>
<p><img src="https://i.loli.net/2020/04/04/G528HhqwdeyRNTn.png" alt="img"></p>
<p> 1、创建 Employee 类，该类带有 Employee 对象的列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String dept;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; subordinates;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, String dept, <span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.dept = dept;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.subordinates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">        subordinates.add(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">        subordinates.remove(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getSubordinates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subordinates;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Employee&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", dept='"</span> + dept + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", salary="</span> + salary +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、使用 Employee 类来创建和打印员工的层次结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee CEO = <span class="keyword">new</span> Employee(<span class="string">"John"</span>,<span class="string">"CEO"</span>, <span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">        Employee headSales = <span class="keyword">new</span> Employee(<span class="string">"Robert"</span>,<span class="string">"Head Sales"</span>, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">        Employee headMarketing = <span class="keyword">new</span> Employee(<span class="string">"Michel"</span>,<span class="string">"Head Marketing"</span>, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">        Employee clerk1 = <span class="keyword">new</span> Employee(<span class="string">"Laura"</span>,<span class="string">"Marketing"</span>, <span class="number">10000</span>);</span><br><span class="line">        Employee clerk2 = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>,<span class="string">"Marketing"</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        Employee salesExecutive1 = <span class="keyword">new</span> Employee(<span class="string">"Richard"</span>,<span class="string">"Sales"</span>, <span class="number">10000</span>);</span><br><span class="line">        Employee salesExecutive2 = <span class="keyword">new</span> Employee(<span class="string">"Rob"</span>,<span class="string">"Sales"</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        CEO.add(headSales);</span><br><span class="line">        CEO.add(headMarketing);</span><br><span class="line"></span><br><span class="line">        headSales.add(salesExecutive1);</span><br><span class="line">        headSales.add(salesExecutive2);</span><br><span class="line"></span><br><span class="line">        headMarketing.add(clerk1);</span><br><span class="line">        headMarketing.add(clerk2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印所有员工</span></span><br><span class="line">        System.out.println(CEO+<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Employee headEmployee : CEO.getSubordinates()) &#123;</span><br><span class="line">            System.out.println(headEmployee);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Employee e : headEmployee.getSubordinates()) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">　　　　　　　System.out.println(<span class="string">""</span>);</span><br><span class="line">&#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://i.loli.net/2020/04/04/XcaLMsK8qEr42ew.png" alt="img"></p>
<p> CEO 直接管理销售主管和市场主管，销售主管和市场主管又分别管理自己手下的员工。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/composite-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/composite-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>缓存数据</title>
    <url>/2020/04/04/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h1><p>​    缓存（Caching）可以存储经常会用到的信息，这样每次需要的时候，这些信息是立即可用的。尽管Spring本身没有实现缓存解决方案，但它对缓存功能提供了声明式的支持，能够与多种流行的缓存实现进行集成。</p>
<p>在往bean上添加缓存注解之前，必须要启用Spring对注解驱动缓存的支持。如果我们使用Java配置的话，可以在其中的一个配置类上加上@EnableCaching，这样的话就能启用注解驱动的缓存。</p>
<p>我们以Spittr 应用的Repository JDBC实现来演示缓存的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.ehcache.CacheManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.ehcache.EhCacheCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.ehcache.EhCacheManagerFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> EhCacheCacheManager <span class="title">cacheManager</span><span class="params">(CacheManager cm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EhCacheCacheManager(cm);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> EhCacheManagerFactoryBean <span class="title">ehcache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EhCacheManagerFactoryBean ehCacheFactoryBean = <span class="keyword">new</span> EhCacheManagerFactoryBean();</span><br><span class="line">    ehCacheFactoryBean.setConfigLocation(<span class="keyword">new</span> ClassPathResource(<span class="string">"spittr/cache/ehcache.xml"</span>));</span><br><span class="line">    <span class="keyword">return</span> ehCacheFactoryBean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>cacheManager()方法创建了一个EhCacheManager的实例，这是通过传入EhCache CacheManager实例实现的。稍微有些诡异的注入会让人感到迷惑，这是因为Spring和EhCache都定义了CacheManager类型。需要明确的是，EhCache的CacheManager要被注入到Spring的EhCacheManager之中。</p>
<p>我们使用EhCache的CacheManager来进行注入，所以也必须声明一个CacheManager bean。为了对其进行简化，Spring提供了EhCacheManagerFactoryBean 来生成EnCache 的CacheManager。方法ehcache()会创建并返回一个EhCacheManagerFactoryBean实例。因为它是一个工厂bean，所以注册在Spring应用上下文的并不是EhCacheManagerFactoryBean，而是CacheManager的一个实例。</p>
<p>下面是 ehcache.xml。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"spittleCache"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxBytesLocalHeap</span>=<span class="string">"50m"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">timeToLiveSeconds</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>我们使用注解为SpittleRepository声明缓存规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"spittleCache"</span>)</span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"spittleCache"</span>)</span><br><span class="line">  <span class="function">Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CachePut</span>(value=<span class="string">"spittleCache"</span>, key=<span class="string">"#result.id"</span>)</span><br><span class="line">  <span class="function">Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"spittleCache"</span>)</span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> spitterId)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@CacheEvict</span>(value=<span class="string">"spittleCache"</span>,condition=<span class="string">""</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Spring提供了四个注解来声明缓存规则<br>@Cacheable 表明Spring在调用方法之前，首先应该在缓存中查找方法的返回值，如果这个值找到，就会返回缓存的值，否则的话，这个方法就会被调用，返回值会房贷缓存之中。<br>@CachePut 表明Spring应该将方法的返回值放入缓存之中，在方法的调用前并不会检查缓存，方法始终都会被调用。<br>@CacheEvict 表明Spring应该在缓存中清除一个或多个条目。<br>@Caching 这是一个分组的注解，能够同时应用多个其他的缓存注解。<br>将注解放在方法前即可启用缓存。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤器模式</title>
    <url>/2020/04/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="结构型模式–过滤器模式"><a href="#结构型模式–过滤器模式" class="headerlink" title="结构型模式–过滤器模式"></a>结构型模式–过滤器模式</h1><p>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种结构型模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把他们连接起来，它结合多个标准来获得单一标准。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 Person 对象、Cirteria 接口 和实现了该接口的实体类，来过滤 Person 对象的列表。CriteriaPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤对象的列表。</p>
<p><img src="https://i.loli.net/2020/04/04/Ur5lMxPp6IqJf8e.png" alt="img"></p>
<p> 1、创建一个 Person 类，在该类上应用标准。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String maritalStatus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String gender, String maritalStatus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.maritalStatus = maritalStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMaritalStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maritalStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", maritalStatus='"</span> + maritalStatus + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、为标准（Criteria）创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建实现了 Criteria 接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriteriaMale</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; malePersons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">            <span class="keyword">if</span>(person.getGender().equalsIgnoreCase(<span class="string">"MALE"</span>))&#123;</span><br><span class="line">                malePersons.add(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> malePersons;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriteriaFemale</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; femalePersons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">            <span class="keyword">if</span>(person.getGender().equalsIgnoreCase(<span class="string">"FEMALE"</span>))&#123;</span><br><span class="line">                femalePersons.add(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> femalePersons;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriteriaSingle</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; singlePersons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">            <span class="keyword">if</span>(person.getMaritalStatus().equalsIgnoreCase(<span class="string">"SINGLE"</span>))&#123;</span><br><span class="line">                singlePersons.add(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singlePersons;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndCriteria</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Criteria criteria;</span><br><span class="line">    <span class="keyword">private</span> Criteria otherCriteria;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndCriteria</span><span class="params">(Criteria criteria, Criteria otherCriteria)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.criteria = criteria;</span><br><span class="line">        <span class="keyword">this</span>.otherCriteria = otherCriteria;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);</span><br><span class="line">        <span class="keyword">return</span> otherCriteria.meetCriteria(firstCriteriaPersons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrCriteria</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Criteria criteria;</span><br><span class="line">    <span class="keyword">private</span> Criteria otherCriteria;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrCriteria</span><span class="params">(Criteria criteria, Criteria otherCriteria)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.criteria = criteria;</span><br><span class="line">        <span class="keyword">this</span>.otherCriteria = otherCriteria;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);</span><br><span class="line">        List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : otherCriteriaItems) &#123;</span><br><span class="line">            <span class="keyword">if</span>(! firstCriteriaItems.contains(person))&#123;</span><br><span class="line">                firstCriteriaItems.add(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstCriteriaItems;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriteriaPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">"Robert"</span>,<span class="string">"Male"</span>, <span class="string">"Single"</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">"John"</span>,<span class="string">"Male"</span>, <span class="string">"Married"</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">"Laura"</span>,<span class="string">"Female"</span>, <span class="string">"Married"</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">"Diana"</span>,<span class="string">"Female"</span>, <span class="string">"Single"</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">"Mike"</span>,<span class="string">"Male"</span>, <span class="string">"Single"</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">"Bobby"</span>,<span class="string">"Male"</span>, <span class="string">"Single"</span>));</span><br><span class="line"></span><br><span class="line">        Criteria male = <span class="keyword">new</span> CriteriaMale();</span><br><span class="line">        Criteria female = <span class="keyword">new</span> CriteriaFemale();</span><br><span class="line">        Criteria single = <span class="keyword">new</span> CriteriaSingle();</span><br><span class="line">        Criteria singleMale = <span class="keyword">new</span> AndCriteria(single,male);</span><br><span class="line">        Criteria singleOrFemale = <span class="keyword">new</span> OrCriteria(single,female);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Males: "</span>);</span><br><span class="line">        printPersons(male.meetCriteria(persons));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Females: "</span>);</span><br><span class="line">        printPersons(female.meetCriteria(persons));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Single Males: "</span>);</span><br><span class="line">        printPersons(singleMale.meetCriteria(persons));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Single Or Females: "</span>);</span><br><span class="line">        printPersons(singleOrFemale.meetCriteria(persons));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersons</span><span class="params">(List&lt;Person&gt; persons)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://i.loli.net/2020/04/04/4SnAKm35FyvH7Jp.png" alt="img"></p>
<p> 我们为 Person 建造了多个 Criteria 并利用它们进行过滤。我们还可以将这些标准进行逻辑操作，使用多个标准来对对象进行过滤。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/filter-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/filter-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2020/04/04/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="行为型模式–中介者模式"><a href="#行为型模式–中介者模式" class="headerlink" title="行为型模式–中介者模式"></a>行为型模式–中介者模式</h1><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p>
<p><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。</p>
<p><strong>如何解决：</strong>将上述网状结构分离为星型结构。</p>
<p><strong>关键代码：</strong>对象 Colleague 之间的通信封装到一个类中单独处理。</p>
<p><strong>应用实例：</strong> 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</p>
<p><strong>优点：</strong> 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。</p>
<p><strong>缺点：</strong>中介者会庞大，变得复杂难以维护。</p>
<p><strong>使用场景：</strong> 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p>
<p><strong>注意事项：</strong>不应当在职责混乱的时候使用。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 <em>ChatRoom</em> 和 <em>User<em>。</em>User</em> 对象使用 <em>ChatRoom</em> 方法来分享他们的消息。</p>
<p><em>MediatorPatternDemo*，我们的演示类使用 *User</em> 对象来显示他们之间的通信。</p>
<p><img src="https://i.loli.net/2020/04/04/OhHFloWqvdMENpI.png" alt="img"></p>
<p> 1、创建中介类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(User user, String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date().toString()+<span class="string">"["</span>+user.getName()+<span class="string">"] :"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建User类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        ChatRoom.showMessage(<span class="keyword">this</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用 User 对象来显示它们之间的通信</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User robert = <span class="keyword">new</span> User(<span class="string">"Robert"</span>);</span><br><span class="line">        User john = <span class="keyword">new</span> User(<span class="string">"John"</span>);</span><br><span class="line">        robert.sendMessage(<span class="string">"Hi, John"</span>);</span><br><span class="line">        john.sendMessage(<span class="string">"Hello, Robert"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/jNMSEFBdg6qp8m2.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/mediator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/mediator-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2020/04/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="结构型模式–装饰器模式"><a href="#结构型模式–装饰器模式" class="headerlink" title="结构型模式–装饰器模式"></a>结构型模式–装饰器模式</h1><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。它是作为现有类的一个包装。</p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<p><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>
<p><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。</p>
<p><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。</p>
<p><strong>关键代码：</strong> 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p>
<p><strong>应用实例：</strong> 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p>
<p><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p><strong>缺点：</strong>多层装饰比较复杂。</p>
<p><strong>使用场景：</strong> 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>
<p><strong>注意事项：</strong>可代替继承。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 <em>Shape</em> 接口和实现了 <em>Shape</em> 接口的实体类。然后我们创建一个实现了 <em>Shape</em> 接口的抽象装饰类 <em>ShapeDecorator*，并把 *Shape</em> 对象作为它的实例变量。</p>
<p><em>RedShapeDecorator</em> 是实现了 <em>ShapeDecorator</em> 的实体类。</p>
<p><em>DecoratorPatternDemo*，我们的演示类使用 *RedShapeDecorator</em> 来装饰 <em>Shape</em> 对象。</p>
<p><img src="https://i.loli.net/2020/04/04/h5SvMjW6mnIqJ7u.png" alt="img"></p>
<p> 1、创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Shape: Rectangle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Shape: Circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建实现了 Shape 接口的抽象装饰类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Shape shapeDecorator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape shapeDecorator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shapeDecorator = shapeDecorator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shapeDecorator.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、创建扩展了 ShapeDecorator 类的实体装饰类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape shapeDecorator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(shapeDecorator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">        setRedBorder(shapeDecorator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Board Color: Red"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、使用 RedShapeDecorator 来装饰 Shape 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        ShapeDecorator redCircle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Circle());</span><br><span class="line">        ShapeDecorator redRectangle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Rectangle());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Circle with normal boarder"</span>);</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\nCircle of red boarder"</span>);</span><br><span class="line">        redCircle.draw();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\nRectangle of red boarder"</span>);</span><br><span class="line">        redRectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/97bGozjSDYws2Zy.png" alt="img"></p>
<p> 我们使用 RedShapeDecorator 装饰类来对 Shape 对象扩展红色的功能，而不是使用RedCircle 继承 Circle 这种方法，避免了子类膨胀。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/decorator-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2020/04/04/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h3 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a><strong>网络层的功能</strong></h3><h4 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h4><p>　　网络互联：将两个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备（中间设备）连接起来。</p>
<p>　　中继设备分以下四种：</p>
<p>　　1）物理层中继设备：中继器，集线器。</p>
<p>　　2）数据链路层中继设备：网桥或交换机。</p>
<p>　　3）网络层中继设备：路由器。</p>
<p>　　4）网络层以上的中继设备：网关。</p>
<p>　　使用物理层的中继设备时，只是把一个网络扩大了，从网络层的角度看仍是同一个网络。网络互联通常指用路由器进行网络互联和路由选择。</p>
<p>　　TCP/IP 体系在网络互联上采用的做法是在网络层采用标准化协议，相互连接的网络可以是异构的。</p>
<p>　　</p>
<h4 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h4><p>　　路由器主要完成两个功能：一是路由选择（确定哪一条路径），二是分组转发（当一个分组到达时采取的动作）。前者是根据特定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断更新和维护路由表。后者处理通过路由器的数据流，关键操作是转发表查询、转发及相关地队列管理和任务调度等。</p>
<p>　　1）路由选择：按照复杂的分布式算法，根据相邻路由器所得到地关于整个网络拓扑的变化情况，动态地选择路由。</p>
<p>　　2）分组转发：指路由器按照转发表将用户的 IP 数据报从合适的端口转发出去。</p>
<p>　　</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>　　因出现过量的分组而引起网络性能下降的现象称为拥塞。拥塞控制的作用是确保子网能够承载所达到的流量。</p>
<p>　　流量控制：抑制发送端的发送数据速率。</p>
<p>　　拥塞控制方法：</p>
<p>​        1）开环控制。在设计网络时事先将有关发生拥塞的因素考虑到。</p>
<p>​        2）闭环控制。采用检测系统监视。</p>
<h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a><strong>路由算法</strong></h3><h4 id="静态路由与动态路由"><a href="#静态路由与动态路由" class="headerlink" title="静态路由与动态路由"></a>静态路由与动态路由</h4><p>​        静态路由算法（非自适应路由算法）。指由网络管理员手工配置的路由信息。</p>
<p>​        动态路由算法（自适应路由算法）。路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的。</p>
<p>　　</p>
<h4 id="距离-向量路由算法"><a href="#距离-向量路由算法" class="headerlink" title="距离-向量路由算法"></a>距离-向量路由算法</h4><p>　　在距离-向量路由算法中所有结点定期地将它们的整个路由选择表传送给所有与之相连的结点。这种路由表包含：1）每条路径的目的地（另一结点）；2）路径的代价（也称距离）。RIP中将距离定义为跳数–从源端口到目的端口的路由器个数。<strong>“好消息传的快，坏消息传的慢”</strong></p>
<p>　　</p>
<h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h4><p>　　链路状态路由算法要求每个参与该算法的结点都具有完全的网络拓扑信息。它们执行下述两项任务：1）主动测试所有邻接结点的状态。2）定期地将链路状态传播给所有其他结点。典型的链路状态算法是OSPF算法。</p>
<p>　　链路状态路由算法有3个特征：</p>
<p>　　1）向本自治系统中所有路由器发送信息，治理使用的方法是洪泛法，路由器通过所有端口向所有相邻的路由器发送信息。每个相邻的路由器又将信息发往所有其他的路由器。</p>
<p>　　2)发送的信息是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。</p>
<p>　　3）只有当链路状态发生变化时，路由器才向所有路由器发送此消息。</p>
<h4 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h4><p>　　因特网把路由选择协议分为两大类：</p>
<p>　　1）一个自治系统内部所使用的路由选择协议称为内部网关协议（IGP），也称域内路由选择，具体的协议有RIP 和OSPF 等。</p>
<p>　　2）自治系统之间所使用的路由选择协议称为外部网关协议（EGP），也称域间路由选择，用在不同自治系统的路由器之间交换路由信息。具体的协议有BGP。</p>
<h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a><strong>IPv4</strong></h3><h4 id="IPv4分组"><a href="#IPv4分组" class="headerlink" title="IPv4分组"></a>IPv4分组</h4><p><img src="https://i.loli.net/2020/04/04/2S4LzoC5UadXEVb.png" alt="img"></p>
<p> 　一个IP分组由首部和数据两部分组成。首部前一部分长度固定，共20B。</p>
<p>　　1）版本。占4位。IP版本，目前使用4。</p>
<p>　　2）首部长度。占4位。<strong>以4B为单位</strong>，最大值为60B（4位最多表示15），最常用20B。</p>
<p>　　3）总长度。占16位。指首部和数据部分的总长度，<strong>单位为字节</strong>，所以最长65535B。</p>
<p>　　4）标识。占16位。它是一个计数器，每产生一个数据报就加1，并赋值给标识字段。</p>
<p>　　5）标志。占3位。X DF MF 共三位。<strong>DF=0表示可以分片。MF=1表示后面还有分片</strong>。</p>
<p>　　6）片偏移。占13位。它指出较长的分组在分片后，某片在原分组中的相对位置。<strong>以8B为单位</strong>。每个分片的长度一定是8B的整数倍。</p>
<p>　　7）首部校验和。占16位。只校验分组的首部，不校验数据部分。</p>
<p>　　8）生存时间（TTL）。占8位。数据段在网络中可通过的路由器的最大值。</p>
<p>　　9）协议。占8位指出分组携带的数据使用何种协议，6 代表 TCP，17 代表UDP。</p>
<p>　　10）源地址字段。占4B，标识发送方的IP地址。</p>
<p>　　11）目的地址字段。占4B，标识接收方的IP地址。</p>
<p>　　</p>
<p>　　分片例子：</p>
<p><img src="https://i.loli.net/2020/04/04/ms5cGHWLrvOjZJX.png" alt="img"></p>
<p> 　网络层转发分组的流程：</p>
<p>　　1）从首部中取出目的主机的IP地址 D，得出目的网络地址N。</p>
<p>　　2）若网络N与此路由器直接相连，把数据报直接交付给目的主机D。否则间接交付执行3。</p>
<p>　　3）若路由表中有目的地址为D的特定主机路由，把数据报传到下一跳路由器。否则执行4。</p>
<p>　　4）若路由表中有到达网络N的路由器，传给下一跳路由器，否则执行5。</p>
<p>　　5）若路由表中有一个默认路由，把数据报传给默认路由，否则执行6。</p>
<p>　　6）报告转发分组出错。</p>
<p>　　总结：检查接收主机是否与发送主机在同一局域网内–》 检查是否可以通过下一跳路由器直达接收主机 –》 检查是否可以通过下一跳路由器到达另一个路由器（可到达目的主机）–》报错。</p>
<p>　　注意：得到下一跳路由器IP地址后不是直接将下一跳路由器的IP之间填入IP数据报首部。而是将其封装在帧中，改变帧的接收MAC地址。通过这个MAC地址找到下一跳路由器。<strong>在不同网络中传送时，MAC帧中的源地址和目的地址要发生变化，网桥在转发帧时，不改变帧的源地址。</strong></p>
<p>　　</p>
<h4 id="IPv4地址与NAT"><a href="#IPv4地址与NAT" class="headerlink" title="IPv4地址与NAT"></a>IPv4地址与NAT</h4><h5 id="IPv4-地址"><a href="#IPv4-地址" class="headerlink" title="IPv4 地址"></a>IPv4 地址</h5><p>　　连接到因特网上的每台主机或路由器都分配一个32比特的全球唯一标识符，即IP地址。传统的IP地址是分类的地址，分为A，B，C，D，E五类。</p>
<p><img src="https://i.loli.net/2020/04/04/YOFb4qsouhinm6T.png" alt="img"></p>
<p>　　<strong>IP地址=网络号+主机号</strong></p>
<p>　　 特殊用途的IP地址：</p>
<p>　　a.主机号全0表示网络本身。</p>
<p>　　b.主机号全1表示网络的广播地址。</p>
<p>　　c. 127.0.0.0 保留为环路自检地址，此地址表示任意主机本身。</p>
<p>　　d.32位全为0，0.0.0.0表示本网络上的本主机</p>
<p>　　e.32位全为1 255.255.255.255 表示整个TCP/IP网络的广播地址，又称受限广播地址。</p>
<p><img src="https://i.loli.net/2020/04/04/FZVzXlYEQIjDyxP.png" alt="img"></p>
<h5 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h5><p>　　网络地址转换（NAT）是指将专用网络地址（如Internet）转换为公用地址（ 如Internet）。它使整个专用网只需一个全球IP地址就可以与因特网连通。工作在传输层。</p>
<p>　　一个典型NAT 转换表 WAN 138.76.29.7：5001 ；LAN 192.168.0.2：2233。NAT 工作在传输层。</p>
<p>　　私有IP地址只用于LAN，不用于WAN连接。私有IP网段如下：</p>
<p>　　A类：1个A类网段，<strong>10</strong>.0.0.0 ~ <strong>10</strong>.255.255.255.255</p>
<p>　　B类：16个B类网段，<strong>172.16</strong>.0.0 ~ <strong>172.31</strong>.255.255</p>
<p>　　C类：256个C类网段，<strong>192.168.0</strong>.0~<strong>192.168.255</strong>.255</p>
<h4 id="子网划分与子网掩码、CIDR"><a href="#子网划分与子网掩码、CIDR" class="headerlink" title="子网划分与子网掩码、CIDR"></a>子网划分与子网掩码、CIDR</h4><h5 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h5><p>　　子网划分纯属一个单位内部的事情，对外仍然表现为没有划分子网的网络。仅仅是把主机号这部分再进行划分。</p>
<h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>　　子网验码是一个与IP地址相对应的、长32bit的二进制串，由一串1和一串0组成。1对应网络号和子网号，0对应主机号。</p>
<p>　　</p>
<p>　　使用子网验码的分组转发如下：</p>
<p>　　a.从首部中取出目的主机的IP地址 D。</p>
<p>　　b.对<strong>路由器直接相连的网络</strong>逐个检查，用各网络的子网验码和D逐位做与操作，如果结果等于该网络的网络号，直接交付，否则间接交付执行c。</p>
<p>　　c.若路由表中有目的地址为D的特定主机路由，把数据报传到下一跳路由器。否则执行d。</p>
<p>　　d.检查路由表中每一行，如果子网掩码与D的与操作结果与目的网络地址网络号相同则传给下一跳路由器，否则执行e。</p>
<p>　　e.若路由表中有一个默认路由，把数据报传给默认路由，否则执行f。</p>
<p>　　f.报告转发分组出错。</p>
<p>　　总结：检查接收主机是否与发送主机在同一局域网内–》 检查是否可以通过下一跳路由器直达接收主机 –》 检查是否有默认路由–》报错。</p>
<h5 id="无分类域间路由选择（CIDR）"><a href="#无分类域间路由选择（CIDR）" class="headerlink" title="无分类域间路由选择（CIDR）"></a>无分类域间路由选择（CIDR）</h5><p>　　CIDR使用“网络前缀”的概念代替子网的概念。</p>
<p>　　<strong>CIDR使用斜线计法 IP地址/网络前缀占用比特数。</strong></p>
<h4 id="ARP、DHCP与ICMP"><a href="#ARP、DHCP与ICMP" class="headerlink" title="ARP、DHCP与ICMP"></a>ARP、DHCP与ICMP</h4><p>　　1）IP地址与硬件地址</p>
<p>　　IP地址由于路由器的隔离不能进行广播，这时候就只能通过数据链路层的MAC地址以广播方式寻址。</p>
<p>　　2）地址解析协议（ARP）</p>
<p>　　IP到MAC地址的映射，这就是地址解析协议（Address Resolution Protocol，ARP）。</p>
<p>　　<strong>ARP工作在网络层，先查看ARP缓存，如果没有目的IP对应的MAC地址则使用目的MAC地址为ff-ff-ff-ff-ff-ff的帧来封装并广播ARP请求分组。</strong>目的主机收到该 ARP 请求后向源主机发出 ARP 响应分组。</p>
<p>　　3）动态主机配置协议（DHCP）</p>
<p>　　动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）常用于给主机动态地分配IP地址，提供了即插即用地机制，允许一台计算机加入新的网络和获取IP地址。DHCP是<strong>应用层</strong>协议，它是基于UDP的。</p>
<p>　　4）网际控制报文协议（ICMP）</p>
<p>　　为了提高IP数据报交付成功的机会，在网络层使用了网际控制报文协议（Internet Control Message Protocol，ICMP）来让主机或路由器报告差错和异常情况。ICMP报文作为IP数据报的数据，加上数据报的首部，组成IP数据报发送出去。</p>
<p>　　ICMP报文有两种 ICMP差错报文和ICMP询问报文。</p>
<p>　　ICMP差错报文5种类型：</p>
<p>　　1）终点不可达。路由器或主机不能交付数据报。</p>
<p>　　2）源点抑制。路由器或主机由于拥塞丢弃数据报。</p>
<p>　　3）时间超过。路由器收到TTL=0的数据报。</p>
<p>　　4）参数问题。路由器或主机收到数据报中首部字段值不正确。</p>
<p>　　5）改变路由（重定向）。路由器把改变路由报文发送给主机。</p>
<p>　　不发送ICMP 差错报文的情况：</p>
<p>　　1）对ICMP 差错报文不发送。</p>
<p>　　2）对第一个分片的数据报片后续所有数据报片都不发送。</p>
<p>　　3）对组播地址的数据报不发送。</p>
<p>　　4)对具有特殊地址的数据报不发送。</p>
<p>　　</p>
<p>　　ICMP询问报文有4种类型：回送请求和回答报文、时间戳请求和回答报文、掩码地址请求和回答报文、路由器询问和通告报文。</p>
<p>　　<strong>ICMP的常见应用是分组间探测PING，PING使用了ICMP会送请求和回答报文。PING工作在应用层，直接使用网络层的ICMP回送请求和回答报文。</strong></p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="IPv6-特点"><a href="#IPv6-特点" class="headerlink" title="IPv6 特点"></a>IPv6 特点</h4><p>　　1）IPv6共128位，2）简化了IP分组头3）更好地支持选项</p>
<p>　　</p>
<h4 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h4><p>　　IPv6 数据报的目的地址可以是 单播、多播和组播。</p>
<p>　　IPv4 向IPv6 过渡可以采用双协议栈和隧道技术两种策略。双协议栈是指在一台设备上同时装有IPv4 和IPv6 协议栈。隧道技术是将整个IPv6数据报封装到IPv4的数据部分。</p>
<h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><h4 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h4><p>　　自治系统（Automatic System，AS）单一技术管理下的一组路由器。</p>
<p>　　</p>
<h4 id="域内路由和域间路由"><a href="#域内路由和域间路由" class="headerlink" title="域内路由和域间路由"></a>域内路由和域间路由</h4><p>　　1）内部网关协议（Internal Gateway Protocol，IGP）：在一个自治系统内部使用的路由选择协议。如 RIP、OSPF。</p>
<p>　　2） 外部网关协议（External Gateway Protocol，EGP）：自治系统之间的路由选择协议。如BGP-4。</p>
<p>　　</p>
<h4 id="路由信息协议（RIP）"><a href="#路由信息协议（RIP）" class="headerlink" title="路由信息协议（RIP）"></a>路由信息协议（RIP）</h4><p>　　网络中的每个路由器维护从它自身到每个目的网络的距离记录。RIP距离最大为15，超过15代表不可达。RIP默认在任意两个使用RIP的路由器之间每30秒广播一次RIP路由更新信息，以便自动建立并维护路由表。RIP中每个网络的子网掩码必须相同。</p>
<p>　　RIP 的特点：</p>
<p>　　1）仅和相邻路由器交换信息。</p>
<p>　　2）路由器交换的信息是当前路由器所知道的全部信息，即自己的额路由表。</p>
<p>　　3）按固定的时间间隔交换路由器信息，如每隔30秒。</p>
<p>　　</p>
<p>　　距离向量算法：</p>
<p>　　每个路由表都有三个关键数据：&lt;目的网络N，距离d，下一跳路由器X&gt;</p>
<p>　　1）对每个相邻路由器中发过来的RIP报文，先修改所有的项目，把“下一跳”字段中的地址都改为 X，并把所有“距离”字段加1。</p>
<p>　　2）对修改后的RIP报文中的每个项目，执行如下步骤。</p>
<p>　　a.当原来的路由表中没有目的网络N时，把该项目添加到路由表中。</p>
<p>　　b.当原来的路由表中有目的网络N，且下一跳路由器地址是X时，用收到的项目替换原路由表中的项目。</p>
<p>　　c.当原来的路由表中有目的网络N，且下一跳地址不是X时，选择距离较小的更新。</p>
<p>　　3）如果180 秒（RIP 默认超时时间为 180秒）还没有收到相邻路由器的更新路由器，那么把此相邻路由器记为不可达路由器。</p>
<p>　　</p>
<p>　　RIP最大优点是实现简单、开销小、收敛过程较快。</p>
<p>　　RIP缺点如下：</p>
<p>　　a.限制了网络的规模</p>
<p>　　b.路由器之间交换的是路由器中的完整路由表因此网络规模越大，开销也越大。</p>
<p>　　c.网络出现故障时，会出现慢收敛现象（需要较长时间才能将此信息传到所有路由器）俗称坏消息传的慢。</p>
<p>　　</p>
<h4 id="开放最短路径优先（OSPF）协议"><a href="#开放最短路径优先（OSPF）协议" class="headerlink" title="开放最短路径优先（OSPF）协议"></a>开放最短路径优先（OSPF）协议</h4><h5 id="OSPF-和-RIP-的区别。"><a href="#OSPF-和-RIP-的区别。" class="headerlink" title="OSPF 和 RIP 的区别。"></a>OSPF 和 RIP 的区别。</h5><p>　　a.OSPF 向本自治系统中的所有路由器发送信息，使用的是洪泛法。RIP仅向临近的路由器发送信息。</p>
<p>　　b.发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是部分信息。RIP发送整个路由表。</p>
<p>　　c.只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p>
<p>　　d.OSPF是网络层协议，它不使用UDP或TCP，而直接使用IP数据报传送（其IP数据报首部协议字段为89）.RIP是应用层协议，它在传输层使用UDP。</p>
<h5 id="OSPF-基本工作原理"><a href="#OSPF-基本工作原理" class="headerlink" title="OSPF 基本工作原理"></a>OSPF 基本工作原理</h5><p>　　各个路由器之间频繁地交换链路状态信息，所有路由器最终都能建立一个链路状态数据库。这个数据库就是全网的拓扑结构，它在全网范围内是一致的。每个路由器根据这个全网拓扑结构图，使用Dijkstra 最短路径算法计算从自己到各目的网络的最优路径，以此构造自己的路由表。当链路状态更新时需要重新计算。</p>
<p>　　注意：虽然使用Dijkstra算法能计算出完整的最优路径，但路由表中不会存储完整的路径，而只存储“下一跳”（只有到了下一跳路由器才能再知道下一跳怎样走）。</p>
<p>　　</p>
<p>　　OSPF 的五种分组类型：</p>
<p>　　a.问候分组，用来维持临站的可达性。</p>
<p>　　b.数据库描述分组，向临站给出自己的链路状态数据库中所有链路状态的摘要信息。</p>
<p>　　c.链路状态请求分组，向对方请求发送某些链路状态项目的详细信息。</p>
<p>　　d.链路状态更新分组，用洪泛法对全网更新链路状态。</p>
<p>　　e.链路状态确认分组，对链路更新分组的确认。</p>
<p>　　通常每隔10秒，每两个相邻路由器都要交换一次问候分组，以便知道哪些站可达。OSPF 还归档每隔一段时间就刷新数据库中的链路状态。</p>
<p>　　</p>
<h4 id="边界网关协议（BGP）"><a href="#边界网关协议（BGP）" class="headerlink" title="边界网关协议（BGP）"></a>边界网关协议（BGP）</h4><p>　　边界网关协议（Border Gateway Protocol，BGP）是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议。只能尽力寻找一条能够到达目的网络且比较好的路由，而非寻找一条最佳路由。<strong>BGP 是应用层协议，它是基于TCP的。</strong></p>
<p>　　BGP的工作原理如下：每个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP”发言人。一个BGP发言人要与其他自治系统中的BGP发言人交换路由信息，就要先建立TCP连接。在此连接上交换BGP报文以建立BGP会话，在利用BGP会话交换路由信息。</p>
<p>　　BGP特点：1）BGP 交换路由信息的结点数量级是自治系统的数量级。2）每个自治系统中的BGP发言人数目是很少的。</p>
<p>　　BGP共使用4种报文：</p>
<p>　　1）打开报文。用来与相邻的另一个BGP发言人建立关系。</p>
<p>　　2）更新报文。用来发送某一路由的信息，以及要撤销的多条路由。</p>
<p>　　3）保活报文。用来确认打开报文并周期性地证实临站关系。</p>
<p>　　4）通知报文。用来发送检测到地差错。</p>
<p><img src="https://i.loli.net/2020/04/04/orCBvgIw8smXcWj.png" alt="img"></p>
<h3 id="IP-组播"><a href="#IP-组播" class="headerlink" title="IP 组播"></a><strong>IP 组播</strong></h3><h4 id="组播的概念"><a href="#组播的概念" class="headerlink" title="组播的概念"></a>组播的概念</h4><p>　　人们所需要的组播机制是让源计算机一次发送的单个分组可以抵达用一个组标识的若干目标主机，并被它们正确接收。</p>
<p>　　组播一定仅应用于UDP。主机使用一个称为IGMP（因特网组管理协议）的协议加入组播组。主机在组播时仅发送一份数据，只有数据在传送路径出现分岔时才将分组复制后继续转发。组播需要路由器的支持。</p>
<h4 id="IP-组播地址"><a href="#IP-组播地址" class="headerlink" title="IP 组播地址"></a>IP 组播地址</h4><p>　　IP 组播使用 D类地址格式。D类地址前四位是1110，因此D类地址范围是 224.0.0.0 ~ 239.255.255.255.每个D类地址标志一个组播组。</p>
<p>　　组播数据报与一般IP数据报的区别是，前者使用D类IP 地址作为目的地址，并且首部中的协议字段值是2，表明使用IGMP。需要注意的是：</p>
<p>　　1）组播数据报也是“尽最大努力交付”，不提供可靠交付。</p>
<p>　　2）组播地址只能用于目的地址，而不能用于源地址。</p>
<p>　　3）对组播数据报不产生ICMP差错报文。</p>
<p>　　4）并非所有D类地址都可以作为组播地址。</p>
<p><img src="https://i.loli.net/2020/04/04/ev5FiWZCnjNrbsV.png" alt="img"></p>
<h4 id="IGMP-与组播路由算法"><a href="#IGMP-与组播路由算法" class="headerlink" title="IGMP 与组播路由算法"></a>IGMP 与组播路由算法</h4><p>　　IGMP 应视为 TCP/IP 的一部分，其工作可分为两个阶段：</p>
<p>　　1）当某台主机加入新的组播组时，该主机应向组播组地址发送一个IGMP 报文，声明自己要称为该组的成员。</p>
<p>　　2）本地组播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否仍继续时组的成员。</p>
<p>　　</p>
<h3 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a><strong>移动IP</strong></h3><h4 id="移动-IP-的概念"><a href="#移动-IP-的概念" class="headerlink" title="移动 IP 的概念"></a>移动 IP 的概念</h4><p>　　支持移动性的因特网体系结构与协议共称移动IP。它是为了满足移动结点在移动中保持其连接性而设计的。</p>
<p>　　基于IPv4 的移动IP定义三种功能实体：移动结点、本地代理和外部代理。本地代理和外部代理又称为移动代理。</p>
<p>　　1）移动结点。具有永久IP地址的移动结点。</p>
<p>　　2）本地代理。在一个网络环境中，一个移动结点的永久“居所”被称为归属网络，在归属网络中代表移动结点执行移动管理功能的实体称为本地代理。</p>
<p>　　3）外部代理。在外部网络中帮助移动结点完成移动管理功能的实体称为外部代理。</p>
<h4 id="移动IP通信过程"><a href="#移动IP通信过程" class="headerlink" title="移动IP通信过程"></a>移动IP通信过程</h4><p>　　移动IP为移动主机设置了两个IP地址，即主地址和辅地址。移动主机在本地网时，使用的是主地址。当移动到另一个网络时，需要获得一个临时的辅地址，但此时主地址仍不变，从外网移回本地网时，辅地址改变或撤销，主地址仍然保持不变。</p>
<h3 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h3><h4 id="路由器的组成和功能"><a href="#路由器的组成和功能" class="headerlink" title="路由器的组成和功能"></a>路由器的组成和功能</h4><p>　　路由器是一种具有多个输入/输出端口的专用计算机，其任务是连接异构网络并完成路由转发，在多个逻辑网络互联时必须使用路由器。如果源主机和目的主机在同一个网络上，那么直接交付而无需通过路由器。如果源主机和目的网络不在同一各网络上，路由器按照转发表指出的路由将数据报转发给下一个路由器，称为间接交付。</p>
<p>　　路由器由路由选择和分组转发两部分构成。路由器是网络层设备，它实现了网络模型的下三层。如果一个存储转发设备实现了某个层次的功能，那么它就可以互联两个在该层次上使用不同协议的网段。例如网桥实现了物理层和数据链路，网桥就可以互联两个物理层和数据链路层不同的网段。</p>
<p>　　路由选择部分也称控制部分，其核心构件是路由选择处理机。</p>
<p><img src="https://i.loli.net/2020/04/04/EBMz9khK71uWvjy.png" alt="img"></p>
<h4 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h4><p><img src="https://i.loli.net/2020/04/04/SQFZdbVO8KBNiDj.png" alt="img"></p>
<h3 id="本章小结及疑难点"><a href="#本章小结及疑难点" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="“尽最大努力交付”有哪些含义？"><a href="#“尽最大努力交付”有哪些含义？" class="headerlink" title="“尽最大努力交付”有哪些含义？"></a>“尽最大努力交付”有哪些含义？</h4><p>​    1）不保证源主机发送的 IP 数据报一定无差错地交付到目的主机。</p>
<p>​    2）不保证源主机发送的 IP 数据报都在某一规定 的时间内交付到目的主机。</p>
<p>​    3）不保证源主机发送的 IP 数据报一定按发送时的顺序交付到目的主机。</p>
<p>​    4）不保证源主机发送的 IP 数据报不会重复交付给目的主机。</p>
<p>​    5）不故意丢弃 IP 数据报。丢弃 IP 数据报的情况是：<strong>路由器检测出首部校验和有错误；或由于网络中通信量过大，路由器或目的主机中的缓存已无存储空间。</strong></p>
<p><strong>交付目的主机的 IP 数据报都是 IP 数据报的首部没有出现差错或没有检测出来有差错的。</strong></p>
<p>​    总结：尽最大努力交付不保证 IP 数据报：无差错、准时到达、按序到达、不会重复交付。丢弃数据报的情况：缓存满。</p>
<h4 id="在互联网中，能否使用一个很大的交换机来代替全部的路由器？"><a href="#在互联网中，能否使用一个很大的交换机来代替全部的路由器？" class="headerlink" title="在互联网中，能否使用一个很大的交换机来代替全部的路由器？"></a>在互联网中，能否使用一个很大的交换机来代替全部的路由器？</h4><p>​        不行。交换机和路由器的功能是很不一样的。交换机和在一个单个的网络中和若干个计算机相连，并且可以将一个计算机发送过来的帧转发给另一个计算机。从这点上看，交换机具有集线器的转发帧的功能。但交换机比集线器的功能强很多。集线器在同一时间只允许一个计算机和其他计算机进行通信，但交换机允许多个计算机同时进行通信。</p>
<p>​        路由器连接两个或几个网络，路由器可在网络之间转发分组（即 IP 数据报）。这些互联的网络是异构的。如果存在异构网络互联，使用交换机是不行的。</p>
<h4 id="当运行-PING-127-0-0-1-时，这个-IP-数据报将发给谁？"><a href="#当运行-PING-127-0-0-1-时，这个-IP-数据报将发给谁？" class="headerlink" title="当运行 PING 127.0.0.1 时，这个 IP 数据报将发给谁？"></a>当运行 PING 127.0.0.1 时，这个 IP 数据报将发给谁？</h4><p>​        127.0.0.1 是环回地址。主机将测试用的 IP 数据报发给本主机的 ICMP（而不是发送到互联网上）以便进行环回测试。</p>
<h4 id="全-1-的-IP-地址是否是向整个互联网进行广播的一种地址？"><a href="#全-1-的-IP-地址是否是向整个互联网进行广播的一种地址？" class="headerlink" title="全 1 的 IP 地址是否是向整个互联网进行广播的一种地址？"></a>全 1 的 IP 地址是否是向整个互联网进行广播的一种地址？</h4><p>​        不是。在 IP 地址中的全 1 地址表示仅在本网络上（发送这个 IP 数据报的主机所连局域网）进行广播。这种广播叫做受限的广播。如果网络号是具体的网络号，主机号全 1 叫做定向广播，这是对某一个具体的网络（网络号指明的网络）上的所有主机进行广播的一种地址。</p>
<h4 id="IP-协议有分片的功能，但广域网中的分组则不必分片。这是为什么？"><a href="#IP-协议有分片的功能，但广域网中的分组则不必分片。这是为什么？" class="headerlink" title="IP 协议有分片的功能，但广域网中的分组则不必分片。这是为什么？"></a>IP 协议有分片的功能，但广域网中的分组则不必分片。这是为什么？</h4><p>​        IP 数据报可能要经过许多个网络，而源主机事先并不知道后面要经过的这些网络中分组的最大长度是多少，当超过某个网络的最大长度限制时就需要分片。</p>
<p>​        广域网能够通过的分组的最大长度是该广域网中所有主机都事先知道的，源主机不可能发送网络不支持的过长分组。</p>
<h4 id="链路层广播和-IP-广播有何区别？"><a href="#链路层广播和-IP-广播有何区别？" class="headerlink" title="链路层广播和 IP 广播有何区别？"></a>链路层广播和 IP 广播有何区别？</h4><p>​        链路层广播使用数据链路层协议，在一个以太网史昂实现对该局域网上所有主机的 MAC 帧进行广播。</p>
<p>​        IP 广播则是用 IP 协议，通过互联网实现的对一个网络上的所有主机的 IP 数据报广播。</p>
<h4 id="当路由器利用-IP-数据报首部中的-“首部校验和”-字段检测出在传输过程中出现了差错时，就简单地将其丢弃。为什么不发送一个-ICMP-报文给源主机呢？"><a href="#当路由器利用-IP-数据报首部中的-“首部校验和”-字段检测出在传输过程中出现了差错时，就简单地将其丢弃。为什么不发送一个-ICMP-报文给源主机呢？" class="headerlink" title="当路由器利用 IP 数据报首部中的 “首部校验和” 字段检测出在传输过程中出现了差错时，就简单地将其丢弃。为什么不发送一个 ICMP 报文给源主机呢？"></a>当路由器利用 IP 数据报首部中的 “首部校验和” 字段检测出在传输过程中出现了差错时，就简单地将其丢弃。为什么不发送一个 ICMP 报文给源主机呢？</h4><p>​        IP 协议并不要求源主机重传有差错的数据报。保证无差错传输是由 TCP 协议完成的。另一方面，首部校验和只能校验出 IP 数据报的首部是否出现差错，但不知道首部中的源地址字段有没有出错，如果出错，将数据报传到错误的地址也是无意义的。</p>
<h4 id="有人认为，不使用-CIDR-也行。例如，使用-CIDR-时，给某单位分配了一个地址块-20，相当于-16-个-C-类地址块。如果不使用-CIDR-，而直接给该单位分配-16-个-C-类地址块，那么在效果上不是一样吗？"><a href="#有人认为，不使用-CIDR-也行。例如，使用-CIDR-时，给某单位分配了一个地址块-20，相当于-16-个-C-类地址块。如果不使用-CIDR-，而直接给该单位分配-16-个-C-类地址块，那么在效果上不是一样吗？" class="headerlink" title="有人认为，不使用 CIDR 也行。例如，使用 CIDR 时，给某单位分配了一个地址块 /20，相当于 16 个 C 类地址块。如果不使用 CIDR ，而直接给该单位分配 16 个 C 类地址块，那么在效果上不是一样吗？"></a>有人认为，不使用 CIDR 也行。例如，使用 CIDR 时，给某单位分配了一个地址块 /20，相当于 16 个 C 类地址块。如果不使用 CIDR ，而直接给该单位分配 16 个 C 类地址块，那么在效果上不是一样吗？</h4><p>​        如果不采用 CIDR ，而直接分配 16 个 C 类地址块，相当于给该单位分配了 16 个 C 类网络。这个单位对外界来说，是 16 个 C 类网络。每一个 C 类网络都要在本单位外面的路由表中占有一个表项，使得路由表更大了。当本单位内的许多主机相互通信时，由于跨越了不同的网络，都必须使用路由器来转发 IP 数据报，开销增大。</p>
<h4 id="IP-数据报中的首部校验和并不检验数据报中的数据，这样做的优缺点是什么？计算首部校验和为什么不使用-CRC-校验码？"><a href="#IP-数据报中的首部校验和并不检验数据报中的数据，这样做的优缺点是什么？计算首部校验和为什么不使用-CRC-校验码？" class="headerlink" title="IP 数据报中的首部校验和并不检验数据报中的数据，这样做的优缺点是什么？计算首部校验和为什么不使用 CRC 校验码？"></a>IP 数据报中的首部校验和并不检验数据报中的数据，这样做的优缺点是什么？计算首部校验和为什么不使用 CRC 校验码？</h4><p>​        优点是不校验数据部分可以加快分组转发的速度，缺点是数据部分出现差错不能及早发现，由上层检查数据是否出错。不使用 CRC 可减少路由器进行校验的时间。</p>
<p><img src="https://i.loli.net/2020/04/11/rPoZzSghkIDjyR6.png" alt="image-20200411110119434"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2020/04/04/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="行为型模式–命令模式"><a href="#行为型模式–命令模式" class="headerlink" title="行为型模式–命令模式"></a>行为型模式–命令模式</h1><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<p><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>
<p><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</p>
<p><strong>关键代码：</strong>定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口</p>
<p><strong>应用实例：</strong>struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p>
<p><strong>优点：</strong> 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。</p>
<p><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。</p>
<p><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</p>
<p><strong>注意事项：</strong>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们首先创建作为命令的接口 <em>Order*，然后创建作为请求的 *Stock</em> 类。实体命令类 <em>BuyStock</em> 和 <em>SellStock*，实现了 *Order</em> 接口，将执行实际的命令处理。创建作为调用对象的类 <em>Broker</em>，它接受订单并能下订单。</p>
<p><em>Broker</em> 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。<em>CommandPatternDemo*，我们的演示类使用 *Broker</em> 类来演示命令模式。</p>
<p><img src="https://i.loli.net/2020/04/04/AeWPFhvN1DkM6KZ.png" alt="img"></p>
<p> 1、创建一个命令接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建一个请求类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"ABC"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Stick [ Name: "</span>+name+<span class="string">",Quantity: "</span>+quantity+<span class="string">" ] bought"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Stick [ Name: "</span>+name+<span class="string">",Quantity: "</span>+quantity+<span class="string">" ] sold"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建实现了 Order 接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyStock</span> <span class="keyword">implements</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuyStock</span><span class="params">(Stock abcStock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        abcStock.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStock</span> <span class="keyword">implements</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellStock</span><span class="params">(Stock abcStock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        abcStock.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、创建命令调用类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Broker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orderList = <span class="keyword">new</span> ArrayList&lt;Order&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeOrder</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        orderList.add(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">            order.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        orderList.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、使用Broker类来接收并执行命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stock abcStock = <span class="keyword">new</span> Stock();</span><br><span class="line"></span><br><span class="line">        BuyStock buyStockOrder = <span class="keyword">new</span> BuyStock(abcStock);</span><br><span class="line">        SellStock sellStockOrder = <span class="keyword">new</span> SellStock(abcStock);</span><br><span class="line"></span><br><span class="line">        Broker broker = <span class="keyword">new</span> Broker();</span><br><span class="line">        broker.takeOrder(buyStockOrder);</span><br><span class="line">        broker.takeOrder(sellStockOrder);</span><br><span class="line"></span><br><span class="line">        broker.placeOrders();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/IgkvH23pxEWoKDc.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/command-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/command-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2020/04/04/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="行为型模式–备忘录模式"><a href="#行为型模式–备忘录模式" class="headerlink" title="行为型模式–备忘录模式"></a>行为型模式–备忘录模式</h1><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当时恢复对象。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p>
<p><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</p>
<p><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。</p>
<p><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。</p>
<p><strong>应用实例：</strong> 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。</p>
<p><strong>优点：</strong> 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p>
<p><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>
<p><strong>使用场景：</strong> 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。</p>
<p><strong>注意事项：</strong> 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>备忘录模式使用三个类 <em>Memento<em>、</em>Originator</em> 和 <em>CareTaker</em>。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。</p>
<p><em>MementoPatternDemo*，我们的演示类使用 *CareTaker</em> 和 <em>Originator</em> 对象来显示对象的状态恢复。</p>
<p><img src="https://i.loli.net/2020/04/04/pkLONuI2i1VD3gG.png" alt="img"></p>
<p> 1、创建 Memento 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建 Originator 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">saveStateToMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建 CareTaker 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;Memento&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento state)</span></span>&#123;</span><br><span class="line">        mementoList.add(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用 CareTaker 类和 Originator 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MementoPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        CareTaker careTaker = <span class="keyword">new</span> CareTaker();</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">"State #1"</span>);</span><br><span class="line">        originator.setState(<span class="string">"State #2"</span>);</span><br><span class="line">        careTaker.add(originator.saveStateToMemento());</span><br><span class="line">        originator.setState(<span class="string">"State #3"</span>);</span><br><span class="line">        careTaker.add(originator.saveStateToMemento());</span><br><span class="line">        originator.setState(<span class="string">"State #4"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Current State: "</span>+originator.getState());</span><br><span class="line">        originator.getStateFromMemento(careTaker.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">"First saved state: "</span>+originator.getState());</span><br><span class="line">        originator.getStateFromMemento(careTaker.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"Second saved state: "</span>+originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/otRQndqHTA9iU1K.png" alt="img"></p>
<p> Memento 记录 Originator 对象的状态， CareTaker 对象负责保存 Memento 对象记录。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/memento-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/memento-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>模板模式</title>
    <url>/2020/04/04/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="行为型模式–模板模式"><a href="#行为型模式–模板模式" class="headerlink" title="行为型模式–模板模式"></a>行为型模式–模板模式</h1><p>在模板模式（Template Pattern）中，一个抽象类公开定义了它的方法/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p>
<p><strong>何时使用：</strong>有一些通用的方法。</p>
<p><strong>如何解决：</strong>将这些通用算法抽象出来。</p>
<p><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现。</p>
<p><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p>
<p><strong>优点：</strong> 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。</p>
<p><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>
<p><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p>
<p><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个定义操作的 <em>Game</em> 抽象类，其中，模板方法设置为 final，这样它就不会被重写。<em>Cricket</em> 和 <em>Football</em> 是扩展了 <em>Game</em> 的实体类，它们重写了抽象类的方法。</p>
<p><em>TemplatePatternDemo*，我们的演示类使用 *Game</em> 来演示模板模式的用法。</p>
<p><img src="https://i.loli.net/2020/04/04/3omVLcfxtAqeHK9.png" alt="img"></p>
<p> 1、创建一个抽象类，它的模板方法被设置为 final</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        initialize();</span><br><span class="line"></span><br><span class="line">        startPlay();</span><br><span class="line"></span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建扩展了上述类的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cricket Game Initialized! Start Playing."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cricket Game Started! Enjoy the game."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cricket Game Finished!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Football Game Initialized! Start Playing."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Football Game Started! Enjoy the game."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Football Game Finished!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用 Game 的模板方法 play() 来演示游戏的定义方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game game = <span class="keyword">new</span> Cricket();</span><br><span class="line">        game.play();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        game = <span class="keyword">new</span> Football();</span><br><span class="line">        game.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/YWuALi69BtNDUJ3.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/template-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/template-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2020/04/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="结构型模式–适配器模式"><a href="#结构型模式–适配器模式" class="headerlink" title="结构型模式–适配器模式"></a>结构型模式–适配器模式</h1><p>　　适配器模式（Adapter Pattern）是作为<strong>两个不兼容的接口之间的桥梁</strong>，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。例如，读卡器是内存卡和电脑之间的适配器。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
<p><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p>
<p><strong>如何解决：</strong>继承或依赖（推荐）。</p>
<p><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。</p>
<p><strong>应用实例：</strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</p>
<p><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p>
<p><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p>
<p><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p>
<p><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们有一个 <em>MediaPlayer</em> 接口和一个实现了 <em>MediaPlayer</em> 接口的实体类 <em>AudioPlayer<em>。默认情况下，</em>AudioPlayer</em> 可以播放 mp3 格式的音频文件。</p>
<p>我们还有另一个接口 <em>AdvancedMediaPlayer</em> 和实现了 <em>AdvancedMediaPlayer</em> 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。</p>
<p>我们想要让 <em>AudioPlayer</em> 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 <em>MediaPlayer</em> 接口的适配器类 <em>MediaAdapter*，并使用 *AdvancedMediaPlayer</em> 对象来播放所需的格式。</p>
<p><em>AudioPlayer</em> 使用适配器类 <em>MediaAdapter</em> 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。<em>AdapterPatternDemo*，我们的演示类使用 *AudioPlayer</em> 类来播放各种格式。</p>
<p><img src="https://i.loli.net/2020/04/04/AxBCiwfhDro5vUI.png" alt="img"></p>
<p> 　1、为媒体播放器和更高级的媒体播放器创建接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType,String fileName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、创建实现了 AdvancedMediaPlayer 接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp4Player</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Playing Mp4 file. name: "</span>+fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VlcPlayer</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Playing vlc file. name: "</span>+fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、创建实现了 MediaPlayer 接口的<strong>适配器类（可以播放视频）</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaAdapter</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AdvancedMediaPlayer advancedMusicPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MediaAdapter</span><span class="params">(String audioType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>))&#123;</span><br><span class="line">            advancedMusicPlayer = <span class="keyword">new</span> VlcPlayer();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">            advancedMusicPlayer = <span class="keyword">new</span> Mp4Player();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>))&#123;</span><br><span class="line">            advancedMusicPlayer.playVlc(fileName);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">            advancedMusicPlayer.playMp4(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　4、创建实现了 MediaPlayer 接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MediaAdapter mediaAdapter; <span class="comment">//添加一个媒体MediaAdapter 使得AudioPlayer 支持播放视频。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp3"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Playing mp3 file. name: "</span>+fileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>) || audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">            mediaAdapter = <span class="keyword">new</span> MediaAdapter(audioType);</span><br><span class="line">            mediaAdapter.play(audioType,fileName);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Invalid media. "</span>+audioType+<span class="string">" format not supported"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　5、使用 AudioPlayer 来播放不同类型的音频格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AudioPlayer audioPlayer = <span class="keyword">new</span> AudioPlayer();</span><br><span class="line"></span><br><span class="line">        audioPlayer.play(<span class="string">"mp3"</span>, <span class="string">"beyond the horizon.mp3"</span>);</span><br><span class="line">        audioPlayer.play(<span class="string">"mp4"</span>, <span class="string">"alone.mp4"</span>);</span><br><span class="line">        audioPlayer.play(<span class="string">"vlc"</span>, <span class="string">"far far away.vlc"</span>);</span><br><span class="line">        audioPlayer.play(<span class="string">"avi"</span>, <span class="string">"mind me.avi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　输出：</p>
<p><img src="https://i.loli.net/2020/04/04/qXJ7ojevdfKGLl5.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/adapter-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/adapter-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2020/04/04/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="行为型模式–策略模式"><a href="#行为型模式–策略模式" class="headerlink" title="行为型模式–策略模式"></a>行为型模式–策略模式</h1><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 Context 对象。策略模式改变 Context 对象的执行算法。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<p><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</p>
<p><strong>关键代码：</strong>实现同一个接口。</p>
<p><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p>
<p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p>
<p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
<p><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p>
<p><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个定义活动的 <em>Strategy</em> 接口和实现了 <em>Strategy</em> 接口的实体策略类。<em>Context</em> 是一个使用了某种策略的类。</p>
<p><em>StrategyPatternDemo*，我们的演示类使用 *Context</em> 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。</p>
<p><img src="https://i.loli.net/2020/04/04/TomPAhiWzBE6tYV.png" alt="img"></p>
<p> 1、创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubtract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建Context类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用Context来查看当它改变策略 Strategy 时的行为变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());</span><br><span class="line">        System.out.println(<span class="string">"10 + 5 = "</span>+context.executeStrategy(<span class="number">10</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubtract());</span><br><span class="line">        System.out.println(<span class="string">"10 - 5 = "</span>+context.executeStrategy(<span class="number">10</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());</span><br><span class="line">        System.out.println(<span class="string">"10 * 5 = "</span>+context.executeStrategy(<span class="number">10</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/fWpuAV12iFE6jTR.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/strategy-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/strategy-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2020/04/04/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="行为型模式–状态模式"><a href="#行为型模式–状态模式" class="headerlink" title="行为型模式–状态模式"></a>行为型模式–状态模式</h1><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。</p>
<p><strong>如何解决：</strong>将各种具体的状态类抽象出来。</p>
<p><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</p>
<p><strong>应用实例：</strong> 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</p>
<p><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p>
<p><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p>
<p><strong>使用场景：</strong> 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。</p>
<p><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 <em>State</em> 接口和实现了 <em>State</em> 接口的实体状态类。<em>Context</em> 是一个带有某个状态的类。</p>
<p><em>StatePatternDemo*，我们的演示类使用 *Context</em> 和状态对象来演示 Context 在状态改变时的行为变化。</p>
<p><img src="https://i.loli.net/2020/04/04/pFTBsYkxqvEe3mb.png" alt="img"></p>
<p> 1、创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Player is in start stage"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Start State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Player is in stop state"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stop State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建 Context 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用 Context 来查看当状态 State 改变时的行为变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line"></span><br><span class="line">        StartState startState = <span class="keyword">new</span> StartState();</span><br><span class="line">        startState.doAction(context);</span><br><span class="line">        System.out.println(context.getState());</span><br><span class="line"></span><br><span class="line">        StopState stopState = <span class="keyword">new</span> StopState();</span><br><span class="line">        stopState.doAction(context);</span><br><span class="line">        System.out.println(context.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当状态 State 改变后，对象的toString方法也发生了变化。</p>
<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/HXnQLia8GxKF3Sj.png" alt="img"></p>
<p>参考：<a href="https://www.runoob.com/design-pattern/state-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/state-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2020/04/04/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="行为型模式–责任链模式"><a href="#行为型模式–责任链模式" class="headerlink" title="行为型模式–责任链模式"></a>行为型模式–责任链模式</h1><p>责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p><strong>何时使用：</strong>在处理消息的时候以过滤很多道。</p>
<p><strong>如何解决：</strong>拦截的类都实现统一接口。</p>
<p><strong>关键代码：</strong>Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p>
<p><strong>应用实例：</strong> 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</p>
<p><strong>优点：</strong> 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p>
<p><strong>缺点：</strong> 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p>
<p><strong>使用场景：</strong> 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p>
<p><strong>注意事项：</strong>在 JAVA WEB 中遇到很多应用。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们创建抽象类 <em>AbstractLogger</em>，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 <em>AbstractLogger</em>。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。</p>
<p><img src="https://i.loli.net/2020/04/04/MXIskRUb7u6FYyr.png" alt="img"></p>
<p> 1、创建抽象的记录器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> AbstractLogger nextLogger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextLogger = nextLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.level &lt;= level)&#123;</span><br><span class="line">            write(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nextLogger != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nextLogger.logMessage(level,message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建扩展了该记录器的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsoleLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Standard Console::Logger: "</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Error Console::Logger: "</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"File::Logger: "</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractLogger <span class="title">getChainOfLoggers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AbstractLogger errorLogger = <span class="keyword">new</span> ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">        AbstractLogger fileLogger = <span class="keyword">new</span> FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">        AbstractLogger consoleLogger = <span class="keyword">new</span> ConsoleLogger(AbstractLogger.INFO);</span><br><span class="line"></span><br><span class="line">        errorLogger.setNextLogger(fileLogger);</span><br><span class="line">        fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> errorLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line"></span><br><span class="line">        loggerChain.logMessage(AbstractLogger.INFO,<span class="string">"This is an information."</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.DEBUG,<span class="string">"This is a debug level information."</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.ERROR,<span class="string">"This is an error information."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/782Gsvf6c4rCl9h.png" alt="img"></p>
<p> 责任链 Error – File – Console </p>
<p>参考：<a href="https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2020/04/04/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="行为型模式–观察者模式"><a href="#行为型模式–观察者模式" class="headerlink" title="行为型模式–观察者模式"></a>行为型模式–观察者模式</h1><p>当对象存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
<p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。</p>
<p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</p>
<p><strong>应用实例：</strong> 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p>
<p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p>
<p><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<p><strong>注意事项：</strong> 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 <em>Subject</em> 类、<em>Observer</em> 抽象类和扩展了抽象类 <em>Observer</em> 的实体类。</p>
<p><em>ObserverPatternDemo*，我们的演示类使用 *Subject</em> 和实体类对象来演示观察者模式。</p>
<p><img src="https://i.loli.net/2020/04/04/2ZDW8mdXlScM7jg.png" alt="img"></p>
<p> 1、创建 Subject 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建 Observer 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建实体观察者类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Binary String: "</span>+Integer.toBinaryString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HexObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hex String: "</span>+Integer.toHexString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OctalObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Octal String: "</span>+Integer.toOctalString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用 Subject 和实体观察者对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> HexObserver(subject);</span><br><span class="line">        <span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line">        <span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"First state change: 15"</span>);</span><br><span class="line">        subject.setState(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Second state change: 10"</span>);</span><br><span class="line">        subject.setState(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/Zm32V8BShouLqGA.png" alt="img"></p>
<p> 我们使用 BinaryObserver、OctalObserver 和 HexObserver 来“观察” Subject 对象的情况，当 Subject 的状态改变时就调用 notifyAllObservers()方法。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/state-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/state-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2020/04/04/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="行为型模式–迭代器模式"><a href="#行为型模式–迭代器模式" class="headerlink" title="行为型模式–迭代器模式"></a>行为型模式–迭代器模式</h1><p>迭代器模式（Iterator Pattern ）用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
<p><strong>主要解决：</strong>不同的方式来遍历整个整合对象。</p>
<p><strong>何时使用：</strong>遍历一个聚合对象。</p>
<p><strong>如何解决：</strong>把在元素之间游走的责任交给迭代器，而不是聚合对象。</p>
<p><strong>关键代码：</strong>定义接口：hasNext, next。</p>
<p><strong>应用实例：</strong>JAVA 中的 iterator。</p>
<p><strong>优点：</strong> 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p>
<p><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<p><strong>使用场景：</strong> 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。</p>
<p><strong>注意事项：</strong>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个叙述导航方法的 <em>Iterator</em> 接口和一个返回迭代器的 <em>Container</em> 接口。实现了 <em>Container</em> 接口的实体类将负责实现 <em>Iterator</em> 接口。</p>
<p><em>IteratorPatternDemo*，我们的演示类使用实体类 *NamesRepository</em> 来打印 <em>NamesRepository</em> 中存储为集合的 <em>Names</em>。</p>
<p><img src="https://img2020.cnblogs.com/i-beta/1450462/202003/1450462-20200317085452375-1651527493.png" alt="img"></p>
<p> 1、创建接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现了 Container 接口的实体类。该类实现了 Iterator 接口的内部类 NameIterator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameRepository</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] names = &#123;<span class="string">"Robert"</span>,<span class="string">"John"</span>,<span class="string">"Julie"</span>,<span class="string">"Lora"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NameIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; names.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())&#123;</span><br><span class="line">                <span class="keyword">return</span> names[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用 NameRepository 来获取迭代器，并打印名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NameRepository nameRepository = <span class="keyword">new</span> NameRepository();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Iterator iter = nameRepository.getIterator(); iter.hasNext();)&#123;</span><br><span class="line">            String name = (String)iter.next();</span><br><span class="line">            System.out.println(<span class="string">"name: "</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/due5PJOoz3E1VUZ.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/iterator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/iterator-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>解决maven依赖下载慢的问题</title>
    <url>/2020/04/04/%E8%A7%A3%E5%86%B3%20IDEA%20%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E5%90%8E%E4%BE%9D%E8%B5%96%E4%B8%8B%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决-IDEA-导入项目后依赖下载慢的问题"><a href="#解决-IDEA-导入项目后依赖下载慢的问题" class="headerlink" title="解决 IDEA 导入项目后依赖下载慢的问题"></a>解决 IDEA 导入项目后依赖下载慢的问题</h1><p>我们找到 IDEA 安装目录下 C:\Program Files\JetBrains\IntelliJ IDEA 2019.3.3\plugins\maven\lib<br>里面会有 maven2 和 maven3 还有其他的文件夹但我们不会去用它们。<br>进入maven3\conf 修改里面的settings.xml<br>在mirrors标签块添加如下代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2020/04/04/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="行为型模式–访问者模式"><a href="#行为型模式–访问者模式" class="headerlink" title="行为型模式–访问者模式"></a>行为型模式–访问者模式</h1><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接收访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>主要将数据结构与数据操作分离。</p>
<p><strong>主要解决：</strong>稳定的数据结构和易变的操作耦合问题。</p>
<p><strong>何时使用：</strong>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</p>
<p><strong>如何解决：</strong>在被访问的类里面加一个对外提供接待访问者的接口。</p>
<p><strong>关键代码：</strong>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p>
<p><strong>应用实例：</strong>您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p>
<p><strong>优点：</strong> 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。</p>
<p><strong>缺点：</strong> 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p>
<p><strong>使用场景：</strong> 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</p>
<p><strong>注意事项：</strong>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个定义接受操作的 <em>ComputerPart</em> 接口。<em>Keyboard<em>、</em>Mouse<em>、</em>Monitor</em> 和 <em>Computer</em> 是实现了 <em>ComputerPart</em> 接口的实体类。我们将定义另一个接口 <em>ComputerPartVisitor<em>，它定义了访问者类的操作。</em>Computer</em> 使用实体访问者来执行相应的动作。</p>
<p><em>VisitorPatternDemo<em>，我们的演示类使用 *Computer</em>、*ComputerPartVisitor</em> 类来演示访问者模式的用法。</p>
<p><img src="https://i.loli.net/2020/04/04/8qB6aYP2cKGeNVx.png" alt="img"></p>
<p> 1、定义一个表示元素的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建扩展了上述接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">    ComputerPart[] parts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        parts = <span class="keyword">new</span> ComputerPart[]&#123;<span class="keyword">new</span> Mouse(),<span class="keyword">new</span> Keyboard(),<span class="keyword">new</span> Monitor()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ComputerPart part : parts) &#123;</span><br><span class="line">            part.accept(computerPartVisitor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、创建实现了上述类的实体访问者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerPartDisplayVisitor</span> <span class="keyword">implements</span> <span class="title">ComputerPartVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying Computer."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Mouse mouse)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying Mouse"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Monitor monitor)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying Monitor."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Keyboard keyboard)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying Keyboard."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ComputerPart computer = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">        computer.accept(<span class="keyword">new</span> ComputerPartDisplayVisitor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://i.loli.net/2020/04/04/5RIuaQ4Otmn3MlZ.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/visitor-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>装配Bean</title>
    <url>/2020/04/04/%E8%A3%85%E9%85%8DBean/</url>
    <content><![CDATA[<h1 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h1><p>Bean – 一种表达实体和信息的规范，便于封装重用。</p>
<p>Bean有以下特点：</p>
<p>1、所有属性为private  2、提供默认构造方法  3、提供Setter和Getter  4、实现Serializable接口</p>
<p>Spring装配Bean三种方式： XML显式配置、Java显式配置、自动装配。</p>
<p><strong>一、自动装配</strong></p>
<p>Spring通过以下两个角度来实现自动化装配</p>
<p>1、组件扫描：Spring会自动发现应用上下文中所创建的bean</p>
<p>2、自动装配：Spring自动满足bean之间的依赖</p>
<p>接下来以一个CD播放器的例子来演示自动装配</p>
<p>首先定义媒体播放器和CD两个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义CD播放器类实现媒体播放器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cd = cd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cd.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@Component注解表明该类会作为组件类，并告知Spring为这个类创建bean</p>
<p>@Autowired注解表明当Spring创建CDPlayer bean 的时候，会通过这个构造器来进行实例化并且会传入一个可设置给CompactDisc类型的bean。</p>
<p>@Autowired注解可以用在类的任何方法上，还可以用于成员变量上。@Inject源于Java依赖注入规范，在大多场景下可与@Autowired互换。</p>
<p>然后定义一个SgtPeppers类，它实现了CompactDisc接口，也是一个组件类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title = <span class="string">"Sgt. Pepper's Lonely Hearts Club Band"</span>;</span><br><span class="line">    <span class="keyword">private</span> String artist = <span class="string">"The Beatles"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Playing "</span>+title+<span class="string">" by "</span>+artist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后定义一个CDPlayer配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 启用组件扫描</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@Configuration代表这是一个配置类</p>
<p>@ComponentScan表示启用组件扫描</p>
<p>组件扫描可以在一个CD播放器一张CD的时候正常工作，但是在有两张CD的时候就不能正常工作了，因为它不知道应该播放哪一张CD，这里我们只有一张披头士的CD，关于多张CD的情况留到后面处理。 </p>
<p>我们也可以用xml来实现组件扫描</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"soundsystem"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>&lt;context:component-scan base-package=”soundsystem” /&gt;表示会在soundsystem这个包内找合适的bean注入到CDplayer</p>
<p>现在定义CDPlayerTest类测试一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.contrib.java.lang.system.StandardOutputStreamLog;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= CDPlayerConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> StandardOutputStreamLog log = <span class="keyword">new</span> StandardOutputStreamLog();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotNull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.play();</span><br><span class="line">        assertEquals(<span class="string">"Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n"</span>,log.getLog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@ContextConfiguration(classes = CDPlayerConfig.class)会使用CDPlayerConfig这个类来配置应用上下文。</p>
<p>下面试试使用XML配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.contrib.java.lang.system.StandardOutputStreamLog;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= <span class="string">"classpath:soundsystem.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerXMLConfigTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> StandardOutputStreamLog log = <span class="keyword">new</span> StandardOutputStreamLog();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotNull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.play();</span><br><span class="line">        assertEquals(<span class="string">"Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n"</span>,log.getLog());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@ContextConfiguration(locations =”classpath:soundsystem.xml”)会使用soundsystem.xml来配置应用上下文。</p>
<p><strong>二、Java显式配置</strong></p>
<p>媒体播放器和CD接口保持不变</p>
<p>接下来看看CD播放器类与自动装配有什么不同之处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cd = cd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cd.play();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>与自动装配比较可以发现类声明上面少了@Component注解 我们没有将CDPlayer声明为一个组件类</p>
<p>SgtPeppers类也没有@Component注解</p>
<p>重点来看看CDplayerConfig类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">compactDisc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CDPlayer <span class="title">cdPlayer</span><span class="params">(CompactDisc cd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里没有@ComponentScan注解然后在配置类中自己定义了两个bean从第一个bean可以看到如果需要注入CompactDisc bean的时候注入的是SgtPeppers类对象，需要注入CDPlayer bean 时注入的时候注入的是CdPlayer对象。</p>
<p>总结一下：Java显式配置与自动装配主要区别在配置类上，Java配置需要显示地声明bean，自动装配配置类有@ComponentScan注解，它会自动扫描带有@Component注解的bean来将其注入到合适的地方。</p>
<p><strong>三、XML显式配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"compactDisc"</span> <span class="attr">class</span>=<span class="string">"soundsystem.SgtPeppers"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cdPlayer"</span> <span class="attr">class</span>=<span class="string">"soundsystem.CDPlayer"</span> <span class="attr">c:cd-ref</span>=<span class="string">"compactDisc"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"compactDisc"</span> <span class="attr">class</span>=<span class="string">"soundsystem.SgtPeppers"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>上述的一行XML配置和上面的一段CDConfig Java配置起到的作用是一样的。</p>
<p>XML中参数的声明是由<constructor-arg>标签来实现，想要注入一个集合可以使用<list>标签包裹集合内所有项</p>
<p>使用<value>标签包裹集合内的一项。</p>
<p>&lt;bean id=”compactDisc”</p>
<p>   class=”soundsystem.BlankDisc”</p>
<p>   c:_0=”Sgt. Pepper’s Lonely Hearts Club Band”</p>
<p>   c:_1=”The Beatles”&gt;</p>
<p>c:_0代表构造器的第一个参数，c:_1代表构造器的第二个参数。</p>
<p><strong>四、混合配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(CDPlayerConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@ImportResource("classpath:cd-config.xml")</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundSystemConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>加粗的两个注解从一个Java配置类和一个XML文档加载应用上下文。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络体系结构</title>
    <url>/2020/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a><strong>计算机网络概述</strong></h3><h4 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h4><p>　　1）广义观点：只要是能实现远程信息处理的系统或能进一步达到资源共享的系统，都是计算机网络。</p>
<p>　　2）资源共享观点：计算机网络是 “以能够共享资源的方式互联起来的自治计算机系统的集合” 。该定义包含三层含义： 1、目的：资源共享；2、组成单元：分布在不同地理位置的多台独立的 “ 自治计算机”；3、网络中的计算机额必须遵循统一的规则–网络协议。</p>
<p>　　3）用户透明性观点：存在一个能够为用户自动管理的网络操作系统，它能够调用用户所需要的资源。　　</p>
<h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h4><p>　　1）从组成部分上来看：完整的计算机网络主要由<strong>硬件、软件、协议</strong>三大部分组成。硬件主要由主机、通信链路（双绞线、光纤）、交换设备（路由器、交换机）和通信处理机（网卡）等组成。软件主要是各种实现资源共享的软件和方便用户使用的各种工具软件（OS、FTP程序等），多属于应用层。协议规定了网络传输数据时所遵循的规范。</p>
<p>　　2）从工作方式来看：计算机网络可分为<strong>边缘部分</strong>和<strong>核心部分。</strong>边缘部分由供用户直接使用的主机使用，核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。</p>
<p>　　3）从功能组成上看，计算机网络由通信子网和资源子网组成，通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络有数据传输、交换、控制和存储的能力。资源子网向网络用户提供共享其他计算机的资源的服务。</p>
<h4 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h4><p>　　1）<strong>数据通信</strong>：实现联网计算机之间的各种信息的传输。</p>
<p>　　2）<strong>资源共享</strong>：软件、硬件、数据的共享。</p>
<p>　　3）分布式处理：当某个计算机系统负荷过重，将任务分配给其他计算机系统。</p>
<p>　　4）提高可靠性。</p>
<p>　　5）负载均衡： 将工作任务均衡地分配给计算机网络中的各台计算机。</p>
<h4 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h4><h5 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h5><p>　　1）广域网 WAN（Wide Area Network）：广域网提供长距离通信。</p>
<p>　　2）城域网 MAN（Metropolitan Area Network）：大多采用以太网技术 覆盖城市或街区。</p>
<p>　　3）局域网 LAN（Local Area Network）：覆盖范围较小，传统上，局域网使用广播技术，广域网使用交换技术。</p>
<p>　　4）个人区域网 PAN（Personal Area Network）：覆盖范围最小。</p>
<p>　　</p>
<h5 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h5><p>　　1）广播式网络：所有联网计算机共享一个公共通信信道。当一台计算机利用它发送报文分组时，其他的所有计算机都会接收到该分组，接收到的计算机会检查目的地址来判断是否为自己的分组，不是则丢弃。</p>
<p>　　2）点对点网络：每条物理线路连接一对计算机。如果没有直接相连的线路，它们之间的分组就要通过中间节点的存储转发到达目的节点。</p>
<p>　　是否采用分组存储转发与路由机制是点对点式网络与广播式网络的区别，广域网基本属于点对点网络。</p>
<h5 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h5><p>　　网络拓扑结构是指网络中结点（路由器、主机等）与通信线路（网线）之间的几何关系。</p>
<p>　　<img src="https://i.loli.net/2020/04/04/DTdmvoEqzWPRCy2.png" alt="img"></p>
<p>　　1）总线形： 建网方便，重负载时通信效率不高。</p>
<p>　　2）星形：便于集中控制管理，成本高，中心结点对故障敏感。</p>
<p>　　3）环形：所有计算机接口设备连成一个环。典型的令牌环局域网。环中信号单向传输。</p>
<p>　　4）网状形：每个结点至少有两条路径与其他结点相连，多用在局域网，可靠性高，成本高。</p>
<h5 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h5><p>　　1）公用网：电信公司出资建设的大型网络。</p>
<p>　　2）专用网：某个单位自建的网络。</p>
<p>　　</p>
<h5 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h5><p>　　交换技术时指各主机之间、各通信设备之间或主机与通信设备之间为交换信息之间所采用的数据格式和交换装置的方式。</p>
<p>　　1）电路交换网络：在源结点和目的结点之间建立一条专用的通路用来传输数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网是传统电话网络。</p>
<p>　　2）报文交换网络：用户数据加上源地址、目的地址、校验码等辅助信息，<strong>封装成报文</strong>，利用中间结点存储转发到达目的结点。</p>
<p>　　3）分组交换网络：<strong>将数据分成较短的固定长度的数据块</strong>，在每个数据块中加上目的地址、源地址和辅助信息组成分组以存储-转发方式传输。</p>
<p>　　</p>
<h5 id="按传输介质分"><a href="#按传输介质分" class="headerlink" title="按传输介质分"></a>按传输介质分</h5><p>　　传输介质分为有线和无线两大类，因此网络可分为有线网络和无线网络。有线网络分为双绞线网络、同轴电缆网络等。无线网络又可分为蓝牙、微波、无线电等类型。</p>
<p>　　　</p>
<h4 id="计算机网络标准化组织"><a href="#计算机网络标准化组织" class="headerlink" title="计算机网络标准化组织"></a>计算机网络标准化组织</h4><p>　　1）国际标准化组织（ISO）：制定主要标准 OSI参考模型、HDLC。</p>
<p>　　2）国际电信联盟（ITU）。</p>
<p>　　3）国际电气电子工程师协会（IEEE）。</p>
<p> 　</p>
<h4 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h4><p>　　1）带宽：网络通信线路所能传输数据的能力，是数字信道所能传输的 “最高数据率” 的同义词，单位 b/s。</p>
<p>　　2）时延：数据（一个分组或报文）从网络（或链路）的一端传送到另一端所需要的总时间，它由4部分构成 发送时延、传播时延、处理时延、排队时延。</p>
<p><img src="https://i.loli.net/2020/04/04/aDkJnfzV4wTejlB.png" alt="img"></p>
<p>​    3）时延带宽积：发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特。</p>
<p>　　时延带宽积 = 传播时延*信道带宽</p>
<p>　　<img src="https://i.loli.net/2020/04/04/ogeU1hSdpj54sB3.png" alt="img"></p>
<p>​        4）往返时延（Round-Trip Time）：从发送端发送数据开始，到发送端收到来自接收端的确认总共经过的时延。</p>
<p>　　5）吞吐量：单位时间内通过某个网络的数据量</p>
<p>　　6）速率：连接到计算机网络上的主机在数字信道上传送数据的速率，也称数据率，单位为b/s。通常把最高数据率称为带宽。</p>
<p>　　7）信道利用率 某一信道有百分之多少的时间是有数据通过的 信道利用率 = 有数据通过时间/（有+无）数据通过时间。</p>
<h3 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h3><h4 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h4><p>　　<img src="https://i.loli.net/2020/04/04/sqlSCvRFknEHVrJ.png" alt="img"></p>
<p> 　服务是垂直的，协议是水平的。</p>
<h4 id="计算机网络协议、接口、服务的概念"><a href="#计算机网络协议、接口、服务的概念" class="headerlink" title="计算机网络协议、接口、服务的概念"></a>计算机网络协议、接口、服务的概念</h4><p>　　1. 协议：为进行网络中的数据交换而建立的规则、标准或约定称为网络协议（Network Protocol）,它是控制两个或多个对等实体进行通信的规则集合。协议由语法、语义和同步组成。语法规定了传输数据的格式。语义规定了所要完成的功能，即发出何种控制信息、完成何种动作和做出何种应答；同步规定了执行各种操作的条件、时序关系等。一个完整的协议通常具有线路管理、差错控制、数据转换等功能。</p>
<p>　　2. 接口：接口是同一结点内相邻两层间交换信息的交换点。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（Service Access Point）进行交互。服务是通过SAP提供给上层使用的。</p>
<p>　　3. 服务：服务是指下层为紧邻的上层提供的功能调用，它是垂直的。上层与下层交换一些命令使用服务原语。OSI将源语分为四类：请求，指示，响应，证实。</p>
<p>　　<img src="https://i.loli.net/2020/04/04/49LkNCq6W3ySmKF.png" alt="img"></p>
<p> 　计算机网络提供的服务可按以下三种方式分类</p>
<p>　　<strong>1）面向连接服务与无连接服务。</strong></p>
<p>　　面向连接服务分为连接建立、数据传输和连接释放三个阶段。例如TCP。</p>
<p>　　无连接服务不需要建立连接，直接发送，尽最大努力交付，不保证通信的可靠性。例如IP，UDP</p>
<p>　　<strong>2）可靠服务与不可靠服务</strong></p>
<p>　　可靠服务指网络具有纠错、检错、应答机制，确保数据正确可靠传送到目的地。</p>
<p>　　不可靠服务是指网络只是尽量正确、可靠地传输，不能保证数据正确、可靠地传送到目的地。</p>
<p>　    <strong>3）有应答服务和无应答服务</strong></p>
<p>　　有应答服务是指接收方在收到数据后向发送方给出相应的应答。例如文件传输服务。</p>
<p>　　无应答服务是指接收方收到数据后不自动给出应答。</p>
<p>　　</p>
<h4 id="ISO-OSI-参考模型和TCP-IP模型"><a href="#ISO-OSI-参考模型和TCP-IP模型" class="headerlink" title="ISO/OSI 参考模型和TCP/IP模型"></a>ISO/OSI 参考模型和TCP/IP模型</h4><p>　　<img src="https://i.loli.net/2020/04/04/obOvLcMiUGETIAN.png" alt="img"></p>
<p> <img src="https://i.loli.net/2020/04/04/DzZ8rgE3SOcYiR4.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/04/04/eRNgk93nSQomYJV.png" alt="img"></p>
<p> <img src="https://i.loli.net/2020/04/04/jVCxW8psaHF7EwO.png" alt="img"></p>
<p> <img src="https://i.loli.net/2020/04/04/gTzGmJbDRMC5kwa.png" alt="img"></p>
<h3 id="本章小结及疑难点"><a href="#本章小结及疑难点" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="计算机网络与分布式计算机系统的主要区别是什么？"><a href="#计算机网络与分布式计算机系统的主要区别是什么？" class="headerlink" title="计算机网络与分布式计算机系统的主要区别是什么？"></a>计算机网络与分布式计算机系统的主要区别是什么？</h4><p>​        分布式系统最主要的特点是：整个系统中的各个计算机对用户都是透明的。用户通过输入命令就可以运行程序，用户并不知道是哪台计算机在为它运行程序。操作系统为用户选择一台最合适的计算机来运行其程序，并将运行的结果传送到合适的地方。</p>
<p>计算机网络则不同，用户必须先登录欲运行程序的计算机，然后按照计算机的地址，将程序通过计算机网络传送到该计算机上运行，最后根据用户的命令将结果传送到指定的计算机。两者的区别主要是软件的不同。</p>
<h4 id="为什么一个网络协议必须考虑到各种不利的情况？"><a href="#为什么一个网络协议必须考虑到各种不利的情况？" class="headerlink" title="为什么一个网络协议必须考虑到各种不利的情况？"></a>为什么一个网络协议必须考虑到各种不利的情况？</h4><p>​        因为网络协议如果不全面考虑不利的情况，那么当情况发生变化时，协议就会保持理想状况，一直等下去。</p>
<h4 id="因特网使用的-IP-协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么当初为什么不把因特网传输设计为可靠的呢？"><a href="#因特网使用的-IP-协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么当初为什么不把因特网传输设计为可靠的呢？" class="headerlink" title="因特网使用的 IP 协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么当初为什么不把因特网传输设计为可靠的呢？"></a>因特网使用的 IP 协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么当初为什么不把因特网传输设计为可靠的呢？</h4><p>​        传统电信网的主要用途使电话通信，并且普通电话机不是智能的，因此电信公司必须花费巨大的代价把电信网设计的非常好，以保证用户的通信质量。<br>计算机网络的先驱们认为，计算机网络和电信网的一个重大区别是终端设备的性能差别很大。于是，他们采用了 “端到端的可靠传输” 策略，即在传输层使用面向连接的 TCP 协议，这样既能使网络部分价格便宜且灵活可靠，又能保证端到端的可靠传输。</p>
<h4 id="端到端通信和点到点通信有什么区别？"><a href="#端到端通信和点到点通信有什么区别？" class="headerlink" title="端到端通信和点到点通信有什么区别？"></a>端到端通信和点到点通信有什么区别？</h4><p>​        由物理层、数据链路层和网络层组成的通信子网为网络环境中的主机提供点到点的服务，而传输层为网络中的主机提供端到端的通信。<br>直接相连的结点之间的通信称为<strong>点到点通信</strong>，它只提供一台机器到另一台机器之间的通信，不涉及程序或进程的概念。同时，点到点通信并不能保证数据传输的可靠性，也不能说明源主机和目的主机之间是哪两个进程在通信，这些工作都是由传输层来完成的。<br>端到端通信建立在点到点通信的基础上，它是由一段段的点到点通信信道构成的，是比点到点通信更高一级的通信方式，以完成应用程序（进程）之间的通信。“端” 是指用户程序的端口，端口号标识了应用层中不同的进程。</p>
<h4 id="如何理解传输速率、带宽和传播速率？"><a href="#如何理解传输速率、带宽和传播速率？" class="headerlink" title="如何理解传输速率、带宽和传播速率？"></a>如何理解传输速率、带宽和传播速率？</h4><p>​        传输速率指主机在<strong>数字信道上发送数据的速率</strong>，也称数据率或比特率，单位是 b/s 。<br>带宽在计算机网络中指数字信道所能传送的“最高数据传输速率”，常用来表示网络的通信线路传送数据的能力。<br>传播速率是指电磁波在信道中传播的速率，单位是 m/s。</p>
<h4 id="试从多个方面比较电路交换、报文交换和分组交换的优缺点。"><a href="#试从多个方面比较电路交换、报文交换和分组交换的优缺点。" class="headerlink" title="试从多个方面比较电路交换、报文交换和分组交换的优缺点。"></a>试从多个方面比较电路交换、报文交换和分组交换的优缺点。</h4><p>​        电路交换的主要特点：<br>1）通信一定由有三个阶段：建立连接、通信、释放连接。<br>2）在整个通信过程中，通信的双方自始至终占用着所使用的物理信道。<br>电路交换对通信线路的利用率比较低。静态分配传输带宽，当发生拥塞时通信质量不会下降。<br>目前常用的分组交换是使用无连接的 IP 协议。这种分组交换以分组作为传输的单位。采用存储转发技术，无连接建立和释放这两个阶段，传送数据较快。动态分配传输带宽，对通信链路是逐段占用的。分组在各路由器存储转发时需要排队，这就会造成一定的时延。<br>报文交换也采用存储转发技术，报文交换不再把 报文分割为更小的分组，而是把整个报文在网络的结点中存储下来，然后转发出去。传输数据的时延较大。</p>
<h4 id="协议与服务有何区别？有何关系？"><a href="#协议与服务有何区别？有何关系？" class="headerlink" title="协议与服务有何区别？有何关系？"></a>协议与服务有何区别？有何关系？</h4><p>​        协议是控制两个对等实体（或多个实体）进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。<br>协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。</p>
<h4 id="网络协议的三个要素是什么？各有什么含义？"><a href="#网络协议的三个要素是什么？各有什么含义？" class="headerlink" title="网络协议的三个要素是什么？各有什么含义？"></a>网络协议的三个要素是什么？各有什么含义？</h4><p>1）语法，即数据与控制信息的结构或格式。<br>2）语义，即需要发出何种控制信息、完成何种动作以及做出何种响应。<br>3）同步，即时间实现顺序的详细说明。</p>
<h4 id="试述具有五层协议的网络体系结构的要点，包括各层的主要功能。"><a href="#试述具有五层协议的网络体系结构的要点，包括各层的主要功能。" class="headerlink" title="试述具有五层协议的网络体系结构的要点，包括各层的主要功能。"></a>试述具有五层协议的网络体系结构的要点，包括各层的主要功能。</h4><p>1）物理层。在物理层上传送数据的单位是比特。物理层的任务就是透明地传送比特流。<br>2）数据链路层。将网络层交下来地 IP 数据报组装成帧，在两个相邻结点间地链路上“透明”地传送帧中的数据。<br>3）网络层。负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组或包进行传送。<br>4）传输层。传输层的任务就是负责向两个主机中进程之间的通信提供服务。<br>5）应用层。直接为用户的应用进程提供服务。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/2020/04/04/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F--%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="行为型模式–解释器模式"><a href="#行为型模式–解释器模式" class="headerlink" title="行为型模式–解释器模式"></a>行为型模式–解释器模式</h1><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<p><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。</p>
<p><strong>何时使用：</strong>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p>
<p><strong>如何解决：</strong>构建语法树，定义终结符与非终结符。</p>
<p><strong>关键代码：</strong>构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。</p>
<p><strong>应用实例：</strong>编译器、运算表达式计算。</p>
<p><strong>优点：</strong> 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。</p>
<p><strong>缺点：</strong> 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。</p>
<p><strong>使用场景：</strong> 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。</p>
<p><strong>注意事项：</strong>可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个接口 <em>Expression</em> 和实现了 <em>Expression</em> 接口的实体类。定义作为上下文中主要解释器的 <em>TerminalExpression</em> 类。其他的类 <em>OrExpression<em>、</em>AndExpression</em> 用于创建组合式表达式。</p>
<p><em>InterpreterPatternDemo*，我们的演示类使用 *Expression</em> 类创建规则和演示表达式的解析。</p>
<p><img src="https://i.loli.net/2020/04/04/xZSyeB81snaL2Pp.png" alt="img"></p>
<p> 1、创建一个表达式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现了上述接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(context.contains(data))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expression expr1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Expression expr2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression expr1, Expression expr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expr1 = expr1;</span><br><span class="line">        <span class="keyword">this</span>.expr2 = expr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expr1.interpret(context) &amp;&amp; expr2.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expression expr1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Expression expr2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrExpression</span><span class="params">(Expression expr1, Expression expr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expr1 = expr1;</span><br><span class="line">        <span class="keyword">this</span>.expr2 = expr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expr1.interpret(context) || expr2.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、InterpreterPatternDemo 使用 Expression 类来创建规则，并解析它们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpreterPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMaleExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Expression robert = <span class="keyword">new</span> TerminalExpression(<span class="string">"Robert"</span>);</span><br><span class="line">        Expression john = <span class="keyword">new</span> TerminalExpression(<span class="string">"John"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrExpression(robert,john);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMarriedWomanExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Expression julie = <span class="keyword">new</span> TerminalExpression(<span class="string">"Julie"</span>);</span><br><span class="line">        Expression married = <span class="keyword">new</span> TerminalExpression(<span class="string">"Married"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndExpression(julie,married);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Expression isMale = getMaleExpression();</span><br><span class="line">    Expression isMarriedWoman = getMarriedWomanExpression();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"John is male? "</span>+isMale.interpret(<span class="string">"John"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Julie is a married women? "</span>+isMarriedWoman.interpret(<span class="string">"Married Julie"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://i.loli.net/2020/04/04/47dmlKVrqYuaUxF.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/interpreter-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/interpreter-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>协议</title>
    <url>/2020/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="应用层协议：（应用程序）"><a href="#应用层协议：（应用程序）" class="headerlink" title="应用层协议：（应用程序）"></a><strong>应用层协议：（应用程序）</strong></h3><h4 id="使用TCP"><a href="#使用TCP" class="headerlink" title="使用TCP"></a>使用TCP</h4><p>　　HTTP（Hypertext Transfer Protocol ）超文本传输协议 &lt;端口号 80&gt;， 面向事务的应用层协议。</p>
<p>　　FTP（File Transfer Protocol ）文件传输协议&lt;端口号21&gt;减少或消除不同操作系统下处理文件的不兼容性。 </p>
<p>　　TELNET 远程登录协议 &lt;端口号23&gt; 。</p>
<p>　　SMTP （Simple Mail Transfer Protocol ）简单邮件传输协议 &lt;端口号25&gt; 用于发送邮件。 </p>
<p>　　POP3 (Post Office Protocol 3) 即邮局协议的第3 个版本，用于接受邮件。 </p>
<p>　　IMAP4 (Internet Message Access Protocol 4) Internet 信息访问协议的第 4 版本 。</p>
<h4 id="使用UDP"><a href="#使用UDP" class="headerlink" title="使用UDP"></a>使用UDP</h4><p>　　DHCP(Dynamic Host Configuration Protocol)动态主机分配协议，使用 UDP 协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。实 现即插即用连网。 </p>
<p>　　DNS(Domin Name System<em>)</em> 域名系统协议，同时占用TCP和UDP的 53 端口。区域传送使用TCP，<strong>域名解析使用UDP</strong>。书上没有写区域传送的内容，只讲了域名解析，我将DNS归于UDP中，其实是不对的。</p>
<h3 id="传输层协议：（进程-端口）-数据单元：数据段"><a href="#传输层协议：（进程-端口）-数据单元：数据段" class="headerlink" title="传输层协议：（进程/端口） 数据单元：数据段"></a><strong>传输层协议：（进程/端口） 数据单元：数据段</strong></h3><p>　　TCP  （Transmission Control Protocol ）传输控制协议提供可靠的面向连接的服务，传输数据前须先建立连接，结束后释放。可靠的全双工信道。可靠、有序、无丢失、不重复。</p>
<p>　　UDP (User Datagram Protocol ）用户数据报协议发送数据前无需建立连接，不使用拥塞控制，不保证可靠交付，最大努力交付。 </p>
<p>　　RTP(Real-time Transport Protocol ）实时传送协议 。</p>
<h3 id="网络层协议：（路由器）数据单元：数据报"><a href="#网络层协议：（路由器）数据单元：数据报" class="headerlink" title="网络层协议：（路由器）数据单元：数据报"></a><strong>网络层协议：（路由器）数据单元：数据报</strong></h3><p>　　IP (IPv4 · IPv6) (Internet Protocol) 网络之间互连的协议。</p>
<p>　　ARP (Address Resolution Protocol) 即地址解析协议，实现通过IP 地址得 知其物理地址。 </p>
<p>　　RARP (Reverse Address Resolution Protocol)反向地址转换协议允许局域 网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP地址。 </p>
<p>　　 ICMP (Internet Control Message Protocol ）Internet 控制报文协议。它是TCP/IP 协议族的一个子协议，用于在IP 主机、路由器之间传递控制消息。</p>
<p>　　 RIP (Router information protocol) 路由信息协议是一种在网关与主机之间交换路由选择信息的标准。 </p>
<p>　　OSPF (Open Shortest Path First)开放式最短路径优先,分布式链路状态协议。 </p>
<h3 id="数据链路层：（网卡、网桥、交换机）数据单元：帧"><a href="#数据链路层：（网卡、网桥、交换机）数据单元：帧" class="headerlink" title="数据链路层：（网卡、网桥、交换机）数据单元：帧"></a><strong>数据链路层：（网卡、网桥、交换机）数据单元：帧</strong></h3><p>　　ARQ（Automatic Repeat-reQuest ）自动重传请求协议，错误纠正协议之一，包括停止等待ARQ 协议和连续ARQ 协议，错误侦测、正面确认、逾时重传与负面确认继以重传等机制。</p>
<p>　　纯 ALOHA 协议 ：不检测信道状态 直接发送 ，一段时间没收到确认 <strong>等待一段随机的时间</strong>后再发送，直到成功。</p>
<p>　　时隙 ALOHA 协议 ：把所有各站在时间上同步起来，并将时间划分为一段段等长的时隙，规定只能在每个时隙开始才能发送一个帧。</p>
<p>　　 CSMA/CD(Carrrier Sense Multiple Access with Collision Detection)载波监听多点接入/碰撞检测协议。<strong>以太网</strong>，总线型网络，协议的实质是载波监听和碰撞检测。载波监听即发数据前先检测总线上是否有其他计算机在发送数据，如暂时不发数据，避免碰撞。碰撞检测为计算机边发送数据边检测信道上的信号电压大小。 </p>
<p>　　CSMA/CA(Carrier Sense Multiple Access with Collision Avoidence) <strong>无线局域网，</strong>CSMA/CA 采用二进制指数退避算法。任何一个站要发送数据帧时，不仅要等待一个时间间隔，还要进入争用窗口，并计算随机退避时间以便再次试图接入信道。</p>
<p>　　PPP(Point-to-Ponit Protocol)点对点协议，<strong>广域网，面向字节</strong>，由三部分组成：一个将IP 数据报封装到串行链路的方法；一个用于建立、配置和测试数据链路连接的链路控制协议。</p>
<p>　　HDLC  （High-Level Data Link Control ）高级数据链路控制，<strong>广域网，面向比特</strong>，同步网上传输数据的数据链路层协议。 </p>
<p>　　 ATM  （Asynchronous Transfer Mode ）异步传递方式，建立在电路交换和分组交换的基础上的一种面向连接的快速分组交换技术。 “异步”是指将ATM 信元“异步插入”到同步的 SDH 比特流中。如同步插入则用户在每帧中所占的时隙相对位置固定不变。“同步”是指网络中各链路上的比特流都是受同一非常精确的主时钟的控制。Wi-Fi 、WiMAX 、DTM 、令牌环、以太网、FDDI 、帧中继、 GPRS 、 EVDO 、HSPA 、L2TP 、ISDN 。</p>
<p>　　</p>
<h3 id="物理层：（中继器、集线器）数据单元：比特"><a href="#物理层：（中继器、集线器）数据单元：比特" class="headerlink" title="物理层：（中继器、集线器）数据单元：比特"></a><strong>物理层：（中继器、集线器）数据单元：比特</strong></h3><p><img src="https://i.loli.net/2020/04/04/YITdvmGgt7KWQy1.png" alt="img"></p>
<p> 参考：<a href="https://www.cnblogs.com/newsouls/p/5436266.html" target="_blank" rel="noopener">https://www.cnblogs.com/newsouls/p/5436266.html</a></p>
<p>　　</p>
<p>　　</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>面向切面的Spring</title>
    <url>/2020/04/04/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84Spring/</url>
    <content><![CDATA[<h1 id="面向切面的Spring"><a href="#面向切面的Spring" class="headerlink" title="面向切面的Spring"></a>面向切面的Spring</h1><p>我们知道如何使用依赖注入（DI）管理和配置我们的应用对象，DI有助于应用对象之间的解耦，而AOP可以实现横切关注点与他们所影响的对象之间的解耦。切面能帮助我们模块化横切关注点，横切关注点可以被描述为影响应用多处的功能。</p>
<p>定义AOP术语，描述切面的术语有通知，切点和连接点。</p>
<p>通知定义了切面是什么以及切面何时开始使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？</p>
<p>Spring切面可以应用5种类型的通知：</p>
<p>前置通知：在目标方法被调用之前调用通知功能；</p>
<p>后置通知：在目标方法完成之后调用通知功能；</p>
<p>返回通知：在目标方法成功执行之后调用通知功能；</p>
<p>异常通知：在目标方法抛出异常后调用的通知功能；</p>
<p>环绕通知：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</p>
<p>我们的应用可能有数千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时，抛出异常时，甚至修改一个字段时，切面代码可以利用这些点插入到应用正常的流程之中，并添加新的行为。</p>
<p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式来匹配通知所要织入的一个或多个连接点。</p>
<p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容–它是什么，在何时和何处完成其功能。</p>
<p>织入是把切面应用到目标对象并创建新的代理对象的过程。</p>
<p>我们先定义一个Performance接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Performance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个它的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcertPerformance</span> <span class="keyword">implements</span> <span class="title">Performance</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Performing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重点是这里的Audience类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(value = <span class="string">"execution(* concert.Performance.perform(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"silencing cellPhone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPerformance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after performance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demanRefund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"demanding a refund"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"around before performance..."</span>);</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">            System.out.println(<span class="string">"around after performance..."</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@Aspect声明这是一个Aspect注解驱动的切面。</p>
<p>@Poincut定义了一个切点，execution(* concert.Performance.perform(..))代表perform这个方法执行时将会声明为一个切点</p>
<p>“ * ” 代表任意返回值类型，“ .. ”代表任意参数类型。也可以写成 * *.perform(..)代表任意类的perform方法。</p>
<p>@Before，@After，@AfterThrowing，分别是前置，后置，异常通知。</p>
<p>@Around声明一个环绕通知</p>
<p>这还不够，我们需要一个配置类，来启用自动代理功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"concert"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Performance <span class="title">performance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcertPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Audience <span class="title">audience</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audience();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@EnableAspectJAutoProxy注解启动了自动代理功能，这里我们声明了两个Bean。</p>
<p>接下来测试一下，AOPTest类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">import</span> concert.ConcertConfig;</span><br><span class="line"><span class="keyword">import</span> concert.Performance;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span></span>= &#123;ConcertConfig<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">AOPTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Performance performance;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        performance.perform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>performance对象会自动注入到AOPTest类中。</p>
<p><img src="https://i.loli.net/2020/04/04/7VN2CGTRIXMWFHO.png" alt="img"></p>
<p>切面运行结果</p>
<p>这里详细写一下IDEA 配置AspectJ的步骤：</p>
<p>1、启用IDEA AspectJ plugin File—Settings–Plugins，搜索栏内搜索AspectJ，启用支持，注意这里只有Ultimate版才会有。</p>
<p>2、添加依赖</p>
<p>build.gradle添加</p>
<p>compile”org.springframework:spring-context:4.0.7.RELEASE”</p>
<p>compile”org.springframework:spring-test:4.0.7.RELEASE”</p>
<p>compile group:’org.aspectj’,name:’aspectjtools’,version:’1.8.9’</p>
<p>testCompile”org.springframework:spring-test:4.0.7.RELEASE”</p>
<p>implementation’junit:junit:4.12’</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高级装配</title>
    <url>/2020/04/04/%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<h1 id="Java高级装配"><a href="#Java高级装配" class="headerlink" title="Java高级装配"></a>Java高级装配</h1><p><strong>一、环境与profile</strong></p>
<p>开发软件的时候需要将一个应用从一个环境迁移到另一个环境，不同的环境数据库配置、加密算法以及外部系统的集成可能会变化。</p>
<p>Spring为解决环境问题引入了bean profile功能，要使用profile首先要将不同的bean定义或整理到一个或多个profile之中，在应用部署到每个环境时要确保对应的profile处于激活状态。</p>
<p>下面以一个数据库配置为例</p>
<p>在开发环境我们使用H2数据库，在生产环境我们使用JNDI从容器中获取数据库配置</p>
<p>我们可以使用Java或XML配置profile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jndi.JndiObjectFactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">embeddedDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2)</span><br><span class="line">                .addScript(<span class="string">"classpath:schema.sql"</span>).addScript(<span class="string">"classpath:test-data.sql"</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">jndiDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JndiObjectFactoryBean jndiObjectFactoryBean = <span class="keyword">new</span> JndiObjectFactoryBean();</span><br><span class="line">        jndiObjectFactoryBean.setJndiName(<span class="string">"jndi/myDS"</span>);</span><br><span class="line">        jndiObjectFactoryBean.setResourceRef(<span class="keyword">true</span>);</span><br><span class="line">        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> (DataSource)jndiObjectFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>与一般的配置相似，多加了一个profile，参数是环境名称。</p>
<p>下面是XML配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:jdbc=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span><br><span class="line">       xmlns:jee=<span class="string">"http://www.springframework.org/schema/jee"</span> xmlns:p=<span class="string">"http://www.springframework.org/schema/p"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/jee</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/jee/spring-jee.xsd</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/jdbc</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/jdbc/spring-jdbc.xsd</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beans profile=<span class="string">"dev"</span>&gt;</span><br><span class="line">        &lt;jdbc:embedded-database id=<span class="string">"dataSource"</span> type=<span class="string">"H2"</span>&gt;</span><br><span class="line">            &lt;jdbc:script location=<span class="string">"classpath:schema.sql"</span>/&gt;</span><br><span class="line">            &lt;jdbc:script location=<span class="string">"test-data.sql"</span>/&gt;</span><br><span class="line">        &lt;/jdbc:embedded-database&gt;</span><br><span class="line">    &lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beans profile=<span class="string">"prod"</span>&gt;</span><br><span class="line">        &lt;jee:jndi-lookup id=<span class="string">"dataSource"</span></span><br><span class="line">                         lazy-init=<span class="string">"true"</span></span><br><span class="line">                         jndi-name=<span class="string">"jdbc/myDatabase"</span></span><br><span class="line">                         resource-ref=<span class="string">"true"</span></span><br><span class="line">                         proxy-<span class="class"><span class="keyword">interface</span></span>=<span class="string">"javax.sql.DataSource"</span>/&gt;</span><br><span class="line">    &lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>接下来写一个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.myapp.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ActiveProfiles;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfigTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= DataSourceConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">    @ActiveProfiles("dev")</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DevDataSourceTest</span></span>&#123;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldBeEmbeddedDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">            assertNotNull(dataSource);</span><br><span class="line">            JdbcTemplate jdbc = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">            List&lt;String&gt; results = jdbc.query(<span class="string">"select id , name from Things"</span>, <span class="keyword">new</span> RowMapper&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> rs.getLong(<span class="string">"id"</span>)+<span class="string">":"</span>+rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            assertEquals(<span class="number">1</span>,results.size());</span><br><span class="line">            assertEquals(<span class="string">"1:A"</span>,results.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>可以看到我们使用Java配置上下文，也可改为使用XML注解，@ActiveProfiles(“dev”)代表激活开发环境profile。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">    @ContextConfiguration("classpath:datasource-config.xml")</span><br><span class="line">    <span class="meta">@ActiveProfiles</span>(<span class="string">"prod"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionDataSourceTest_XMLConfig</span></span>&#123;</span><br><span class="line">        <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">        <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldBeEmbeddedDatasource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// should be null, because there isn't a datasource configured in JNDI</span></span><br><span class="line">            assertNull(dataSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到我们使用Java配置上下文，也可改为使用XML注解，@ActiveProfiles(“prod”)代表激活生产环境profile。</p>
<p><strong>二、条件化的Bean</strong></p>
<p>假设你希望一个或多个bean只有在特定的类路径下包含特定的库时才创建，或者我们希望某个bean只有当另外一个特定的bean也声明了之后才会创建。我们还有可能要求某个特定的环境变量设置之后才会创建某个bean。</p>
<p>我们先定义一个MagicBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hubuma.restfun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是它的配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hubuma.restfun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Conditional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(MagicExistsCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">MagicBean</span> <span class="title">magicBean</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MagicBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@Conditional会通过Condition接口进行条件对比，从而实现条件化创建bean，设置给@Conditional的类可以是任意实现Condition接口的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hubuma.restfun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicExistsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        Environment env = context.getEnvironment();</span><br><span class="line">        <span class="keyword">return</span> env.containsProperty(<span class="string">"magic"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>matches方法表示需要检查环境中是否存在名为magic 的环境属性，若存在则创建bean。</p>
<p><strong>三、处理自动装配的歧义性</strong></p>
<p>自动装配再仅有一个bean匹配所需要的结果时才有效。</p>
<p>假设我们使用@Autowired注解标注了getDessert()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dessert  = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dessert是一个接口，并且有三个类实现了这个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cake</span> <span class="title">imlements</span> <span class="title">Dessert</span></span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookies</span> <span class="keyword">implements</span> <span class="title">Dessert</span></span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>在组件扫描的时候，能够发现他们并创建为Spring应用上下文里的bean，当Spring尝试装配setDessert()中的Dessert参数时，它并没有唯一的、无歧义的可选值，Spring此时会抛出NoUniqueBeanDefinitionException。</p>
<p>我们可以使用@Primary注解来将一个可选的bean设为首选项。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>解决自动装配歧义性问题，限定符是一个更强大的机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"iceCream"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dessert  = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定注入setDessert方法的是IceCream 类的实例。@Qualifier注解所设置的参数就是想要注入bean的ID，所有使用@Component注解的声明的类都会创建为bean，并且bean的ID为首字母变为小写的类名。</p>
<p>我们可以设置自己的限定符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dessert  = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样注入setDessert的就是IceCream类的实例了。</p>
<p>当有两个cold限定符的时候一个cold限定符就不够用了，但是Java不允许在同一个条目上重复出现相同类型的多个注解我们不能使用两条@Qualifier注解来实现限定，此时我们只能自己声明注解然后进行限定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.CONSTRUCTOR,ElementType.FIELD,ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Cold &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.CONSTRUCTOR,ElementType.FIELD,ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Creamy &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法或类上使用@Cold和@Creamy注解即可限定。</p>
<p><strong>四、bean的作用域</strong></p>
<p>Spring定义了多种作用域，可以基于这些作用域创建bean，包括：</p>
<p>单例（Singleton）在整个应用中只创建bean的一个实例。</p>
<p>原型（ProtoType）每次注入或通过Spring应用上下文获取的时候都会创建一个新的bean实例。</p>
<p>会话（Session）在Web应用中，为每个会话创建一个bean实例。</p>
<p>请求（Request）在Web应用中，为每个请求创建一个bean实例。</p>
<p>默认创建是以单例模式创建的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueThing</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以原型模式创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotePad</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>五、运行时值注入</strong></p>
<p>当讨论依赖注入时我们通常讨论的是将一个bean注入到另一个bean的属性或构造器中，但bean装配的另一个方面是将一个值注入到bean的属性或构造器参数中。</p>
<p>定义一个BlankDisc类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankDisc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String title;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String artist;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlankDisc</span><span class="params">(String title, String artist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.artist = artist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getArtist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> artist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>app.properties文件内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">disc.title=Sgt. Peppers Lonely Hearts Club Band</span><br><span class="line">disc.artist=The Beatles</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"app.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BlankDisc <span class="title">blankDisc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(env.getProperty(<span class="string">"disc.title"</span>),env.getProperty(<span class="string">"disc.artist"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>app.properties文件会被加载到Spring的Environment中然后可以从中检索属性。</p>
<p>值注入还可以有默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlankDiscblankDisc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(env.getProperty(<span class="string">"disc.title"</span>,<span class="string">"Rattle and Hum"</span>),</span><br><span class="line">            env.getProperty(<span class="string">"disc.artist"</span>,<span class="string">"U2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用SpEL表达式来进行装配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlankDisc</span><span class="params">(@Value(<span class="string">"#systemProperties['disc.title']"</span>)</span> String title,</span></span><br><span class="line"><span class="function">                 @<span class="title">Value</span><span class="params">(<span class="string">"#systemProperties['disc.artist']"</span>)</span>  String artist) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.artist = artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpEL表示浮点值 #{3.1.4159}</p>
<p>表示String#{‘Hello’}</p>
<p>表示boolean类型#{false}</p>
<p>SpEL能做的一件基础事情就是通过ID引用其他bean</p>
<p>#{sgtPeppers}</p>
<p>#{sgtPeppers.artist}</p>
<p>我们还可以调用bean上的方法</p>
<p>#{artistSelector.selectArtist()}</p>
<p>这里只介绍了SpEL的部分知识，具体的看手册。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Github访问不了的问题</title>
    <url>/2020/04/04/%E8%A7%A3%E5%86%B3Github%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决Github访问不了的问题"><a href="#解决Github访问不了的问题" class="headerlink" title="解决Github访问不了的问题"></a>解决Github访问不了的问题</h1><p>修改hosts文件 hosts在windows中位于C:\Windows\System32\drivers\etc目录下</p>
<p>将文件只读去掉</p>
<p>添加</p>
<p>192.30.253.112 github.com<br>192.30.253.119 gist.github.com<br>151.101.100.133 assets-cdn.github.com<br>151.101.100.133 raw.githubusercontent.com<br>151.101.100.133 gist.githubusercontent.com<br>151.101.100.133 cloud.githubusercontent.com<br>151.101.100.133 camo.githubusercontent.com<br>151.101.100.133 avatars0.githubusercontent.com<br>151.101.100.133 avatars1.githubusercontent.com<br>151.101.100.133 avatars2.githubusercontent.com<br>151.101.100.133 avatars3.githubusercontent.com<br>151.101.100.133 avatars4.githubusercontent.com<br>151.101.100.133 avatars5.githubusercontent.com<br>151.101.100.133 avatars6.githubusercontent.com<br>151.101.100.133 avatars7.githubusercontent.com<br>151.101.100.133 avatars8.githubusercontent.com</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串 Hard</title>
    <url>/2020/05/23/%E5%AD%97%E7%AC%A6%E4%B8%B2Hard/</url>
    <content><![CDATA[<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h4><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;</span><br><span class="line">输出: &quot;BANC&quot;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>如果 S 中不存这样的子串，则返回空字符串 <code>&quot;&quot;</code>。</li>
<li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p>我们可以用滑动窗口的思想解决这个问题，在滑动窗口类型的问题中都会有两个指针。一个用于延伸现有窗口的 right 指针，和一个用于收缩窗口的 left 指针。在任意时刻，只有一个指针移动，另一个保持静止。我们在 s 上滑动窗口，通过 right 指针不断扩张窗口，当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩直到得到最小窗口。</p>
<p>如何判断滑动窗口[left,right)是否包含字符串 t 中所有字符呢？当让我们可以暴力统计，但这样效率太低。我们使用两个辅助数组 ，winFreq 表示窗口中的字符统计数组，tFreq 表示字符串 t 中的字符统计数组。维护变量 distance，表示滑动窗口内部包含了 t 中字符的个数，窗口内单个字符个数等于 t 中对应字符个数时不再增加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> tLen = t.length();</span><br><span class="line">        <span class="keyword">if</span>(sLen == <span class="number">0</span> || tLen == <span class="number">0</span> || tLen &gt; sLen)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArrayS = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charArrayT = t.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] winFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span>[] tFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : charArrayT)&#123;</span><br><span class="line">            tFreq[c] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//distance 表示滑动窗口内部包含了 t 中字符的个数，窗口内单个字符个数等于 t 中对应字符个数时不再增加</span></span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = sLen + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//[left, right)滑动窗口长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; sLen)&#123;</span><br><span class="line">            <span class="keyword">char</span> charRight = charArrayS[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右边界元素在 t 中不出现</span></span><br><span class="line">            <span class="keyword">if</span>(tFreq[charRight] == <span class="number">0</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右边界元素在 t 中出现</span></span><br><span class="line">            <span class="keyword">if</span>(winFreq[charRight] &lt; tFreq[charRight])&#123;</span><br><span class="line">                distance++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//窗口字符减一，窗口右边界右移</span></span><br><span class="line">            winFreq[charRight]++;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左边界向右移动，滑动窗口此时已经包含 t 中所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(distance == tLen)&#123;</span><br><span class="line">                <span class="comment">//统计最小子串的开始位置及长度</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; minLen)&#123;</span><br><span class="line">                    minLen = right - left;</span><br><span class="line">                    begin = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//左边界元素在 t 中没有出现</span></span><br><span class="line">                <span class="keyword">char</span> charLeft = charArrayS[left];</span><br><span class="line">                <span class="keyword">if</span>(tFreq[charLeft] == <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左边界元素在 t 中出现</span></span><br><span class="line">                <span class="keyword">if</span>(winFreq[charLeft] == tFreq[charLeft])&#123;</span><br><span class="line">                    distance--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//窗口字符减一，窗口左边界右移</span></span><br><span class="line">                winFreq[charLeft]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minLen == sLen + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + minLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以优化空间只使用 tFreq 一个数组，将 distance 设置为 tLen ，对distance 使用减法，当distance == 0时表示窗口中含有字符串 t 中所有字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> tLen = t.length();</span><br><span class="line">        <span class="keyword">if</span>(sLen == <span class="number">0</span> || tLen == <span class="number">0</span> || tLen &gt; sLen)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArrayS = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charArrayT = t.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] tFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : charArrayT)&#123;</span><br><span class="line">            tFreq[c] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//distance 表示滑动窗口内部包含了 t 中字符的个数，窗口内单个字符个数等于 t 中对应字符个数时不再增加</span></span><br><span class="line">        <span class="keyword">int</span> distance = tLen;</span><br><span class="line">        <span class="keyword">int</span> minLen = sLen + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//[left, right)滑动窗口长度</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right &lt; sLen)&#123;</span><br><span class="line">            <span class="keyword">char</span> charRight = charArrayS[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右边界元素在 t 中出现</span></span><br><span class="line">            <span class="keyword">if</span>(tFreq[charRight] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                distance--;</span><br><span class="line">            &#125;</span><br><span class="line">            tFreq[charRight]--;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左边界向右移动，滑动窗口此时已经包含 t 中所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(distance == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//统计最小子串的开始位置及长度</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; minLen)&#123;</span><br><span class="line">                    minLen = right - left;</span><br><span class="line">                    begin = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//左边界元素在 t 中出现</span></span><br><span class="line">                <span class="keyword">char</span> charLeft = charArrayS[left];</span><br><span class="line">                <span class="keyword">if</span>(tFreq[charLeft] == <span class="number">0</span>)&#123;</span><br><span class="line">                    distance++;</span><br><span class="line">                &#125;</span><br><span class="line">                tFreq[charLeft]++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minLen == sLen + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + minLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>链表 Medium</title>
    <url>/2020/05/25/%E9%93%BE%E8%A1%A8Medium/</url>
    <content><![CDATA[<h4 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></h4><p>运用你所掌握的数据结构，设计和实现一个 <a href="https://baike.baidu.com/item/LRU" target="_blank" rel="noopener">LRU (最近最少使用) 缓存机制</a>。它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p>
<p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<p><strong>进阶:</strong></p>
<p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回  1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得密钥 2 作废</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得密钥 1 作废</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回  3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; 返回  4</span><br></pre></td></tr></table></figure>

<p>LRU 缓存可以使用一个哈希表和一个双向链表维护在缓存中的键值对。使用哈希表可以将 get 操作达到常数级复杂度。</p>
<ol>
<li><p>get 操作，首先判断 key 是否存在：</p>
<ul>
<li>key 不存在，返回 -1；</li>
<li>key 存在，通过哈希表定位到双向链表中的结点，将其移动到双向链表头部，返回该结点的值。</li>
</ul>
</li>
<li><p>put 操作，首先判断 key 是否存在：</p>
<ul>
<li>key 不存在，直接新建一个结点，将该结点加入哈希表和双向链表头部。并判断是否超出容量，如果超出容量删除链尾结点；</li>
<li>key 存在，更新 value ，并将该结点移动到链表头部。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;<span class="keyword">this</span>.key = key; <span class="keyword">this</span>.value = value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key 存在，先通过哈希表定位，再移动到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode newNode = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line">            <span class="comment">//添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">//添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(size &gt; capacity)&#123;</span><br><span class="line">                <span class="comment">//超出容量，删除双向链表的尾部结点</span></span><br><span class="line">                DLinkedNode tail = removeTail();</span><br><span class="line">                <span class="comment">//删除哈希表中的对应项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode node)</span></span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode node)</span></span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode node)</span></span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DLinkedNode <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DLinkedNode res = tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>空间复杂度O(n) 时间复杂度 O(1)</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串 Medium</title>
    <url>/2020/05/28/%E5%AD%97%E7%AC%A6%E4%B8%B2Medium/</url>
    <content><![CDATA[<h4 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></h4><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <em>encoded_string</em> 正好重复 <em>k</em> 次。注意 <em>k</em> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <em>k</em> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</span><br><span class="line">s &#x3D; &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</span><br><span class="line">s &#x3D; &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure>

<p>在此题中可能出现括号嵌套的情况，比如 <code>3[a2[c]]</code>，这种情况下我们先转化为<code>2[abcbc]</code>，再转化成<code>abcbcabcbc</code>。我们可以使用栈或递归来实现。使用栈的具体做法是：</p>
<ol>
<li>如果当前字符为数字，则取出一个数字（连续的多个数位）并进栈。</li>
<li>如果当前字符为字母或左括号，直接进栈。</li>
<li>如果当前字符为右括号，开始出栈，直到出现左括号，此时栈顶元素为已经出栈的字符串重复出现的次数。</li>
</ol>
<p>重复以上操作，直到遍历到字符串末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//访问字符的下标</span></span><br><span class="line">    <span class="keyword">int</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(ptr &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(ptr);</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(cur))&#123;</span><br><span class="line">                <span class="comment">//获取数字并将字符串进栈</span></span><br><span class="line">                String digits = getDigits(s);</span><br><span class="line">                stack.addLast(digits);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((Character.isLetter(cur) || cur == <span class="string">'['</span>))&#123;</span><br><span class="line">                <span class="comment">//获取一个字母并进栈</span></span><br><span class="line">                stack.addLast(String.valueOf(s.charAt(ptr++)));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//跳过右括号</span></span><br><span class="line">                ++ptr;</span><br><span class="line">                LinkedList&lt;String&gt; sub = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                <span class="comment">//将栈内字符串保存，直到遇到左括号</span></span><br><span class="line">                <span class="keyword">while</span>(! <span class="string">"["</span>.equals(stack.peekLast()))&#123;</span><br><span class="line">                    sub.addLast(stack.removeLast());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将字符串顺序转换回来</span></span><br><span class="line">                Collections.reverse(sub);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//左括号出栈</span></span><br><span class="line">                stack.removeLast();</span><br><span class="line">                <span class="comment">//此时栈顶元素为括号内字符串重复的次数，将字符串解析为数字</span></span><br><span class="line">                <span class="keyword">int</span> repTime = Integer.parseInt(stack.removeLast());</span><br><span class="line">                <span class="comment">//生成字符串</span></span><br><span class="line">                StringBuffer t = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                String o = getString(sub);</span><br><span class="line">                <span class="keyword">while</span>(repTime-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    t.append(o);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将字符串添加到栈顶</span></span><br><span class="line">                stack.addLast(t.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getString(stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getDigits</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取数字</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(Character.isDigit(s.charAt(ptr)))&#123;</span><br><span class="line">            sb.append(s.charAt(ptr++));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getString</span><span class="params">(LinkedList&lt;String&gt; v)</span></span>&#123;</span><br><span class="line">        <span class="comment">//整合结果</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(String s : v)&#123;</span><br><span class="line">            sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渐进时间复杂度为 O(S)，渐进空间复杂度为 O(S)。</p>
<p>我们还可以使用递归来完成此题。使用递归的具体做法是：</p>
<ol>
<li><p>如果当前位置为数字位，那么后面一定包含一个用方括号表示的字符串<code>k[...]</code>。</p>
<ul>
<li>我们可以先解析数字，然后递归解析后面的内容，遇到对应的右括号则可以根据解析的数字x 和字符串 s’  构造一个新的字符串 x * s’。</li>
<li>在解析完一个<code>k[...]</code>后，再次调用递归函数，解析右括号右边的内容。</li>
</ul>
</li>
<li><p>如果当前位置是字母位，直接解析当前字母，然后递归向下解析这个字母后面的内容。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ptr;</span><br><span class="line">    String src;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        src = s;</span><br><span class="line">        ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//结束处理</span></span><br><span class="line">        <span class="keyword">if</span>(ptr == src.length() || src.charAt(ptr) == <span class="string">']'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> cur = src.charAt(ptr);</span><br><span class="line">        <span class="keyword">int</span> repTime = <span class="number">1</span>;</span><br><span class="line">        String ret=<span class="string">""</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">if</span>(Character.isDigit(cur))&#123;<span class="comment">//当前位置是数字</span></span><br><span class="line">            <span class="comment">//解析Digit</span></span><br><span class="line">            repTime = getDigits();</span><br><span class="line">            <span class="comment">//过滤左括号</span></span><br><span class="line">            ++ptr;</span><br><span class="line">            <span class="comment">//解析String</span></span><br><span class="line">            String str = getString();</span><br><span class="line">            <span class="comment">//过滤右括号</span></span><br><span class="line">            ++ptr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构造字符串</span></span><br><span class="line">            <span class="keyword">while</span>(repTime-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ret += str;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Character.isLetter(cur))&#123;<span class="comment">//当前位置是字母</span></span><br><span class="line">            ret = String.valueOf(src.charAt(ptr++));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再次调用递归函数，解析右括号右边的内容</span></span><br><span class="line">        <span class="keyword">return</span> ret + getString();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//从字符串中解析数字</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDigits</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ptr &lt; src.length() &amp;&amp; Character.isDigit(src.charAt(ptr)))&#123;</span><br><span class="line">            ret = ret * <span class="number">10</span> + src.charAt(ptr++) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渐进时间复杂度为 O(S)，渐进空间复杂度为 O(S)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>数组 Hard</title>
    <url>/2020/05/30/%E6%95%B0%E7%BB%84Hard/</url>
    <content><![CDATA[<h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h4><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="https://i.loli.net/2020/05/30/pCdscWKFb4qRMNP.png" alt="img"></p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p>
<p><img src="https://i.loli.net/2020/05/30/Nmh9znMFBDqGJ7b.png" alt="img"></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>

<p>方法一：暴力法</p>
<p>矩形面积为宽乘高，我们可以固定其中一个，然后枚举另一个求出最大矩形面积。这里我们枚举高，使用一重循环枚举某一根柱子，将其固定为矩形的高度 h，随后我们以这根柱子为中心向左右两边扩散，当遇到高度比 h 小的柱子时停止，得到矩形的宽度 w，进而求出矩形面积 w*h。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len  = heights.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举每一根柱子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//寻找左边界</span></span><br><span class="line">            <span class="keyword">for</span>(left = i - <span class="number">1</span> ; left &gt;= <span class="number">0</span> &amp;&amp; heights[left] &gt;= heights[i] ; --left);</span><br><span class="line">            <span class="comment">//寻找右边界</span></span><br><span class="line">            <span class="keyword">for</span>(right = i + <span class="number">1</span> ; right &lt; len &amp;&amp; heights[right] &gt;= heights[i] ; ++right);</span><br><span class="line">			<span class="comment">//计算结果</span></span><br><span class="line">            res = Math.max(res, heights[i] * (right - left - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2) 空间复杂度 O(1)</p>
<p>方法二：单调栈</p>
<p>对于某一根柱子 i ，高度为 h = heights[i]。我们需要向两边扩展，找到<strong>左右两侧最近的高度小于  h 的柱子</strong>。先来看如何求一根柱子左侧且最近的小于其高度的柱子。</p>
<p>对于两根柱子，下标分别为 a 和 b，其中 a &lt; b，且heights[a] &gt;= heights[b]。在后面的柱子 i 向左照小于其高度的柱子时，由于柱子 a 的高度大于柱子 b 的高度，所以柱子 a 不可能成为柱子 i 左侧最近且小于其高度的柱子（应该是柱子 b），称为柱子 b  <strong>挡住</strong>了柱子 a。</p>
<p>这样一来，我们可以对数组从左到右进行遍历，同时维护一个可能作为答案的数据结构，其中按照从小到大存放柱子的下标值，并且它们的高度值也是单调递增的。如果有两个相邻的下标值不满足递增关系，则后者会挡住前者，前者不会作为答案。 </p>
<p>我们在枚举到第 i 根柱子时，可以先将所有高度大于等于 heights[i] 的下标值全部移除，剩下的下标值中高度最高的即为答案。在这之后，我们将 i 放入数据结构中，开始接下来的枚举。</p>
<p>我们使用栈这一数据结构：</p>
<ul>
<li>栈中存放了下标值 j。从栈底到栈顶，j 的值严格单调递增，同时对应的高度值也严格单调递增；</li>
<li>当我们枚举到第 i 根柱子时，我们从栈顶不断地移除 heights[j] &gt;= heights[i] 的 j 值。在移除完毕后，栈顶的 j 值就一定满足 heights[j] &lt; heights[i]。此时 j 就是 i 左侧最近的小于其高度的柱子；</li>
<li>再将 i 放入栈顶。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len  = heights.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">//枚举每一根柱子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//栈顶的柱子 j 高度比当前柱子 i 的高度大，不满足递增关系。</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peekLast()] &gt; heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.removeLast()];</span><br><span class="line">				<span class="comment">//如果两个柱子高度相等不满足递增关系，出栈一个元素。</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peekLast()] == height)&#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="keyword">int</span> width;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;<span class="comment">//栈为空，左侧的柱子都比柱子 i 高</span></span><br><span class="line">                    width = i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//栈非空，左侧最近比柱子 i 小的下标为栈顶元素的值</span></span><br><span class="line">                    width = i - stack.peekLast() - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//计算矩形面积</span></span><br><span class="line">                area = Math.max(area, width * height);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//将柱子 i 添加到栈中</span></span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        	<span class="comment">//考虑遍历完数组后栈中不为空的情况，例如高度数组为[1,2,3,4,5]。</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.removeLast()];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp;  heights[stack.peekLast()] == height)&#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> width;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    width = len;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    width = len - stack.peekLast() - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                area = Math.max(area, width * height);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n) 空间复杂度 O(n)</p>
<p>我们还可以用哨兵来保持栈中不为空，这样少了很多判空处理。同时由于最后一个柱子高度为 0 可以清空栈，同时处理了高度数组为[1,2,3,4,5] 这种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len  = heights.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//高度数组首尾添加高度为 0 的两个柱子。</span></span><br><span class="line">        <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            newHeights[i + <span class="number">1</span>] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        len += <span class="number">2</span>;</span><br><span class="line">        heights = newHeights;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">//将高度为 0 的柱子下标加入栈中</span></span><br><span class="line">        stack.addLast(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">// 从第一根高度不为 0 的柱子开始遍历。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//不可能有高度小于 0 的柱子，所以不需要判断栈是否为空</span></span><br><span class="line">            <span class="keyword">while</span>(heights[stack.peekLast()] &gt; heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.removeLast()];</span><br><span class="line">                <span class="comment">//计算宽度</span></span><br><span class="line">                <span class="keyword">int</span> width = i - stack.peekLast() - <span class="number">1</span>;</span><br><span class="line">                area = Math.max(area, width * height);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将柱子 i 添加到栈中</span></span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度，空间复杂度同上。</p>
<h4 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a></h4><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的时间复杂度为 <em>O(n)</em>。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<p>考虑枚举数组中的每一个数 x，考虑以其为起点，不断尝试匹配 x + 1，x + 2，…… 是否存在。采用暴力法，需要 O(n) 来遍历每个元素，使用 O(n^2) 来求取最长连续序列，时间复杂度 O(n^2)，总共时间复杂度O(n^3)。我们可以采用哈希表优化，这样判断一个数字是否存在只用 O(1)，总共时间复杂度O(n^2)。分析判断的过程，我们发现执行了很多不必要的枚举，如果已知有一个 x, x+1, x+2, … , x+y 的连续序列，我们从 x+1, x+2, … , x+y 等位置开始寻找的最长连续序列绝对小于从 x 处得到的最长连续序列长度大。因此，我们在外层循环的时候跳过这种情况。</p>
<p>如何跳过这种情况呢？由于我们要枚举的数 x 一定在数组中不存在前驱数 x - 1 的，不然我们会从 x - 1处开始尝试匹配，因此在哈希表中检查是否存在数 x - 1 即能判断是否需要跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; s = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//生成哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            s.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">//判断是否跳过匹配</span></span><br><span class="line">            <span class="keyword">if</span>(!s.contains(num - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//匹配</span></span><br><span class="line">                <span class="keyword">while</span>(s.contains(currentNum + <span class="number">1</span>))&#123;</span><br><span class="line">                    currentNum++ ;</span><br><span class="line">                    currentStreak++ ;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">			<span class="comment">//更新最大长度</span></span><br><span class="line">                longestStreak = Math.max(currentStreak, longestStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestStreak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n) ，空间复杂度 O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树 Easy</title>
    <url>/2020/05/31/%E4%BA%8C%E5%8F%89%E6%A0%91Easy/</url>
    <content><![CDATA[<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h4><p>给定一个二叉树，检查它是否是镜像对称的。 </p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p> 但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong></p>
<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<p>如果一个二叉树的左右子树镜像对称，那么这个树镜像对称。两个子树镜像对称有如下性质：</p>
<ul>
<li><p>左右两个子树根结点值相等</p>
</li>
<li><p>每个树的右子树与另一个子树的左子树镜像对称</p>
</li>
</ul>
<p>我们可以使用两个指针 p  和 q ，它们最开始都指向根结点，p 右移时， q 左移，p 左移时，q 右移，同时判断 p 和 q 的值是否相等并递归判断它们的子树是否镜像对称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个结点遍历一次，时间复杂度 O(n)。递归层数不超过 n 层，渐进空间复杂度为 O(n)。</p>
<p>我们还可以使用一个队列来模拟递归，每次进队列两个二叉树的镜像结点，依次判断它们的值是否相等，直到队列为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode u, TreeNode v)</span></span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(u);</span><br><span class="line">        queue.offer(v);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            u = queue.poll();</span><br><span class="line">            v = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(u == <span class="keyword">null</span> &amp;&amp; v == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((u ==<span class="keyword">null</span> || v == <span class="keyword">null</span>) || (u.val != v.val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            queue.offer(u.left);</span><br><span class="line">            queue.offer(v.right);</span><br><span class="line"></span><br><span class="line">            queue.offer(u.right);</span><br><span class="line">            queue.offer(v.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个结点遍历一次，时间复杂度 O(n)。每个结点入队一次，队列中最多 n 个结点，渐进空间复杂度为O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数学 Medium</title>
    <url>/2020/06/02/%E6%95%B0%E5%AD%A6Medium/</url>
    <content><![CDATA[<h4 id="面试题64-求1-2-…-n"><a href="#面试题64-求1-2-…-n" class="headerlink" title="面试题64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">面试题64. 求1+2+…+n</a></h4><p>难度中等76收藏分享切换为英文关注反馈</p>
<p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10000</code></li>
</ul>
<p>对于此题我们首先想到等差数列求和公式：<code>(1 + n) * n / 2</code>，很可惜，我们并不能使用乘除法。我们想到使用递归来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : n + sumNums(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用了三目运算符，也不符合题目要求，这里我们使用 &amp;&amp; 短路与的知识，例如 A &amp;&amp; B，当逻辑结果 A 为false 时，B 不会被执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以使用异常机制来实现递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[n];</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> n + sumNums(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度O(n)。</p>
<p>我们还可以模拟乘法来解决这个问题，利用加法和移位来模拟乘法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mul(n, n+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; b != <span class="number">0</span>; b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">            a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用了循环不符合要求，但我们注意到 n 最大为 10000，只用 14 位二进制就可表示，我们直接将循环代码写 14 次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, a = n, b = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(log n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS &amp; BFS Hard</title>
    <url>/2020/06/07/DFS&amp;BFSHard/</url>
    <content><![CDATA[<h4 id="126-单词接龙-II"><a href="#126-单词接龙-II" class="headerlink" title="126. 单词接龙 II"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. 单词接龙 II</a></h4><p>给定两个单词（<em>beginWord</em> 和 <em>endWord<em>）和一个字典 *wordList</em>，找出所有从 *beginWord</em> 到 <em>endWord</em> 的最短转换序列。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p><strong>说明:</strong></p>
<ul>
<li>如果不存在这样的转换序列，返回一个空列表。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;</span><br><span class="line">endWord &#x3D; &quot;cog&quot;</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: []</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>

<p> 本题要求的是最短转换序列，看到最短首先想到的就是<strong>BFS</strong> 。想到 BFS 就能想到图。我们需要建立图的模型：将每个单词抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明它们之间有一条双向边。因此只要把满足转换条件的点相连，就形成了一张图。如下图（来自<a href="https://leetcode-cn.com/problems/word-ladder-ii/solution/dan-ci-jie-long-ii-by-leetcode-solution/" target="_blank" rel="noopener">Leetcode</a>）</p>
<p><img src="https://i.loli.net/2020/06/07/z5qoG1lrcUI78LP.png" alt="image-20200607171920249"></p>
<p>有了上图我们以 <code>hit</code> 为图的起点，以<code>cog</code> 为终点进行广度优先搜索，寻找 hit 到 cog 的最短路径。</p>
<p>方便起见，我们先给每一个单词标号，即给每个单词分配一个 id。创建一个由单词 word到 id 对应的映射 wordId，并将 beginWord 与 wordList 中所有的单词都加入这个映射中。之后我们检查 endWord 是否在该映射内，若不存在，则输入无解。我们可以使用哈希表实现上面的映射关系。</p>
<p>同理我们可以创建一个由对应 id 到 word 的映射 idWord，方便最后输出结果。由于 id 实际上是整数且连续，所以这个映射用数组实现即可。</p>
<p>接下来我们将 idWord 中的单词两两匹配，检查它们是否可以通过改变一个字母进行互相转换。如果可以，则在这两个点之间建一条双向边。</p>
<p>为了保留相同长度的多条路径，我们采用 cost 数组，其中 cost[i] 表示 beginWord 对应的点到第 i 个点的代价（即转换次数）。初始情况下其所有元素初始化为无穷大。</p>
<p>接下来将起点加入队列开始广度优先搜索，队列的每一个节点中保存从起点开始的所有路径。</p>
<p>对于每次取出的节点 now，每个节点都是一个数组，数组中的最后一个元素为当前路径的最后节点 last :</p>
<ul>
<li>若该节点为终点，则将其路径转换为对应的单词存入答案;</li>
<li>若该节点不为终点，则遍历和它连通的节点（假设为 to ）中满足 cost[to] &gt;= cost[now] + 1cost[to]&gt;=cost[now]+1 的加入队列，并更新 cost[to] = cost[now] + 1cost[to]=cost[now]+1。如果 cost[to] &lt; cost[now] + 1cost[to]&lt;cost[now]+1，说明这个节点已经被访问过，不需要再考虑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; wordId; <span class="comment">//单词到 id 的映射</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; idWord; <span class="comment">//id到单词的映射</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt;[] edges; <span class="comment">//图的边</span></span><br><span class="line"></span><br><span class="line">    Solution()&#123;</span><br><span class="line">        wordId = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        idWord = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将 wordList 所有单词加入 wordId 中 相同的只保留一个，并为每个单词分配一个 id。</span></span><br><span class="line">        <span class="keyword">for</span>(String word : wordList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(! wordId.containsKey(word))&#123;</span><br><span class="line">                wordId.put(word, id++ );</span><br><span class="line">                idWord.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若 endWord 不在 wordList 中则无解</span></span><br><span class="line">        <span class="keyword">if</span>(! wordId.containsKey(endWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把 beginWord 也加入 wordId 中</span></span><br><span class="line">        <span class="keyword">if</span>(! wordId.containsKey(beginWord))&#123;</span><br><span class="line">            wordId.put(beginWord, id++);</span><br><span class="line">            idWord.add(beginWord);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化存储边的数组</span></span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList[idWord.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idWord.size(); i++)&#123;</span><br><span class="line">            edges[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idWord.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; idWord.size(); j++)&#123;</span><br><span class="line">                <span class="comment">//如果两者可以通过转换得到 则在它们间建一条无向边</span></span><br><span class="line">                <span class="keyword">if</span>(transformCheck(idWord.get(i), idWord.get(j)))&#123;</span><br><span class="line">                    edges[i].add(j);</span><br><span class="line">                    edges[j].add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dest = wordId.get(endWord); <span class="comment">//目的 id</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res  = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存答案</span></span><br><span class="line">        <span class="keyword">int</span>[] cost = <span class="keyword">new</span> <span class="keyword">int</span>[id];<span class="comment">//到每个点的代价</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id; i++)&#123;</span><br><span class="line">            cost[i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将起点加入队列，并将其cost 设置为 0 </span></span><br><span class="line">        Queue&lt;ArrayList&lt;Integer&gt;&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; tmpBegin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmpBegin.add(wordId.get(beginWord));</span><br><span class="line">        q.add(tmpBegin);</span><br><span class="line">        cost[wordId.get(beginWord)] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//广度优先搜索</span></span><br><span class="line">    <span class="keyword">while</span>(! q.isEmpty())&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; now = q.poll();</span><br><span class="line">        <span class="keyword">int</span> last = now.get(now.size() - <span class="number">1</span>);<span class="comment">//最近访问的点</span></span><br><span class="line">        <span class="keyword">if</span>(last == dest)&#123;<span class="comment">//若该点为终点则将其存入答案 res 中</span></span><br><span class="line">            ArrayList&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> index : now)&#123;</span><br><span class="line">                tmp.add(idWord.get(index));</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//该点不为终点 继续搜索</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges[last].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = edges[last].get(i);</span><br><span class="line">                <span class="comment">//此处 &lt;= 目的在于把代价相同的不同路径全部保存下来</span></span><br><span class="line">                <span class="keyword">if</span>(cost[last] + <span class="number">1</span> &lt;= cost[to])&#123;</span><br><span class="line">                    cost[to] = cost[last] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//把 to 加入路径中</span></span><br><span class="line">                    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(now); tmp.add(to);</span><br><span class="line">                    q.add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">transformCheck</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length() &amp;&amp; diff &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1.charAt(i) != str2.charAt(i))&#123;</span><br><span class="line">                diff++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N^2<em>C)<em>。其中 N 为 <code>wordList</code> 的长度，</em>C</em> 为列表中单词的长度。空间复杂度：O(N^2)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>图 Medium</title>
    <url>/2020/06/08/%E5%9B%BEMedium/</url>
    <content><![CDATA[<h4 id="990-等式方程的可满足性"><a href="#990-等式方程的可满足性" class="headerlink" title="990. 等式方程的可满足性"></a><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">990. 等式方程的可满足性</a></h4><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：如果我们指定，a &#x3D; 1 且 b &#x3D; 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：[&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]</span><br><span class="line">输入：true</span><br><span class="line">解释：我们可以指定 a &#x3D; 1 且 b &#x3D; 1 以满足满足这两个方程。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;c&#x3D;&#x3D;c&quot;,&quot;b&#x3D;&#x3D;d&quot;,&quot;x!&#x3D;z&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= equations.length &lt;= 500</code></li>
<li><code>equations[i].length == 4</code></li>
<li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li>
<li><code>equations[i][1]</code> 要么是 <code>&#39;=&#39;</code>，要么是 <code>&#39;!&#39;</code></li>
<li><code>equations[i][2]</code> 是 <code>&#39;=&#39;</code></li>
</ol>
<p>由于相等关系具有<strong>传递性</strong>，所有相等的变量属于同一个集合，只关心连通性，不关心距离，因此很容易想到并查集。</p>
<p>算法流程：</p>
<ul>
<li>扫描所有等式，将等式两边的顶点进行合并；</li>
<li>再扫描所有不等式，检查每一个不等式的两个顶点是不是在一个连通分量里：<ul>
<li>如果在，代表 a == b 和 a != b 同时成立，返回 false</li>
<li>如果所有检查都没有矛盾，返回 true</li>
</ul>
</li>
</ul>
<p>使用一个数组 parent 存储每个变量的连通分量信息，其中的每个元素表示当前连通分量的父节点信息，如果父节点是自身，说明该变量为所在连通分量的根结点。一开始所有变量的父节点都是它们自身。对于合并操作，我们将第一个变量的根结点的父节点指向第二个变量的根结点；对于查找操作，我们沿着当前变量的父节点一路向上查找，直到找到根结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        UnionFind unionFind = <span class="keyword">new</span> UnionFind(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String equation : equations)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] charArray = equation.toCharArray();</span><br><span class="line">            <span class="keyword">if</span>(charArray[<span class="number">1</span>] == <span class="string">'='</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> index1 = charArray[<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> index2 = charArray[<span class="number">3</span>] - <span class="string">'a'</span>;</span><br><span class="line">                unionFind.union(index1, index2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String equation : equations)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] charArray = equation.toCharArray();</span><br><span class="line">            <span class="keyword">if</span>(charArray[<span class="number">1</span>] == <span class="string">'!'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> index1 = charArray[<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> index2 = charArray[<span class="number">3</span>] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(unionFind.isConnected(index1, index2))&#123;</span><br><span class="line">                    <span class="comment">//如果合并失败，表示等式有矛盾，返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查了所有不等式，没有发现矛盾，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="comment">//找根结点</span></span><br><span class="line">            <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">                <span class="comment">//路径压缩</span></span><br><span class="line">                parent[x] = parent[parent[x]];</span><br><span class="line">                x = parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">            <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="comment">//根结点相同则连通</span></span><br><span class="line">            <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n + ClogC)，其中 n 是 equations 中的方程数量，C 是变量的总数，本题中变量都是小写字母即 C&lt;=26。并查集代码中使用了路径压缩算法，对于每个方程的合并和查找的均摊时间复杂度都是 O(logC)。</p>
<p>空间复杂度 O(C)，创建一个 parent 数组存储每个变量的连通分量信息。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
